// Copyright (C) 2021-2025 Jihuan Tian <jihuan_tian@hotmail.com>
//
// This file is part of the HierBEM library.
//
// HierBEM is free software: you can use it, redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as published by the
// Free Software Foundation, either version 3 of the License, or (at your
// option) any later version. The full text of the license can be found in the
// file LICENSE at the top level directory of HierBEM.

// File: normal-vector.cc
// Description: This file calculates the surface normal vectors of the mesh on a
// sphere model generated by deal.ii GridGenerator. The purpose is to verify if
// the the calculated normal vector is consistent with the mesh.
// Author: Jihuan Tian
// Date: 2020-11-28 Copyright (C) 2020 Jihuan Tian
// <jihuan_tian@hotmail.com>

#include <deal.II/base/logstream.h>

#include <deal.II/grid/grid_generator.h>
#include <deal.II/grid/tria.h>

#include "laplace/laplace_bem.h"

using namespace dealii;

int
main()
{
  deallog.depth_console(2);
  deallog.pop();

  Triangulation<2, 3> triangulation;
  GridGenerator::hyper_sphere(triangulation, Point<3>(0., 0., 0.), 1.);
  triangulation.refine_global(1);

  // Use isometric element of 2nd order.
  const unsigned int fe_order = 2;
  FE_Q<2, 3>         fe(fe_order);
  MappingQ<2, 3>     mapping(fe_order);

  // Iterate over each cell in the triangulation.
  std::vector<Tensor<1, 3>> normal_vector_list;
  unsigned int              counter = 0;
  deallog << "Support points\n";
  for (const auto &cell : triangulation.active_cell_iterators())
    {
      // Get the support points in tensor product order.
      std::vector<Point<3>> support_points =
        HierBEM::tensor_product_support_points_in_real_cell(cell, fe, mapping);

      // Print each support point.
      for (unsigned int i = 0; i < support_points.size(); i++)
        {
          deallog << counter << " " << support_points[i] << "\n";
        }

      // Calculate the normal vector is the current cell.
      Tensor<1, 3> normal_vector;
      HierBEM::surface_jacobian_det_and_normal_vector(fe,
                                                      support_points,
                                                      Point<2>(0.5, 0.5),
                                                      normal_vector);
      normal_vector_list.push_back(normal_vector);

      counter++;
    }

  deallog << "\nCell centers\n";
  counter = 0;
  for (const auto &cell : triangulation.active_cell_iterators())
    {
      Point<3> center = cell->center();
      deallog << counter << " " << center << "\n";

      counter++;
    }

  deallog << "\nNormal vectors\n";
  counter = 0;
  for (unsigned int i = 0; i < normal_vector_list.size(); i++, counter++)
    {
      deallog << counter << " " << normal_vector_list[i] << "\n";
    }
}
