/**
 * @file call-octave-dealii.cc
 * @brief
 *
 * @ingroup testers
 * @author
 * @date 2023-10-09
 */

#include <deal.II/base/logstream.h>

#include <octave/builtin-defun-decls.h>
#include <octave/interpreter.h>
#include <octave/oct.h>
#include <octave/octave.h>
#include <octave/parse.h>

#include <iostream>

using namespace std;
using namespace dealii;

// Octave interpreter
static octave::interpreter interpreter;

void
call_builtins_directly()
{
  {
    // Call builtin function norm() directly
    octave_idx_type n     = 2;
    Matrix          a_mat = Matrix(n, n);

    for (octave_idx_type i = 0; i < n; i++)
      for (octave_idx_type j = 0; j < n; j++)
        a_mat(i, j) = (i + 1) + (j + 1);

    octave_value_list in;
    in(0) = a_mat;

#if OCTAVE_MAJOR_VERSION < 8
    octave_value_list out = Fnorm(in, 1 /*n_ret*/);
#else
    octave_value_list out = octave::Fnorm(in, 1 /*n_ret*/);
#endif
    Assert(out.length() == 1, ExcInternalError());
    deallog << "Fnorm ret: " << out(0).double_value() << std::endl;
  }

  {
    // Call builtin function gcd() directly
    octave_idx_type   n = 2;
    octave_value_list in;

    for (octave_idx_type i = 0; i < n; i++)
      in(i) = octave_value(5 * (i + 2));

#if OCTAVE_MAJOR_VERSION < 8
    octave_value_list out = Fgcd(in, 1 /*n_ret*/);
#else
    octave_value_list out = octave::Fgcd(in, 1 /*n_ret*/);
#endif
    Assert(out.length() == 1, ExcInternalError());
    deallog << "gcd ret: " << out(0).int_value() << std::endl;
  }
}

void
call_functions_by_interpreter()
{
  {
    // Call builtin function gcd() through interpreter
    octave_idx_type   n = 2;
    octave_value_list in;

    for (octave_idx_type i = 0; i < n; i++)
      in(i) = octave_value(5 * (i + 2));

    octave_value_list out = octave::feval("gcd", in, 1 /*n_ret*/);
    Assert(out.length() == 1, ExcInternalError());
    deallog << "gcd ret: " << out(0).int_value() << std::endl;
  }

  {
    // Call function cond() defined in *.m files through interpreter
    octave_idx_type n = 2;

    Matrix a_mat = Matrix(n, n);
    for (octave_idx_type i = 0; i < n; i++)
      for (octave_idx_type j = 0; j < n; j++)
        a_mat(i, j) = (i + 1) * 10 + (j + 1);

    // Stringify Octave matrix object by streaming interface
    std::ostringstream oss;
    oss << a_mat;
    std::string a_str = oss.str();

    deallog << "a matrix:\n" << a_str << std::endl;

    // Calculate frobenius norm of matrix
    octave_value_list in;
    in(0) = a_mat;
    in(1) = "fro";

    octave_value_list out = octave::feval("cond", in, 1 /*n_ret*/);
    Assert(out.length() == 1, ExcInternalError());
    deallog << "cond ret: " << out(0).double_value() << std::endl;
  }
}

void
source_file_by_interpreter()
{
  {
    try
      {
        // NOTE This M-file will output on stdout async, so any
        // output generated by main thread should be flushed out
        // before running any Octave source that use stdout for
        // output!
        octave::source_file(std::string(SOURCE_DIR "/test.m"));
      }
    catch (const std::runtime_error &e)
      {
        deallog << "Runtime-error caught: " << e.what() << std::endl;
      }
    catch (const std::exception &e)
      {
        deallog << "Exception caught: " << e.what() << std::endl;
      }
    catch (...)
      {
        deallog << "Unknown exception caught";
      }

    int               parse_status;
    octave_value_list out =
      interpreter.eval_string("mat2str(a)", true, parse_status);
    Assert(parse_status == 0, ExcInternalError());
    Assert(out.length() > 0, ExcInternalError());
    deallog << "mat2str ret: " << out(0).string_value() << std::endl;
  }
}

void
init_octave_interpreter()
{
  // Initialize and start Octave interpreter instance
  int status = interpreter.execute();
  Assert(status == 0, ExcInternalError());
}

int
main(int /*argc*/, const char * /*argv*/[])
{
  deallog.depth_console(2);
  deallog.pop();

  call_builtins_directly();

  // NOTE There can be only one Octave interpreter active per thread
  init_octave_interpreter();

  call_functions_by_interpreter();
  source_file_by_interpreter();

#if OCTAVE_MAJOR_VERSION == 6
  // need call interpreter's shutdown() method explicitly to prevent segfault on
  // exit
  interpreter.shutdown();
#endif

  return 0;
}
