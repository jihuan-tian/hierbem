/**
 * @file cad-manifold.cc
 * @brief Test for reading STEP file and generating mesh
 *
 * @ingroup testers
 * @date 2025-02-25
 */

#include <deal.II/grid/grid_generator.h>
#include <deal.II/grid/grid_out.h>
#include <deal.II/grid/tria.h>

#include <deal.II/opencascade/manifold_lib.h>
#include <deal.II/opencascade/utilities.h>

#include <TopExp_Explorer.hxx>
#include <TopoDS.hxx>
#include <catch2/catch_all.hpp>
#include <fmt/core.h>

#include <fstream>

#include "grid_in_ext.h"
using namespace Catch::Matchers;

TEST_CASE("Extract TopoDS_Shape from CAD file", "[cad][demo]")
{
  // Read STEP file using deal.II interface
  TopoDS_Shape shape =
    dealii::OpenCASCADE::read_STEP(SOURCE_DIR "/test_model.stp", 1.0);
  REQUIRE(!shape.IsNull());

  // Count solids in the shape
  int solid_count = 0;
  for (TopExp_Explorer exp(shape, TopAbs_SOLID); exp.More(); exp.Next())
    {
      solid_count++;
    }

  fmt::print("Number of solids: {}\n", solid_count);
}

TEST_CASE("Generate mesh from STEP file", "[cad][demo][mesh]")
{
  // Read STEP file
  TopoDS_Shape shape =
    dealii::OpenCASCADE::read_STEP(SOURCE_DIR "/test_model.stp", 1.0);
  REQUIRE(!shape.IsNull());

  // The nodes in the mesh generated by Gmsh using the quasi-structured quad
  // method do not lie exactly on the sphere, so we need to use a large
  // tolerance here.
  const double tolerance = 5e-3;
  fmt::print("Tolerance: {}\n", tolerance);

  std::vector<TopoDS_Compound>  compounds;
  std::vector<TopoDS_CompSolid> compsolids;
  std::vector<TopoDS_Solid>     solids;
  std::vector<TopoDS_Shell>     shells;
  std::vector<TopoDS_Wire>      wires;
  dealii::OpenCASCADE::extract_compound_shapes(
    shape, compounds, compsolids, solids, shells, wires);

  fmt::print("Number of wires: {}\n", wires.size());
  fmt::print("Number of shells: {}\n", shells.size());
  fmt::print("Number of solids: {}\n", solids.size());
  fmt::print("Number of compsolids: {}\n", compsolids.size());
  fmt::print("Number of compounds: {}\n", compounds.size());

  std::vector<TopoDS_Face>   faces;
  std::vector<TopoDS_Edge>   edges;
  std::vector<TopoDS_Vertex> vertices;
  dealii::OpenCASCADE::extract_geometrical_shapes(shape,
                                                  faces,
                                                  edges,
                                                  vertices);

  fmt::print("Number of faces: {}\n", faces.size());
  fmt::print("Number of edges: {}\n", edges.size());
  fmt::print("Number of vertices: {}\n", vertices.size());

  dealii::Triangulation<2, 3> tria;
  dealii::GridOut             grid_out;

  try
    {
      // Read mesh file
      {
        std::ifstream msh_file(SOURCE_DIR "/test_model.msh");
        HierBEM::read_msh(msh_file, tria);
      }

      fmt::print("Original mesh has {} cells\n", tria.n_active_cells());
      REQUIRE(tria.n_active_cells() > 0);

      // Output original mesh
      std::ofstream out_original("test_model_original.vtk");
      grid_out.write_vtk(tria, out_original);
      fmt::print("Simple refined mesh has {} cells\n", tria.n_active_cells());

      // Refine mesh without manifold information
      tria.refine_global(1);
      std::ofstream out_refined_no_manifold(
        "test_model_refined_no_manifold.vtk");
      grid_out.write_vtk(tria, out_refined_no_manifold);

      // Reset triangulation
      tria.clear();

      // Reread mesh file
      {
        std::ifstream msh_file(SOURCE_DIR "/test_model.msh");
        HierBEM::read_msh(msh_file, tria);
      }

      // Iterating all active cells and set their manifold_ids
      for (const auto &cell : tria.active_cell_iterators())
        {
          cell->set_all_manifold_ids(1);
        }

      // Add CAD manifold
      dealii::OpenCASCADE::NormalProjectionManifold<2, 3> face_manifold(
        shape, tolerance);
      tria.set_manifold(1, face_manifold);

      // Refine mesh with manifold information
      tria.refine_global(1);
      std::ofstream out_refined_with_manifold(
        "test_model_refined_with_manifold.vtk");
      grid_out.write_vtk(tria, out_refined_with_manifold);
    }
  catch (const std::exception &e)
    {
      fmt::print("Exception: {}\n", e.what());
      REQUIRE(false);
    }
}
