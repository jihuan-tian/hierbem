<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>laplace-bem: HMatrix&lt; spacedim, Number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    skipTags: ["script","noscript","style","textarea","pre","code"],
    processEscapes: false,
    processEnvironments: true,
    preview: "TeX"
  },
  TeX: {
    Macros: {
      intd: "\\,{\\rm d}",
      diff: "{\\rm d}",
      Diff: "{\\rm D}",
      pdiff: "\\partial",
      DD: ["\\frac{\\diff}{\\diff #2}\\left( #1 \\right)", 2],
      Dd: ["\\frac{\\diff #1}{\\diff #2}", 2],
      PD: ["\\frac{\\pdiff}{\\pdiff #2}\\left( #1 \\right)", 2],
      Pd: ["\\frac{\\pdiff #1}{\\pdiff #2}", 2],
      rme: "{\\rm e}",
      rmi: "{\\rm i}",
      rmj: "{\\rm j}",
      vect: ["\\boldsymbol{#1}", 1],
      dform: ["\\overset{\\rightharpoonup}{\\boldsymbol{#1}}", 1],
      cochain: ["\\overset{\\rightharpoonup}{#1}", 1],
      Abs: ["\\big\\lvert#1\\big\\rvert", 1],
      abs: ["\\lvert#1\\rvert", 1],
      Norm: ["\\big\\lVert#1\\big\\rVert", 1],
      norm: ["\\lVert#1\\rVert", 1],
      normvect: "\\vect{n}",
      ouset: ["\\overset{#3}{\\underset{#2}{#1}}", 3],
      cscript: ["\\;\\; #1", 1],
      suchthat: "\\textit{S.T.\\;}",
      prefstar: "\\ast",
      restrict: "\\big\\vert",
      sgn: "{\\rm sgn}",
      erf: "{\\rm erf}",
      Bd: "{\\rm Bd}",
      Int: "{\\rm Int}",
      rank: "{\\rm rank}",
      divergence: "{\\rm div}",
      grad: "{\\rm grad}",
      tr: "{\\rm tr}",
      span: "{\\rm span}"
    },
    extensions: ["AMScd.js"],
    equationNumbers: { autoNumber: "AMS" }
  },
  "HTML-CSS": {
     availableFonts: ["STIX","TeX"],
     preferredFont: "TeX",
     webFont: "TeX",
     imageFont: "TeX",
     showMathMenu: true
  },
  MMLorHTML: {
    prefer: {
      MSIE:    "MML",
      Firefox: "MML",
      Opera:   "HTML",
      other:   "HTML"
    }
  }
});
</script><script type="text/javascript" src="http://localhost/js/MathJax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">laplace-bem
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Solve Laplace problem using the boundary element method (BEM)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classHMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HMatrix&lt; spacedim, Number &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for HMatrix&lt; spacedim, Number &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classHMatrix__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5ca8dc549783d38371a01ecd621ecb34"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> = std::make_unsigned&lt; types::blas_int &gt;::<a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">type</a></td></tr>
<tr class="separator:a5ca8dc549783d38371a01ecd621ecb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae3dc35e1aefee2580d27ad2d65c906de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae3dc35e1aefee2580d27ad2d65c906de">HMatrix</a> ()</td></tr>
<tr class="separator:ae3dc35e1aefee2580d27ad2d65c906de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4dead0321e8df38865bf6fbd0f6e81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6a4dead0321e8df38865bf6fbd0f6e81">HMatrix</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct, const unsigned int fixed_rank_k=1)</td></tr>
<tr class="separator:a6a4dead0321e8df38865bf6fbd0f6e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe44a3aa2b813f593b787f24be56a1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a4fe44a3aa2b813f593b787f24be56a1c">HMatrix</a> (typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const unsigned int fixed_rank_k=1)</td></tr>
<tr class="separator:a4fe44a3aa2b813f593b787f24be56a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a62fe726b69cbde07b1f434417d318"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ad3a62fe726b69cbde07b1f434417d318">HMatrix</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, const unsigned int fixed_rank_k)</td></tr>
<tr class="separator:ad3a62fe726b69cbde07b1f434417d318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72a32400b866e633dda058c949d4f79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af72a32400b866e633dda058c949d4f79">HMatrix</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:af72a32400b866e633dda058c949d4f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d444d5d8d3d88e31b7c1046c29017fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a3d444d5d8d3d88e31b7c1046c29017fd">HMatrix</a> (typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, const unsigned int fixed_rank_k)</td></tr>
<tr class="separator:a3d444d5d8d3d88e31b7c1046c29017fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b27ea3c54897b34ccb163415d1569d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a97b27ea3c54897b34ccb163415d1569d">HMatrix</a> (typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a97b27ea3c54897b34ccb163415d1569d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb8d0add9bffecafc12f4c6b1dcab8e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#abeb8d0add9bffecafc12f4c6b1dcab8e">HMatrix</a> (typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;H)</td></tr>
<tr class="separator:abeb8d0add9bffecafc12f4c6b1dcab8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78aa967d7a99e27cc172f0db3791306b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a78aa967d7a99e27cc172f0db3791306b">HMatrix</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;H)</td></tr>
<tr class="separator:a78aa967d7a99e27cc172f0db3791306b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5227e35290f6c9fba1e8948e9a29c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a0b5227e35290f6c9fba1e8948e9a29c3">HMatrix</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;H)</td></tr>
<tr class="separator:a0b5227e35290f6c9fba1e8948e9a29c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556325d4cdaee699f17aa1be63bb58ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a556325d4cdaee699f17aa1be63bb58ee">HMatrix</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;H)</td></tr>
<tr class="separator:a556325d4cdaee699f17aa1be63bb58ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f804163e1695cfb952ddb6b0df2503"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a83f804163e1695cfb952ddb6b0df2503">reinit</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct, const unsigned int fixed_rank_k=1)</td></tr>
<tr class="separator:a83f804163e1695cfb952ddb6b0df2503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d20c1839f3d7a756107b8e4defea0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a41d20c1839f3d7a756107b8e4defea0b">reinit</a> (typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const unsigned int fixed_rank_k=1)</td></tr>
<tr class="separator:a41d20c1839f3d7a756107b8e4defea0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c72ede65323af5b57a6b16f5774de50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a2c72ede65323af5b57a6b16f5774de50">operator=</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;H)</td></tr>
<tr class="separator:a2c72ede65323af5b57a6b16f5774de50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83958971f40409b3b2a192b71eae1513"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a83958971f40409b3b2a192b71eae1513">operator=</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;H)</td></tr>
<tr class="separator:a83958971f40409b3b2a192b71eae1513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bdd40f7fcf5c912c34c427df518300"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a00bdd40f7fcf5c912c34c427df518300"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a00bdd40f7fcf5c912c34c427df518300">convertToFullMatrix</a> (MatrixType &amp;M) const</td></tr>
<tr class="separator:a00bdd40f7fcf5c912c34c427df518300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812e8276888b2ad866edf7ce9b286839"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">release</a> ()</td></tr>
<tr class="separator:a812e8276888b2ad866edf7ce9b286839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55bd45587b895bfdb977e7cbea46519"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae55bd45587b895bfdb977e7cbea46519">clear</a> ()</td></tr>
<tr class="separator:ae55bd45587b895bfdb977e7cbea46519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0815bc9c3654391bb2b3095383e6cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">clear_hmat_node</a> ()</td></tr>
<tr class="separator:aec0815bc9c3654391bb2b3095383e6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16c956c1b22eb307e9f360a83f4fa75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae16c956c1b22eb307e9f360a83f4fa75">~HMatrix</a> ()</td></tr>
<tr class="separator:ae16c956c1b22eb307e9f360a83f4fa75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadea9fa59f420d22b3b1c939f6b573cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aadea9fa59f420d22b3b1c939f6b573cc">get_type</a> () const</td></tr>
<tr class="separator:aadea9fa59f420d22b3b1c939f6b573cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe735f7712a10ba5325ff116f8ca1c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aabe735f7712a10ba5325ff116f8ca1c7">get_m</a> () const</td></tr>
<tr class="separator:aabe735f7712a10ba5325ff116f8ca1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff89130116d62ea4159bc69ca11f8d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#abff89130116d62ea4159bc69ca11f8d5">get_n</a> () const</td></tr>
<tr class="separator:abff89130116d62ea4159bc69ca11f8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0189de6e276fbd3425c4a7ef132f5e16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a0189de6e276fbd3425c4a7ef132f5e16">get_rkmatrix</a> ()</td></tr>
<tr class="separator:a0189de6e276fbd3425c4a7ef132f5e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c81db6357d0e00b82fd523af001ae5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a64c81db6357d0e00b82fd523af001ae5">get_rkmatrix</a> () const</td></tr>
<tr class="separator:a64c81db6357d0e00b82fd523af001ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72191c447afaa0fd84505022cf1d174e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a72191c447afaa0fd84505022cf1d174e">calc_rank_upper_bound_for_rkmatrices</a> () const</td></tr>
<tr class="separator:a72191c447afaa0fd84505022cf1d174e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d914c27d4e990d476a4529b2daa64cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a9d914c27d4e990d476a4529b2daa64cd">get_fullmatrix</a> ()</td></tr>
<tr class="separator:a9d914c27d4e990d476a4529b2daa64cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed550b5b41a64c6f1bbcde4f8f7eca91"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aed550b5b41a64c6f1bbcde4f8f7eca91">get_fullmatrix</a> () const</td></tr>
<tr class="separator:aed550b5b41a64c6f1bbcde4f8f7eca91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0572b2c0484ce618db0034e3bc7988ed"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a0572b2c0484ce618db0034e3bc7988ed">get_submatrices</a> ()</td></tr>
<tr class="separator:a0572b2c0484ce618db0034e3bc7988ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8e9bc437ab86296d78950081ea34cd"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8f8e9bc437ab86296d78950081ea34cd">get_submatrices</a> () const</td></tr>
<tr class="separator:a8f8e9bc437ab86296d78950081ea34cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e849f7e8f35e3ebdfcb2dbb7ad4ad01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a7e849f7e8f35e3ebdfcb2dbb7ad4ad01">print_formatted</a> (std::ostream &amp;out, const unsigned int precision=3, const bool scientific=true, const unsigned int width=0, const char *zero_string=&quot; &quot;, const double denominator=1., const double threshold=0.) const</td></tr>
<tr class="separator:a7e849f7e8f35e3ebdfcb2dbb7ad4ad01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f87883cf49080706233441c0e09171"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ad8f87883cf49080706233441c0e09171">print_matrix_info</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ad8f87883cf49080706233441c0e09171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0c393acf1c416ebc7ab05ca85d9e49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aab0c393acf1c416ebc7ab05ca85d9e49">print_current_matrix_info</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:aab0c393acf1c416ebc7ab05ca85d9e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae904288a7e0ac82d9fd2364b1c150bc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae904288a7e0ac82d9fd2364b1c150bc2">print_matrix_info_as_dot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ae904288a7e0ac82d9fd2364b1c150bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f958a13c56d64564d59487e67bc8a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a42f958a13c56d64564d59487e67bc8a2">write_fullmatrix_leaf_node</a> (std::ostream &amp;out, const Number singular_value_threshold=0.) const</td></tr>
<tr class="separator:a42f958a13c56d64564d59487e67bc8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c8ccd5763d3952505741c657b6468c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac2c8ccd5763d3952505741c657b6468c">write_rkmatrix_leaf_node</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ac2c8ccd5763d3952505741c657b6468c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0ae0960a40ad78a941aee823e80315"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aaf0ae0960a40ad78a941aee823e80315">write_leaf_set</a> (std::ostream &amp;out, const Number singular_value_threshold=0.) const</td></tr>
<tr class="separator:aaf0ae0960a40ad78a941aee823e80315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1e1ddbfeb133520dcd50c0174aab8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aac1e1ddbfeb133520dcd50c0174aab8d">write_leaf_set_by_iteration</a> (std::ostream &amp;out, const Number singular_value_threshold=0.) const</td></tr>
<tr class="separator:aac1e1ddbfeb133520dcd50c0174aab8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da518d5ca7e685e3e787f58dcad4e61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a1da518d5ca7e685e3e787f58dcad4e61">find_row_diag_block_for_offdiag_block</a> ()</td></tr>
<tr class="separator:a1da518d5ca7e685e3e787f58dcad4e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab763860706b9cbef8f5e73d995f29a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a1ab763860706b9cbef8f5e73d995f29a">find_col_diag_block_for_offdiag_block</a> ()</td></tr>
<tr class="separator:a1ab763860706b9cbef8f5e73d995f29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64be687cacd167efc12b892aa154dcd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a64be687cacd167efc12b892aa154dcd3">truncate_to_rank</a> (<a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> new_rank)</td></tr>
<tr class="separator:a64be687cacd167efc12b892aa154dcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938473855f9e95358d00ee7ea14f6c51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a938473855f9e95358d00ee7ea14f6c51">truncate_to_rank_preserve_positive_definite</a> (<a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> new_rank, const bool is_only_handle_tril=true)</td></tr>
<tr class="separator:a938473855f9e95358d00ee7ea14f6c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421beeb0b30d63f286a7905db394bdab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a421beeb0b30d63f286a7905db394bdab">truncate_to_rank_diag_preserve_positive_definite</a> (<a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> new_rank, const bool is_only_handle_tril=true)</td></tr>
<tr class="separator:a421beeb0b30d63f286a7905db394bdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88546d9ca48a3c1a2a0874545cc4c8df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a88546d9ca48a3c1a2a0874545cc4c8df">truncate_to_rank_off_diag_preserve_positive_definite</a> (<a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> new_rank, const bool is_compensate_diag_blocks=true)</td></tr>
<tr class="separator:a88546d9ca48a3c1a2a0874545cc4c8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11b5761aba86606effd14b4bdf31912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">vmult</a> (Vector&lt; Number &gt; &amp;y, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:aa11b5761aba86606effd14b4bdf31912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ca2a043c8a02a531d5d08437356310"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a21ca2a043c8a02a531d5d08437356310">vmult</a> (Vector&lt; Number &gt; &amp;y, const Number alpha, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:a21ca2a043c8a02a531d5d08437356310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690927f0810d85d08f0ab2239e405ffe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a690927f0810d85d08f0ab2239e405ffe">vmult</a> (Vector&lt; Number &gt; &amp;y, const std::map&lt; types::global_dof_index, size_t &gt; &amp;y_index_global_to_local_map, const Vector&lt; Number &gt; &amp;x, const std::map&lt; types::global_dof_index, size_t &gt; &amp;x_index_global_to_local_map) const</td></tr>
<tr class="separator:a690927f0810d85d08f0ab2239e405ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a61c4d55a5d132b25589240be5c015"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab0a61c4d55a5d132b25589240be5c015">vmult</a> (Vector&lt; Number &gt; &amp;y, const std::map&lt; types::global_dof_index, size_t &gt; &amp;y_index_global_to_local_map, const Number alpha, const Vector&lt; Number &gt; &amp;x, const std::map&lt; types::global_dof_index, size_t &gt; &amp;x_index_global_to_local_map) const</td></tr>
<tr class="separator:ab0a61c4d55a5d132b25589240be5c015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e5255eb5ce46136d0e2b195c82f016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">Tvmult</a> (Vector&lt; Number &gt; &amp;y, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:a72e5255eb5ce46136d0e2b195c82f016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46298efb74444db494068cc3fab73431"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a46298efb74444db494068cc3fab73431">Tvmult</a> (Vector&lt; Number &gt; &amp;y, const Number alpha, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:a46298efb74444db494068cc3fab73431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a9fb807eab3f9f0903c03dd637382c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a52a9fb807eab3f9f0903c03dd637382c">Tvmult</a> (Vector&lt; Number &gt; &amp;y, const std::map&lt; types::global_dof_index, size_t &gt; &amp;y_index_global_to_local_map, const Vector&lt; Number &gt; &amp;x, const std::map&lt; types::global_dof_index, size_t &gt; &amp;x_index_global_to_local_map) const</td></tr>
<tr class="separator:a52a9fb807eab3f9f0903c03dd637382c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce6e0dd7cfa3dc0fff165d6ed819017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a9ce6e0dd7cfa3dc0fff165d6ed819017">Tvmult</a> (Vector&lt; Number &gt; &amp;y, const std::map&lt; types::global_dof_index, size_t &gt; &amp;y_index_global_to_local_map, const Number alpha, const Vector&lt; Number &gt; &amp;x, const std::map&lt; types::global_dof_index, size_t &gt; &amp;x_index_global_to_local_map) const</td></tr>
<tr class="separator:a9ce6e0dd7cfa3dc0fff165d6ed819017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168b6eea2e5b27528497850bf5ee2bbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a168b6eea2e5b27528497850bf5ee2bbe">h_h_mmult_reduction</a> ()</td></tr>
<tr class="separator:a168b6eea2e5b27528497850bf5ee2bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c88893c6ca784d4e56653d8b0e3e67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a38c88893c6ca784d4e56653d8b0e3e67">h_h_mmult_horizontal_split</a> (<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bc_tree)</td></tr>
<tr class="separator:a38c88893c6ca784d4e56653d8b0e3e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253c23d09e89a9a37a7d808374b5ae4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a253c23d09e89a9a37a7d808374b5ae4e">h_h_mmult_vertical_split</a> (<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bc_tree)</td></tr>
<tr class="separator:a253c23d09e89a9a37a7d808374b5ae4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab315324e3ece178943f406823f792746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab315324e3ece178943f406823f792746">h_h_mmult_cross_split</a> (<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bc_tree)</td></tr>
<tr class="separator:ab315324e3ece178943f406823f792746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40d53aabc8bec86fa543638d48ba64e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af40d53aabc8bec86fa543638d48ba64e">mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct_a, const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct_b, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct_c, const unsigned int fixed_rank=1)</td></tr>
<tr class="separator:af40d53aabc8bec86fa543638d48ba64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4139e9069e3b18d4719c527ce2e0414c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a4139e9069e3b18d4719c527ce2e0414c">mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct_a, const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct_b, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct_c, const unsigned int fixed_rank, const bool adding)</td></tr>
<tr class="separator:a4139e9069e3b18d4719c527ce2e0414c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea0317bff2670e3ed7e48416f908873"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a4ea0317bff2670e3ed7e48416f908873">mmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a4ea0317bff2670e3ed7e48416f908873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdb7dbcff58654f53a149b94e545bf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aefdb7dbcff58654f53a149b94e545bf7">mmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const unsigned int fixed_rank)</td></tr>
<tr class="separator:aefdb7dbcff58654f53a149b94e545bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7fe2940b614a130d154a29b28b39d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a0b7fe2940b614a130d154a29b28b39d4">mTmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a0b7fe2940b614a130d154a29b28b39d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae163c33fc8d51f96df712ca192e0b6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aae163c33fc8d51f96df712ca192e0b6f">mTmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const unsigned int fixed_rank)</td></tr>
<tr class="separator:aae163c33fc8d51f96df712ca192e0b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f96186426cd3147d5af32ca84ad25ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">add</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k) const</td></tr>
<tr class="separator:a8f96186426cd3147d5af32ca84ad25ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea42f5112b88270fef73342853fa386d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aea42f5112b88270fef73342853fa386d">add</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, const Number b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k) const</td></tr>
<tr class="separator:aea42f5112b88270fef73342853fa386d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd48ada567962ab0dc75c31986bd1a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a9bd48ada567962ab0dc75c31986bd1a6">add</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k) const</td></tr>
<tr class="separator:a9bd48ada567962ab0dc75c31986bd1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42aaa86b9f47c5c1514e4f06e343db6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af42aaa86b9f47c5c1514e4f06e343db6">add</a> (const Number b, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k) const</td></tr>
<tr class="separator:af42aaa86b9f47c5c1514e4f06e343db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1793dff400aeae649f909d7f45db8b8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a1793dff400aeae649f909d7f45db8b8a">add</a> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;B, const std::map&lt; types::global_dof_index, size_t &gt; &amp;row_index_global_to_local_map_for_rk, const std::map&lt; types::global_dof_index, size_t &gt; &amp;col_index_global_to_local_map_for_rk, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k) const</td></tr>
<tr class="separator:a1793dff400aeae649f909d7f45db8b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3800d6fded523d5c8eeb8fd0c106a34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ad3800d6fded523d5c8eeb8fd0c106a34">add</a> (const Number b, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;B, const std::map&lt; types::global_dof_index, size_t &gt; &amp;row_index_global_to_local_map_for_rk, const std::map&lt; types::global_dof_index, size_t &gt; &amp;col_index_global_to_local_map_for_rk, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k) const</td></tr>
<tr class="separator:ad3800d6fded523d5c8eeb8fd0c106a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9000d7604e2045cf7cad7458daca340"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab9000d7604e2045cf7cad7458daca340">add</a> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k)</td></tr>
<tr class="separator:ab9000d7604e2045cf7cad7458daca340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94981e45b7d9aa0f2afae77d414f1c1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a94981e45b7d9aa0f2afae77d414f1c1a">add</a> (const Number b, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k)</td></tr>
<tr class="separator:a94981e45b7d9aa0f2afae77d414f1c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72668962dbad336f0c289bbd060e6ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac72668962dbad336f0c289bbd060e6ce">addsym_diag</a> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;E)</td></tr>
<tr class="separator:ac72668962dbad336f0c289bbd060e6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403d72a5eea3912d67fd0807ddd0baf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a403d72a5eea3912d67fd0807ddd0baf8">add</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k)</td></tr>
<tr class="separator:a403d72a5eea3912d67fd0807ddd0baf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66071b53145fe007ac040fa0c4b47c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af66071b53145fe007ac040fa0c4b47c6">add</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, const Number b, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k)</td></tr>
<tr class="separator:af66071b53145fe007ac040fa0c4b47c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af972cb62d436b8dca5d95a5b6e2ed964"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af972cb62d436b8dca5d95a5b6e2ed964">invert_by_gauss_elim</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M_inv, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k)</td></tr>
<tr class="separator:af972cb62d436b8dca5d95a5b6e2ed964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee2443c3f85cd6a961e77e5287e43f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">solve_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;b, const bool is_unit_diagonal=true) const</td></tr>
<tr class="separator:aeee2443c3f85cd6a961e77e5287e43f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c226aaa96ad7b1a7f0c1507d43bba89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a4c226aaa96ad7b1a7f0c1507d43bba89">solve_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const bool is_unit_diagonal=true) const</td></tr>
<tr class="separator:a4c226aaa96ad7b1a7f0c1507d43bba89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898ed2cdcb0351a6a9b57251320b5d1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a898ed2cdcb0351a6a9b57251320b5d1d">solve_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;b, const std::map&lt; types::global_dof_index, size_t &gt; &amp;vector_index_global_to_local_map, const bool is_unit_diagonal=true) const</td></tr>
<tr class="separator:a898ed2cdcb0351a6a9b57251320b5d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddd48bc33e45d0b4221416cbb039cc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a5ddd48bc33e45d0b4221416cbb039cc3">solve_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const std::map&lt; types::global_dof_index, size_t &gt; &amp;vector_index_global_to_local_map, const bool is_unit_diagonal=true) const</td></tr>
<tr class="separator:a5ddd48bc33e45d0b4221416cbb039cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fa0ad9c55bb5225440ccab58608cf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a20fa0ad9c55bb5225440ccab58608cf8">solve_by_forward_substitution_matrix_valued</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;X, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;Z, const unsigned int fixed_rank, const bool is_unit_diagonal=true)</td></tr>
<tr class="separator:a20fa0ad9c55bb5225440ccab58608cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948b0b53490cc7614ee82fec80fa245a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a948b0b53490cc7614ee82fec80fa245a">solve_cholesky_by_forward_substitution_matrix_valued</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;X, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;Z, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a948b0b53490cc7614ee82fec80fa245a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624fc153099a20572a655457d4f81b70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a624fc153099a20572a655457d4f81b70">solve_transpose_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;b) const</td></tr>
<tr class="separator:a624fc153099a20572a655457d4f81b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f9bb1bc4e584fc5f29541be6b85ef1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a94f9bb1bc4e584fc5f29541be6b85ef1">solve_transpose_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b) const</td></tr>
<tr class="separator:a94f9bb1bc4e584fc5f29541be6b85ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa73f541d0b5eb8cddde5386fd140d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aefa73f541d0b5eb8cddde5386fd140d0">solve_transpose_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;b, const std::map&lt; types::global_dof_index, size_t &gt; &amp;vector_index_global_to_local_map) const</td></tr>
<tr class="separator:aefa73f541d0b5eb8cddde5386fd140d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9c993ce276353fda2bfefd0b932670"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8e9c993ce276353fda2bfefd0b932670">solve_transpose_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const std::map&lt; types::global_dof_index, size_t &gt; &amp;vector_index_global_to_local_map) const</td></tr>
<tr class="separator:a8e9c993ce276353fda2bfefd0b932670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469507ef4061efcc29a65c413ac7acea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a469507ef4061efcc29a65c413ac7acea">solve_transpose_by_forward_substitution_matrix_valued</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;X, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;Z, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a469507ef4061efcc29a65c413ac7acea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f0e0b791e50a3d9b5c0e73ee4423c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a41f0e0b791e50a3d9b5c0e73ee4423c6">solve_cholesky_transpose_by_forward_substitution_matrix_valued</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;X, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;Z, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a41f0e0b791e50a3d9b5c0e73ee4423c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b64d4a5b7120a2599ec3e3e0708775"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab8b64d4a5b7120a2599ec3e3e0708775">solve_block_triangular_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;b, const bool is_unit_block_diagonal=true) const</td></tr>
<tr class="separator:ab8b64d4a5b7120a2599ec3e3e0708775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8046a87be454c81d4a884b53150685a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa8046a87be454c81d4a884b53150685a">solve_block_triangular_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const bool is_unit_block_diagonal=true) const</td></tr>
<tr class="separator:aa8046a87be454c81d4a884b53150685a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09beb710b79d47e34ff3283424cf2a22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a09beb710b79d47e34ff3283424cf2a22">solve_cholesky_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;b) const</td></tr>
<tr class="separator:a09beb710b79d47e34ff3283424cf2a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d32edbfaac9221dc5e219640c3ecd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a59d32edbfaac9221dc5e219640c3ecd3">solve_cholesky_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b) const</td></tr>
<tr class="separator:a59d32edbfaac9221dc5e219640c3ecd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987af3012854b397b90f19f742085155"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a987af3012854b397b90f19f742085155">solve_cholesky_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;b, const std::map&lt; types::global_dof_index, size_t &gt; &amp;vector_index_global_to_local_map) const</td></tr>
<tr class="separator:a987af3012854b397b90f19f742085155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b81214fb9287b344dff8349c7122583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a0b81214fb9287b344dff8349c7122583">solve_cholesky_by_forward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const std::map&lt; types::global_dof_index, size_t &gt; &amp;vector_index_global_to_local_map) const</td></tr>
<tr class="separator:a0b81214fb9287b344dff8349c7122583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7231b00a53ef6b860d774d1daad738f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac7231b00a53ef6b860d774d1daad738f">solve_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;b, const bool is_unit_diagonal=false) const</td></tr>
<tr class="separator:ac7231b00a53ef6b860d774d1daad738f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89582b86090d18d33f7ae04deda1f5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab89582b86090d18d33f7ae04deda1f5f">solve_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const bool is_unit_diagonal=false) const</td></tr>
<tr class="separator:ab89582b86090d18d33f7ae04deda1f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc13c9cf448ec8b47147053d02f357b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aedc13c9cf448ec8b47147053d02f357b">solve_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;b, const std::map&lt; types::global_dof_index, size_t &gt; &amp;vector_index_global_to_local_map, const bool is_unit_diagonal=false) const</td></tr>
<tr class="separator:aedc13c9cf448ec8b47147053d02f357b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90525e857add22b334bac84e6baacd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa90525e857add22b334bac84e6baacd2">solve_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const std::map&lt; types::global_dof_index, size_t &gt; &amp;vector_index_global_to_local_map, const bool is_unit_diagonal=false) const</td></tr>
<tr class="separator:aa90525e857add22b334bac84e6baacd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81db0ff79182302de83d693bab9f9e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa81db0ff79182302de83d693bab9f9e3">solve_block_triangular_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;b, const bool is_unit_block_diagonal=false) const</td></tr>
<tr class="separator:aa81db0ff79182302de83d693bab9f9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69432f004b60ade76aaabf2c94dd205c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a69432f004b60ade76aaabf2c94dd205c">solve_block_triangular_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const bool is_unit_block_diagonal=false) const</td></tr>
<tr class="separator:a69432f004b60ade76aaabf2c94dd205c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054ad84d52a9ee6df9df3bda0a17cfb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a054ad84d52a9ee6df9df3bda0a17cfb7">solve_cholesky_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;b) const</td></tr>
<tr class="separator:a054ad84d52a9ee6df9df3bda0a17cfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880948492a7df252f3696219f6966703"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a880948492a7df252f3696219f6966703">solve_cholesky_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b) const</td></tr>
<tr class="separator:a880948492a7df252f3696219f6966703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8bbf6f35a2099872fbcbfda2cb1abbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae8bbf6f35a2099872fbcbfda2cb1abbd">solve_cholesky_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;b, const std::map&lt; types::global_dof_index, size_t &gt; &amp;vector_index_global_to_local_map) const</td></tr>
<tr class="separator:ae8bbf6f35a2099872fbcbfda2cb1abbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcb361dfb254ff716755ba8b7ed9cf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8dcb361dfb254ff716755ba8b7ed9cf1">solve_cholesky_by_backward_substitution</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b, const std::map&lt; types::global_dof_index, size_t &gt; &amp;vector_index_global_to_local_map) const</td></tr>
<tr class="separator:a8dcb361dfb254ff716755ba8b7ed9cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf95fce81ec83a759d1db8d10c3e34fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#acf95fce81ec83a759d1db8d10c3e34fb">compute_lu_factorization</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;LU, const unsigned int fixed_rank) const</td></tr>
<tr class="separator:acf95fce81ec83a759d1db8d10c3e34fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba14c63550f42d8a971beab340337b0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aba14c63550f42d8a971beab340337b0e">compute_lu_factorization</a> (const unsigned int fixed_rank)</td></tr>
<tr class="separator:aba14c63550f42d8a971beab340337b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6c76f7db2b9239f24df292e945a970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a7d6c76f7db2b9239f24df292e945a970">compute_cholesky_factorization</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;L, const unsigned int fixed_rank) const</td></tr>
<tr class="separator:a7d6c76f7db2b9239f24df292e945a970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6e787e46fb082579b2d3aea1ad54f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#abc6e787e46fb082579b2d3aea1ad54f6">compute_cholesky_factorization</a> (const unsigned int fixed_rank)</td></tr>
<tr class="separator:abc6e787e46fb082579b2d3aea1ad54f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e9dd55091e7eaed11ffb803321c49d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a83e9dd55091e7eaed11ffb803321c49d">solve_lu</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b) const</td></tr>
<tr class="separator:a83e9dd55091e7eaed11ffb803321c49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5582db8445ec15c69bc4bfdda19d547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac5582db8445ec15c69bc4bfdda19d547">solve_cholesky</a> (Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b) const</td></tr>
<tr class="separator:ac5582db8445ec15c69bc4bfdda19d547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c7390b792e6e47ab2861616a997d99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a27c7390b792e6e47ab2861616a997d99">coarsen_to_subtree</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;subtree, const unsigned int fixed_rank_k)</td></tr>
<tr class="separator:a27c7390b792e6e47ab2861616a997d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525ad4d453f4f496b98cccb341c8b60b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a525ad4d453f4f496b98cccb341c8b60b">coarsen_to_partition</a> (const std::vector&lt; typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_pointer_type &gt; &amp;partition, const unsigned int fixed_rank_k)</td></tr>
<tr class="separator:a525ad4d453f4f496b98cccb341c8b60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139f32982527ba981e0211b5663e3b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">build_leaf_set</a> ()</td></tr>
<tr class="separator:a139f32982527ba981e0211b5663e3b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c9102fc04997c1ae3627185379d9bb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac5c9102fc04997c1ae3627185379d9bb">get_leaf_set</a> ()</td></tr>
<tr class="separator:ac5c9102fc04997c1ae3627185379d9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851d7bb3632bc1d18538d4d1dd5f6393"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a851d7bb3632bc1d18538d4d1dd5f6393">get_leaf_set</a> () const</td></tr>
<tr class="separator:a851d7bb3632bc1d18538d4d1dd5f6393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f83de878e6079330ec3c374f587a04"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab0f83de878e6079330ec3c374f587a04">find_block_cluster_in_leaf_set</a> (const <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt; &amp;block_cluster)</td></tr>
<tr class="separator:ab0f83de878e6079330ec3c374f587a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723cc200afe31148fcc28f0120c5ec54"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a723cc200afe31148fcc28f0120c5ec54">find_block_cluster_in_leaf_set</a> (const <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt; &amp;block_cluster) const</td></tr>
<tr class="separator:a723cc200afe31148fcc28f0120c5ec54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b353962226c78910d6ddb6b5b8e460"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ad2b353962226c78910d6ddb6b5b8e460">refine_to_supertree</a> ()</td></tr>
<tr class="separator:ad2b353962226c78910d6ddb6b5b8e460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fd60090b0de7bdea52fc84ddeb22c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af6fd60090b0de7bdea52fc84ddeb22c3">convert_between_different_block_cluster_trees</a> (<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct1, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct2, const unsigned int fixed_rank_k2=1)</td></tr>
<tr class="separator:af6fd60090b0de7bdea52fc84ddeb22c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e023f39b1f8916117a63557895a91b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a9e023f39b1f8916117a63557895a91b4">remove_hmat_pair_from_mm_product_list</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M2)</td></tr>
<tr class="separator:a9e023f39b1f8916117a63557895a91b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ab9b3be4ea0ef959da40e81313b2e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae0ab9b3be4ea0ef959da40e81313b2e3">remove_hmat_pair_from_mm_product_list</a> (const std::pair&lt; const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&gt; &amp;hmat_pair)</td></tr>
<tr class="separator:ae0ab9b3be4ea0ef959da40e81313b2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f24998c7de1d0e336577be41c6281e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tree_8h.html#a922ca07db9633957939f697a65aff11d">TreeNodeSplitMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6f24998c7de1d0e336577be41c6281e3">determine_mm_split_mode_from_Sigma_P</a> ()</td></tr>
<tr class="separator:a6f24998c7de1d0e336577be41c6281e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8b5a9fb65c716187d95bcdb43542884c"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8b5a9fb65c716187d95bcdb43542884c">submatrix_index_invalid</a> = 9</td></tr>
<tr class="separator:a8b5a9fb65c716187d95bcdb43542884c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afd8e08ec263ea524bef3c5c66796c61d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#afd8e08ec263ea524bef3c5c66796c61d">_print_matrix_info_as_dot_node</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:afd8e08ec263ea524bef3c5c66796c61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55b568236ffdd71b5378ac6c6ace50a"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:ab55b568236ffdd71b5378ac6c6ace50a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">_convertToFullMatrix</a> (MatrixType &amp;M) const</td></tr>
<tr class="separator:ab55b568236ffdd71b5378ac6c6ace50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60934e84cc3c9f6c75d011a2005f512a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a60934e84cc3c9f6c75d011a2005f512a">_build_leaf_set</a> (std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a> *&gt; &amp;total_leaf_set) const</td></tr>
<tr class="separator:a60934e84cc3c9f6c75d011a2005f512a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66979dbdf56155c63f0706649e8545b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a66979dbdf56155c63f0706649e8545b9">distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves</a> (const unsigned int fixed_rank=0)</td></tr>
<tr class="separator:a66979dbdf56155c63f0706649e8545b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e24569fe32027c840b160f9dcd1ad7"><td class="memItemLeft" align="right" valign="top"><a id="a39e24569fe32027c840b160f9dcd1ad7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>distribute_sigma_r_and_f_to_leaves</b> (const unsigned int fixed_rank=0)</td></tr>
<tr class="separator:a39e24569fe32027c840b160f9dcd1ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187e0c009a7c28679df7e92e0b01929c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a187e0c009a7c28679df7e92e0b01929c">_distribute_sigma_r_and_f_to_leaves</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat, const unsigned int fixed_rank=0)</td></tr>
<tr class="separator:a187e0c009a7c28679df7e92e0b01929c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74e3b0c19e9178cfe699a6620a51170"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af74e3b0c19e9178cfe699a6620a51170">_invert_by_gauss_elim</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M_inv, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k)</td></tr>
<tr class="separator:af74e3b0c19e9178cfe699a6620a51170"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a89ef60f3ba737c04708195ca0bb13620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">type</a></td></tr>
<tr class="separator:a89ef60f3ba737c04708195ca0bb13620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd1b9a32f2c7693e603a7c6ea916e4f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">submatrices</a></td></tr>
<tr class="separator:a4bd1b9a32f2c7693e603a7c6ea916e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71690997092a4142799b2fa2dbf53db4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a71690997092a4142799b2fa2dbf53db4">parent</a></td></tr>
<tr class="separator:a71690997092a4142799b2fa2dbf53db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c851dd63ba1a466c19f451be369475"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a64c851dd63ba1a466c19f451be369475">submatrix_index</a></td></tr>
<tr class="separator:a64c851dd63ba1a466c19f451be369475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dbd471077be0ad8325d0f2afe3d43f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">leaf_set</a></td></tr>
<tr class="separator:a61dbd471077be0ad8325d0f2afe3d43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97a8f5e42aba0f1d5faf41f35a27819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">rkmatrix</a></td></tr>
<tr class="separator:aa97a8f5e42aba0f1d5faf41f35a27819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328134c9e9cb2c4b05d5431c0ca8a533"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">fullmatrix</a></td></tr>
<tr class="separator:a328134c9e9cb2c4b05d5431c0ca8a533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a304494c970b5b267be1d8459d51586"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_pointer_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a></td></tr>
<tr class="separator:a4a304494c970b5b267be1d8459d51586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b3a936f1b40e320e96d47471da07ae"><td class="memItemLeft" align="right" valign="top">std::vector&lt; types::global_dof_index &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">row_indices</a></td></tr>
<tr class="separator:a33b3a936f1b40e320e96d47471da07ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30ae65e37ec5e4ccc7de2f6b9ea91e6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; types::global_dof_index &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">col_indices</a></td></tr>
<tr class="separator:ac30ae65e37ec5e4ccc7de2f6b9ea91e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d64145335fc0521603b206a22a67578"><td class="memItemLeft" align="right" valign="top">std::map&lt; types::global_dof_index, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">row_index_global_to_local_map</a></td></tr>
<tr class="separator:a4d64145335fc0521603b206a22a67578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab337c7b4f2f40699b9b7f3ab17a1e056"><td class="memItemLeft" align="right" valign="top">std::map&lt; types::global_dof_index, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">col_index_global_to_local_map</a></td></tr>
<tr class="separator:ab337c7b4f2f40699b9b7f3ab17a1e056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5523463043e4d542eae17d262bd22ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">m</a></td></tr>
<tr class="separator:aa5523463043e4d542eae17d262bd22ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ae2eb472f81f80653ed4411629c2d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">n</a></td></tr>
<tr class="separator:ab5ae2eb472f81f80653ed4411629c2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12da9454687e5ca15837d63e2bf0b595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a12da9454687e5ca15837d63e2bf0b595">Tind</a></td></tr>
<tr class="separator:a12da9454687e5ca15837d63e2bf0b595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d96d0252ef8c873ae06cf87874acaf3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">Sigma_P</a></td></tr>
<tr class="separator:a3d96d0252ef8c873ae06cf87874acaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d341b4e606d1be2d71b8ea636efe7b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">Sigma_R</a></td></tr>
<tr class="separator:a04d341b4e606d1be2d71b8ea636efe7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa659b6df63d533432ec1a24435cd9c40"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">Sigma_F</a></td></tr>
<tr class="separator:aa659b6df63d533432ec1a24435cd9c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa949159fde08b9c728ce2cd4c6b99de6"><td class="memTemplParams" colspan="2"><a id="aa949159fde08b9c728ce2cd4c6b99de6"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:aa949159fde08b9c728ce2cd4c6b99de6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitHMatrixWrtBlockClusterNode</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>)</td></tr>
<tr class="separator:aa949159fde08b9c728ce2cd4c6b99de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b4274a06c4ec21a0c1ee4ed870d3a3"><td class="memTemplParams" colspan="2"><a id="ab5b4274a06c4ec21a0c1ee4ed870d3a3"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ab5b4274a06c4ec21a0c1ee4ed870d3a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitHMatrixWrtBlockClusterNode</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const std::vector&lt; std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *&gt;&gt; &amp;<a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">Sigma_P</a>)</td></tr>
<tr class="separator:ab5b4274a06c4ec21a0c1ee4ed870d3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe123e0f8daa856e4b85e00829398b79"><td class="memTemplParams" colspan="2"><a id="abe123e0f8daa856e4b85e00829398b79"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:abe123e0f8daa856e4b85e00829398b79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitHMatrixWrtBlockClusterNode</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *&gt; &amp;hmat_pair)</td></tr>
<tr class="separator:abe123e0f8daa856e4b85e00829398b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a9e7eae8c4fbab8c426552399d072a"><td class="memTemplParams" colspan="2"><a id="a69a9e7eae8c4fbab8c426552399d072a"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a69a9e7eae8c4fbab8c426552399d072a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildrenWithoutAlloc</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const bool is_build_index_set_global_to_local_map)</td></tr>
<tr class="separator:a69a9e7eae8c4fbab8c426552399d072a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9dff162efb21e08ab5d6fc3bc2219fa"><td class="memTemplParams" colspan="2"><a id="ac9dff162efb21e08ab5d6fc3bc2219fa"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ac9dff162efb21e08ab5d6fc3bc2219fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildren</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const unsigned int fixed_rank_k, bool is_build_index_set_global_to_local_map)</td></tr>
<tr class="separator:ac9dff162efb21e08ab5d6fc3bc2219fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97abbebc640c23d742408edfa3526572"><td class="memTemplParams" colspan="2"><a id="a97abbebc640c23d742408edfa3526572"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a97abbebc640c23d742408edfa3526572"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildren</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const unsigned int fixed_rank_k, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M, bool is_build_index_set_global_to_local_map)</td></tr>
<tr class="separator:a97abbebc640c23d742408edfa3526572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3f09c87b4186e3c99b57404c10f8b3"><td class="memTemplParams" colspan="2"><a id="a4b3f09c87b4186e3c99b57404c10f8b3"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a4b3f09c87b4186e3c99b57404c10f8b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildren</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M, bool is_build_index_set_global_to_local_map)</td></tr>
<tr class="separator:a4b3f09c87b4186e3c99b57404c10f8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac490314e7c775bf5bbaef5562aad650"><td class="memTemplParams" colspan="2"><a id="aac490314e7c775bf5bbaef5562aad650"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:aac490314e7c775bf5bbaef5562aad650"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildren</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const unsigned int fixed_rank_k, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M, const std::map&lt; types::global_dof_index, size_t &gt; &amp;row_index_global_to_local_map_for_M, const std::map&lt; types::global_dof_index, size_t &gt; &amp;col_index_global_to_local_map_for_M, bool is_build_index_set_global_to_local_map)</td></tr>
<tr class="separator:aac490314e7c775bf5bbaef5562aad650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac91976ab243c469da338d960885847"><td class="memTemplParams" colspan="2"><a id="a7ac91976ab243c469da338d960885847"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a7ac91976ab243c469da338d960885847"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildren</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M, const std::map&lt; types::global_dof_index, size_t &gt; &amp;row_index_global_to_local_map_for_M, const std::map&lt; types::global_dof_index, size_t &gt; &amp;col_index_global_to_local_map_for_M, bool is_build_index_set_global_to_local_map)</td></tr>
<tr class="separator:a7ac91976ab243c469da338d960885847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d91a693388f0f14c515f7c97c14aed"><td class="memTemplParams" colspan="2"><a id="ab0d91a693388f0f14c515f7c97c14aed"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ab0d91a693388f0f14c515f7c97c14aed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildren</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;&amp;H)</td></tr>
<tr class="separator:ab0d91a693388f0f14c515f7c97c14aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac511284701f9f527c0480608242d0619"><td class="memTemplParams" colspan="2"><a id="ac511284701f9f527c0480608242d0619"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ac511284701f9f527c0480608242d0619"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RefineHMatrixWrtExtendedBlockClusterTree</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *starting_hmat, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *current_hmat)</td></tr>
<tr class="separator:ac511284701f9f527c0480608242d0619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47825229983c7fa5755b3be8d5ac03f7"><td class="memTemplParams" colspan="2"><a id="a47825229983c7fa5755b3be8d5ac03f7"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a47825229983c7fa5755b3be8d5ac03f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertHMatBlockToRkMatrix</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat_block, const unsigned int fixed_rank_k, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat_root_block, size_t *calling_counter, const std::string &amp;output_file_base_name)</td></tr>
<tr class="separator:a47825229983c7fa5755b3be8d5ac03f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7e9489e842016dd9815a0490c7667d"><td class="memItemLeft" align="right" valign="top"><a id="aaa7e9489e842016dd9815a0490c7667d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>build_index_set_global_to_local_map</b> (const std::vector&lt; types::global_dof_index &gt; &amp;index_set_as_local_to_global_map, std::map&lt; types::global_dof_index, size_t &gt; &amp;global_to_local_map)</td></tr>
<tr class="separator:aaa7e9489e842016dd9815a0490c7667d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5b4592067610eec18b830482897243"><td class="memTemplParams" colspan="2"><a id="a1b5b4592067610eec18b830482897243"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a1b5b4592067610eec18b830482897243"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_rk_mmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a1b5b4592067610eec18b830482897243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04c7cb6f2968253cf41b1d1a93760c7"><td class="memTemplParams" colspan="2"><a id="af04c7cb6f2968253cf41b1d1a93760c7"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:af04c7cb6f2968253cf41b1d1a93760c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_rk_mmult</b> (const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:af04c7cb6f2968253cf41b1d1a93760c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59530b8595d7716e02b405e35dbc561"><td class="memTemplParams" colspan="2"><a id="ad59530b8595d7716e02b405e35dbc561"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ad59530b8595d7716e02b405e35dbc561"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_rk_mTmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:ad59530b8595d7716e02b405e35dbc561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf5a4058289ffe89a9f88379e643e53"><td class="memTemplParams" colspan="2"><a id="a8cf5a4058289ffe89a9f88379e643e53"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a8cf5a4058289ffe89a9f88379e643e53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_rk_mTmult</b> (const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a8cf5a4058289ffe89a9f88379e643e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614ba3b92b97d95cb3146db181611a34"><td class="memTemplParams" colspan="2"><a id="a614ba3b92b97d95cb3146db181611a34"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a614ba3b92b97d95cb3146db181611a34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_rk_mmult_for_h_h_mmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M, bool is_M1M2_last_in_M_Sigma_P)</td></tr>
<tr class="separator:a614ba3b92b97d95cb3146db181611a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa94f9688a9443024a2631d2bfae06c8"><td class="memTemplParams" colspan="2"><a id="afa94f9688a9443024a2631d2bfae06c8"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:afa94f9688a9443024a2631d2bfae06c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rk_h_mmult</b> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:afa94f9688a9443024a2631d2bfae06c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a9c2821153dd59f0d230a997879ff3"><td class="memTemplParams" colspan="2"><a id="a52a9c2821153dd59f0d230a997879ff3"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a52a9c2821153dd59f0d230a997879ff3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rk_h_mmult</b> (const Number1 alpha, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a52a9c2821153dd59f0d230a997879ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c04e99e7f40fb0c9f3dcc042e95882a"><td class="memTemplParams" colspan="2"><a id="a0c04e99e7f40fb0c9f3dcc042e95882a"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a0c04e99e7f40fb0c9f3dcc042e95882a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rk_h_mTmult</b> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a0c04e99e7f40fb0c9f3dcc042e95882a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fddb7ff1c462d5605b63ea0b10bcc34"><td class="memTemplParams" colspan="2"><a id="a2fddb7ff1c462d5605b63ea0b10bcc34"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a2fddb7ff1c462d5605b63ea0b10bcc34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rk_h_mTmult</b> (const Number1 alpha, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a2fddb7ff1c462d5605b63ea0b10bcc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b12cf1aa7504c436b84394f2116f6a9"><td class="memTemplParams" colspan="2"><a id="a9b12cf1aa7504c436b84394f2116f6a9"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a9b12cf1aa7504c436b84394f2116f6a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rk_h_mmult_for_h_h_mmult</b> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M, bool is_M1M2_last_in_M_Sigma_P)</td></tr>
<tr class="separator:a9b12cf1aa7504c436b84394f2116f6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ccef980f81f9fb3c63675f3f9c014f"><td class="memTemplParams" colspan="2"><a id="a85ccef980f81f9fb3c63675f3f9c014f"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a85ccef980f81f9fb3c63675f3f9c014f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a85ccef980f81f9fb3c63675f3f9c014f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72731e18525c507f92b16d880858b93"><td class="memTemplParams" colspan="2"><a id="ab72731e18525c507f92b16d880858b93"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ab72731e18525c507f92b16d880858b93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mmult</b> (const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:ab72731e18525c507f92b16d880858b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcedf4b5e2f14d085cce5cdc3f2b46cf"><td class="memTemplParams" colspan="2"><a id="adcedf4b5e2f14d085cce5cdc3f2b46cf"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:adcedf4b5e2f14d085cce5cdc3f2b46cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mTmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:adcedf4b5e2f14d085cce5cdc3f2b46cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86eb2a4d2b7039163dd4f28650fe747e"><td class="memTemplParams" colspan="2"><a id="a86eb2a4d2b7039163dd4f28650fe747e"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a86eb2a4d2b7039163dd4f28650fe747e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mTmult</b> (const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a86eb2a4d2b7039163dd4f28650fe747e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3866052a5345742ad9f44f11f33989"><td class="memTemplParams" colspan="2"><a id="aea3866052a5345742ad9f44f11f33989"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:aea3866052a5345742ad9f44f11f33989"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:aea3866052a5345742ad9f44f11f33989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad090448398bf367cba0b208456144e7d"><td class="memTemplParams" colspan="2"><a id="ad090448398bf367cba0b208456144e7d"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ad090448398bf367cba0b208456144e7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mmult</b> (const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:ad090448398bf367cba0b208456144e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f368b3c372ece4b6506d89bb9e255df"><td class="memTemplParams" colspan="2"><a id="a8f368b3c372ece4b6506d89bb9e255df"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a8f368b3c372ece4b6506d89bb9e255df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mTmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a8f368b3c372ece4b6506d89bb9e255df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81f9d9c00ebd7bdabb28b6ea0646236"><td class="memTemplParams" colspan="2"><a id="ad81f9d9c00ebd7bdabb28b6ea0646236"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ad81f9d9c00ebd7bdabb28b6ea0646236"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mTmult</b> (const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:ad81f9d9c00ebd7bdabb28b6ea0646236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897365f6716975f71b528f610498c69b"><td class="memTemplParams" colspan="2"><a id="a897365f6716975f71b528f610498c69b"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a897365f6716975f71b528f610498c69b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mmult_for_h_h_mmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M, bool is_M1M2_last_in_M_Sigma_P)</td></tr>
<tr class="separator:a897365f6716975f71b528f610498c69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b0f45b3a6734fef74d90f28fcefbc1"><td class="memTemplParams" colspan="2"><a id="a67b0f45b3a6734fef74d90f28fcefbc1"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a67b0f45b3a6734fef74d90f28fcefbc1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mmult</b> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a67b0f45b3a6734fef74d90f28fcefbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58df6eed9eb48d8d725476c8e289d859"><td class="memTemplParams" colspan="2"><a id="a58df6eed9eb48d8d725476c8e289d859"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a58df6eed9eb48d8d725476c8e289d859"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mmult</b> (const Number1 alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a58df6eed9eb48d8d725476c8e289d859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a400c086f929a643da87cf6dc493c26"><td class="memTemplParams" colspan="2"><a id="a6a400c086f929a643da87cf6dc493c26"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a6a400c086f929a643da87cf6dc493c26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mTmult</b> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a6a400c086f929a643da87cf6dc493c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2beff0c056d76818dc4e61dded73fe0"><td class="memTemplParams" colspan="2"><a id="ac2beff0c056d76818dc4e61dded73fe0"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ac2beff0c056d76818dc4e61dded73fe0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mTmult</b> (const Number1 alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:ac2beff0c056d76818dc4e61dded73fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d1ce72cb294b2c4da6536250905a32"><td class="memTemplParams" colspan="2"><a id="a66d1ce72cb294b2c4da6536250905a32"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a66d1ce72cb294b2c4da6536250905a32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mmult</b> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a66d1ce72cb294b2c4da6536250905a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6da79ad8924c127c5eb34acf396cf00"><td class="memTemplParams" colspan="2"><a id="ac6da79ad8924c127c5eb34acf396cf00"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ac6da79ad8924c127c5eb34acf396cf00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mmult</b> (const Number1 alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:ac6da79ad8924c127c5eb34acf396cf00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439a1469e55ddc97987ee592b920cedb"><td class="memTemplParams" colspan="2"><a id="a439a1469e55ddc97987ee592b920cedb"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a439a1469e55ddc97987ee592b920cedb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mTmult</b> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a439a1469e55ddc97987ee592b920cedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c51795179e7c52726d2eb3a76a17914"><td class="memTemplParams" colspan="2"><a id="a7c51795179e7c52726d2eb3a76a17914"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a7c51795179e7c52726d2eb3a76a17914"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mTmult</b> (const Number1 alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a7c51795179e7c52726d2eb3a76a17914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311938523b49a053a8cf16bc96576cdf"><td class="memTemplParams" colspan="2"><a id="a311938523b49a053a8cf16bc96576cdf"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a311938523b49a053a8cf16bc96576cdf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mmult_for_h_h_mmult</b> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M, bool is_M1M2_last_in_M_Sigma_P)</td></tr>
<tr class="separator:a311938523b49a053a8cf16bc96576cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad755e8e3b11e19f553e77bae172ce849"><td class="memTemplParams" colspan="2"><a id="ad755e8e3b11e19f553e77bae172ce849"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ad755e8e3b11e19f553e77bae172ce849"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mmult_phase1_recursion</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt; &amp;<a class="el" href="classHMatrix.html#a12da9454687e5ca15837d63e2bf0b595">Tind</a>)</td></tr>
<tr class="separator:ad755e8e3b11e19f553e77bae172ce849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58016ed0bee33836c69eb23970c24df"><td class="memTemplParams" colspan="2"><a id="ac58016ed0bee33836c69eb23970c24df"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ac58016ed0bee33836c69eb23970c24df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mmult_phase2</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt; &amp;target_bc_tree, const unsigned int fixed_rank)</td></tr>
<tr class="separator:ac58016ed0bee33836c69eb23970c24df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51daefaa59911ec728910847e968027"><td class="memTemplParams" colspan="2"><a id="ae51daefaa59911ec728910847e968027"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ae51daefaa59911ec728910847e968027"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mmult_from_leaf_node</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const unsigned int fixed_rank)</td></tr>
<tr class="separator:ae51daefaa59911ec728910847e968027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ecdcf004204cdf053251309abfe2a8"><td class="memTemplParams" colspan="2"><a id="a93ecdcf004204cdf053251309abfe2a8"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a93ecdcf004204cdf053251309abfe2a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mmult_from_leaf_node</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a93ecdcf004204cdf053251309abfe2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983f20b2ffc0f0ad5f6e464f7244a2bf"><td class="memTemplParams" colspan="2"><a id="a983f20b2ffc0f0ad5f6e464f7244a2bf"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a983f20b2ffc0f0ad5f6e464f7244a2bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mTmult_from_leaf_node</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a983f20b2ffc0f0ad5f6e464f7244a2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31200d7f85e3d9ec53117c80df47cdaf"><td class="memTemplParams" colspan="2"><a id="a31200d7f85e3d9ec53117c80df47cdaf"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a31200d7f85e3d9ec53117c80df47cdaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mTmult_from_leaf_node</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a31200d7f85e3d9ec53117c80df47cdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cad078355a647e17dd33970f5449e0"><td class="memTemplParams" colspan="2"><a id="a13cad078355a647e17dd33970f5449e0"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a13cad078355a647e17dd33970f5449e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mmult_level_conserving</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a13cad078355a647e17dd33970f5449e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec01211adffa740f7e6ef82fd31b68cf"><td class="memTemplParams" colspan="2"><a id="aec01211adffa740f7e6ef82fd31b68cf"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:aec01211adffa740f7e6ef82fd31b68cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mmult_level_conserving</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const unsigned int fixed_rank)</td></tr>
<tr class="separator:aec01211adffa740f7e6ef82fd31b68cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5ee01109ae6f420d5d68444b212d68"><td class="memTemplParams" colspan="2"><a id="add5ee01109ae6f420d5d68444b212d68"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:add5ee01109ae6f420d5d68444b212d68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mTmult_level_conserving</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const unsigned int fixed_rank)</td></tr>
<tr class="separator:add5ee01109ae6f420d5d68444b212d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5803f16610413cda0dcbcde5011ea3b"><td class="memTemplParams" colspan="2"><a id="aa5803f16610413cda0dcbcde5011ea3b"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:aa5803f16610413cda0dcbcde5011ea3b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mTmult_level_conserving</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, const Number1 alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, const unsigned int fixed_rank)</td></tr>
<tr class="separator:aa5803f16610413cda0dcbcde5011ea3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec67bee413b9db0bedfe58ddc0d91c1"><td class="memTemplParams" colspan="2"><a id="a4ec67bee413b9db0bedfe58ddc0d91c1"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a4ec67bee413b9db0bedfe58ddc0d91c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_hmatrix_node</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat_dst, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat_src)</td></tr>
<tr class="separator:a4ec67bee413b9db0bedfe58ddc0d91c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e52ecf1ea024322e4318243e922a1c"><td class="memTemplParams" colspan="2"><a id="a10e52ecf1ea024322e4318243e922a1c"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a10e52ecf1ea024322e4318243e922a1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_hmatrix_node</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat_dst, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;&amp;hmat_src)</td></tr>
<tr class="separator:a10e52ecf1ea024322e4318243e922a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ce56e1013c5060804023841e3ac93b"><td class="memTemplParams" colspan="2"><a id="a29ce56e1013c5060804023841e3ac93b"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a29ce56e1013c5060804023841e3ac93b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_hmatrix</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat_dst, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat_src)</td></tr>
<tr class="separator:a29ce56e1013c5060804023841e3ac93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eefa50a413f628f9b74c4b7ca7fd118"><td class="memTemplParams" colspan="2"><a id="a9eefa50a413f628f9b74c4b7ca7fd118"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a9eefa50a413f628f9b74c4b7ca7fd118"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>print_h_submatrix_accessor</b> (std::ostream &amp;out, const std::string &amp;name, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a9eefa50a413f628f9b74c4b7ca7fd118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee7e6e1599718531085769438a918a7"><td class="memTemplParams" colspan="2"><a id="adee7e6e1599718531085769438a918a7"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:adee7e6e1599718531085769438a918a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>print_h_h_submatrix_mmult_accessor</b> (std::ostream &amp;out, const std::string &amp;name1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const std::string &amp;name2, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2)</td></tr>
<tr class="separator:adee7e6e1599718531085769438a918a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cbdadb17c9b375a0183d2172b678ff"><td class="memTemplParams" colspan="2"><a id="aa5cbdadb17c9b375a0183d2172b678ff"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:aa5cbdadb17c9b375a0183d2172b678ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hmatrix_solve_lu</b> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;L, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;U, Vector&lt; Number1 &gt; &amp;x, const Vector&lt; Number1 &gt; &amp;b)</td></tr>
<tr class="separator:aa5cbdadb17c9b375a0183d2172b678ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2e9410cc83312bd7d00cebf4584b75"><td class="memTemplParams" colspan="2"><a id="a9f2e9410cc83312bd7d00cebf4584b75"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a9f2e9410cc83312bd7d00cebf4584b75"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hmatrix_solve_cholesky</b> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;L, Vector&lt; Number1 &gt; &amp;x, const Vector&lt; Number1 &gt; &amp;b)</td></tr>
<tr class="separator:a9f2e9410cc83312bd7d00cebf4584b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5ca8dc549783d38371a01ecd621ecb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca8dc549783d38371a01ecd621ecb34">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> =  std::make_unsigned&lt;types::blas_int&gt;::<a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the type for container size. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae3dc35e1aefee2580d27ad2d65c906de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3dc35e1aefee2580d27ad2d65c906de">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. </p>

</div>
</div>
<a id="a6a4dead0321e8df38865bf6fbd0f6e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4dead0321e8df38865bf6fbd0f6e81">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct the hierarchical structure without data from the root node of a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>. </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, and <a class="el" href="classBlockClusterTree.html#a4a4f3b893380d1d7f53b772589a847d2">BlockClusterTree&lt; spacedim, Number &gt;::get_root()</a>.</p>

</div>
</div>
<a id="a4fe44a3aa2b813f593b787f24be56a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe44a3aa2b813f593b787f24be56a1c">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct the hierarchical structure without data from a <a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>. </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>.</p>

</div>
</div>
<a id="ad3a62fe726b69cbde07b1f434417d318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a62fe726b69cbde07b1f434417d318">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from the root node of a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a> while copying the data of a global full matrix, which is created on the complete block cluster \(I \times J\). </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, and <a class="el" href="classBlockClusterTree.html#a4a4f3b893380d1d7f53b772589a847d2">BlockClusterTree&lt; spacedim, Number &gt;::get_root()</a>.</p>

</div>
</div>
<a id="af72a32400b866e633dda058c949d4f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72a32400b866e633dda058c949d4f79">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from the root node of a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a> while copying the data of a global full matrix, which is created on the complete block cluster \(I \times J\).</p>
<p>This version has no rank truncation. </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, and <a class="el" href="classBlockClusterTree.html#a4a4f3b893380d1d7f53b772589a847d2">BlockClusterTree&lt; spacedim, Number &gt;::get_root()</a>.</p>

</div>
</div>
<a id="a3d444d5d8d3d88e31b7c1046c29017fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d444d5d8d3d88e31b7c1046c29017fd">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from a <a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a> while copying the data of a global full matrix, which is created on the complete block cluster \(I \times J\). </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>.</p>

</div>
</div>
<a id="a97b27ea3c54897b34ccb163415d1569d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b27ea3c54897b34ccb163415d1569d">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from a <a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a> while copying the data of a global full matrix, which is created on the complete block cluster \(I \times J\).</p>
<p>This version has no rank truncation. </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>.</p>

</div>
</div>
<a id="abeb8d0add9bffecafc12f4c6b1dcab8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb8d0add9bffecafc12f4c6b1dcab8e">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from a <code><a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a></code> in a <code><a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a></code> while moving the data from the leaf set of the \(\mathcal{H}\)-matrix <code>H</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bc_node</td><td></td></tr>
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>.</p>

</div>
</div>
<a id="a78aa967d7a99e27cc172f0db3791306b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78aa967d7a99e27cc172f0db3791306b">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from the root node of a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a> while moving the data from the leaf set of the \(\mathcal{H}\)-matrix <code>H</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bct</td><td></td></tr>
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, and <a class="el" href="classBlockClusterTree.html#a4a4f3b893380d1d7f53b772589a847d2">BlockClusterTree&lt; spacedim, Number &gt;::get_root()</a>.</p>

</div>
</div>
<a id="a0b5227e35290f6c9fba1e8948e9a29c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5227e35290f6c9fba1e8948e9a29c3">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deep copy constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>.</p>

</div>
</div>
<a id="a556325d4cdaee699f17aa1be63bb58ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556325d4cdaee699f17aa1be63bb58ee">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shallow copy constructor.</p>
<p>After the copy operation, the data in the source matrix <code>H</code> are transferred to the current \(\mathcal{H}\)-matrix node and <code>H</code> is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae16c956c1b22eb307e9f360a83f4fa75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16c956c1b22eb307e9f360a83f4fa75">&#9670;&nbsp;</a></span>~HMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::~<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor which releases the memory by recursion. </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a60934e84cc3c9f6c75d011a2005f512a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60934e84cc3c9f6c75d011a2005f512a">&#9670;&nbsp;</a></span>_build_leaf_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_build_leaf_set </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>total_leaf_set</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collect \(\mathcal{H}\)-matrix nodes in the leaf set into a vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_leaf_set</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a66979dbdf56155c63f0706649e8545b9">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>.</p>

</div>
</div>
<a id="ab55b568236ffdd71b5378ac6c6ace50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55b568236ffdd71b5378ac6c6ace50a">&#9670;&nbsp;</a></span>_convertToFullMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_convertToFullMatrix </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert an <a class="el" href="classHMatrix.html">HMatrix</a> to a full matrix by recursion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a00bdd40f7fcf5c912c34c427df518300">HMatrix&lt; spacedim, Number &gt;::convertToFullMatrix()</a>.</p>

</div>
</div>
<a id="a187e0c009a7c28679df7e92e0b01929c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187e0c009a7c28679df7e92e0b01929c">&#9670;&nbsp;</a></span>_distribute_sigma_r_and_f_to_leaves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Restrict each rank-k matrix in the list <code>Sigma_R</code> of <code>starting_hmat</code> to the block as a full matrix.</p>
<p>Restrict each full matrix in the list <code>Sigma_F</code> of <code>starting_hmat</code> to the block as a full matrix.</p>
<p>Restrict each rank-k matrix in the list <code>Sigma_R</code> of <code>starting_hmat</code> to the block as a rank-k matrix.</p>
<p>Restrict each full matrix in the list <code>Sigma_F</code> of <code>starting_hmat</code> to the block as a rank-k matrix.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classRkMatrix.html#a5305306386e47bcded819ce8d7f7935c">RkMatrix&lt; Number &gt;::restrictToFullMatrix()</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a66979dbdf56155c63f0706649e8545b9">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>.</p>

</div>
</div>
<a id="af74e3b0c19e9178cfe699a6620a51170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74e3b0c19e9178cfe699a6620a51170">&#9670;&nbsp;</a></span>_invert_by_gauss_elim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_invert_by_gauss_elim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the inverse of the \(\mathcal{H}\)-matrix node via Gauss elimination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M_inv</td><td></td></tr>
    <tr><td class="paramname">M_root</td><td>The \(\mathcal{H}\)-matrix node from which this recursive function is called for the first time. </td></tr>
    <tr><td class="paramname">M_root_bct</td><td>The block cluster tree associated with <code>M_root</code>. </td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>If the current matrix block to be handled has a same \(\tau\) cluster and \(\sigma\) cluster and belongs to the leaf set of <code>M_root</code>, directly calculate its inverse as full matrix.</p>
<p><b>2021-10-05 At present, we assume the \(\mathcal{H}\)-matrix hierarchy is completely the same as the associated block cluster tree, or rather, the block cluster tree is not finer than the \(\mathcal{H}\)-matrix. Therefore, whether the block cluster node is a leaf is equivalent to whether the \(\mathcal{H}\)-matrix node is a leaf. In a more generalized implementation, the block cluster tree can be finer than the \(\mathcal{H}\)-matrix hierarchy.</b></p>
<p>Number of matrix blocks in a row, which is also the number of matrix blocks in a column.</p>
<p>Stage 1: eliminate the lower triangular part of the matrix.</p>
<p>Calculate the inverse of the diagonal block \(M \vert_{\tau[l]\times\tau[l]}\). The formula \(l + l \cdot k\) calculates the 1D index of the diagonal block in <code>submatrices</code>. This is because the submatrices of the current \(\mathcal{H}\)-matrix node is stored in the following order:</p>
<p><code> submatrices = {tau[0]*sigma[0], tau[0]*sigma[1], tau[1]*sigma[0], tau[1]*sigma[1]} </code></p>
<p>Since \(\tau\) is the same as \(\sigma\), we have</p>
<p><code> submatrices = {tau[0]*tau[0], tau[0]*tau[1], tau[1]*tau[0], tau[1]*tau[1]} </code></p>
<p>Hence, the index of <code>tau</code>[0]*tau[0] in <code>submatrices</code> is 0 and the index of <code>tau</code>[1]*tau[1] in <code>submatrices</code> is 3. The former index is calculated as <code>0 + 0 * 2 = 0</code>, while the latter index is calculated as <code>1 + 1 * 2 = 3</code>.</p>
<p>Iterate over the columns from \(l + 1\) to \(k\) in the source matrix and scale each matrix block with the factor <code>M_inv.submatrices</code>[diag_block_index_in_submatrices]. Also note that the column index starts from zero, therefore the loop variable \(j \in [l+1, k)\).</p>
<p>Migrate the newly created \(\mathcal{H}\)-matrix to the target submatrix.</p>
<p>Iterate over the columns from \(0\) to \(l - 1\) in the inverse matrix and scale each matrix block with the factor <code>M_inv.submatrices</code>[diag_block_index_in_submatrices].</p>
<p>Migrate the newly created \(\mathcal{H}\)-matrix to the target submatrix.</p>
<p>Iterate over the rows from \(l + 1\) to \(k - 1\) in order to eliminate the matrix blocks \(M_{l+1,l}, \cdots, M_{k - 1,l}\).</p>
<p>Stage 2: eliminate the upper triangular part of the matrix.</p>
<p>Eliminate the elements \(M_{l-1,l}, \cdots, M_{1,l}\).</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#af972cb62d436b8dca5d95a5b6e2ed964">HMatrix&lt; spacedim, Number &gt;::invert_by_gauss_elim()</a>.</p>

</div>
</div>
<a id="afd8e08ec263ea524bef3c5c66796c61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8e08ec263ea524bef3c5c66796c61d">&#9670;&nbsp;</a></span>_print_matrix_info_as_dot_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_print_matrix_info_as_dot_node </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the \(\mathcal{H}\)-matrix hierarchy information recursively as a node in the directional graph in Graphviz dot format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create the graph node for the current \(\mathcal{H}\)-matrix node. When the current \(\mathcal{H}\)-matrix node is a full matrix, use red background. When it is a rank-k matrix, use green background.</p>
<p>Construct the relationship between the current node and its children.</p>
<p>Print each submatrix node.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ae904288a7e0ac82d9fd2364b1c150bc2">HMatrix&lt; spacedim, Number &gt;::print_matrix_info_as_dot()</a>.</p>

</div>
</div>
<a id="a8f96186426cd3147d5af32ca84ad25ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f96186426cd3147d5af32ca84ad25ea">&#9670;&nbsp;</a></span>add() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the current <a class="el" href="classHMatrix.html">HMatrix</a> <code>A</code> with another <a class="el" href="classHMatrix.html">HMatrix</a> <code>B</code> into <code>C</code>, i.e. whole matrix addition instead of addition limited to a specific block, where <code>C</code> will be truncated to a fixed rank <code>fixed_rank</code>.</p>
<p>This algorithm is intrinsically recursive, i.e. the addition of parent HMatrices will perform the addition of each pair of child HMatrices corresponding to a same block cluster. Strictly speaking, this member function <code>add</code> is not a recursive function, because the class instance which calls <code>add</code> changes from parent to child <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p>N.B.</p>
<ol type="1">
<li>The two operands should have the same partition.</li>
<li>The hierarchical structure of <code>C</code> should be pre-generated.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p><b>Work flow</b></p>
<p>Recursively add each pair of submatrices.</p>
<p>Perform addition of full matrices.</p>
<p>Perform addition of rank-k matrices.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ab9000d7604e2045cf7cad7458daca340">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="hmatrix_8h.html#a6534ff122b0835d0313d94264794b601">h_h_mmult_level_conserving()</a>, <a class="el" href="hmatrix_8h.html#a8855023aa4832e4119c6ead1115d4beb">h_h_mTmult_level_conserving()</a>, <a class="el" href="hmatrix-add-formatted-with-factor_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="classHMatrix.html#a4139e9069e3b18d4719c527ce2e0414c">HMatrix&lt; spacedim, Number &gt;::mmult()</a>.</p>

</div>
</div>
<a id="aea42f5112b88270fef73342853fa386d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea42f5112b88270fef73342853fa386d">&#9670;&nbsp;</a></span>add() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the addition with factor \(C = A + b B\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>
<p><b>Work flow</b></p>
<p>Recursively add each pair of submatrices.</p>
<p>Perform addition of full matrices.</p>
<p>Perform addition of rank-k matrices.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="a9bd48ada567962ab0dc75c31986bd1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd48ada567962ab0dc75c31986bd1a6">&#9670;&nbsp;</a></span>add() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the <a class="el" href="classHMatrix.html">HMatrix</a> <code>B</code> into the current <a class="el" href="classHMatrix.html">HMatrix</a> <code>A</code>, i.e. whole matrix addition instead of addition limited to a specific block, where <code>C</code> will be truncated to a fixed rank <code>fixed_rank</code>.</p>
<p>This algorithm is intrinsically recursive, i.e. the addition of parent HMatrices will perform the addition of each pair of child HMatrices corresponding to a same block cluster. Strictly speaking, this member function <code>add</code> is not a recursive function, because the class instance which calls <code>add</code> changes from parent to child <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p>N.B. The two operands should have the same partition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p><b>Work flow</b></p>
<p>Recursively add each pair of submatrices.</p>
<p>Perform addition of full matrices.</p>
<p>Perform addition of rank-k matrices.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="af42aaa86b9f47c5c1514e4f06e343db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42aaa86b9f47c5c1514e4f06e343db6">&#9670;&nbsp;</a></span>add() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the addition \(A = A + b B\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>
<p><b>Work flow</b></p>
<p>Recursively add each pair of submatrices.</p>
<p>Perform addition of full matrices.</p>
<p>Perform addition of rank-k matrices.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="a1793dff400aeae649f909d7f45db8b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1793dff400aeae649f909d7f45db8b8a">&#9670;&nbsp;</a></span>add() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_index_global_to_local_map_for_rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_index_global_to_local_map_for_rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a rank-k matrix into the current \(\mathcal{H}\)-matrix node.</p>
<p>The rank-k matrix will be restricted to each leaf node of the \(\mathcal{H}\)-matrix node and the addition will be performed there. In this implementation, the row and column global to local index maps with respect to <code>B</code> should be explicit provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Restrict the rank-k matrix to the local full matrix then perform the addition with the leaf node of the \(\mathcal{H}\)-matrix.</p>
<p>Create a local rank-k matrix by restricting from the original large rank-k matrix.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classRkMatrix.html#a5305306386e47bcded819ce8d7f7935c">RkMatrix&lt; Number &gt;::restrictToFullMatrix()</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="ad3800d6fded523d5c8eeb8fd0c106a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3800d6fded523d5c8eeb8fd0c106a34">&#9670;&nbsp;</a></span>add() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_index_global_to_local_map_for_rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_index_global_to_local_map_for_rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a rank-k matrix multiplied by a factor into the current \(\mathcal{H}\)-matrix node.</p>
<p>The rank-k matrix will be restricted to each leaf node of the \(\mathcal{H}\)-matrix node and the addition will be performed there. In this implementation, the row and column global to local index maps with respect to <code>B</code> should be explicitly provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Restrict the rank-k matrix to the local full matrix then perform the addition with the leaf node of the \(\mathcal{H}\)-matrix.</p>
<p>Create a local rank-k matrix by restricting from the original large rank-k matrix.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classRkMatrix.html#a5305306386e47bcded819ce8d7f7935c">RkMatrix&lt; Number &gt;::restrictToFullMatrix()</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="ab9000d7604e2045cf7cad7458daca340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9000d7604e2045cf7cad7458daca340">&#9670;&nbsp;</a></span>add() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a rank-k matrix into the current \(\mathcal{H}\)-matrix node.</p>
<p>The rank-k matrix will be restricted to each leaf node of the \(\mathcal{H}\)-matrix node and the addition will be performed there. In this implementation, the row and column global to local index maps with respect to <code>B</code> are the same as those associated with the \(\mathcal{H}\)-matrix, i.e. the rank-k matrix and \(\mathcal{H}\)-matrix are on a same block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classRkMatrix.html#a58686c65ca8c952558eae4fa185e7d6a">RkMatrix&lt; Number &gt;::get_m()</a>, <a class="el" href="classRkMatrix.html#a4f719c760482c2ab75cc5647277a9cdd">RkMatrix&lt; Number &gt;::get_n()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, and <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>.</p>

</div>
</div>
<a id="a94981e45b7d9aa0f2afae77d414f1c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94981e45b7d9aa0f2afae77d414f1c1a">&#9670;&nbsp;</a></span>add() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a rank-k matrix multiplied by a factor into the current \(\mathcal{H}\)-matrix node.</p>
<p>The rank-k matrix will be restricted to each leaf node of the \(\mathcal{H}\)-matrix node and the addition will be performed there. In this implementation, the row and column global to local index maps with respect to <code>B</code> are the same as those associated with the \(\mathcal{H}\)-matrix, i.e. the rank-k matrix and \(\mathcal{H}\)-matrix are on a same block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classRkMatrix.html#a58686c65ca8c952558eae4fa185e7d6a">RkMatrix&lt; Number &gt;::get_m()</a>, <a class="el" href="classRkMatrix.html#a4f719c760482c2ab75cc5647277a9cdd">RkMatrix&lt; Number &gt;::get_n()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, and <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>.</p>

</div>
</div>
<a id="a403d72a5eea3912d67fd0807ddd0baf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403d72a5eea3912d67fd0807ddd0baf8">&#9670;&nbsp;</a></span>add() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the \(\mathcal{H}\)-matrix addition \(C = A + B\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>.</p>

</div>
</div>
<a id="af66071b53145fe007ac040fa0c4b47c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66071b53145fe007ac040fa0c4b47c6">&#9670;&nbsp;</a></span>add() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the \(\mathcal{H}\)-matrix addition \(C = A + b B\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>.</p>

</div>
</div>
<a id="ac72668962dbad336f0c289bbd060e6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72668962dbad336f0c289bbd060e6ce">&#9670;&nbsp;</a></span>addsym_diag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::addsym_diag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the error matrix \(EE^H\) recursively to the leaf diagonal blocks of the current \(\mathcal{H}\)-matrix node for preserving positive definiteness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Only when the error matrix has non-zero dimension, there will be actual addition to the diagonal blocks.</p>
<p>Make an assertion that the current \(\mathcal{H}\)-matrix node should be a diagonal block.</p>
<p>When the current \(\mathcal{H}\)-matrix node is a leaf node, since it is a diagonal block, it must be a full matrix. Then, we directly add \(EE^H\) into the current \(\mathcal{H}\)-matrix node.</p>
<p>Make an assertion that the current \(\mathcal{H}\)-matrix node should have submatrices.</p>
<p>Restrict the rows of the error matrix \(E\) to the cluster \(t_1\).</p>
<p>Restrict the rows of the error matrix \(E\) to the cluster \(t_2\).</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classLAPACKFullMatrixExt.html#a74d566120461e1a2437b9fd9a070633f">LAPACKFullMatrixExt&lt; Number &gt;::fill_row()</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classLAPACKFullMatrixExt.html#a132200a53d62265a213059e2d93c8e82">LAPACKFullMatrixExt&lt; Number &gt;::mTmult()</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a88546d9ca48a3c1a2a0874545cc4c8df">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank_off_diag_preserve_positive_definite()</a>.</p>

</div>
</div>
<a id="a139f32982527ba981e0211b5663e3b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139f32982527ba981e0211b5663e3b43">&#9670;&nbsp;</a></span>build_leaf_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::build_leaf_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build the leaf set of the current \(\mathcal{H}\)-matrix node. </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a60934e84cc3c9f6c75d011a2005f512a">HMatrix&lt; spacedim, Number &gt;::_build_leaf_set()</a>, and <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a27c7390b792e6e47ab2861616a997d99">HMatrix&lt; spacedim, Number &gt;::coarsen_to_subtree()</a>, <a class="el" href="classHMatrix.html#af6fd60090b0de7bdea52fc84ddeb22c3">HMatrix&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees()</a>, <a class="el" href="classHMatrix.html#a6a4dead0321e8df38865bf6fbd0f6e81">HMatrix&lt; spacedim, Number &gt;::HMatrix()</a>, <a class="el" href="classHMatrix.html#af972cb62d436b8dca5d95a5b6e2ed964">HMatrix&lt; spacedim, Number &gt;::invert_by_gauss_elim()</a>, <a class="el" href="classHMatrix.html#af40d53aabc8bec86fa543638d48ba64e">HMatrix&lt; spacedim, Number &gt;::mmult()</a>, <a class="el" href="classHMatrix.html#a83958971f40409b3b2a192b71eae1513">HMatrix&lt; spacedim, Number &gt;::operator=()</a>, <a class="el" href="classHMatrix.html#ad2b353962226c78910d6ddb6b5b8e460">HMatrix&lt; spacedim, Number &gt;::refine_to_supertree()</a>, and <a class="el" href="classHMatrix.html#a83f804163e1695cfb952ddb6b0df2503">HMatrix&lt; spacedim, Number &gt;::reinit()</a>.</p>

</div>
</div>
<a id="a72191c447afaa0fd84505022cf1d174e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72191c447afaa0fd84505022cf1d174e">&#9670;&nbsp;</a></span>calc_rank_upper_bound_for_rkmatrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::calc_rank_upper_bound_for_rkmatrices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate and set the rank upper bound for each rank-k matrix in the \(\mathcal{H}\)-matrix hierarchy. </p>

<p class="reference">References <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-solve-cholesky-in-situ_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="ae55bd45587b895bfdb977e7cbea46519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55bd45587b895bfdb977e7cbea46519">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the whole \(\mathcal{H}\)-matrix hierarchy. </p>
<p>Recursively clear submatrices.</p>
<p>Clear the current matrix node.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="aec0815bc9c3654391bb2b3095383e6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0815bc9c3654391bb2b3095383e6cb">&#9670;&nbsp;</a></span>clear_hmat_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::clear_hmat_node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the current \(\mathcal{H}\)-matrix node. </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a71690997092a4142799b2fa2dbf53db4">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a64c851dd63ba1a466c19f451be369475">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, <a class="el" href="classHMatrix.html#a8b5a9fb65c716187d95bcdb43542884c">HMatrix&lt; spacedim, Number &gt;::submatrix_index_invalid</a>, <a class="el" href="classHMatrix.html#a12da9454687e5ca15837d63e2bf0b595">HMatrix&lt; spacedim, Number &gt;::Tind</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ae55bd45587b895bfdb977e7cbea46519">HMatrix&lt; spacedim, Number &gt;::clear()</a>.</p>

</div>
</div>
<a id="a525ad4d453f4f496b98cccb341c8b60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525ad4d453f4f496b98cccb341c8b60b">&#9670;&nbsp;</a></span>coarsen_to_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::coarsen_to_partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_pointer_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Coarsen the current \(\mathcal{H}\)-matrix via recursive call so that its leaf set complies with the given partition. Each rank-k matrix in the \(\mathcal{H}\)-matrix structure will be truncated to <code>fixed_rank_k</code>.</p>
<p>Since this is a recursive member function, it does not execute leaf set rebuilding, which is an operation on the overall \(\mathcal{H}\)-matrix hierarchy.</p>
<p>This member function implements the operator \(\mathcal{T}_{P&#39; \leftarrow P}^{\mathcal{H} \leftarrow \mathcal{H}}\) for the case \(T(I \times J, P&#39;) \subset T(I \times J, P)\) in (7.9) in Hackbusch's \(\mathcal{H}\)-matrix book. Because there is no internal check about this, users should ensure this set inclusion relationship.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>N.B. The function call <code>find_pointer_data</code> here involves the comparison of two block cluster nodes, which internally compares the contained two block clusters, which further compares the contained tau node and sigma node pointers. Therefore, at the moment, the inner most comparison is shallow comparison.</p>
<p>The block cluster node associated with the current \(\mathcal{H}\)-matrix node belongs to the given <code>partition</code>. Then \(\mathcal{T}_r^{\mathcal{R} \leftarrow \mathcal{H}}\) will be applied to this \(\mathcal{H}\)-matrix node.</p>
<p>When the block cluster node associated with the current \(\mathcal{H}\)-matrix node does not belong to the <code>partition</code>, recursively call this same member function of its each child.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="generic__functors_8h.html#ad741e5fc6f9f2d7acafe6e5530b1f52e">find_pointer_data()</a>, and <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a27c7390b792e6e47ab2861616a997d99">HMatrix&lt; spacedim, Number &gt;::coarsen_to_subtree()</a>, and <a class="el" href="classHMatrix.html#af6fd60090b0de7bdea52fc84ddeb22c3">HMatrix&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees()</a>.</p>

</div>
</div>
<a id="a27c7390b792e6e47ab2861616a997d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c7390b792e6e47ab2861616a997d99">&#9670;&nbsp;</a></span>coarsen_to_subtree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::coarsen_to_subtree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>subtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Coarsen the current \(\mathcal{H}\)-matrix so that it corresponds to the partition determined by the <code>subtree</code>. Each rank-k matrix in the hierarchical matrix structure will be truncated to <code>fixed_rank_k</code>.</p>
<p>This function calls <code><a class="el" href="classHMatrix.html#a525ad4d453f4f496b98cccb341c8b60b">HMatrix&lt;spacedim, Number&gt;::coarsen_to_partition</a></code> internally. After that, the leaf set is rebuilt.</p>
<p>This member function implements the operator \(\mathcal{T}_{P&#39; \leftarrow P}^{\mathcal{H} \leftarrow \mathcal{H}}\) for the case \(T(I \times J, P&#39;) \subset T(I \times J, P)\) in (7.9) in Hackbusch's \(\mathcal{H}\)-matrix book. Because there is no internal check about this, users should ensure that the given <code>subtree</code> is really a subtree of the block cluster tree associated with this \(\mathcal{H}\)-matrix hierarchy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subtree</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="classHMatrix.html#a525ad4d453f4f496b98cccb341c8b60b">HMatrix&lt; spacedim, Number &gt;::coarsen_to_partition()</a>, and <a class="el" href="classBlockClusterTree.html#a162b396d814b420f96289425529852e9">BlockClusterTree&lt; spacedim, Number &gt;::get_leaf_set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-coarsening_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a7d6c76f7db2b9239f24df292e945a970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6c76f7db2b9239f24df292e945a970">&#9670;&nbsp;</a></span>compute_cholesky_factorization() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_cholesky_factorization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Cholesky factorization of an \(\mathcal{H}\)-matrix. Only the lower triangular \(\mathcal{H}\)-matrix factor \(L\) is stored in the output variable <code>L</code>. The matrix \(L\) should have the same hierarchical structure as the original matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and the Cholesky factorization can be directly applied to it using LAPACK.</p>
<p>N.B. Unlike the LU factorization, the Cholesky factorization performed by LAPACK has no pivoting.</p>
<p>Copy the full matrix from the source matrix to the result matrix <code>L</code>.</p>
<p>After the Cholesky factorization, the matrix <code>L</code> is stored in the same full matrix. Hence, this operation is in situ.</p>
<p>At present, Cholesky factorization is only to be applied to square matrix and block square matrix.</p>
<p>When the current \(\mathcal{H}\)-matrix node is not a leaf, iterate over each block row.</p>
<p>Iterate over each block column from beginning to the diagonal block.</p>
<p>Create a local \(\mathcal{H}\)-matrix \(Z_{ij}\) as the new RHS matrix.</p>
<p>Iterate over each block column before the \(j\)-th column.</p>
<p>When the current block column is before the i'th column, solve \(L_{ij} L_{jj}^T = M_{ij}\) using the matrix-valued Cholesky transposed forward substitution.</p>
<p>When coming to the diagonal block, go down one level of recursion for Cholesky factorization.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#a7d6c76f7db2b9239f24df292e945a970">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_factorization()</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a7d6c76f7db2b9239f24df292e945a970">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_factorization()</a>, and <a class="el" href="hmatrix-solve-cholesky-in-situ_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="abc6e787e46fb082579b2d3aea1ad54f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6e787e46fb082579b2d3aea1ad54f6">&#9670;&nbsp;</a></span>compute_cholesky_factorization() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_cholesky_factorization </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Cholesky factorization of an \(\mathcal{H}\)-matrix in situ. Only the lower triangular \(\mathcal{H}\)-matrix factor \(L\) is stored in the original matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and the Cholesky factorization can be directly applied to it using LAPACK.</p>
<p>N.B. Unlike the LU factorization, the Cholesky factorization performed by LAPACK has no pivoting.</p>
<p>After the Cholesky factorization, the matrix <code>L</code> is stored in the same full matrix. Hence, this operation is in situ.</p>
<p>At present, Cholesky factorization is only to be applied to square matrix and block square matrix.</p>
<p>When the current \(\mathcal{H}\)-matrix node is not a leaf, iterate over each block row.</p>
<p>Iterate over each block column from beginning to the diagonal block.</p>
<p>Create a local \(\mathcal{H}\)-matrix \(Z_{ij}\) as the new RHS matrix.</p>
<p>Iterate over each block column before the \(j\)-th column.</p>
<p>When the current block column is before the i'th column, solve \(L_{ij} L_{jj}^T = M_{ij}\) using the matrix-valued Cholesky transposed forward substitution.</p>
<p>When coming to the diagonal block, go down one level of recursion for Cholesky factorization.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#a7d6c76f7db2b9239f24df292e945a970">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_factorization()</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="acf95fce81ec83a759d1db8d10c3e34fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf95fce81ec83a759d1db8d10c3e34fb">&#9670;&nbsp;</a></span>compute_lu_factorization() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_lu_factorization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>LU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the LU factorization of an \(\mathcal{H}\)-matrix. The resulted \(L\) and \(U\) factors are stored in a same \(\mathcal{H}\)-matrix \(LU\). The matrix \(LU\) should have the same hierarchical structure as the original matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LU</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and the LU factorization can be directly applied to it using LAPACK.</p>
<p>N.B. The LU factorization performed by LAPACK has row partial pivoting.</p>
<p>Copy the full matrix from the source matrix to the result matrix <code>LU</code>.</p>
<p>After the LU factorization, L and U matrices are stored in the same full matrix. Hence, this operation is in situ.</p>
<p>At present, LU factorization is only to be applied to square matrix and block square matrix.</p>
<p>When the current \(\mathcal{H}\)-matrix node is not a leaf, iterate over each block row.</p>
<p>Iterate over each block column.</p>
<p>Iterate over each block column before the \(\min\{i, j\}\)-th column using the loop counter \(k\). The corresponding submatrix product \(L_{i,k}U_{k,j}\) needs to be subtracted from the RHS submatrix \(M_{ij}\).</p>
<p>Create a local \(\mathcal{H}\)-matrix \(Z_{ij}\) as the new RHS matrix.</p>
<p>When the current block column is before the i'th column, solve \(L_{ij} U_{jj}=M_{ij}\) to get \(L_{ij}\) using the matrix-valued transposed forward substitution.</p>
<p>When the current block column is i, go down one level of recursion for LU factorization.</p>
<p>Solve \(L_{ii}U_{ij}=M_{ij}\) for \(L_{ii}\).</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#acf95fce81ec83a759d1db8d10c3e34fb">HMatrix&lt; spacedim, Number &gt;::compute_lu_factorization()</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#acf95fce81ec83a759d1db8d10c3e34fb">HMatrix&lt; spacedim, Number &gt;::compute_lu_factorization()</a>, and <a class="el" href="hmatrix-solve-lu-in-situ_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="aba14c63550f42d8a971beab340337b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba14c63550f42d8a971beab340337b0e">&#9670;&nbsp;</a></span>compute_lu_factorization() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::compute_lu_factorization </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the LU factorization of an \(\mathcal{H}\)-matrix in situ. The resulted \(L\) and \(U\) factors are stored in the original \(\mathcal{H}\)-matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and the LU factorization can be directly applied to it using LAPACK.</p>
<p>N.B. The LU factorization performed by LAPACK has row partial pivoting.</p>
<p>After the LU factorization, L and U matrices are stored in the same full matrix. Hence, this operation is in situ.</p>
<p>At present, LU factorization is only to be applied to square matrix and block square matrix.</p>
<p>When the current \(\mathcal{H}\)-matrix node is not a leaf, iterate over each block row.</p>
<p>Iterate over each block column.</p>
<p>Iterate over each block column before the \(\min\{i, j\}\)-th column using the loop counter \(k\). The corresponding submatrix product \(L_{i,k}U_{k,j}\) needs to be subtracted from the RHS submatrix \(M_{ij}\).</p>
<p>Create a local \(\mathcal{H}\)-matrix \(Z_{ij}\) as the new RHS matrix.</p>
<p>When the current block column is before the i'th column, solve \(L_{ij} U_{jj}=M_{ij}\) to get \(L_{ij}\) using the matrix-valued transposed forward substitution.</p>
<p>When the current block column is i, go down one level of recursion for LU factorization.</p>
<p>Solve \(L_{ii}U_{ij}=M_{ij}\) for \(L_{ii}\).</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#acf95fce81ec83a759d1db8d10c3e34fb">HMatrix&lt; spacedim, Number &gt;::compute_lu_factorization()</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="af6fd60090b0de7bdea52fc84ddeb22c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6fd60090b0de7bdea52fc84ddeb22c3">&#9670;&nbsp;</a></span>convert_between_different_block_cluster_trees()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k2</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an \(\mathcal{H}\)-matrix between two different block cluster trees \(T\) and \(T&#39;\), where \(T := T(I \times J, P)\) and \(T&#39; := T&#39;(I \times J, P&#39;)\). The two trees have incompatible partitions and do not contain each other. However, they are constructed on the same cluster trees \(T(I)\) and \(T(J)\). This enables us to make a <b>shallow</b> comparison of two block cluster nodes based on the pointer addresses related to the comprising clusters, which is useful for verify the equality of two block cluster nodes.</p>
<p>The procedures of this algorithm are as below. Assume the current \(\mathcal{H}\)-matrix to be converted is associated with the block cluster tree \(T\).</p>
<ol type="1">
<li>Extend \(T\) to be finer than \(T&#39;\), from which we get the new block cluster tree \(T&#39;&#39;\).</li>
<li>Refine the original \(\mathcal{H}\)-matrix with respect to the extended tree \(T&#39;&#39;\).</li>
<li>Get and keep a record of the leaf set of the block cluster tree \(T&#39;\), which will be used for matrix coarsening in the last step.</li>
<li>Extend \(T&#39;\) to the finer block cluster tree \(T&#39;&#39;\), from which we get \(\tilde{T}&#39;\).</li>
<li>Build a new \(\mathcal{H}\)-matrix with respect to \(\tilde{T}&#39;\) with the actual data migrated from the leaf nodes of the original \(\mathcal{H}\)-matrix.</li>
<li>Coarsen the new \(\mathcal{H}\)-matrix to the original partition of \(T&#39;\).</li>
<li>Delete the hierarchy of the original \(\mathcal{H}\)-matrix.</li>
<li>Assign the new \(\mathcal{H}\)-matrix object to the original \(\mathcal{H}\)-matrix object.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bct1</td><td>The block cluster tree which is associated with the current \(\mathcal{H}\)-matrix. </td></tr>
    <tr><td class="paramname">bct2</td><td>The block cluster tree to which the current \(\mathcal{H}\)-matrix is to be converted. </td></tr>
  </table>
  </dd>
</dl>
<p>Make a copy of the leaf set of the target block cluster tree, which will be used for the final coarsening.</p>
<p>Extend the block cluster tree associated with the current \(\mathcal{H}\)-matrix to the coarsest tree which is finer than the target block cluster tree. If the block cluster tree has really been extended, refine the \(\mathcal{H}\)-matrix to its extended block cluster tree.</p>
<p>Extend <code>bct2</code> to the finer partition obtained from <code>bct1</code> as above. N.B. Now the leaf set of <code>bct1</code> after refinement is the same as that of <code>bct2</code> after this extension.</p>
<p>Create a new \(\mathcal{H}\)-matrix with respect to the extended <code>bct2</code>, which accepts the data migrated from the leaf set of the current \(\mathcal{H}\)-matrix.</p>
<dl class="section note">
<dt>Note </dt>
<dd><ul>
<li>
This hierarchical structure of the new \(\mathcal{H}\)-matrix is built with respect to the extended block cluster tree <code>bct2</code>. </li>
<li>
The shallow copy constructor cannot be used here because the new \(\mathcal{H}\)-matrix has a different block cluster tree structure from the current \(\mathcal{H}\)-matrix, even though they have the same partition after tree extension. </li>
</ul>
</dd>
</dl>
<p>Coarsen the new \(\mathcal{H}\)-matrix to the original leaf set of <code>bct2</code>. Then rebuild its leaf set.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The structure of the block cluster tree associated with the \(\mathcal{H}\)-matrix is still same as before, which has more levels than the \(\mathcal{H}\)-matrix. Therefore, we should prune the block cluster tree to make it consistent with the \(\mathcal{H}\)-matrix. </dd>
</dl>
<p>Move the new \(\mathcal{H}\)-matrix to the current \(\mathcal{H}\)-matrix by shallow assignment.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="classHMatrix.html#a525ad4d453f4f496b98cccb341c8b60b">HMatrix&lt; spacedim, Number &gt;::coarsen_to_partition()</a>, <a class="el" href="classBlockClusterTree.html#a3c4a4da89b964559cc02ecbf13ad4a4b">BlockClusterTree&lt; spacedim, Number &gt;::extend_finer_than_partition()</a>, <a class="el" href="classBlockClusterTree.html#adfe18d32a3c05a9209a5cdc9270b47d7">BlockClusterTree&lt; spacedim, Number &gt;::extend_to_finer_partition()</a>, <a class="el" href="classBlockClusterTree.html#a162b396d814b420f96289425529852e9">BlockClusterTree&lt; spacedim, Number &gt;::get_leaf_set()</a>, <a class="el" href="classBlockClusterTree.html#af1663a109b6fd5c67c85e9bb88a54a13">BlockClusterTree&lt; spacedim, Number &gt;::prune_to_partition()</a>, and <a class="el" href="classHMatrix.html#ad2b353962226c78910d6ddb6b5b8e460">HMatrix&lt; spacedim, Number &gt;::refine_to_supertree()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, and <a class="el" href="hmatrix-fine-ntp-to-tp_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a00bdd40f7fcf5c912c34c427df518300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00bdd40f7fcf5c912c34c427df518300">&#9670;&nbsp;</a></span>convertToFullMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::convertToFullMatrix </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an <a class="el" href="classHMatrix.html">HMatrix</a> to a full matrix by calling the internal recursive function.</p>
<dl class="section note">
<dt>Note </dt>
<dd>This function only has the verification purpose. In reality, a large dense matrix cannot be saved as a full matrix. </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, and <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-add-formatted-with-factor_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a6f24998c7de1d0e336577be41c6281e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f24998c7de1d0e336577be41c6281e3">&#9670;&nbsp;</a></span>determine_mm_split_mode_from_Sigma_P()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tree_8h.html#a922ca07db9633957939f697a65aff11d">TreeNodeSplitMode</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::determine_mm_split_mode_from_Sigma_P </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check the consistency of the tree node split modes which are associated with the \(\mathcal{H}\)-matrix node pairs stored in the list \(\Sigma_P\) of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#aad08ee9bd389abe7b7b76fd0f2cb292e">h_h_mmult_phase1_recursion()</a>.</p>

</div>
</div>
<a id="a66979dbdf56155c63f0706649e8545b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66979dbdf56155c63f0706649e8545b9">&#9670;&nbsp;</a></span>distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Only non-leaf \(\mathcal{H}\)-matrix nodes need to be processed.</p>
<p>Since the current \(\mathcal{H}\)-matrix node has children, its type should be <code>HierarchicalMatrixType</code> and we make an assertion on it.</p>
<p>Distribute matrices in \(\Sigma_b^R\) and \(\Sigma_b^F\) of the current \(\mathcal{H}\)-matrix node to the leaf nodes which are its descendants. This is a recursive function call.</p>
<p>Distribute matrices in \(\Sigma_b^R\) and \(\Sigma_b^F\) of each child matrix of the current \(\mathcal{H}\)-matrix node to the leaf nodes which are its descendants.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a187e0c009a7c28679df7e92e0b01929c">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a60934e84cc3c9f6c75d011a2005f512a">HMatrix&lt; spacedim, Number &gt;::_build_leaf_set()</a>, and <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>.</p>

</div>
</div>
<a id="ab0f83de878e6079330ec3c374f587a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f83de878e6079330ec3c374f587a04">&#9670;&nbsp;</a></span>find_block_cluster_in_leaf_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;::iterator <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::find_block_cluster_in_leaf_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a block cluster in the leaf set of the current \(\mathcal{H}\)-matrix and returns the iterator of the corresponding \(\mathcal{H}\)-matrix node in the leaf set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_cluster</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>Perform a shallow comparison, i.e. compare by pointer address, of the block clusters.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The data held by those previously found leaf nodes of the source \(\mathcal{H}\)-matrix have already been migrated to the leaf nodes of the new \(\mathcal{H}\)-matrix, which will make the data fields in these leaf nodes being empty. Hence, we will bypass them. </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>.</p>

</div>
</div>
<a id="a723cc200afe31148fcc28f0120c5ec54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723cc200afe31148fcc28f0120c5ec54">&#9670;&nbsp;</a></span>find_block_cluster_in_leaf_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;::const_iterator <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::find_block_cluster_in_leaf_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_cluster</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a block cluster in the leaf set of the current \(\mathcal{H}\)-matrix and returns the iterator of the corresponding \(\mathcal{H}\)-matrix node in the leaf set (const version).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_cluster</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>Perform a shallow comparison, i.e. compare by pointer address, of the block clusters.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The data held by those previously found leaf nodes of the source \(\mathcal{H}\)-matrix have already been migrated to the leaf nodes of the new \(\mathcal{H}\)-matrix, which will make the data fields in these leaf nodes being empty. Hence, we will bypass them. </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>.</p>

</div>
</div>
<a id="a1ab763860706b9cbef8f5e73d995f29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab763860706b9cbef8f5e73d995f29a">&#9670;&nbsp;</a></span>find_col_diag_block_for_offdiag_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::find_col_diag_block_for_offdiag_block </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the diagonal block corresponding to the column block cluster of the current \(\mathcal{H}\)-matrix node which is assumed in the lower triangular part of the whole matrix.</p>
<p><b>The algorithm does not check internally whether the current \(\mathcal{H}\)-matrix node locates in the lower triangular part of the whole matrix. The user should ensure this presumption.</b></p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>We make an assertion here that the current \(\mathcal{H}\)-matrix node should not be on the top level in the \(\mathcal{H}\)-matrix hierarchy.</p>
<p>According to the currently adopted tensor product way of constructing block clusters from clusters, the diagonal block can only be the first or last sibling of the current \(\mathcal{H}\)-matrix node. Therefore, when the current \(\mathcal{H}\)-matrix node's <code>submatrix_index</code> is 1 (2), we will directly check if the first (last) sibling is a diagonal block on a same column.</p>
<p>We should also note that if an off-diagonal block is split into sub-blocks and such case will occur when the fine non-tensor product partition is adopted, none of its submatrices are diagonal blocks, even though the <code>submatrix_index</code> of which is 0 or 3.</p>
<p>When the first or last sibling of the current \(\mathcal{H}\)-matrix node is not a diagonal block, we will look for the corresponding diagonal block on a same column by first recursing back to the top level of the \(\mathcal{H}\)-matrix hierarchy then recursing forward to the current level.</p>
<p>When the current \(\mathcal{H}\)-matrix node is on the top level of the \(\mathcal{H}\)-matrix hierarchy, throw an error, because the diaognal block should have been found already.</p>
<p>Check if the last (3rd) sibling of the current \(\mathcal{H}\)-matrix node is a diagonal block. Such checking is performed via shallow comparison, i.e. compare the pointer addresses of \(\tau\) and \(\sigma\) clusters.</p>
<dl class="section note">
<dt>Note </dt>
<dd>By default, the submatrices are organized in the following order. <code> <table class="doxtable">
<tr>
<th>0 </th><th>1  </th></tr>
<tr>
<td>2 </td><td>3 </td></tr>
</table>
</code> </dd>
</dl>
<p>Go one recursion level up for further searching.</p>
<p>Check if the first sibling of the current \(\mathcal{H}\)-matrix node is a diagonal block. Such checking is performed via shallow comparison, i.e. compare the pointer addresses of \(\tau\) and \(\sigma\) clusters.</p>
<p>Go one recursion level up for further searching.</p>
<p>Go one recursion level up for further searching.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#a71690997092a4142799b2fa2dbf53db4">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a64c851dd63ba1a466c19f451be369475">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a88546d9ca48a3c1a2a0874545cc4c8df">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank_off_diag_preserve_positive_definite()</a>.</p>

</div>
</div>
<a id="a1da518d5ca7e685e3e787f58dcad4e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da518d5ca7e685e3e787f58dcad4e61">&#9670;&nbsp;</a></span>find_row_diag_block_for_offdiag_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::find_row_diag_block_for_offdiag_block </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the diagonal block corresponding to the row block cluster of the current \(\mathcal{H}\)-matrix node which is assumed in the lower triangular part of the whole matrix.</p>
<p><b>The algorithm does not check internally whether the current \(\mathcal{H}\)-matrix node locates in the lower triangular part of the whole matrix. The user should ensure this presumption.</b></p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>We make an assertion here that the current \(\mathcal{H}\)-matrix node should not be on the top level in the \(\mathcal{H}\)-matrix hierarchy.</p>
<p>According to the currently adopted tensor product way of constructing block clusters from clusters, the diagonal block can only be the first or last sibling of the current \(\mathcal{H}\)-matrix node. Therefore, when the current \(\mathcal{H}\)-matrix node's <code>submatrix_index</code> is 1 (2), we will directly check if the first (last) sibling is a diagonal block on a same row.</p>
<p>We should also note that if an off-diagonal block is split into sub-blocks and such case will occur when the fine non-tensor product partition is adopted, none of its submatrices are diagonal blocks, even though the <code>submatrix_index</code> of which is 0 or 3.</p>
<p>When the first or last sibling of the current \(\mathcal{H}\)-matrix node is not a diagonal block, we will look for the corresponding diagonal block on a same row by first recursing back to the top level of the \(\mathcal{H}\)-matrix hierarchy then recursing forward to the current level.</p>
<p>When the current \(\mathcal{H}\)-matrix node is on the top level of the \(\mathcal{H}\)-matrix hierarchy, throw an error.</p>
<p>Check if the first sibling of the current \(\mathcal{H}\)-matrix node is a diagonal block. Such checking is performed via shallow comparison, i.e. compare the pointer addresses of \(\tau\) and \(\sigma\) clusters.</p>
<dl class="section note">
<dt>Note </dt>
<dd>By default, the submatrices are organized in the following order. <code> <table class="doxtable">
<tr>
<th>0 </th><th>1  </th></tr>
<tr>
<td>2 </td><td>3 </td></tr>
</table>
</code> </dd>
</dl>
<p>Go one recursion level up for further searching.</p>
<p>Check if the last (3rd) sibling of the current \(\mathcal{H}\)-matrix node is a diagonal block. Such checking is performed via shallow comparison, i.e. compare the pointer addresses of \(\tau\) and \(\sigma\) clusters.</p>
<p>Go one recursion level up for further searching.</p>
<p>Go one recursion level up for further searching.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#a71690997092a4142799b2fa2dbf53db4">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a64c851dd63ba1a466c19f451be369475">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-find-diagonal-blocks_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="classHMatrix.html#a88546d9ca48a3c1a2a0874545cc4c8df">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank_off_diag_preserve_positive_definite()</a>.</p>

</div>
</div>
<a id="a9d914c27d4e990d476a4529b2daa64cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d914c27d4e990d476a4529b2daa64cd">&#9670;&nbsp;</a></span>get_fullmatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_fullmatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the pointer to the full matrix of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-rkmatrix-conversion_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="aed550b5b41a64c6f1bbcde4f8f7eca91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed550b5b41a64c6f1bbcde4f8f7eca91">&#9670;&nbsp;</a></span>get_fullmatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_fullmatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the pointer to the full matrix of the current \(\mathcal{H}\)-matrix node (const version). </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>.</p>

</div>
</div>
<a id="ac5c9102fc04997c1ae3627185379d9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c9102fc04997c1ae3627185379d9bb">&#9670;&nbsp;</a></span>get_leaf_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_leaf_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the leaf set of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>.</p>

</div>
</div>
<a id="a851d7bb3632bc1d18538d4d1dd5f6393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851d7bb3632bc1d18538d4d1dd5f6393">&#9670;&nbsp;</a></span>get_leaf_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_leaf_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the leaf set of the current \(\mathcal{H}\)-matrix node (const version). </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>.</p>

</div>
</div>
<a id="aabe735f7712a10ba5325ff116f8ca1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe735f7712a10ba5325ff116f8ca1c7">&#9670;&nbsp;</a></span>get_m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of rows of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>.</p>

</div>
</div>
<a id="abff89130116d62ea4159bc69ca11f8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff89130116d62ea4159bc69ca11f8d5">&#9670;&nbsp;</a></span>get_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of columns of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>.</p>

</div>
</div>
<a id="a0189de6e276fbd3425c4a7ef132f5e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0189de6e276fbd3425c4a7ef132f5e16">&#9670;&nbsp;</a></span>get_rkmatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_rkmatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the pointer to the rank-k matrix of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-rkmatrix-conversion_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a64c81db6357d0e00b82fd523af001ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c81db6357d0e00b82fd523af001ae5">&#9670;&nbsp;</a></span>get_rkmatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_rkmatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the pointer to the rank-k matrix of the current \(\mathcal{H}\)-matrix node (const version). </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>.</p>

</div>
</div>
<a id="a0572b2c0484ce618db0034e3bc7988ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0572b2c0484ce618db0034e3bc7988ed">&#9670;&nbsp;</a></span>get_submatrices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_submatrices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the vector of submatrices of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-find-diagonal-blocks_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a8f8e9bc437ab86296d78950081ea34cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8e9bc437ab86296d78950081ea34cd">&#9670;&nbsp;</a></span>get_submatrices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_submatrices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the vector of submatrices of the current \(\mathcal{H}\)-matrix node (const version). </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>.</p>

</div>
</div>
<a id="aadea9fa59f420d22b3b1c939f6b573cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadea9fa59f420d22b3b1c939f6b573cc">&#9670;&nbsp;</a></span>get_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the matrix type of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-rkmatrix-conversion_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="ab315324e3ece178943f406823f792746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab315324e3ece178943f406823f792746">&#9670;&nbsp;</a></span>h_h_mmult_cross_split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::h_h_mmult_cross_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc_tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements <code>MM_C</code> in Hackbusch's \(\mathcal{H}\)-matrix book. </p>
<p>Split the block cluster \(b\) in \(T_{\rm ind}\).</p>
<p>Append the initialized child to the list of submatrices of <code>M</code>.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Append the initialized child to the list of submatrices of <code>M</code>.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Iterate over each multiplication subtask.</p>
<p>Create \(\mathcal{H}\)-matrices corresponding to the child block clusters after splitting.</p>
<p>\(\Sigma_{b_s(1)}^P := \Sigma_{b_s(1)}^P \cup \{[\tilde{M}_1(1), \tilde{M}_2(1)], [\tilde{M}_1(2), \tilde{M}_2(3)]\}\)</p>
<p>\(\Sigma_{b_s(2)}^P := \Sigma_{b_s(2)}^P \cup \{[\tilde{M}_1(1), \tilde{M}_2(2)], [\tilde{M}_1(2), \tilde{M}_2(4)]\}\)</p>
<p>\(\Sigma_{b_s(3)}^P := \Sigma_{b_s(3)}^P \cup \{[\tilde{M}_1(3), \tilde{M}_2(1)], [\tilde{M}_1(4), \tilde{M}_2(3)]\}\)</p>
<p>\(\Sigma_{b_s(4)}^P := \Sigma_{b_s(4)}^P \cup \{[\tilde{M}_1(3), \tilde{M}_2(2)], [\tilde{M}_1(4), \tilde{M}_2(4)]\}\)</p>
<p>Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p>Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p>Update the matrix type of the current \(\mathcal{H}\)-matrix.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, and <a class="el" href="block__cluster__tree_8h.html#a16ad2c7c8e746258ce244315d6181c72">split_block_cluster_node()</a>.</p>

</div>
</div>
<a id="a38c88893c6ca784d4e56653d8b0e3e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c88893c6ca784d4e56653d8b0e3e67">&#9670;&nbsp;</a></span>h_h_mmult_horizontal_split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::h_h_mmult_horizontal_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc_tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements <code>MM_H</code> in Hackbusch's \(\mathcal{H}\)-matrix book. </p>
<p>Split the block cluster \(b\) in \(T_{\rm ind}\).</p>
<p>Append the initialized child to the list of submatrices of <code>M</code>.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Iterate over each multiplication subtask.</p>
<p>Create \(\mathcal{H}\)-matrices corresponding to the child block clusters after splitting.</p>
<p>Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p>Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p>Update the matrix type of the current \(\mathcal{H}\)-matrix.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, and <a class="el" href="block__cluster__tree_8h.html#a16ad2c7c8e746258ce244315d6181c72">split_block_cluster_node()</a>.</p>

</div>
</div>
<a id="a168b6eea2e5b27528497850bf5ee2bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168b6eea2e5b27528497850bf5ee2bbe">&#9670;&nbsp;</a></span>h_h_mmult_reduction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::h_h_mmult_reduction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform \(\mathcal{H}\)-matrix MM multiplication reduction. This is (7.21) in Hackbusch's \(\mathcal{H}\)-matrix book. </p>
<p>When one of the operands is either full matrix or rank-k matrix, perform direct multiplication.</p>
<p>Migrate the current H-matrix node pair to the list <code>Sigma_P_cannot_reduced</code>.</p>
<p>Remove the current H-matrix node pair from the original list in <code>M</code>.</p>
<p>Merge the elements in <code>Sigma_P_cannot_reduced</code> back to <code>Sigma_P</code> in <code>M</code> for further processing.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#aad08ee9bd389abe7b7b76fd0f2cb292e">h_h_mmult_phase1_recursion()</a>.</p>

</div>
</div>
<a id="a253c23d09e89a9a37a7d808374b5ae4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253c23d09e89a9a37a7d808374b5ae4e">&#9670;&nbsp;</a></span>h_h_mmult_vertical_split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::h_h_mmult_vertical_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc_tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements <code>MM_V</code> in Hackbusch's \(\mathcal{H}\)-matrix book. </p>
<p>Split the block cluster \(b\) in \(T_{\rm ind}\).</p>
<p>Append the initialized child to the list of submatrices of <code>M</code>.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Iterate over each multiplication subtask.</p>
<p>Create \(\mathcal{H}\)-matrices corresponding to the child block clusters after splitting.</p>
<p>Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p>Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p>Update the matrix type of the current \(\mathcal{H}\)-matrix.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, and <a class="el" href="block__cluster__tree_8h.html#a16ad2c7c8e746258ce244315d6181c72">split_block_cluster_node()</a>.</p>

</div>
</div>
<a id="af972cb62d436b8dca5d95a5b6e2ed964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af972cb62d436b8dca5d95a5b6e2ed964">&#9670;&nbsp;</a></span>invert_by_gauss_elim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::invert_by_gauss_elim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the inverse of the \(\mathcal{H}\)-matrix node via Gauss elimination by calling the recursive function <a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt;::_invert_by_gauss_elim.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M_inv</td><td></td></tr>
    <tr><td class="paramname">M_root</td><td>The \(\mathcal{H}\)-matrix node from which this recursive function is called for the first time. </td></tr>
    <tr><td class="paramname">M_root_bct</td><td>The block cluster tree associated with <code>M_root</code>. </td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Rebuild the leaf set of the current \(\mathcal{H}\)-matrix and its inverse.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#af74e3b0c19e9178cfe699a6620a51170">HMatrix&lt; spacedim, Number &gt;::_invert_by_gauss_elim()</a>, and <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-invert-by-gauss-elim_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="af40d53aabc8bec86fa543638d48ba64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40d53aabc8bec86fa543638d48ba64e">&#9670;&nbsp;</a></span>mmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of two \(\mathcal{H}\)-matrices \(C = A \cdot B\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">bct_a</td><td></td></tr>
    <tr><td class="paramname">bct_b</td><td></td></tr>
    <tr><td class="paramname">bct_c</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section">
<dt>Work flow </dt>
<dd><p class="startdd"></p>
<ul>
<li>
<p class="startli">Release the resource of the result matrix.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Initialize the induced block cluster tree \(T_{\rm ind}\) for the result matrix with a single root node.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Associate with the root node of the induced block cluster tree \(T_{\rm ind}\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Perform recursive multiplication while constructing the induced block cluster tree \(T_{\rm ind}\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">After the construction of the induced block cluster tree \(T_{\rm ind}\), rebuild its leaf set as well as near field and far field sets, and update the tree depth and maximum level.</p>
<p>DEBUG: Print the structure of the \(T_{\rm ind}\) block cluster tree.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Build the leaf set of the result matrix.</p>
<p>DEBUG: Print the structure of the \(T_{\rm ind}\) block cluster tree.</p>
<p class="endli"></p>
</li>
</ul>
</dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="classTreeNode.html#a7bf414928c965e707e0246f7a90a747d">TreeNode&lt; T, N &gt;::get_data_reference()</a>, <a class="el" href="classBlockClusterTree.html#ab00acda5e8fd4c3e381637d8d9322923">BlockClusterTree&lt; spacedim, Number &gt;::get_n_min()</a>, <a class="el" href="classBlockClusterTree.html#a4a4f3b893380d1d7f53b772589a847d2">BlockClusterTree&lt; spacedim, Number &gt;::get_root()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, and <a class="el" href="classHMatrix.html#a12da9454687e5ca15837d63e2bf0b595">HMatrix&lt; spacedim, Number &gt;::Tind</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-hmatrix-alpha-mmult-level-conserving-all-fine-ntp-member-function-call_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="classHMatrix.html#a4139e9069e3b18d4719c527ce2e0414c">HMatrix&lt; spacedim, Number &gt;::mmult()</a>.</p>

</div>
</div>
<a id="a4139e9069e3b18d4719c527ce2e0414c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4139e9069e3b18d4719c527ce2e0414c">&#9670;&nbsp;</a></span>mmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>adding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of two \(\mathcal{H}\)-matrices, the result of which will be appended to the target matrix <code>C</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">bct_a</td><td></td></tr>
    <tr><td class="paramname">bct_b</td><td></td></tr>
    <tr><td class="paramname">bct_c</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">adding</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>, and <a class="el" href="classHMatrix.html#af40d53aabc8bec86fa543638d48ba64e">HMatrix&lt; spacedim, Number &gt;::mmult()</a>.</p>

</div>
</div>
<a id="a4ea0317bff2670e3ed7e48416f908873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea0317bff2670e3ed7e48416f908873">&#9670;&nbsp;</a></span>mmult_level_conserving() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::mmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Level conserving \(\mathcal{H}\)-matrix multiplication, the result of which will be appended to the target matrix <code>C</code>, i.e. \(C = C + AB\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="hmatrix-hmatrix-alpha-mmult-level-conserving-all-fine-ntp-member-function-call_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="aefdb7dbcff58654f53a149b94e545bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefdb7dbcff58654f53a149b94e545bf7">&#9670;&nbsp;</a></span>mmult_level_conserving() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::mmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Level conserving \(\mathcal{H}\)-matrix multiplication with a factored multiplied to the matrix product, the result of which will be appended to the target matrix <code>C</code>, i.e. \(C = C + \alpha \cdot A B\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b7fe2940b614a130d154a29b28b39d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7fe2940b614a130d154a29b28b39d4">&#9670;&nbsp;</a></span>mTmult_level_conserving() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::mTmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Level conserving \(\mathcal{H}\)-matrix multiplication with the second operand being transposed, the result of which will be appended to the target matrix <code>C</code>, i.e. \(C = C + \alpha \cdot A B^T\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="hmatrix-hmatrix-alpha-mTmult-level-conserving-all-fine-ntp-member-function-call_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="aae163c33fc8d51f96df712ca192e0b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae163c33fc8d51f96df712ca192e0b6f">&#9670;&nbsp;</a></span>mTmult_level_conserving() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::mTmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Level conserving \(\mathcal{H}\)-matrix multiplication with the second operand being transposed, the result of which will be multiplied by a factor and then appended to the target matrix <code>C</code>, i.e. \(C = C + \alpha \cdot A B^T\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c72ede65323af5b57a6b16f5774de50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c72ede65323af5b57a6b16f5774de50">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment via shallow copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>.</p>

</div>
</div>
<a id="a83958971f40409b3b2a192b71eae1513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83958971f40409b3b2a192b71eae1513">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment via deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, and <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>.</p>

</div>
</div>
<a id="aab0c393acf1c416ebc7ab05ca85d9e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0c393acf1c416ebc7ab05ca85d9e49">&#9670;&nbsp;</a></span>print_current_matrix_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::print_current_matrix_info </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the current \(\mathcal{H}\)-matrix node information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Print the size of \(\Sigma_b^P\), \(\Sigma_b^R\) and \(\Sigma_b^F\).</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#a71690997092a4142799b2fa2dbf53db4">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a64c851dd63ba1a466c19f451be369475">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-find-diagonal-blocks_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="classHMatrix.html#ad8f87883cf49080706233441c0e09171">HMatrix&lt; spacedim, Number &gt;::print_matrix_info()</a>.</p>

</div>
</div>
<a id="a7e849f7e8f35e3ebdfcb2dbb7ad4ad01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e849f7e8f35e3ebdfcb2dbb7ad4ad01">&#9670;&nbsp;</a></span>print_formatted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::print_formatted </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>zero_string</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>denominator</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the \(\mathcal{H}\)-matrix data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">precision</td><td></td></tr>
    <tr><td class="paramname">scientific</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">zero_string</td><td></td></tr>
    <tr><td class="paramname">denominator</td><td></td></tr>
    <tr><td class="paramname">threshold</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-deep-copy-constructor_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="ad8f87883cf49080706233441c0e09171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f87883cf49080706233441c0e09171">&#9670;&nbsp;</a></span>print_matrix_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::print_matrix_info </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the \(\mathcal{H}\)-matrix hierarchy information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#aab0c393acf1c416ebc7ab05ca85d9e49">HMatrix&lt; spacedim, Number &gt;::print_current_matrix_info()</a>, and <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-check-parent-and-submatrix-index_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="ae904288a7e0ac82d9fd2364b1c150bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae904288a7e0ac82d9fd2364b1c150bc2">&#9670;&nbsp;</a></span>print_matrix_info_as_dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::print_matrix_info_as_dot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the \(\mathcal{H}\)-matrix hierarchy information as directional graph in Graphviz dot format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Write the header of the Graphviz dot file.</p>
<p>Define the node style.</p>
<p>Add comment nodes.</p>
<p>Finalize the Graphviz dot file.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#afd8e08ec263ea524bef3c5c66796c61d">HMatrix&lt; spacedim, Number &gt;::_print_matrix_info_as_dot_node()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-check-parent-and-submatrix-index_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="ad2b353962226c78910d6ddb6b5b8e460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b353962226c78910d6ddb6b5b8e460">&#9670;&nbsp;</a></span>refine_to_supertree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::refine_to_supertree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refine the current \(\mathcal{H}\)-matrix, whose associated block cluster tree has been extended. The operation has no accuracy loss.</p>
<p>This member function implements the operator \(\mathcal{T}_{P&#39; \leftarrow P}^{\mathcal{H} \leftarrow \mathcal{H}}\) for the case \(T(I \times J, P&#39;) \supset T(I \times J, P)\) in (7.9) in Hackbusch's \(\mathcal{H}\)-matrix book. Because there is no internal check about this, users should ensure that the original block cluster tree associated with this \(\mathcal{H}\)-matrix hierarchy has really been extended. </p>
<dl class="section">
<dt>Work flow </dt>
<dd><p class="startdd"></p>
<p>Iterate over the leaf set of the \(\mathcal{H}\)-matrix hierarchy.</p>
<p>Refine from the current \(\mathcal{H}\)-matrix leaf node.</p>
<p>After the refinement operation, we check the number of child matrices of the current \(\mathcal{H}\)-matrix leaf node.</p>
<p>If the current \(\mathcal{H}\)-matrix leaf node has a non-empty collection of submatrices, it has really been refined. Then delete its originally associated matrix data, either a full matrix or a rank-k matrix, and modify its matrix type as <code>HierarchicalMatrixType</code>.</p>
<p>After the refinement operation for all the leaf nodes of the original \(\mathcal{H}\)-matrix hierarchy finishes, rebuild the leaf set of the new \(\mathcal{H}\)-matrix hierarchy.</p>
<p class="enddd"></p>
</dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#af6fd60090b0de7bdea52fc84ddeb22c3">HMatrix&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees()</a>, and <a class="el" href="hmatrix-refinement_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a83f804163e1695cfb952ddb6b0df2503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f804163e1695cfb952ddb6b0df2503">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialize the hierarchical structure without data from the root node of a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bct</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="classBlockClusterTree.html#a4a4f3b893380d1d7f53b772589a847d2">BlockClusterTree&lt; spacedim, Number &gt;::get_root()</a>, and <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>.</p>

</div>
</div>
<a id="a41d20c1839f3d7a756107b8e4defea0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d20c1839f3d7a756107b8e4defea0b">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialize the hierarchical structure without data from a <a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bc_node</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, and <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>.</p>

</div>
</div>
<a id="a812e8276888b2ad866edf7ce9b286839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812e8276888b2ad866edf7ce9b286839">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TODO: Construct from a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a> and a Sauter quadrature object/functor. Release the memory and status of the \(\mathcal{H}\)-matrix hierarchy. </p>
<p>The deletion of <code>submatrix</code> will call the destructor of this sub-HMatrix, which will further recursively call the destructor of the submatrices of this sub-HMatrix. Hence, this destructor is intrinsically recursive.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a71690997092a4142799b2fa2dbf53db4">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a64c851dd63ba1a466c19f451be369475">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, <a class="el" href="classHMatrix.html#a8b5a9fb65c716187d95bcdb43542884c">HMatrix&lt; spacedim, Number &gt;::submatrix_index_invalid</a>, <a class="el" href="classHMatrix.html#a12da9454687e5ca15837d63e2bf0b595">HMatrix&lt; spacedim, Number &gt;::Tind</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#af40d53aabc8bec86fa543638d48ba64e">HMatrix&lt; spacedim, Number &gt;::mmult()</a>, <a class="el" href="classHMatrix.html#a2c72ede65323af5b57a6b16f5774de50">HMatrix&lt; spacedim, Number &gt;::operator=()</a>, <a class="el" href="classHMatrix.html#a83f804163e1695cfb952ddb6b0df2503">HMatrix&lt; spacedim, Number &gt;::reinit()</a>, and <a class="el" href="classHMatrix.html#ae16c956c1b22eb307e9f360a83f4fa75">HMatrix&lt; spacedim, Number &gt;::~HMatrix()</a>.</p>

</div>
</div>
<a id="a9e023f39b1f8916117a63557895a91b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e023f39b1f8916117a63557895a91b4">&#9670;&nbsp;</a></span>remove_hmat_pair_from_mm_product_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a pair of \(\mathcal{H}\)-matrix nodes from the list of matrix-matrix product subtasks to be performed, i.e. from the list <code><a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix::Sigma_P</a></code>. </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, and <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>.</p>

</div>
</div>
<a id="ae0ab9b3be4ea0ef959da40e81313b2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ab9b3be4ea0ef959da40e81313b2e3">&#9670;&nbsp;</a></span>remove_hmat_pair_from_mm_product_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a pair of \(\mathcal{H}\)-matrix nodes from the list of matrix-matrix product subtasks to be performed, i.e. from the list <code><a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix::Sigma_P</a></code>. </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>.</p>

</div>
</div>
<a id="aa81db0ff79182302de83d693bab9f9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81db0ff79182302de83d693bab9f9e3">&#9670;&nbsp;</a></span>solve_block_triangular_by_backward_substitution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_block_triangular_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_block_diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the block upper triangular matrix \(Ux=b\) by backward substitution.</p>
<p>Being different from the version for solving triangular \(\mathcal{H}\)-matrix,</p>
<ol type="1">
<li>when the block upper triangular matrix is unit, its diagonal blocks in the leaf set, which must be in the full matrix format, should be an identity matrix, i.e. \(L\vert_{\tau\times\tau} = I\) for \(\tau\times\tau \in P\). In this case, there is no need to actually solve it.</li>
<li>when the block upper triangular matrix is not unit, its diagonal blocks in the leaf set should be full matrices. In this case, a general linear system solver should be adopted to solve it.</li>
</ol>
<p><b>Even though the member variables of the current class will be not be modified, the actual heap memory data related to full matrix in the leaf set will be changed, since LU factorization will be performed.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">is_unit_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>The current \(\mathcal{H}\)-matrix node should be square.</p>
<p>When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be solved via LU factorization.</p>
<p>In this case, the diagonal block in the leaf set should be an identity matrix, the solution <code>x</code> is the same as the right hand side vector <code>b</code>, so here we do nothing.</p>
<p>In this case, the diagonal block in the leaf set should be general full matrix and forward substitution cannot be applied any more. Instead, LU factorization is adopted.</p>
<p>Restrict vector <code>b</code> to the column cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p>Solve the full matrix using LU factorization.</p>
<p>Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p>Iterate over each block row of the matrix.</p>
<p>Iterate each block column after the i'th column, i.e. after the diagonal submatrix block.</p>
<p>Solve the current diagonal block using backward substitution.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-block-triangular-backward-substitution-unit-diag_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="classHMatrix.html#a69432f004b60ade76aaabf2c94dd205c">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_backward_substitution()</a>.</p>

</div>
</div>
<a id="a69432f004b60ade76aaabf2c94dd205c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69432f004b60ade76aaabf2c94dd205c">&#9670;&nbsp;</a></span>solve_block_triangular_by_backward_substitution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_block_triangular_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_block_diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the block upper triangular matrix \(Lx=b\) by backward substitution.</p>
<p>Refer to <code>solve_block_triangular_by_backward_substitution</code>( Vector&lt;Number&gt; &amp;b, const bool is_unit_block_diagonal = false) const.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">is_unit_block_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#aa81db0ff79182302de83d693bab9f9e3">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_backward_substitution()</a>.</p>

</div>
</div>
<a id="ab8b64d4a5b7120a2599ec3e3e0708775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b64d4a5b7120a2599ec3e3e0708775">&#9670;&nbsp;</a></span>solve_block_triangular_by_forward_substitution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_block_triangular_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_block_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the block lower triangular matrix \(Lx=b\) by forward substitution.</p>
<p>Being different from the version for solving triangular \(\mathcal{H}\)-matrix,</p>
<ol type="1">
<li>when the block lower triangular matrix is unit, its diagonal blocks in the leaf set, which must be in the full matrix format, should be an identity matrix, i.e. \(L\vert_{\tau\times\tau} = I\) for \(\tau\times\tau \in P\). In this case, there is no need to actually solve it.</li>
<li>when the block lower triangular matrix is not unit, its diagonal blocks in the leaf set should be full matrices. In this case, a general linear system solver should be adopted to solve it.</li>
</ol>
<p><b>Even though the member variables of the current class will be not be modified, the actual heap memory data related to full matrix in the leaf set will be changed, since LU factorization will be performed.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">is_unit_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>The current \(\mathcal{H}\)-matrix node should be square.</p>
<p>When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be solved via LU factorization.</p>
<p>In this case, the diagonal block in the leaf set should be an identity matrix, the solution <code>x</code> is the same as the right hand side vector <code>b</code>, so here we do nothing.</p>
<p>In this case, the diagonal block in the leaf set should be general full matrix and forward substitution cannot be applied any more. Instead, LU factorization is adopted.</p>
<p>Restrict vector <code>b</code> to the column cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p>Solve the full matrix using LU factorization.</p>
<p>Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p>Iterate over each block row of the matrix.</p>
<p>Iterate each block column before the i'th column, i.e. before the diagonal submatrix block.</p>
<p>Solve the current diagonal block using forward substitution.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-block-triangular-forward-substitution-unit-diag_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="classHMatrix.html#aa8046a87be454c81d4a884b53150685a">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_forward_substitution()</a>.</p>

</div>
</div>
<a id="aa8046a87be454c81d4a884b53150685a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8046a87be454c81d4a884b53150685a">&#9670;&nbsp;</a></span>solve_block_triangular_by_forward_substitution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_block_triangular_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_block_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the block lower triangular matrix \(Lx=b\) by forward substitution.</p>
<p>Refer to <code>solve_block_triangular_by_forward_substitution</code>( Vector&lt;Number&gt; &amp;b, const bool is_unit_block_diagonal = false) const.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">is_unit_block_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#ab8b64d4a5b7120a2599ec3e3e0708775">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_forward_substitution()</a>.</p>

</div>
</div>
<a id="ac7231b00a53ef6b860d774d1daad738f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7231b00a53ef6b860d774d1daad738f">&#9670;&nbsp;</a></span>solve_by_backward_substitution() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the upper triangular matrix \(Ux=b\) by backward substitution.</p>
<p>The right hand side vector \(b\) will be overwritten by the solution vector \(x\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Right hand side vector and after execution, it stores the result vector. </td></tr>
  </table>
  </dd>
</dl>
<p>The current \(\mathcal{H}\)-matrix node should be square.</p>
<p>When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via backward substitution.</p>
<p>Restrict vector <code>b</code> to the column cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p>Perform backward substitution for the full matrix.</p>
<p>Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p>Iterate over each block row of the matrix.</p>
<p>Iterate each block column after the i'th column, i.e. after the diagonal submatrix block.</p>
<p>Solve the current diagonal block using backward substitution.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-backward-substitution-coarse-ntp_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, <a class="el" href="classHMatrix.html#ab89582b86090d18d33f7ae04deda1f5f">HMatrix&lt; spacedim, Number &gt;::solve_by_backward_substitution()</a>, and <a class="el" href="classHMatrix.html#a83e9dd55091e7eaed11ffb803321c49d">HMatrix&lt; spacedim, Number &gt;::solve_lu()</a>.</p>

</div>
</div>
<a id="ab89582b86090d18d33f7ae04deda1f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89582b86090d18d33f7ae04deda1f5f">&#9670;&nbsp;</a></span>solve_by_backward_substitution() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the upper triangular matrix \(Ux=b\) by backward substitution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">is_unit_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#ac7231b00a53ef6b860d774d1daad738f">HMatrix&lt; spacedim, Number &gt;::solve_by_backward_substitution()</a>.</p>

</div>
</div>
<a id="aedc13c9cf448ec8b47147053d02f357b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc13c9cf448ec8b47147053d02f357b">&#9670;&nbsp;</a></span>solve_by_backward_substitution() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_index_global_to_local_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the upper triangular matrix \(Ux=b\) by backward substitution.</p>
<p>The right hand side vector \(b\) will be overwritten by the solution vector \(x\).</p>
<p><b>The vector <code>b</code> is to be accessed via local indices with the assistance of <code>vector_index_global_to_local_map</code>.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Right hand side vector and after execution, it stores the result vector. </td></tr>
  </table>
  </dd>
</dl>
<p>The current \(\mathcal{H}\)-matrix node should be square.</p>
<p>When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via backward substitution.</p>
<p>Restrict vector <code>b</code> to the column cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p>Perform backward substitution for the full matrix.</p>
<p>Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p>Iterate over each block row of the matrix.</p>
<p>Iterate each block column after the i'th column, i.e. after the diagonal submatrix block.</p>
<p>Solve the current diagonal block using backward substitution.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="aa90525e857add22b334bac84e6baacd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90525e857add22b334bac84e6baacd2">&#9670;&nbsp;</a></span>solve_by_backward_substitution() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_index_global_to_local_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the upper triangular matrix \(Ux=b\) by backward substitution.</p>
<p><b>The vectors <code>x</code> and <code>b</code> are to be accessed via local indices with the assistance of <code>vector_index_global_to_local_map</code>.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">is_unit_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#ac7231b00a53ef6b860d774d1daad738f">HMatrix&lt; spacedim, Number &gt;::solve_by_backward_substitution()</a>.</p>

</div>
</div>
<a id="aeee2443c3f85cd6a961e77e5287e43f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee2443c3f85cd6a961e77e5287e43f9">&#9670;&nbsp;</a></span>solve_by_forward_substitution() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the lower triangular matrix \(Lx=b\) by forward substitution.</p>
<p>The right hand side vector \(b\) will be overwritten by the solution vector \(x\).</p>
<p><b>The vector <code>b</code> is accessed directly by using the DoF index stored in clusters.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Right hand side global vector. After execution, it stores the result vector. </td></tr>
  </table>
  </dd>
</dl>
<p>The current \(\mathcal{H}\)-matrix node should be square.</p>
<p>When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via forward substitution.</p>
<p>Restrict vector <code>b</code> to the column cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p>Perform forward substitution for the full matrix. N.B. The right hand side vector should be permuted if the current lower triangular matrix is obtained from the row pivoted LU factorization.</p>
<p>Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p>Iterate over each block row of the matrix.</p>
<p>Iterate each block column before the i'th column, i.e. before the diagonal submatrix block.</p>
<p>Solve the current diagonal block using forward substitution.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-forward-substitution-coarse-ntp_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, <a class="el" href="classHMatrix.html#a4c226aaa96ad7b1a7f0c1507d43bba89">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a20fa0ad9c55bb5225440ccab58608cf8">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a09beb710b79d47e34ff3283424cf2a22">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a41f0e0b791e50a3d9b5c0e73ee4423c6">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_transpose_by_forward_substitution_matrix_valued()</a>, and <a class="el" href="classHMatrix.html#a83e9dd55091e7eaed11ffb803321c49d">HMatrix&lt; spacedim, Number &gt;::solve_lu()</a>.</p>

</div>
</div>
<a id="a4c226aaa96ad7b1a7f0c1507d43bba89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c226aaa96ad7b1a7f0c1507d43bba89">&#9670;&nbsp;</a></span>solve_by_forward_substitution() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the lower triangular matrix \(Lx=b\) by forward substitution.</p>
<p><b>The vectors <code>b</code> and <code>x</code> are accessed directly by using the DoF index stored in clusters.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td>Right hand side global vector. </td></tr>
    <tr><td class="paramname">is_unit_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>.</p>

</div>
</div>
<a id="a898ed2cdcb0351a6a9b57251320b5d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898ed2cdcb0351a6a9b57251320b5d1d">&#9670;&nbsp;</a></span>solve_by_forward_substitution() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_index_global_to_local_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the lower triangular matrix \(Lx=b\) by forward substitution.</p>
<p>The right hand side vector \(b\) will be overwritten by the solution vector \(x\).</p>
<p><b>The vector <code>b</code> is to be accessed via local indices with the assistance of <code>vector_index_global_to_local_map</code>.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Right hand side vector and after execution, it stores the result vector. </td></tr>
  </table>
  </dd>
</dl>
<p>The current \(\mathcal{H}\)-matrix node should be square.</p>
<p>When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via forward substitution.</p>
<p>Restrict vector <code>b</code> to the column cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p>Perform forward substitution for the full matrix. N.B. The right hand side vector should be permuted if the current lower triangular matrix is obtained from the row pivoted LU factorization.</p>
<p>Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p>Iterate over each block row of the matrix.</p>
<p>Iterate each block column before the i'th column, i.e. before the diagonal submatrix block.</p>
<p>Solve the current diagonal block using forward substitution.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a5ddd48bc33e45d0b4221416cbb039cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddd48bc33e45d0b4221416cbb039cc3">&#9670;&nbsp;</a></span>solve_by_forward_substitution() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_index_global_to_local_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the lower triangular matrix \(Lx=b\) by forward substitution.</p>
<p><b>The vectors <code>x</code> and <code>b</code> are to be accessed via local indices with the assistance of <code>vector_index_global_to_local_map</code>.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">is_unit_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>.</p>

</div>
</div>
<a id="a20fa0ad9c55bb5225440ccab58608cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fa0ad9c55bb5225440ccab58608cf8">&#9670;&nbsp;</a></span>solve_by_forward_substitution_matrix_valued()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_by_forward_substitution_matrix_valued </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_unit_diagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the matrix-valued problem \(L\vert_{\tau\times\tau}X\vert_{\tau\times\sigma}=Z\vert_{\tau\times\sigma}\) using forward substitution.</p>
<p><b>The problem to be solved is restricted to specific block clusters. Hence, when this recursive algorithm for forward substitution comes to a leaf node of \(Z\), it implies the column vectors stored in \(Z\) are to be accessed via local indices. Therefore, when calling the procedure <code>HMAtrix&lt;spacedim, Number&gt;::solve_by_forward_substitution</code>, the version with the argument <code>vector_index_global_to_local_map</code> should be used, i.e. <code><a class="el" href="classHMatrix.html#a898ed2cdcb0351a6a9b57251320b5d1d">HMatrix&lt;spacedim, Number&gt;::solve_by_forward_substitution(Vector&lt;Number&gt; &amp;b, const std::map&lt;types::global_dof_index, size_t&gt; &amp; vector_index_global_to_local_map, const bool is_unit_diagonal) const</a></code>.</b></p>
<dl class="section note">
<dt>Note </dt>
<dd>Because the <code>col_index_global_to_local_map</code> in in some diagonal \(\mathcal{H}\)-matrix node in \(L\) may be built, this member function is not <code>const</code>. </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td></td></tr>
    <tr><td class="paramname">Z</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
    <tr><td class="paramname">is_unit_diagonal</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>When the current \(\mathcal{H}\)-matrix node of <code>X</code> or <code>Z</code> is a full matrix, we need to solve a multiple RHS problem.</p>
<p>Iterate over each column of <code>X</code> and <code>Z</code>.</p>
<p>Solve the current lower triangular \(\mathcal{H}\)-matrix \(L\vert_{\tau,\tau}X\vert_{\tau,j}=Z\vert_{\tau,j}\) using the forward substitution for \(\mathcal{H}\)-matrices.</p>
<p>Merge back the solution vector <code>X_col</code> into <code>X</code>, while the matrix <code>Z</code> is intact.</p>
<p>When the current \(\mathcal{H}\)-matrix node of <code>X</code> or <code>Z</code> is a rank-k matrix, we iterate over each column of its component matrix <code>A</code> and solve a multiple RHS problem. The resulted solution matrix <code>A'</code> is just the component matrix <code>A</code> of the rank-k matrix <code>X</code>.</p>
<p>Copy the data of the rank-k matrix <code>Z</code> to the rank-k matrix <code>X</code>. The component matrix <code>B</code> of <code>X</code> will be intact, while the component matrix <code>A</code> of X will be solved by using the forward substitution for \(\mathcal{H}\)-matrices.</p>
<p>This can be further elucidated as: because \(L\vert_{\tau\times\tau}X\vert_{\tau\times\sigma} = Z\vert_{\tau\times\sigma}\), where \(Z\vert_{\tau\times\sigma} = AB^T\). Since \(X\) is also a rank-k matrix, let \(X=A&#39;B^T\). Hence, the component matrix \(A&#39;\) of \(X\) can be solved as \(L\vert_{\tau\times\tau}A&#39;=A\).</p>
<p>Merge back the column vector of <code>A'</code> into <code>A'</code>.</p>
<p>When the current \(\mathcal{H}\)-matrix node of <code>X</code> or <code>Z</code> does not belong to the leaf set, perform a recursive forward substitution based on the submatrix structure of the current \(\mathcal{H}\)-matrix \(L\).</p>
<p>The number of row blocks and column blocks of \(L\vert_{\tau\times\tau}\) should be the same.</p>
<p>Number of row blocks of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\), which should be the same as the number of row or column blocks of \(L\vert_{\tau\times\tau}\).</p>
<p>Number of column blocks of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\).</p>
<dl class="section note">
<dt>Note </dt>
<dd>N.B. <code>n_row_blocks</code> does not have to be equal to <code>n_col_blocks</code>, since <code>X</code> or <code>Z</code> may be rectangular. </dd>
</dl>
<p>Iterate over each block row of \(L\vert_{\tau\times\tau}\).</p>
<p>Iterate over each child cluster node of the cluster \(\sigma\), i.e. each block column of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\).</p>
<p>Iterate over each block column before the i'th column in \(L\vert_{\tau\times\tau}\).</p>
<p>Go down one level of recursion and solve the current diagonal block matrix \(L\vert_{\tau_i\times\tau_i}\).</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-forward-substitution-matrix-valued_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="classHMatrix.html#a948b0b53490cc7614ee82fec80fa245a">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_by_forward_substitution_matrix_valued()</a>.</p>

</div>
</div>
<a id="ac5582db8445ec15c69bc4bfdda19d547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5582db8445ec15c69bc4bfdda19d547">&#9670;&nbsp;</a></span>solve_cholesky()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the whole linear system formed by the current \(\mathcal{H}\)-matrix, which should have been applied the Cholesky factorization. The right hand side vector <code>b</code> should be accessed via global indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a054ad84d52a9ee6df9df3bda0a17cfb7">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution()</a>, and <a class="el" href="classHMatrix.html#a09beb710b79d47e34ff3283424cf2a22">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_by_forward_substitution()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-solve-cholesky-in-situ_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a054ad84d52a9ee6df9df3bda0a17cfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054ad84d52a9ee6df9df3bda0a17cfb7">&#9670;&nbsp;</a></span>solve_cholesky_by_backward_substitution() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the upper triangular matrix \(Ux=b\) by backward substitution, where \(U\) is the transpose of the current matrix \(L\).</p>
<p>The right hand side vector \(b\) will be overwritten by the solution vector \(x\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Right hand side vector and after execution, it stores the result vector. </td></tr>
  </table>
  </dd>
</dl>
<p>The current \(\mathcal{H}\)-matrix node should be square.</p>
<p>When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via backward substitution.</p>
<p>Restrict vector <code>b</code> to the <b>row</b> cluster of the current \(\mathcal{H}\)-matrix node, since the actual matrix to be solved is the transposition of the current matrix.</p>
<p>Perform backward substitution for the full matrix, where the transposed matrix is solved.</p>
<p>Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p>Iterate over each block column of the matrix.</p>
<p>Iterate each row column after the j'th row, i.e. after the diagonal submatrix block.</p>
<p>Since the transpose of the current matrix is to be solved, <code>Tvmult</code> is used here instead of <code>vmult</code>.</p>
<p>Solve the current diagonal block using backward substitution.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-cholesky-backward-substitution_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, <a class="el" href="classHMatrix.html#ac5582db8445ec15c69bc4bfdda19d547">HMatrix&lt; spacedim, Number &gt;::solve_cholesky()</a>, and <a class="el" href="classHMatrix.html#a880948492a7df252f3696219f6966703">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution()</a>.</p>

</div>
</div>
<a id="a880948492a7df252f3696219f6966703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880948492a7df252f3696219f6966703">&#9670;&nbsp;</a></span>solve_cholesky_by_backward_substitution() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the upper triangular matrix \(Ux=b\) by backward substitution, where \(U\) is the transpose of the current matrix \(L\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Result vector. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a054ad84d52a9ee6df9df3bda0a17cfb7">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution()</a>.</p>

</div>
</div>
<a id="ae8bbf6f35a2099872fbcbfda2cb1abbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8bbf6f35a2099872fbcbfda2cb1abbd">&#9670;&nbsp;</a></span>solve_cholesky_by_backward_substitution() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_index_global_to_local_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the upper triangular matrix \(Ux=b\) by backward substitution, where \(U\) is the transpose of the current matrix \(L\).</p>
<p>The right hand side vector \(b\) will be overwritten by the solution vector \(x\).</p>
<p><b>The vector <code>b</code> is to be accessed via local indices with the assistance of <code>vector_index_global_to_local_map</code>.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Right hand side vector and after execution, it stores the result vector. </td></tr>
  </table>
  </dd>
</dl>
<p>The current \(\mathcal{H}\)-matrix node should be square.</p>
<p>When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via backward substitution.</p>
<p>Restrict vector <code>b</code> to the <b>row</b> cluster of the current \(\mathcal{H}\)-matrix node, since the actual matrix to be solved is the transposition of the current matrix.</p>
<p>Perform backward substitution for the full matrix, where the transposed matrix is solved.</p>
<p>Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p>Iterate over each block column of the matrix.</p>
<p>Iterate each row column after the j'th row, i.e. after the diagonal submatrix block.</p>
<p>Since the transpose of the current matrix is to be solved, <code>Tvmult</code> is used here instead of <code>vmult</code>.</p>
<p>Solve the current diagonal block using backward substitution.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a8dcb361dfb254ff716755ba8b7ed9cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcb361dfb254ff716755ba8b7ed9cf1">&#9670;&nbsp;</a></span>solve_cholesky_by_backward_substitution() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_index_global_to_local_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the upper triangular matrix \(Ux=b\) by backward substitution, where \(U\) is the transpose of the current matrix \(L\).</p>
<p><b>The vectors <code>x</code> and <code>b</code> are to be accessed via local indices with the assistance of <code>vector_index_global_to_local_map</code>.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Result vector. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a054ad84d52a9ee6df9df3bda0a17cfb7">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution()</a>.</p>

</div>
</div>
<a id="a09beb710b79d47e34ff3283424cf2a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09beb710b79d47e34ff3283424cf2a22">&#9670;&nbsp;</a></span>solve_cholesky_by_forward_substitution() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the lower triangular matrix \(Lx=b\) by forward substitution, where \(L\) is obtained from a Cholesky decomposition. Hence, \(L\) is not normed.</p>
<p>This function directly calls <code>solve_by_forward_substitution</code>(Vector&lt;Number&gt; &amp;b, const bool is_unit_diagonal = false) with <code>is_unit_diagonal</code> being <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Right hand side vector and after execution, it stores the result vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ac5582db8445ec15c69bc4bfdda19d547">HMatrix&lt; spacedim, Number &gt;::solve_cholesky()</a>.</p>

</div>
</div>
<a id="a59d32edbfaac9221dc5e219640c3ecd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d32edbfaac9221dc5e219640c3ecd3">&#9670;&nbsp;</a></span>solve_cholesky_by_forward_substitution() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the lower triangular matrix \(Lx=b\) by forward substitution, where \(L\) is obtained from a Cholesky decomposition. Hence, \(L\) is not normed.</p>
<p>This function directly calls <code>void</code> solve_by_forward_substitution(Vector&lt;Number&gt; &amp; x, const Vector&lt;Number&gt; &amp;b, const bool is_unit_diagonal = false) const with <code>is_unit_diagonal</code> being <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Solution vector. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>.</p>

</div>
</div>
<a id="a987af3012854b397b90f19f742085155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987af3012854b397b90f19f742085155">&#9670;&nbsp;</a></span>solve_cholesky_by_forward_substitution() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_index_global_to_local_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the lower triangular matrix \(Lx=b\) by forward substitution, where \(L\) is obtained from a Cholesky decomposition. Hence, \(L\) is not normed.</p>
<p>This function directly calls <code>solve_by_forward_substitution</code>(Vector&lt;Number&gt; &amp;b, const std::map&lt;types::global_dof_index, size_t&gt; &amp; vector_index_global_to_local_map, const bool is_unit_diagonal = false) with <code>is_unit_diagonal</code> being <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Right hand side vector and after execution, it stores the result vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>.</p>

</div>
</div>
<a id="a0b81214fb9287b344dff8349c7122583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b81214fb9287b344dff8349c7122583">&#9670;&nbsp;</a></span>solve_cholesky_by_forward_substitution() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_index_global_to_local_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the lower triangular matrix \(Lx=b\) by forward substitution, where \(L\) is obtained from a Cholesky decomposition. Hence, \(L\) is not normed.</p>
<p>This function directly calls <code>solve_by_forward_substitution</code>(Vector&lt;Number&gt; &amp; x, const Vector&lt;Number&gt; &amp;b, const std::map&lt;types::global_dof_index, size_t&gt; &amp; vector_index_global_to_local_map, const bool is_unit_diagonal = false) with <code>is_unit_diagonal</code> being <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Solution vector. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>.</p>

</div>
</div>
<a id="a948b0b53490cc7614ee82fec80fa245a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948b0b53490cc7614ee82fec80fa245a">&#9670;&nbsp;</a></span>solve_cholesky_by_forward_substitution_matrix_valued()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_by_forward_substitution_matrix_valued </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the matrix-valued problem \(L\vert_{\tau\times\tau}X\vert_{\tau\times\sigma}=Z\vert_{\tau\times\sigma}\) using forward substitution, where \(L\vert_{\tau\times\tau}\) is obtained from a Cholesky decomposition. Hence, \(L\vert_{\tau\times\tau}\) is not normed.</p>
<p>This function directly calls <code>solve_by_forward_substitution_matrix_valued</code>( HMatrix&lt;spacedim, Number&gt; &amp;X, HMatrix&lt;spacedim, Number&gt; &amp;Z, const unsigned int fixed_rank, const bool is_unit_diagonal = false) with <code>is_unit_diagonal</code> being <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td></td></tr>
    <tr><td class="paramname">Z</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a20fa0ad9c55bb5225440ccab58608cf8">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution_matrix_valued()</a>.</p>

</div>
</div>
<a id="a41f0e0b791e50a3d9b5c0e73ee4423c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f0e0b791e50a3d9b5c0e73ee4423c6">&#9670;&nbsp;</a></span>solve_cholesky_transpose_by_forward_substitution_matrix_valued()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_cholesky_transpose_by_forward_substitution_matrix_valued </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the matrix-valued problem \(X\vert_{\tau\times\sigma}U\vert_{\sigma\times\sigma} = Z\vert_{\tau\times\sigma}\), where the upper triangular \(\mathcal{H}\)-matrix \(U\vert_{\sigma\times\sigma}\) is obtained from a Cholesky factorization.</p>
<p>Since only the lower triangular part of a Cholesky factorization is stored or effective, \(U\vert_{\sigma\times\sigma} = L^T\vert_{\sigma\times\sigma}\). Therefore, a transposed system is solved using forward substitution, i.e. \(U^T\vert_{\sigma\times\sigma}X^T\vert_{\sigma\times\tau} = L\vert_{\sigma\times\sigma}X^T\vert_{\sigma\times\tau} = Z^T\vert_{\sigma\times\tau}\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td></td></tr>
    <tr><td class="paramname">Z</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>The current \(\mathcal{H}\)-matrix is \(L\vert_{\sigma\times\sigma}\) and the equation is \(L\vert_{\sigma\times\sigma}X\vert_{\sigma\times\tau}^T\), the column dimension of \(L\) should be the same as the column dimension of \(X\).</p>
<p>When the current \(\mathcal{H}\)-matrix node of <code>X</code> or <code>Z</code> is a full matrix, we need to solve a multiple RHS problem.</p>
<p>Iterate over each row of <code>X</code> and <code>Z</code>.</p>
<p>Solve the problem \(L\vert_{\sigma\times\sigma}X\vert_{\sigma,i} = Z\vert_{\sigma,i}\) using the forward substitution for \(\mathcal{H}\)-matrices, while the lower triangular matrix is not unit.</p>
<p>Merge back the solution vector <code>X_row</code> into <code>X</code>, while the matrix <code>Z</code> is intact.</p>
<p>Solve the lower triangular \(\mathcal{H}\)-matrix using the forward substitution for \(\mathcal{H}\)-matrices, while the matrix does not have unit diagonal.</p>
<p>Merge back the column vector into <code>B'</code>.</p>
<p>When the current \(\mathcal{H}\)-matrix node of <code>X</code> or <code>Z</code> does not belong to the leaf set, perform a recursive forward substitution based on the submatrix structure of the current \(\mathcal{H}\)-matrix \(U\).</p>
<p>The number of row blocks and column blocks of \(L\vert_{\sigma\times\sigma}\) should be the same.</p>
<p>Number of row blocks of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\).</p>
<p>Number of column blocks of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\), which should be the same as the number of row or column blocks of \(L\vert_{\sigma\times\sigma}\).</p>
<dl class="section note">
<dt>Note </dt>
<dd>N.B. <code>n_row_blocks</code> does not have to be equal to <code>n_col_blocks</code>, since <code>X</code> or <code>Z</code> may be rectangular. </dd>
</dl>
<p>Iterate over each block column of \(U\vert_{\sigma\times\sigma}\).</p>
<p>Iterate over each child cluster node of the cluster \(\tau\), i.e. each block row of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\).</p>
<p>Iterate over each block row before the j'th row in \(U\vert_{\sigma\times\sigma}\).</p>
<p>Go down one level of recursion and solve the current diagonal block matrix \(U\vert_{\sigma_i \times \sigma_i}\).</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-cholesky-transpose-forward-substitution-matrix-valued_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="classHMatrix.html#a469507ef4061efcc29a65c413ac7acea">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued()</a>.</p>

</div>
</div>
<a id="a83e9dd55091e7eaed11ffb803321c49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e9dd55091e7eaed11ffb803321c49d">&#9670;&nbsp;</a></span>solve_lu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_lu </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the whole linear system formed by the current \(\mathcal{H}\)-matrix, which should have been applied the LU factorization. The right hand side vector <code>b</code> should be accessed via global indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#ac7231b00a53ef6b860d774d1daad738f">HMatrix&lt; spacedim, Number &gt;::solve_by_backward_substitution()</a>, and <a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-solve-lu-in-situ_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a624fc153099a20572a655457d4f81b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624fc153099a20572a655457d4f81b70">&#9670;&nbsp;</a></span>solve_transpose_by_forward_substitution() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the transpose of an upper triangular matrix \(U^Tx=b\) by forward substitution.</p>
<p>The right hand side vector \(b\) will be overwritten by the solution vector \(x\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Right hand side vector and after execution, it stores the result vector. </td></tr>
  </table>
  </dd>
</dl>
<p>The current \(\mathcal{H}\)-matrix node should be square.</p>
<p>When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix, whose transpose can be directly solved via forward substitution.</p>
<p>Restrict vector <code>b</code> to the row cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p>Perform forward substitution for the transpose of the full matrix. N.B. The right hand side vector will not be permuted.</p>
<p>Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p>Iterate over each block row of the matrix.</p>
<p>Iterate each block column.</p>
<p>Iterate each block row before the j'th row, i.e. before the diagonal submatrix block.</p>
<p>Solve the current diagonal block using forward substitution.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-transpose-forward-substitution_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, <a class="el" href="classHMatrix.html#a94f9bb1bc4e584fc5f29541be6b85ef1">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution()</a>, and <a class="el" href="classHMatrix.html#a469507ef4061efcc29a65c413ac7acea">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued()</a>.</p>

</div>
</div>
<a id="a94f9bb1bc4e584fc5f29541be6b85ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f9bb1bc4e584fc5f29541be6b85ef1">&#9670;&nbsp;</a></span>solve_transpose_by_forward_substitution() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the transpose of an upper triangular matrix \(U^Tx=b\) by forward substitution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Result vector. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a624fc153099a20572a655457d4f81b70">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution()</a>.</p>

</div>
</div>
<a id="aefa73f541d0b5eb8cddde5386fd140d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa73f541d0b5eb8cddde5386fd140d0">&#9670;&nbsp;</a></span>solve_transpose_by_forward_substitution() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_index_global_to_local_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the transpose of an upper triangular matrix \(U^Tx=b\) by forward substitution.</p>
<p>The right hand side vector \(b\) will be overwritten by the solution vector \(x\).</p>
<p><b>The vector <code>b</code> is to be accessed via local indices with the assistance of <code>vector_index_global_to_local_map</code>.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Right hand side vector and after execution, it stores the result vector. </td></tr>
  </table>
  </dd>
</dl>
<p>The current \(\mathcal{H}\)-matrix node should be square.</p>
<p>When the current \(\mathcal{H}\)-matrix node belongs to the leaf set, it must be a full matrix, whose transpose can be directly solved via forward substitution.</p>
<p>Restrict vector <code>b</code> to the row cluster of the current \(\mathcal{H}\)-matrix node.</p>
<p>Perform forward substitution for the transpose of the full matrix. N.B. The right hand side vector will not be permuted.</p>
<p>Copy back the restricted vector <code>local_b</code> to the original vector <code>b</code>.</p>
<p>Iterate over each block row of the matrix.</p>
<p>Iterate each block column.</p>
<p>Iterate each block row before the j'th row, i.e. before the diagonal submatrix block.</p>
<p>Solve the current diagonal block using forward substitution.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a8e9c993ce276353fda2bfefd0b932670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9c993ce276353fda2bfefd0b932670">&#9670;&nbsp;</a></span>solve_transpose_by_forward_substitution() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_index_global_to_local_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the transpose of an upper triangular matrix \(U^Tx=b\) by forward substitution.</p>
<p><b>The vectors <code>x</code> and <code>b</code> are to be accessed via local indices with the assistance of <code>vector_index_global_to_local_map</code>.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Result vector. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a624fc153099a20572a655457d4f81b70">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution()</a>, and <a class="el" href="classHMatrix.html#a469507ef4061efcc29a65c413ac7acea">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued()</a>.</p>

</div>
</div>
<a id="a469507ef4061efcc29a65c413ac7acea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469507ef4061efcc29a65c413ac7acea">&#9670;&nbsp;</a></span>solve_transpose_by_forward_substitution_matrix_valued()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the matrix-valued problem \(X\vert_{\tau\times\sigma}U\vert_{\sigma\times\sigma} = Z\vert_{\tau\times\sigma}\).</p>
<p>A transposed system is solved, i.e. \(U^T\vert_{\sigma\times\sigma}X^T\vert_{\sigma\times\tau} = Z^T\vert_{\sigma\times\tau}\). Then \(U^T\vert_{\sigma\times\sigma}\) is a lower triangular \(\mathcal{H}\)-matrix and a similar procedure as that in the matrix-valued forward substitution can be applied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td></td></tr>
    <tr><td class="paramname">Z</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>When the current \(\mathcal{H}\)-matrix node of <code>X</code> or <code>Z</code> is a full matrix, we need to solve a multiple RHS problem.</p>
<p>Iterate over each row of <code>X</code> and <code>Z</code>.</p>
<p>Solve the problem \(X\vert_{i,\sigma}U\vert_{\sigma\times\sigma} = Z\vert_{i,\sigma}\) using the transposed forward substitution for \(\mathcal{H}\)-matrices.</p>
<p>Merge back the solution vector <code>X_row</code> into <code>X</code>, while the matrix <code>Z</code> is intact.</p>
<p>Solve the problem using the transposed forward substitution for \(\mathcal{H}\)-matrices.</p>
<p>Merge back the column vector of <code>B'</code> into <code>B'</code>.</p>
<p>When the current \(\mathcal{H}\)-matrix node of <code>X</code> or <code>Z</code> does not belong to the leaf set, perform a recursive forward substitution based on the submatrix structure of the current \(\mathcal{H}\)-matrix \(U\).</p>
<p>The number of row blocks and column blocks of \(L\vert_{\tau\times\tau}\) should be the same.</p>
<p>Number of row blocks of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\).</p>
<p>Number of column blocks of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\), which should be the same as the number of row or column blocks of \(U\vert_{\sigma\times\sigma}\).</p>
<dl class="section note">
<dt>Note </dt>
<dd>N.B. <code>n_row_blocks</code> does not have to be equal to <code>n_col_blocks</code>, since <code>X</code> or <code>Z</code> may be rectangular. </dd>
</dl>
<p>Iterate over each block column of \(U\vert_{\sigma\times\sigma}\).</p>
<p>Iterate over each child cluster node of the cluster \(\tau\), i.e. each block row of \(X\vert_{\tau\times\sigma}\) or \(Z\vert_{\tau\times\sigma}\).</p>
<p>Iterate over each block row before the j'th row in \(U\vert_{\sigma\times\sigma}\).</p>
<p>Go down one level of recursion and solve the current diagonal block matrix \(U\vert_{\sigma_j\times\sigma_j}\).</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a41f0e0b791e50a3d9b5c0e73ee4423c6">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_transpose_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a624fc153099a20572a655457d4f81b70">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-transpose-forward-substitution-matrix-valued_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="classHMatrix.html#a8e9c993ce276353fda2bfefd0b932670">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution()</a>.</p>

</div>
</div>
<a id="a64be687cacd167efc12b892aa154dcd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64be687cacd167efc12b892aa154dcd3">&#9670;&nbsp;</a></span>truncate_to_rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::truncate_to_rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>new_rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate all rank-k matrices in the leaf set of the \(\mathcal{H}\)-matrix to rank-k matrices with the given <code>new_rank</code>, while the full matrices in the leaf set, i.e. those near-field matrices, are kept intact.</p>
<dl class="section note">
<dt>Note </dt>
<dd>This method implements the operator \(\mathcal{T}_{r \leftarrow s}^{\mathcal{H}}\) in (7.5) in Hackbusch's \(\mathcal{H}\)-matrix book. </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Do nothing.</p>
<p>Truncate the <a class="el" href="classRkMatrix.html">RkMatrix</a> in-place.</p>

<p class="reference">References <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-truncate-to-fixed-rank_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a421beeb0b30d63f286a7905db394bdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421beeb0b30d63f286a7905db394bdab">&#9670;&nbsp;</a></span>truncate_to_rank_diag_preserve_positive_definite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::truncate_to_rank_diag_preserve_positive_definite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>new_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_only_handle_tril</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate all rank-k matrices in the leaf set of the \(\mathcal{H}\)-matrix to rank-k matrices with the given <code>new_rank</code>, while the full matrices in the leaf set, i.e. those near-field matrices, are kept intact. In this version, the initial \(\mathcal{H}\)-matrix is a diagonal block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>At present, it is prescribed that the block cluster tree should be a quad tree.</p>
<p>Make an assertion that the first and last submatrices of the current \(\mathcal{H}\)-matrix node are really diagonal blocks by comparing the <b>pointer addresses</b> of the \(\tau\) cluster node and \(\sigma\) cluster node.</p>
<p>Do nothing.</p>
<p>Rank-k matrix should not appear as a diagonal block.</p>
<p>Do nothing.</p>
<p>Rank-k matrix should not appear as a diagonal block.</p>
<p>The error matrices will be added to the diagonal blocks when handling the bottom left block, i.e. <code>submatrices</code>[2]. So here we do nothing after rank truncation of the rank-k matrix.</p>
<p>Do nothing.</p>
<p>Since the first and last submatrices of the current \(\mathcal{H}\)-matrix node are diagonal blocks, directly add the error matrices into them.</p>
<p>Do nothing.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a938473855f9e95358d00ee7ea14f6c51">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank_preserve_positive_definite()</a>.</p>

</div>
</div>
<a id="a88546d9ca48a3c1a2a0874545cc4c8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88546d9ca48a3c1a2a0874545cc4c8df">&#9670;&nbsp;</a></span>truncate_to_rank_off_diag_preserve_positive_definite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::truncate_to_rank_off_diag_preserve_positive_definite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>new_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_compensate_diag_blocks</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate all rank-k matrices in the leaf set of the \(\mathcal{H}\)-matrix to rank-k matrices with the given <code>new_rank</code>, while the full matrices in the leaf set, i.e. those near-field matrices, are kept intact. In this version, the initial \(\mathcal{H}\)-matrix is an off-diagonal block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>At present, it is prescribed that the block cluster tree should be a quad tree.</p>
<p>Handle the four lower triangular blocks.</p>
<p>Do nothing.</p>
<p>Find the diagonal \(\mathcal{H}\)-matrix node having the same column cluster as the current \(\mathcal{H}\)-matrix node.</p>
<p>Find the diagonal \(\mathcal{H}\)-matrix node having the same row cluster as the current \(\mathcal{H}\)-matrix node.</p>
<p>Perform error compensation for preserving the positive definiteness.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#ac72668962dbad336f0c289bbd060e6ce">HMatrix&lt; spacedim, Number &gt;::addsym_diag()</a>, <a class="el" href="classHMatrix.html#a1ab763860706b9cbef8f5e73d995f29a">HMatrix&lt; spacedim, Number &gt;::find_col_diag_block_for_offdiag_block()</a>, <a class="el" href="classHMatrix.html#a1da518d5ca7e685e3e787f58dcad4e61">HMatrix&lt; spacedim, Number &gt;::find_row_diag_block_for_offdiag_block()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="a938473855f9e95358d00ee7ea14f6c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938473855f9e95358d00ee7ea14f6c51">&#9670;&nbsp;</a></span>truncate_to_rank_preserve_positive_definite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::truncate_to_rank_preserve_positive_definite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>new_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_only_handle_tril</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate all rank-k matrices in the leaf set of the \(\mathcal{H}\)-matrix to rank-k matrices with the given <code>new_rank</code>, while the full matrices in the leaf set, i.e. those near-field matrices, are kept intact.</p>
<p><b>The original \(\mathcal{H}\)-matrix is assumed to be symmetric and positive definite (SPD). When rank truncation is performed for far field rank-k matrices, the truncation error matrix components will be added to diagonal blocks according to the stabilization method proposed in Bebendorf, M., and W. Hackbusch. 2007. “Stabilized Rounded Addition of Hierarchical Matrices.” Numerical Linear Algebra with Applications 14 (5): 407–23. <a href="https://doi.org/10.1002/nla.525">https://doi.org/10.1002/nla.525</a>.</b></p>
<dl class="section note">
<dt>Note </dt>
<dd>This method implements the operator \(\mathcal{T}_{r \leftarrow s}^{\mathcal{H}}\) in (7.5) in Hackbusch's \(\mathcal{H}\)-matrix book. </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_rank</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a421beeb0b30d63f286a7905db394bdab">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank_diag_preserve_positive_definite()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-solve-cholesky-in-situ_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a72e5255eb5ce46136d0e2b195c82f016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e5255eb5ce46136d0e2b195c82f016">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate matrix-vector multiplication as \(y = y + M^T \cdot x\), i.e. the matrix \(M\) is transposed.</p>
<p>Because the matrix \(M\) is transposed, the roles for <code>row_indices</code> and <code>col_indices</code> should be swapped. Also refer to <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix::vmult</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, and <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>.</p>

</div>
</div>
<a id="a46298efb74444db494068cc3fab73431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46298efb74444db494068cc3fab73431">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate matrix-vector multiplication as \(y = y + \alpha \cdot M^T \cdot x\), i.e. the matrix \(M\) is transposed.</p>
<p>Because the matrix \(M\) is transposed, the roles for <code>row_indices</code> and <code>col_indices</code> should be swapped. Also refer to <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix::vmult</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="a52a9fb807eab3f9f0903c03dd637382c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a9fb807eab3f9f0903c03dd637382c">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_index_global_to_local_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_index_global_to_local_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate matrix-vector multiplication as \(y = y + M^T \cdot x\), i.e. the matrix \(M\) is transposed.</p>
<p>Because the matrix \(M\) is transposed, the roles for <code>row_indices</code> and <code>col_indices</code> should be swapped.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The input vectors <code>x</code> and <code>y</code> are to be accessed via local indices with the assistance of <code>row_index_global_to_local_map</code> and <code>col_index_global_to_local_map</code>. </dd>
</dl>
<p>Also refer to <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix::vmult</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="a9ce6e0dd7cfa3dc0fff165d6ed819017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce6e0dd7cfa3dc0fff165d6ed819017">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_index_global_to_local_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_index_global_to_local_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate matrix-vector multiplication as \(y = y + \alpha \cdot M^T \cdot x\), i.e. the matrix \(M\) is transposed.</p>
<p>Because the matrix \(M\) is transposed, the roles for <code>row_indices</code> and <code>col_indices</code> should be swapped.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The input vectors <code>x</code> and <code>y</code> are to be accessed via local indices with the assistance of <code>row_index_global_to_local_map</code> and <code>col_index_global_to_local_map</code>. </dd>
</dl>
<p>Also refer to <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix::vmult</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="aa11b5761aba86606effd14b4bdf31912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11b5761aba86606effd14b4bdf31912">&#9670;&nbsp;</a></span>vmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate matrix-vector multiplication as \(y = y + M \cdot x\).</p>
<dl class="section note">
<dt>Note </dt>
<dd><ol type="1">
<li>The recursive algorithm for \(\mathcal{H}\)-matrix-vector multiplication needs to collect the results from different components in the leaf set and corresponding vector block in \(x\). More importantly, there will be a series of such results contributing to a same block in the result vector \(y\). Therefore, if the interface of this function is designed with the parameter <code>add</code> as that in the <code>vmult</code> function of <code>LAPACKFullMatrix</code> in deal.ii, in all recursive calls of <code>vmult</code> except the first one, this <code>add</code> flag should be set to <code>true</code>, irrespective of the original flag value passed into the first call of <code>vmult</code>. Hence, we do not include the <code>add</code> flag in the <code>vmult</code> function.</li>
<li>The input vectors <code>x</code> and <code>y</code> are to be accessed via global DoF indices.  </li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#acf140473681cc5ea3ab57fafdc986357">f_h_mTmult()</a>, <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, <a class="el" href="hmatrix_8h.html#a8c5bc5080b3c7e065e70fdba10faae55">h_f_mTmult()</a>, <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h.html#a4d0d61778a104b7e1452c3b9be60b5e4">h_rk_mTmult()</a>, and <a class="el" href="hmatrix_8h.html#aca19ab9519b7b1aa1b9660dbfa8fe604">rk_h_mTmult()</a>.</p>

</div>
</div>
<a id="a21ca2a043c8a02a531d5d08437356310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ca2a043c8a02a531d5d08437356310">&#9670;&nbsp;</a></span>vmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate matrix-vector multiplication as \(y = y + \alpha \codt M \cdot x\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="a690927f0810d85d08f0ab2239e405ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690927f0810d85d08f0ab2239e405ffe">&#9670;&nbsp;</a></span>vmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_index_global_to_local_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_index_global_to_local_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate matrix-vector multiplication as \(y = y + M \cdot x\).</p>
<dl class="section note">
<dt>Note </dt>
<dd><ol type="1">
<li>The recursive algorithm for \(\mathcal{H}\)-matrix-vector multiplication needs to collect the results from different components in the leaf set and corresponding vector block in \(x\). More importantly, there will be a series of such results contributing to a same block in the result vector \(y\). Therefore, if the interface of this function is designed with the parameter <code>add</code> as that in the <code>vmult</code> function of <code>LAPACKFullMatrix</code> in deal.ii, in all recursive calls of <code>vmult</code> except the first one, this <code>add</code> flag should be set to <code>true</code>, irrespective of the original flag value passed into the first call of <code>vmult</code>. Hence, we do not include the <code>add</code> flag in the <code>vmult</code> function.</li>
<li>The input vectors <code>x</code> and <code>y</code> are to be accessed via local indices with the assistance of <code>row_index_global_to_local_map</code> and <code>col_index_global_to_local_map</code>. </li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="ab0a61c4d55a5d132b25589240be5c015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a61c4d55a5d132b25589240be5c015">&#9670;&nbsp;</a></span>vmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_index_global_to_local_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_index_global_to_local_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate matrix-vector multiplication as \(y = y + \alpha \cdot M \cdot x\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">y_index_global_to_local_map</td><td></td></tr>
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">x_index_global_to_local_map</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="a42f958a13c56d64564d59487e67bc8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f958a13c56d64564d59487e67bc8a2">&#9670;&nbsp;</a></span>write_fullmatrix_leaf_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::write_fullmatrix_leaf_node </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>singular_value_threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write formatted full matrix leaf node to the output stream.</p>
<p>The leaf node is written in the following format:</p>
<blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<p>[list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field,rank</p>
<p>For example,</p>
<blockquote class="doxtable">
<p>[1 2 3 ...],[7 8 9 ...],1,1 </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">singular_value_threshold</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Print index set of cluster \(\tau\).</p>
<p>Print index set of cluster \(\sigma\).</p>
<p>Print the <code>is_near_field</code> flag.</p>
<p>Make a copy of the matrix block and calculate its rank using SVD.</p>
<p>Print the <code>rank</code> flag.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#aaf0ae0960a40ad78a941aee823e80315">HMatrix&lt; spacedim, Number &gt;::write_leaf_set()</a>.</p>

</div>
</div>
<a id="aaf0ae0960a40ad78a941aee823e80315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0ae0960a40ad78a941aee823e80315">&#9670;&nbsp;</a></span>write_leaf_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::write_leaf_set </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>singular_value_threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write formatted leaf set to the output stream as well as the rank of each matrix block by recursion.</p>
<p>Each leaf node is written in the following format:</p>
<blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<p>[list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field,rank</p>
<p>For example,</p>
<blockquote class="doxtable">
<p>[1 2 3 ...],[7 8 9 ...],1,1 </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">singular_value_threshold</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, <a class="el" href="classHMatrix.html#a42f958a13c56d64564d59487e67bc8a2">HMatrix&lt; spacedim, Number &gt;::write_fullmatrix_leaf_node()</a>, and <a class="el" href="classHMatrix.html#ac2c8ccd5763d3952505741c657b6468c">HMatrix&lt; spacedim, Number &gt;::write_rkmatrix_leaf_node()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-bct-struct-with-rank_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="aac1e1ddbfeb133520dcd50c0174aab8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1e1ddbfeb133520dcd50c0174aab8d">&#9670;&nbsp;</a></span>write_leaf_set_by_iteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::write_leaf_set_by_iteration </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>singular_value_threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write formatted leaf set to the output stream as well as the rank of each matrix block by iteration.</p>
<p>Each leaf node is written in the following format:</p>
<blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<p>[list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field,rank</p>
<p>For example,</p>
<blockquote class="doxtable">
<p>[1 2 3 ...],[7 8 9 ...],1,1 </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">singular_value_threshold</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-backward-substitution-coarse-ntp_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="ac2c8ccd5763d3952505741c657b6468c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c8ccd5763d3952505741c657b6468c">&#9670;&nbsp;</a></span>write_rkmatrix_leaf_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::write_rkmatrix_leaf_node </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write formatted rank-k matrix leaf node to the output stream.</p>
<p>The leaf node is written in the following format:</p>
<blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<p>[list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field,rank</p>
<p>For example,</p>
<blockquote class="doxtable">
<p>[1 2 3 ...],[7 8 9 ...],1,1 </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Print index set of cluster \(\tau\).</p>
<p>Print index set of cluster \(\sigma\).</p>
<p>Print the <code>is_near_field</code> flag.</p>
<p>Print the <code>rank</code> flag.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#aaf0ae0960a40ad78a941aee823e80315">HMatrix&lt; spacedim, Number &gt;::write_leaf_set()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4a304494c970b5b267be1d8459d51586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a304494c970b5b267be1d8459d51586">&#9670;&nbsp;</a></span>bc_node</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt;spacedim, Number&gt;::node_pointer_type <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::bc_node</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the corresponding block cluster node in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#af74e3b0c19e9178cfe699a6620a51170">HMatrix&lt; spacedim, Number &gt;::_invert_by_gauss_elim()</a>, <a class="el" href="classHMatrix.html#ac72668962dbad336f0c289bbd060e6ce">HMatrix&lt; spacedim, Number &gt;::addsym_diag()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="classHMatrix.html#a525ad4d453f4f496b98cccb341c8b60b">HMatrix&lt; spacedim, Number &gt;::coarsen_to_partition()</a>, <a class="el" href="classHMatrix.html#a7d6c76f7db2b9239f24df292e945a970">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_factorization()</a>, <a class="el" href="classHMatrix.html#acf95fce81ec83a759d1db8d10c3e34fb">HMatrix&lt; spacedim, Number &gt;::compute_lu_factorization()</a>, <a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="classHMatrix.html#a1ab763860706b9cbef8f5e73d995f29a">HMatrix&lt; spacedim, Number &gt;::find_col_diag_block_for_offdiag_block()</a>, <a class="el" href="classHMatrix.html#a1da518d5ca7e685e3e787f58dcad4e61">HMatrix&lt; spacedim, Number &gt;::find_row_diag_block_for_offdiag_block()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="classHMatrix.html#ab315324e3ece178943f406823f792746">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_cross_split()</a>, <a class="el" href="hmatrix_8h.html#a2b842125056627d38c5aee3a077e596c">h_h_mmult_from_leaf_node()</a>, <a class="el" href="classHMatrix.html#a38c88893c6ca784d4e56653d8b0e3e67">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_horizontal_split()</a>, <a class="el" href="hmatrix_8h.html#a6534ff122b0835d0313d94264794b601">h_h_mmult_level_conserving()</a>, <a class="el" href="classHMatrix.html#a168b6eea2e5b27528497850bf5ee2bbe">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_reduction()</a>, <a class="el" href="classHMatrix.html#a253c23d09e89a9a37a7d808374b5ae4e">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_vertical_split()</a>, <a class="el" href="hmatrix_8h.html#ab9d49e86d3c8b5596b1b603793818276">h_h_mTmult_from_leaf_node()</a>, <a class="el" href="hmatrix_8h.html#a8855023aa4832e4119c6ead1115d4beb">h_h_mTmult_level_conserving()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a65e47eb35744c93b8955b6d564e5bf9a">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="classHMatrix.html#aab0c393acf1c416ebc7ab05ca85d9e49">HMatrix&lt; spacedim, Number &gt;::print_current_matrix_info()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="classHMatrix.html#aa81db0ff79182302de83d693bab9f9e3">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#ab8b64d4a5b7120a2599ec3e3e0708775">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#ac7231b00a53ef6b860d774d1daad738f">HMatrix&lt; spacedim, Number &gt;::solve_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a20fa0ad9c55bb5225440ccab58608cf8">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a054ad84d52a9ee6df9df3bda0a17cfb7">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#a41f0e0b791e50a3d9b5c0e73ee4423c6">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_transpose_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a624fc153099a20572a655457d4f81b70">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a469507ef4061efcc29a65c413ac7acea">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a421beeb0b30d63f286a7905db394bdab">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank_diag_preserve_positive_definite()</a>, <a class="el" href="classHMatrix.html#a42f958a13c56d64564d59487e67bc8a2">HMatrix&lt; spacedim, Number &gt;::write_fullmatrix_leaf_node()</a>, and <a class="el" href="classHMatrix.html#ac2c8ccd5763d3952505741c657b6468c">HMatrix&lt; spacedim, Number &gt;::write_rkmatrix_leaf_node()</a>.</p>

</div>
</div>
<a id="ab337c7b4f2f40699b9b7f3ab17a1e056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab337c7b4f2f40699b9b7f3ab17a1e056">&#9670;&nbsp;</a></span>col_index_global_to_local_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;types::global_dof_index, size_t&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::col_index_global_to_local_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map from local column indices to global column indices for the cluster \(\sigma\). The set of local column indices is the range \([0, \#\sigma - 1]\). The corresponding set of global column indices is a subset of \(J\).</p>
<dl class="section note">
<dt>Note </dt>
<dd>This mapping is only constructed for H-matrices in the leaf set. </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a187e0c009a7c28679df7e92e0b01929c">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#ab9000d7604e2045cf7cad7458daca340">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a66979dbdf56155c63f0706649e8545b9">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#acf140473681cc5ea3ab57fafdc986357">f_h_mTmult()</a>, <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, <a class="el" href="hmatrix_8h.html#a8c5bc5080b3c7e065e70fdba10faae55">h_f_mTmult()</a>, <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h.html#a4d0d61778a104b7e1452c3b9be60b5e4">h_rk_mTmult()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a65e47eb35744c93b8955b6d564e5bf9a">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#aca19ab9519b7b1aa1b9660dbfa8fe604">rk_h_mTmult()</a>, <a class="el" href="classHMatrix.html#a20fa0ad9c55bb5225440ccab58608cf8">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution_matrix_valued()</a>, and <a class="el" href="classHMatrix.html#a41f0e0b791e50a3d9b5c0e73ee4423c6">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_transpose_by_forward_substitution_matrix_valued()</a>.</p>

</div>
</div>
<a id="ac30ae65e37ec5e4ccc7de2f6b9ea91e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">&#9670;&nbsp;</a></span>col_indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;types::global_dof_index&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::col_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the vector of global column indices, which is stored as the index set in the cluster \(\sigma\). It is a subset of \(J\). By accessing this vector using indices starting from 0, we actually obtain the mapping from the current matrix's local column indices to the global column indices. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#a187e0c009a7c28679df7e92e0b01929c">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#a1793dff400aeae649f909d7f45db8b8a">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a66979dbdf56155c63f0706649e8545b9">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#acf140473681cc5ea3ab57fafdc986357">f_h_mTmult()</a>, <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, <a class="el" href="hmatrix_8h.html#a8c5bc5080b3c7e065e70fdba10faae55">h_f_mTmult()</a>, <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h.html#a4d0d61778a104b7e1452c3b9be60b5e4">h_rk_mTmult()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a65e47eb35744c93b8955b6d564e5bf9a">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#aca19ab9519b7b1aa1b9660dbfa8fe604">rk_h_mTmult()</a>, <a class="el" href="classHMatrix.html#aa81db0ff79182302de83d693bab9f9e3">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#ab8b64d4a5b7120a2599ec3e3e0708775">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#ac7231b00a53ef6b860d774d1daad738f">HMatrix&lt; spacedim, Number &gt;::solve_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a20fa0ad9c55bb5225440ccab58608cf8">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a054ad84d52a9ee6df9df3bda0a17cfb7">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#a41f0e0b791e50a3d9b5c0e73ee4423c6">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_transpose_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a624fc153099a20572a655457d4f81b70">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

</div>
</div>
<a id="a328134c9e9cb2c4b05d5431c0ca8a533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328134c9e9cb2c4b05d5431c0ca8a533">&#9670;&nbsp;</a></span>fullmatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt;Number&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::fullmatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the full matrix. It is not null when the current <a class="el" href="classHMatrix.html">HMatrix</a> object belongs to the near field. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#a187e0c009a7c28679df7e92e0b01929c">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#af74e3b0c19e9178cfe699a6620a51170">HMatrix&lt; spacedim, Number &gt;::_invert_by_gauss_elim()</a>, <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#ac72668962dbad336f0c289bbd060e6ce">HMatrix&lt; spacedim, Number &gt;::addsym_diag()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="classHMatrix.html#a7d6c76f7db2b9239f24df292e945a970">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_factorization()</a>, <a class="el" href="classHMatrix.html#acf95fce81ec83a759d1db8d10c3e34fb">HMatrix&lt; spacedim, Number &gt;::compute_lu_factorization()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="classHMatrix.html#a9d914c27d4e990d476a4529b2daa64cd">HMatrix&lt; spacedim, Number &gt;::get_fullmatrix()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a6534ff122b0835d0313d94264794b601">h_h_mmult_level_conserving()</a>, <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, <a class="el" href="hmatrix_8h.html#a8855023aa4832e4119c6ead1115d4beb">h_h_mTmult_level_conserving()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a65e47eb35744c93b8955b6d564e5bf9a">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="classHMatrix.html#a7e849f7e8f35e3ebdfcb2dbb7ad4ad01">HMatrix&lt; spacedim, Number &gt;::print_formatted()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="classHMatrix.html#aa81db0ff79182302de83d693bab9f9e3">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#ab8b64d4a5b7120a2599ec3e3e0708775">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#ac7231b00a53ef6b860d774d1daad738f">HMatrix&lt; spacedim, Number &gt;::solve_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a20fa0ad9c55bb5225440ccab58608cf8">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a054ad84d52a9ee6df9df3bda0a17cfb7">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#a41f0e0b791e50a3d9b5c0e73ee4423c6">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_transpose_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a624fc153099a20572a655457d4f81b70">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a469507ef4061efcc29a65c413ac7acea">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

</div>
</div>
<a id="a61dbd471077be0ad8325d0f2afe3d43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61dbd471077be0ad8325d0f2afe3d43f">&#9670;&nbsp;</a></span>leaf_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt; *&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::leaf_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A list of submatrices in the leaf set. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a3e61ba5438c4cf0337664ec4b8562873">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#ab0f83de878e6079330ec3c374f587a04">HMatrix&lt; spacedim, Number &gt;::find_block_cluster_in_leaf_set()</a>, <a class="el" href="classHMatrix.html#ac5c9102fc04997c1ae3627185379d9bb">HMatrix&lt; spacedim, Number &gt;::get_leaf_set()</a>, <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, <a class="el" href="classHMatrix.html#ad2b353962226c78910d6ddb6b5b8e460">HMatrix&lt; spacedim, Number &gt;::refine_to_supertree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, and <a class="el" href="classHMatrix.html#aac1e1ddbfeb133520dcd50c0174aab8d">HMatrix&lt; spacedim, Number &gt;::write_leaf_set_by_iteration()</a>.</p>

</div>
</div>
<a id="aa5523463043e4d542eae17d262bd22ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5523463043e4d542eae17d262bd22ad">&#9670;&nbsp;</a></span>m</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::m</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of rows in the matrix. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#af74e3b0c19e9178cfe699a6620a51170">HMatrix&lt; spacedim, Number &gt;::_invert_by_gauss_elim()</a>, <a class="el" href="classHMatrix.html#ab9000d7604e2045cf7cad7458daca340">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="classHMatrix.html#a00bdd40f7fcf5c912c34c427df518300">HMatrix&lt; spacedim, Number &gt;::convertToFullMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#acf140473681cc5ea3ab57fafdc986357">f_h_mTmult()</a>, <a class="el" href="classHMatrix.html#aabe735f7712a10ba5325ff116f8ca1c7">HMatrix&lt; spacedim, Number &gt;::get_m()</a>, <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a8c5bc5080b3c7e065e70fdba10faae55">h_f_mTmult()</a>, <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a4d0d61778a104b7e1452c3b9be60b5e4">h_rk_mTmult()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a65e47eb35744c93b8955b6d564e5bf9a">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#aca19ab9519b7b1aa1b9660dbfa8fe604">rk_h_mTmult()</a>, <a class="el" href="classHMatrix.html#aa81db0ff79182302de83d693bab9f9e3">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#ab8b64d4a5b7120a2599ec3e3e0708775">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#ac7231b00a53ef6b860d774d1daad738f">HMatrix&lt; spacedim, Number &gt;::solve_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a20fa0ad9c55bb5225440ccab58608cf8">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a054ad84d52a9ee6df9df3bda0a17cfb7">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#a41f0e0b791e50a3d9b5c0e73ee4423c6">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_transpose_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a624fc153099a20572a655457d4f81b70">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a469507ef4061efcc29a65c413ac7acea">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

</div>
</div>
<a id="ab5ae2eb472f81f80653ed4411629c2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ae2eb472f81f80653ed4411629c2d1">&#9670;&nbsp;</a></span>n</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::n</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of columns in the matrix. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#af74e3b0c19e9178cfe699a6620a51170">HMatrix&lt; spacedim, Number &gt;::_invert_by_gauss_elim()</a>, <a class="el" href="classHMatrix.html#ab9000d7604e2045cf7cad7458daca340">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="classHMatrix.html#a00bdd40f7fcf5c912c34c427df518300">HMatrix&lt; spacedim, Number &gt;::convertToFullMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#acf140473681cc5ea3ab57fafdc986357">f_h_mTmult()</a>, <a class="el" href="classHMatrix.html#abff89130116d62ea4159bc69ca11f8d5">HMatrix&lt; spacedim, Number &gt;::get_n()</a>, <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a8c5bc5080b3c7e065e70fdba10faae55">h_f_mTmult()</a>, <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a4d0d61778a104b7e1452c3b9be60b5e4">h_rk_mTmult()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a65e47eb35744c93b8955b6d564e5bf9a">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#aca19ab9519b7b1aa1b9660dbfa8fe604">rk_h_mTmult()</a>, <a class="el" href="classHMatrix.html#aa81db0ff79182302de83d693bab9f9e3">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#ab8b64d4a5b7120a2599ec3e3e0708775">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#ac7231b00a53ef6b860d774d1daad738f">HMatrix&lt; spacedim, Number &gt;::solve_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a20fa0ad9c55bb5225440ccab58608cf8">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a054ad84d52a9ee6df9df3bda0a17cfb7">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#a41f0e0b791e50a3d9b5c0e73ee4423c6">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_transpose_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a624fc153099a20572a655457d4f81b70">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a469507ef4061efcc29a65c413ac7acea">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

</div>
</div>
<a id="a71690997092a4142799b2fa2dbf53db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71690997092a4142799b2fa2dbf53db4">&#9670;&nbsp;</a></span>parent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::parent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the parent \(\mathcal{H}\)-matrix. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#af4b3e4f5b78b4b6a9885325225eba0a1">copy_hmatrix()</a>, <a class="el" href="hmatrix_8h.html#a3e61ba5438c4cf0337664ec4b8562873">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a1ab763860706b9cbef8f5e73d995f29a">HMatrix&lt; spacedim, Number &gt;::find_col_diag_block_for_offdiag_block()</a>, <a class="el" href="classHMatrix.html#a1da518d5ca7e685e3e787f58dcad4e61">HMatrix&lt; spacedim, Number &gt;::find_row_diag_block_for_offdiag_block()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a65e47eb35744c93b8955b6d564e5bf9a">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="classHMatrix.html#aab0c393acf1c416ebc7ab05ca85d9e49">HMatrix&lt; spacedim, Number &gt;::print_current_matrix_info()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, and <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>.</p>

</div>
</div>
<a id="aa97a8f5e42aba0f1d5faf41f35a27819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97a8f5e42aba0f1d5faf41f35a27819">&#9670;&nbsp;</a></span>rkmatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt;Number&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::rkmatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the rank-k matrix. It is not null when the current <a class="el" href="classHMatrix.html">HMatrix</a> object belongs to the far field. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#a187e0c009a7c28679df7e92e0b01929c">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#a72191c447afaa0fd84505022cf1d174e">HMatrix&lt; spacedim, Number &gt;::calc_rank_upper_bound_for_rkmatrices()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a0189de6e276fbd3425c4a7ef132f5e16">HMatrix&lt; spacedim, Number &gt;::get_rkmatrix()</a>, <a class="el" href="hmatrix_8h.html#a6534ff122b0835d0313d94264794b601">h_h_mmult_level_conserving()</a>, <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, <a class="el" href="hmatrix_8h.html#a8855023aa4832e4119c6ead1115d4beb">h_h_mTmult_level_conserving()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a65e47eb35744c93b8955b6d564e5bf9a">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="classHMatrix.html#a7e849f7e8f35e3ebdfcb2dbb7ad4ad01">HMatrix&lt; spacedim, Number &gt;::print_formatted()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>, <a class="el" href="classHMatrix.html#a20fa0ad9c55bb5225440ccab58608cf8">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a41f0e0b791e50a3d9b5c0e73ee4423c6">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_transpose_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a469507ef4061efcc29a65c413ac7acea">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a64be687cacd167efc12b892aa154dcd3">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank()</a>, <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

</div>
</div>
<a id="a4d64145335fc0521603b206a22a67578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d64145335fc0521603b206a22a67578">&#9670;&nbsp;</a></span>row_index_global_to_local_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;types::global_dof_index, size_t&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::row_index_global_to_local_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map from local row indices to global row indices for the cluster \(\tau\). The set of local row indices is the range \([0, \#\tau - 1]\). The corresponding set of global row indices is a subset of \(I\).</p>
<dl class="section note">
<dt>Note </dt>
<dd>This mapping is only constructed for H-matrices in the leaf set. </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a187e0c009a7c28679df7e92e0b01929c">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#ab9000d7604e2045cf7cad7458daca340">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#ac72668962dbad336f0c289bbd060e6ce">HMatrix&lt; spacedim, Number &gt;::addsym_diag()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a66979dbdf56155c63f0706649e8545b9">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#acf140473681cc5ea3ab57fafdc986357">f_h_mTmult()</a>, <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, <a class="el" href="hmatrix_8h.html#a8c5bc5080b3c7e065e70fdba10faae55">h_f_mTmult()</a>, <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h.html#a4d0d61778a104b7e1452c3b9be60b5e4">h_rk_mTmult()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a65e47eb35744c93b8955b6d564e5bf9a">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#aca19ab9519b7b1aa1b9660dbfa8fe604">rk_h_mTmult()</a>, and <a class="el" href="classHMatrix.html#a469507ef4061efcc29a65c413ac7acea">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued()</a>.</p>

</div>
</div>
<a id="a33b3a936f1b40e320e96d47471da07ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b3a936f1b40e320e96d47471da07ae">&#9670;&nbsp;</a></span>row_indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;types::global_dof_index&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::row_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the vector of global row indices, which is stored as the index in the cluster \(\tau\). It is a subset of \(I\). By accessing this vector using indices starting from 0, we actually obtain the mapping from the current matrix's local row indices to the global row indices. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#a187e0c009a7c28679df7e92e0b01929c">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#a1793dff400aeae649f909d7f45db8b8a">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#ac72668962dbad336f0c289bbd060e6ce">HMatrix&lt; spacedim, Number &gt;::addsym_diag()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a66979dbdf56155c63f0706649e8545b9">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#acf140473681cc5ea3ab57fafdc986357">f_h_mTmult()</a>, <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, <a class="el" href="hmatrix_8h.html#a8c5bc5080b3c7e065e70fdba10faae55">h_f_mTmult()</a>, <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h.html#a4d0d61778a104b7e1452c3b9be60b5e4">h_rk_mTmult()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a65e47eb35744c93b8955b6d564e5bf9a">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#aca19ab9519b7b1aa1b9660dbfa8fe604">rk_h_mTmult()</a>, <a class="el" href="classHMatrix.html#aa81db0ff79182302de83d693bab9f9e3">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#ab8b64d4a5b7120a2599ec3e3e0708775">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#ac7231b00a53ef6b860d774d1daad738f">HMatrix&lt; spacedim, Number &gt;::solve_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a054ad84d52a9ee6df9df3bda0a17cfb7">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#a624fc153099a20572a655457d4f81b70">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a469507ef4061efcc29a65c413ac7acea">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

</div>
</div>
<a id="aa659b6df63d533432ec1a24435cd9c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa659b6df63d533432ec1a24435cd9c40">&#9670;&nbsp;</a></span>Sigma_F</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt;Number&gt; *&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Sigma_F</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of full matrix pointers used in \(\mathcal{H}\)-matrix multiplication. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a187e0c009a7c28679df7e92e0b01929c">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a3e61ba5438c4cf0337664ec4b8562873">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a66979dbdf56155c63f0706649e8545b9">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="classHMatrix.html#aab0c393acf1c416ebc7ab05ca85d9e49">HMatrix&lt; spacedim, Number &gt;::print_current_matrix_info()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, and <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>.</p>

</div>
</div>
<a id="a3d96d0252ef8c873ae06cf87874acaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d96d0252ef8c873ae06cf87874acaf3">&#9670;&nbsp;</a></span>Sigma_P</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt;<a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt; *&gt; &gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Sigma_P</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of pairs of pointers to \(\mathcal{H}\)-matrix nodes for multiplication. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a3e61ba5438c4cf0337664ec4b8562873">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a6f24998c7de1d0e336577be41c6281e3">HMatrix&lt; spacedim, Number &gt;::determine_mm_split_mode_from_Sigma_P()</a>, <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#aad08ee9bd389abe7b7b76fd0f2cb292e">h_h_mmult_phase1_recursion()</a>, <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, <a class="el" href="classHMatrix.html#a168b6eea2e5b27528497850bf5ee2bbe">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_reduction()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="classHMatrix.html#aab0c393acf1c416ebc7ab05ca85d9e49">HMatrix&lt; spacedim, Number &gt;::print_current_matrix_info()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="classHMatrix.html#a9e023f39b1f8916117a63557895a91b4">HMatrix&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list()</a>, and <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>.</p>

</div>
</div>
<a id="a04d341b4e606d1be2d71b8ea636efe7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d341b4e606d1be2d71b8ea636efe7b">&#9670;&nbsp;</a></span>Sigma_R</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classRkMatrix.html">RkMatrix</a>&lt;Number&gt; *&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Sigma_R</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of rank-k matrix pointers used in \(\mathcal{H}\)-matrix multiplication. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a187e0c009a7c28679df7e92e0b01929c">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a3e61ba5438c4cf0337664ec4b8562873">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a66979dbdf56155c63f0706649e8545b9">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="classHMatrix.html#aab0c393acf1c416ebc7ab05ca85d9e49">HMatrix&lt; spacedim, Number &gt;::print_current_matrix_info()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, and <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>.</p>

</div>
</div>
<a id="a4bd1b9a32f2c7693e603a7c6ea916e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd1b9a32f2c7693e603a7c6ea916e4f">&#9670;&nbsp;</a></span>submatrices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt; *&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::submatrices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A list of submatrices of type \(\mathcal{H}\)-matrix. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a60934e84cc3c9f6c75d011a2005f512a">HMatrix&lt; spacedim, Number &gt;::_build_leaf_set()</a>, <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#a187e0c009a7c28679df7e92e0b01929c">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#af74e3b0c19e9178cfe699a6620a51170">HMatrix&lt; spacedim, Number &gt;::_invert_by_gauss_elim()</a>, <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#ac72668962dbad336f0c289bbd060e6ce">HMatrix&lt; spacedim, Number &gt;::addsym_diag()</a>, <a class="el" href="classHMatrix.html#a72191c447afaa0fd84505022cf1d174e">HMatrix&lt; spacedim, Number &gt;::calc_rank_upper_bound_for_rkmatrices()</a>, <a class="el" href="classHMatrix.html#ae55bd45587b895bfdb977e7cbea46519">HMatrix&lt; spacedim, Number &gt;::clear()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="classHMatrix.html#a525ad4d453f4f496b98cccb341c8b60b">HMatrix&lt; spacedim, Number &gt;::coarsen_to_partition()</a>, <a class="el" href="classHMatrix.html#a7d6c76f7db2b9239f24df292e945a970">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_factorization()</a>, <a class="el" href="classHMatrix.html#acf95fce81ec83a759d1db8d10c3e34fb">HMatrix&lt; spacedim, Number &gt;::compute_lu_factorization()</a>, <a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h.html#af4b3e4f5b78b4b6a9885325225eba0a1">copy_hmatrix()</a>, <a class="el" href="hmatrix_8h.html#a3e61ba5438c4cf0337664ec4b8562873">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a66979dbdf56155c63f0706649e8545b9">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#a1ab763860706b9cbef8f5e73d995f29a">HMatrix&lt; spacedim, Number &gt;::find_col_diag_block_for_offdiag_block()</a>, <a class="el" href="classHMatrix.html#a1da518d5ca7e685e3e787f58dcad4e61">HMatrix&lt; spacedim, Number &gt;::find_row_diag_block_for_offdiag_block()</a>, <a class="el" href="classHMatrix.html#a0572b2c0484ce618db0034e3bc7988ed">HMatrix&lt; spacedim, Number &gt;::get_submatrices()</a>, <a class="el" href="hmatrix_8h.html#a6534ff122b0835d0313d94264794b601">h_h_mmult_level_conserving()</a>, <a class="el" href="hmatrix_8h.html#a8855023aa4832e4119c6ead1115d4beb">h_h_mTmult_level_conserving()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a65e47eb35744c93b8955b6d564e5bf9a">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="classHMatrix.html#aab0c393acf1c416ebc7ab05ca85d9e49">HMatrix&lt; spacedim, Number &gt;::print_current_matrix_info()</a>, <a class="el" href="classHMatrix.html#a7e849f7e8f35e3ebdfcb2dbb7ad4ad01">HMatrix&lt; spacedim, Number &gt;::print_formatted()</a>, <a class="el" href="classHMatrix.html#ad8f87883cf49080706233441c0e09171">HMatrix&lt; spacedim, Number &gt;::print_matrix_info()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="classHMatrix.html#aa81db0ff79182302de83d693bab9f9e3">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#ab8b64d4a5b7120a2599ec3e3e0708775">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#ac7231b00a53ef6b860d774d1daad738f">HMatrix&lt; spacedim, Number &gt;::solve_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a20fa0ad9c55bb5225440ccab58608cf8">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a054ad84d52a9ee6df9df3bda0a17cfb7">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#a41f0e0b791e50a3d9b5c0e73ee4423c6">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_transpose_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a624fc153099a20572a655457d4f81b70">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a469507ef4061efcc29a65c413ac7acea">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a64be687cacd167efc12b892aa154dcd3">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank()</a>, <a class="el" href="classHMatrix.html#a421beeb0b30d63f286a7905db394bdab">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank_diag_preserve_positive_definite()</a>, <a class="el" href="classHMatrix.html#a88546d9ca48a3c1a2a0874545cc4c8df">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank_off_diag_preserve_positive_definite()</a>, <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>, <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>, and <a class="el" href="classHMatrix.html#aaf0ae0960a40ad78a941aee823e80315">HMatrix&lt; spacedim, Number &gt;::write_leaf_set()</a>.</p>

</div>
</div>
<a id="a64c851dd63ba1a466c19f451be369475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c851dd63ba1a466c19f451be369475">&#9670;&nbsp;</a></span>submatrix_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::submatrix_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Submatrix index of the current \(\mathcal{H}\)-matrix node wrt. its parent \(\mathcal{H}\)-matrix node. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a1ab763860706b9cbef8f5e73d995f29a">HMatrix&lt; spacedim, Number &gt;::find_col_diag_block_for_offdiag_block()</a>, <a class="el" href="classHMatrix.html#a1da518d5ca7e685e3e787f58dcad4e61">HMatrix&lt; spacedim, Number &gt;::find_row_diag_block_for_offdiag_block()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a65e47eb35744c93b8955b6d564e5bf9a">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="classHMatrix.html#aab0c393acf1c416ebc7ab05ca85d9e49">HMatrix&lt; spacedim, Number &gt;::print_current_matrix_info()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, and <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>.</p>

</div>
</div>
<a id="a8b5a9fb65c716187d95bcdb43542884c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5a9fb65c716187d95bcdb43542884c">&#9670;&nbsp;</a></span>submatrix_index_invalid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::submatrix_index_invalid = 9</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invalid submatrix index of the current \(\mathcal{H}\)-matrix node wrt. its parent \(\mathcal{H}\)-matrix node, which is used for initializing the <code>submatrix_index</code> member variable. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, and <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>.</p>

</div>
</div>
<a id="a12da9454687e5ca15837d63e2bf0b595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12da9454687e5ca15837d63e2bf0b595">&#9670;&nbsp;</a></span>Tind</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt;spacedim, Number&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tind</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Block cluster tree when this matrix is the product of two \(\mathcal{H}\)-matrices. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a3e61ba5438c4cf0337664ec4b8562873">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, <a class="el" href="classHMatrix.html#af40d53aabc8bec86fa543638d48ba64e">HMatrix&lt; spacedim, Number &gt;::mmult()</a>, and <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>.</p>

</div>
</div>
<a id="a89ef60f3ba737c04708195ca0bb13620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ef60f3ba737c04708195ca0bb13620">&#9670;&nbsp;</a></span>type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix type. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a60934e84cc3c9f6c75d011a2005f512a">HMatrix&lt; spacedim, Number &gt;::_build_leaf_set()</a>, <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#a187e0c009a7c28679df7e92e0b01929c">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#af74e3b0c19e9178cfe699a6620a51170">HMatrix&lt; spacedim, Number &gt;::_invert_by_gauss_elim()</a>, <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#ac72668962dbad336f0c289bbd060e6ce">HMatrix&lt; spacedim, Number &gt;::addsym_diag()</a>, <a class="el" href="classHMatrix.html#a72191c447afaa0fd84505022cf1d174e">HMatrix&lt; spacedim, Number &gt;::calc_rank_upper_bound_for_rkmatrices()</a>, <a class="el" href="classHMatrix.html#ae55bd45587b895bfdb977e7cbea46519">HMatrix&lt; spacedim, Number &gt;::clear()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="classHMatrix.html#a7d6c76f7db2b9239f24df292e945a970">HMatrix&lt; spacedim, Number &gt;::compute_cholesky_factorization()</a>, <a class="el" href="classHMatrix.html#acf95fce81ec83a759d1db8d10c3e34fb">HMatrix&lt; spacedim, Number &gt;::compute_lu_factorization()</a>, <a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a66979dbdf56155c63f0706649e8545b9">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="classHMatrix.html#aadea9fa59f420d22b3b1c939f6b573cc">HMatrix&lt; spacedim, Number &gt;::get_type()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a6534ff122b0835d0313d94264794b601">h_h_mmult_level_conserving()</a>, <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, <a class="el" href="classHMatrix.html#a168b6eea2e5b27528497850bf5ee2bbe">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_reduction()</a>, <a class="el" href="hmatrix_8h.html#a8855023aa4832e4119c6ead1115d4beb">h_h_mTmult_level_conserving()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a65e47eb35744c93b8955b6d564e5bf9a">InitAndCreateHMatrixChildrenWithoutAlloc()</a>, <a class="el" href="classHMatrix.html#a7e849f7e8f35e3ebdfcb2dbb7ad4ad01">HMatrix&lt; spacedim, Number &gt;::print_formatted()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>, <a class="el" href="classHMatrix.html#aa81db0ff79182302de83d693bab9f9e3">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#ab8b64d4a5b7120a2599ec3e3e0708775">HMatrix&lt; spacedim, Number &gt;::solve_block_triangular_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#ac7231b00a53ef6b860d774d1daad738f">HMatrix&lt; spacedim, Number &gt;::solve_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#aeee2443c3f85cd6a961e77e5287e43f9">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a20fa0ad9c55bb5225440ccab58608cf8">HMatrix&lt; spacedim, Number &gt;::solve_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a054ad84d52a9ee6df9df3bda0a17cfb7">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_by_backward_substitution()</a>, <a class="el" href="classHMatrix.html#a41f0e0b791e50a3d9b5c0e73ee4423c6">HMatrix&lt; spacedim, Number &gt;::solve_cholesky_transpose_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a624fc153099a20572a655457d4f81b70">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution()</a>, <a class="el" href="classHMatrix.html#a469507ef4061efcc29a65c413ac7acea">HMatrix&lt; spacedim, Number &gt;::solve_transpose_by_forward_substitution_matrix_valued()</a>, <a class="el" href="classHMatrix.html#a64be687cacd167efc12b892aa154dcd3">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank()</a>, <a class="el" href="classHMatrix.html#a421beeb0b30d63f286a7905db394bdab">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank_diag_preserve_positive_definite()</a>, <a class="el" href="classHMatrix.html#a88546d9ca48a3c1a2a0874545cc4c8df">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank_off_diag_preserve_positive_definite()</a>, <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>, <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>, <a class="el" href="classHMatrix.html#a42f958a13c56d64564d59487e67bc8a2">HMatrix&lt; spacedim, Number &gt;::write_fullmatrix_leaf_node()</a>, <a class="el" href="classHMatrix.html#aaf0ae0960a40ad78a941aee823e80315">HMatrix&lt; spacedim, Number &gt;::write_leaf_set()</a>, <a class="el" href="classHMatrix.html#aac1e1ddbfeb133520dcd50c0174aab8d">HMatrix&lt; spacedim, Number &gt;::write_leaf_set_by_iteration()</a>, and <a class="el" href="classHMatrix.html#ac2c8ccd5763d3952505741c657b6468c">HMatrix&lt; spacedim, Number &gt;::write_rkmatrix_leaf_node()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/jihuan/Projects/deal.ii/program/dealii-9.1.1/examples/laplace-bem/include/<a class="el" href="hmatrix_8h_source.html">hmatrix.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
