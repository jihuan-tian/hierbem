<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>laplace-bem: HMatrix&lt; spacedim, Number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    skipTags: ["script","noscript","style","textarea","pre","code"],
    processEscapes: false,
    processEnvironments: true,
    preview: "TeX"
  },
  TeX: {
    Macros: {
      intd: "\\,{\\rm d}",
      diff: "{\\rm d}",
      Diff: "{\\rm D}",
      pdiff: "\\partial",
      DD: ["\\frac{\\diff}{\\diff #2}\\left( #1 \\right)", 2],
      Dd: ["\\frac{\\diff #1}{\\diff #2}", 2],
      PD: ["\\frac{\\pdiff}{\\pdiff #2}\\left( #1 \\right)", 2],
      Pd: ["\\frac{\\pdiff #1}{\\pdiff #2}", 2],
      rme: "{\\rm e}",
      rmi: "{\\rm i}",
      rmj: "{\\rm j}",
      vect: ["\\boldsymbol{#1}", 1],
      dform: ["\\overset{\\rightharpoonup}{\\boldsymbol{#1}}", 1],
      cochain: ["\\overset{\\rightharpoonup}{#1}", 1],
      Abs: ["\\big\\lvert#1\\big\\rvert", 1],
      abs: ["\\lvert#1\\rvert", 1],
      Norm: ["\\big\\lVert#1\\big\\rVert", 1],
      norm: ["\\lVert#1\\rVert", 1],
      normvect: "\\vect{n}",
      ouset: ["\\overset{#3}{\\underset{#2}{#1}}", 3],
      cscript: ["\\;\\; #1", 1],
      suchthat: "\\textit{S.T.\\;}",
      prefstar: "\\ast",
      restrict: "\\big\\vert",
      sgn: "{\\rm sgn}",
      erf: "{\\rm erf}",
      Bd: "{\\rm Bd}",
      Int: "{\\rm Int}",
      rank: "{\\rm rank}",
      divergence: "{\\rm div}",
      grad: "{\\rm grad}",
      tr: "{\\rm tr}",
      span: "{\\rm span}"
    },
    extensions: ["AMScd.js"],
    equationNumbers: { autoNumber: "AMS" }
  },
  "HTML-CSS": {
     availableFonts: ["STIX","TeX"],
     preferredFont: "TeX",
     webFont: "TeX",
     imageFont: "TeX",
     showMathMenu: true
  },
  MMLorHTML: {
    prefer: {
      MSIE:    "MML",
      Firefox: "MML",
      Opera:   "HTML",
      other:   "HTML"
    }
  }
});
</script><script type="text/javascript" src="http://localhost/js/MathJax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">laplace-bem
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Solve Laplace problem using the boundary element method (BEM)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classHMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HMatrix&lt; spacedim, Number &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for HMatrix&lt; spacedim, Number &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classHMatrix__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5ca8dc549783d38371a01ecd621ecb34"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> = std::make_unsigned&lt; types::blas_int &gt;::<a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">type</a></td></tr>
<tr class="separator:a5ca8dc549783d38371a01ecd621ecb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae3dc35e1aefee2580d27ad2d65c906de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae3dc35e1aefee2580d27ad2d65c906de">HMatrix</a> ()</td></tr>
<tr class="separator:ae3dc35e1aefee2580d27ad2d65c906de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4dead0321e8df38865bf6fbd0f6e81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6a4dead0321e8df38865bf6fbd0f6e81">HMatrix</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct, const unsigned int fixed_rank_k=1)</td></tr>
<tr class="separator:a6a4dead0321e8df38865bf6fbd0f6e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe44a3aa2b813f593b787f24be56a1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a4fe44a3aa2b813f593b787f24be56a1c">HMatrix</a> (typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const unsigned int fixed_rank_k=1)</td></tr>
<tr class="separator:a4fe44a3aa2b813f593b787f24be56a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7d103ec4f093870f9e792e26d6b915"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8e7d103ec4f093870f9e792e26d6b915">HMatrix</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, const unsigned int fixed_rank_k=1)</td></tr>
<tr class="separator:a8e7d103ec4f093870f9e792e26d6b915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb59b3981e9f32f319479088d786989d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#abb59b3981e9f32f319479088d786989d">HMatrix</a> (typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, const unsigned int fixed_rank_k=1)</td></tr>
<tr class="separator:abb59b3981e9f32f319479088d786989d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb8d0add9bffecafc12f4c6b1dcab8e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#abeb8d0add9bffecafc12f4c6b1dcab8e">HMatrix</a> (typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;H)</td></tr>
<tr class="separator:abeb8d0add9bffecafc12f4c6b1dcab8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78aa967d7a99e27cc172f0db3791306b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a78aa967d7a99e27cc172f0db3791306b">HMatrix</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;H)</td></tr>
<tr class="separator:a78aa967d7a99e27cc172f0db3791306b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5227e35290f6c9fba1e8948e9a29c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a0b5227e35290f6c9fba1e8948e9a29c3">HMatrix</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;H)</td></tr>
<tr class="separator:a0b5227e35290f6c9fba1e8948e9a29c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556325d4cdaee699f17aa1be63bb58ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a556325d4cdaee699f17aa1be63bb58ee">HMatrix</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;H)</td></tr>
<tr class="separator:a556325d4cdaee699f17aa1be63bb58ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f804163e1695cfb952ddb6b0df2503"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a83f804163e1695cfb952ddb6b0df2503">reinit</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct, const unsigned int fixed_rank_k=1)</td></tr>
<tr class="separator:a83f804163e1695cfb952ddb6b0df2503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d20c1839f3d7a756107b8e4defea0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a41d20c1839f3d7a756107b8e4defea0b">reinit</a> (typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const unsigned int fixed_rank_k=1)</td></tr>
<tr class="separator:a41d20c1839f3d7a756107b8e4defea0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c72ede65323af5b57a6b16f5774de50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a2c72ede65323af5b57a6b16f5774de50">operator=</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;H)</td></tr>
<tr class="separator:a2c72ede65323af5b57a6b16f5774de50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83958971f40409b3b2a192b71eae1513"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a83958971f40409b3b2a192b71eae1513">operator=</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;H)</td></tr>
<tr class="separator:a83958971f40409b3b2a192b71eae1513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bdd40f7fcf5c912c34c427df518300"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a00bdd40f7fcf5c912c34c427df518300"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a00bdd40f7fcf5c912c34c427df518300">convertToFullMatrix</a> (MatrixType &amp;M) const</td></tr>
<tr class="separator:a00bdd40f7fcf5c912c34c427df518300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812e8276888b2ad866edf7ce9b286839"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">release</a> ()</td></tr>
<tr class="separator:a812e8276888b2ad866edf7ce9b286839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55bd45587b895bfdb977e7cbea46519"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae55bd45587b895bfdb977e7cbea46519">clear</a> ()</td></tr>
<tr class="separator:ae55bd45587b895bfdb977e7cbea46519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0815bc9c3654391bb2b3095383e6cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">clear_hmat_node</a> ()</td></tr>
<tr class="separator:aec0815bc9c3654391bb2b3095383e6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16c956c1b22eb307e9f360a83f4fa75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae16c956c1b22eb307e9f360a83f4fa75">~HMatrix</a> ()</td></tr>
<tr class="separator:ae16c956c1b22eb307e9f360a83f4fa75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadea9fa59f420d22b3b1c939f6b573cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aadea9fa59f420d22b3b1c939f6b573cc">get_type</a> () const</td></tr>
<tr class="separator:aadea9fa59f420d22b3b1c939f6b573cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe735f7712a10ba5325ff116f8ca1c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aabe735f7712a10ba5325ff116f8ca1c7">get_m</a> () const</td></tr>
<tr class="separator:aabe735f7712a10ba5325ff116f8ca1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff89130116d62ea4159bc69ca11f8d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#abff89130116d62ea4159bc69ca11f8d5">get_n</a> () const</td></tr>
<tr class="separator:abff89130116d62ea4159bc69ca11f8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0189de6e276fbd3425c4a7ef132f5e16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a0189de6e276fbd3425c4a7ef132f5e16">get_rkmatrix</a> ()</td></tr>
<tr class="separator:a0189de6e276fbd3425c4a7ef132f5e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c81db6357d0e00b82fd523af001ae5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a64c81db6357d0e00b82fd523af001ae5">get_rkmatrix</a> () const</td></tr>
<tr class="separator:a64c81db6357d0e00b82fd523af001ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d914c27d4e990d476a4529b2daa64cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a9d914c27d4e990d476a4529b2daa64cd">get_fullmatrix</a> ()</td></tr>
<tr class="separator:a9d914c27d4e990d476a4529b2daa64cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed550b5b41a64c6f1bbcde4f8f7eca91"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aed550b5b41a64c6f1bbcde4f8f7eca91">get_fullmatrix</a> () const</td></tr>
<tr class="separator:aed550b5b41a64c6f1bbcde4f8f7eca91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0572b2c0484ce618db0034e3bc7988ed"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a0572b2c0484ce618db0034e3bc7988ed">get_submatrices</a> ()</td></tr>
<tr class="separator:a0572b2c0484ce618db0034e3bc7988ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8e9bc437ab86296d78950081ea34cd"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8f8e9bc437ab86296d78950081ea34cd">get_submatrices</a> () const</td></tr>
<tr class="separator:a8f8e9bc437ab86296d78950081ea34cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e849f7e8f35e3ebdfcb2dbb7ad4ad01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a7e849f7e8f35e3ebdfcb2dbb7ad4ad01">print_formatted</a> (std::ostream &amp;out, const unsigned int precision=3, const bool scientific=true, const unsigned int width=0, const char *zero_string=&quot; &quot;, const double denominator=1., const double threshold=0.) const</td></tr>
<tr class="separator:a7e849f7e8f35e3ebdfcb2dbb7ad4ad01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f87883cf49080706233441c0e09171"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ad8f87883cf49080706233441c0e09171">print_matrix_info</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ad8f87883cf49080706233441c0e09171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f958a13c56d64564d59487e67bc8a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a42f958a13c56d64564d59487e67bc8a2">write_fullmatrix_leaf_node</a> (std::ostream &amp;out, const Number singular_value_threshold=0.) const</td></tr>
<tr class="separator:a42f958a13c56d64564d59487e67bc8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c8ccd5763d3952505741c657b6468c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac2c8ccd5763d3952505741c657b6468c">write_rkmatrix_leaf_node</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ac2c8ccd5763d3952505741c657b6468c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0ae0960a40ad78a941aee823e80315"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aaf0ae0960a40ad78a941aee823e80315">write_leaf_set</a> (std::ostream &amp;out, const Number singular_value_threshold=0.) const</td></tr>
<tr class="separator:aaf0ae0960a40ad78a941aee823e80315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1e1ddbfeb133520dcd50c0174aab8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aac1e1ddbfeb133520dcd50c0174aab8d">write_leaf_set_by_iteration</a> (std::ostream &amp;out, const Number singular_value_threshold=0.) const</td></tr>
<tr class="separator:aac1e1ddbfeb133520dcd50c0174aab8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64be687cacd167efc12b892aa154dcd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a64be687cacd167efc12b892aa154dcd3">truncate_to_rank</a> (<a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> new_rank)</td></tr>
<tr class="separator:a64be687cacd167efc12b892aa154dcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11b5761aba86606effd14b4bdf31912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">vmult</a> (Vector&lt; Number &gt; &amp;y, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:aa11b5761aba86606effd14b4bdf31912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afddab534366617b6be203b3c5238a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a2afddab534366617b6be203b3c5238a6">vmult_local_vector</a> (Vector&lt; Number &gt; &amp;y, const std::map&lt; types::global_dof_index, size_t &gt; &amp;y_index_global_to_local_map, const Vector&lt; Number &gt; &amp;x, const std::map&lt; types::global_dof_index, size_t &gt; &amp;x_index_global_to_local_map) const</td></tr>
<tr class="separator:a2afddab534366617b6be203b3c5238a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e5255eb5ce46136d0e2b195c82f016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">Tvmult</a> (Vector&lt; Number &gt; &amp;y, const Vector&lt; Number &gt; &amp;x) const</td></tr>
<tr class="separator:a72e5255eb5ce46136d0e2b195c82f016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166893f3f371d4542cb57aaa33e533d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a166893f3f371d4542cb57aaa33e533d1">Tvmult_local_vector</a> (Vector&lt; Number &gt; &amp;y, const std::map&lt; types::global_dof_index, size_t &gt; &amp;y_index_global_to_local_map, const Vector&lt; Number &gt; &amp;x, const std::map&lt; types::global_dof_index, size_t &gt; &amp;x_index_global_to_local_map) const</td></tr>
<tr class="separator:a166893f3f371d4542cb57aaa33e533d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168b6eea2e5b27528497850bf5ee2bbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a168b6eea2e5b27528497850bf5ee2bbe">h_h_mmult_reduction</a> ()</td></tr>
<tr class="separator:a168b6eea2e5b27528497850bf5ee2bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c88893c6ca784d4e56653d8b0e3e67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a38c88893c6ca784d4e56653d8b0e3e67">h_h_mmult_horizontal_split</a> (<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bc_tree)</td></tr>
<tr class="separator:a38c88893c6ca784d4e56653d8b0e3e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253c23d09e89a9a37a7d808374b5ae4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a253c23d09e89a9a37a7d808374b5ae4e">h_h_mmult_vertical_split</a> (<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bc_tree)</td></tr>
<tr class="separator:a253c23d09e89a9a37a7d808374b5ae4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab315324e3ece178943f406823f792746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab315324e3ece178943f406823f792746">h_h_mmult_cross_split</a> (<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bc_tree)</td></tr>
<tr class="separator:ab315324e3ece178943f406823f792746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40d53aabc8bec86fa543638d48ba64e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af40d53aabc8bec86fa543638d48ba64e">mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct_a, const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct_b, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct_c, const unsigned int fixed_rank=1)</td></tr>
<tr class="separator:af40d53aabc8bec86fa543638d48ba64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4139e9069e3b18d4719c527ce2e0414c"><td class="memItemLeft" align="right" valign="top"><a id="a4139e9069e3b18d4719c527ce2e0414c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct_a, const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct_b, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct_c, const unsigned int fixed_rank, const bool adding)</td></tr>
<tr class="separator:a4139e9069e3b18d4719c527ce2e0414c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f96186426cd3147d5af32ca84ad25ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">add</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;C, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k) const</td></tr>
<tr class="separator:a8f96186426cd3147d5af32ca84ad25ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd48ada567962ab0dc75c31986bd1a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a9bd48ada567962ab0dc75c31986bd1a6">add</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;B, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k) const</td></tr>
<tr class="separator:a9bd48ada567962ab0dc75c31986bd1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab100d1469f662efdbf894a0345b702b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab100d1469f662efdbf894a0345b702b8">invert_by_gauss_elim</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M_inv, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M_root, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M_inv_root, const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;M_root_bct, const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;M_inv_root_bct, const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> fixed_rank_k)</td></tr>
<tr class="separator:ab100d1469f662efdbf894a0345b702b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c7390b792e6e47ab2861616a997d99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a27c7390b792e6e47ab2861616a997d99">coarsen_to_subtree</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;subtree, const unsigned int fixed_rank_k)</td></tr>
<tr class="separator:a27c7390b792e6e47ab2861616a997d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525ad4d453f4f496b98cccb341c8b60b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a525ad4d453f4f496b98cccb341c8b60b">coarsen_to_partition</a> (const std::vector&lt; typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_pointer_type &gt; &amp;partition, const unsigned int fixed_rank_k)</td></tr>
<tr class="separator:a525ad4d453f4f496b98cccb341c8b60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139f32982527ba981e0211b5663e3b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">build_leaf_set</a> ()</td></tr>
<tr class="separator:a139f32982527ba981e0211b5663e3b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c9102fc04997c1ae3627185379d9bb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac5c9102fc04997c1ae3627185379d9bb">get_leaf_set</a> ()</td></tr>
<tr class="separator:ac5c9102fc04997c1ae3627185379d9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851d7bb3632bc1d18538d4d1dd5f6393"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a851d7bb3632bc1d18538d4d1dd5f6393">get_leaf_set</a> () const</td></tr>
<tr class="separator:a851d7bb3632bc1d18538d4d1dd5f6393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f83de878e6079330ec3c374f587a04"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab0f83de878e6079330ec3c374f587a04">find_block_cluster_in_leaf_set</a> (const <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt; &amp;block_cluster)</td></tr>
<tr class="separator:ab0f83de878e6079330ec3c374f587a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723cc200afe31148fcc28f0120c5ec54"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a723cc200afe31148fcc28f0120c5ec54">find_block_cluster_in_leaf_set</a> (const <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt; &amp;block_cluster) const</td></tr>
<tr class="separator:a723cc200afe31148fcc28f0120c5ec54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b353962226c78910d6ddb6b5b8e460"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ad2b353962226c78910d6ddb6b5b8e460">refine_to_supertree</a> ()</td></tr>
<tr class="separator:ad2b353962226c78910d6ddb6b5b8e460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fd60090b0de7bdea52fc84ddeb22c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#af6fd60090b0de7bdea52fc84ddeb22c3">convert_between_different_block_cluster_trees</a> (<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct1, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct2, const unsigned int fixed_rank_k2=1)</td></tr>
<tr class="separator:af6fd60090b0de7bdea52fc84ddeb22c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e023f39b1f8916117a63557895a91b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a9e023f39b1f8916117a63557895a91b4">remove_hmat_pair_from_mm_product_list</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M2)</td></tr>
<tr class="separator:a9e023f39b1f8916117a63557895a91b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ab9b3be4ea0ef959da40e81313b2e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ae0ab9b3be4ea0ef959da40e81313b2e3">remove_hmat_pair_from_mm_product_list</a> (const std::pair&lt; const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&gt; &amp;hmat_pair)</td></tr>
<tr class="separator:ae0ab9b3be4ea0ef959da40e81313b2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f24998c7de1d0e336577be41c6281e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tree_8h.html#a922ca07db9633957939f697a65aff11d">TreeNodeSplitMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a6f24998c7de1d0e336577be41c6281e3">determine_mm_split_mode_from_Sigma_P</a> ()</td></tr>
<tr class="separator:a6f24998c7de1d0e336577be41c6281e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ab55b568236ffdd71b5378ac6c6ace50a"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:ab55b568236ffdd71b5378ac6c6ace50a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">_convertToFullMatrix</a> (MatrixType &amp;M) const</td></tr>
<tr class="separator:ab55b568236ffdd71b5378ac6c6ace50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60934e84cc3c9f6c75d011a2005f512a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a60934e84cc3c9f6c75d011a2005f512a">_build_leaf_set</a> (std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a> *&gt; &amp;total_leaf_set) const</td></tr>
<tr class="separator:a60934e84cc3c9f6c75d011a2005f512a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01360c3d9a93154f2e629b6c413aa991"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a01360c3d9a93154f2e629b6c413aa991">distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves</a> ()</td></tr>
<tr class="separator:a01360c3d9a93154f2e629b6c413aa991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963ad3e2c76ba7034b5057fef03254e1"><td class="memItemLeft" align="right" valign="top"><a id="a963ad3e2c76ba7034b5057fef03254e1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>distribute_sigma_r_and_f_to_leaves</b> ()</td></tr>
<tr class="separator:a963ad3e2c76ba7034b5057fef03254e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2229caab9b862f9c54b7f3a806125fba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a2229caab9b862f9c54b7f3a806125fba">_distribute_sigma_r_and_f_to_leaves</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;starting_hmat)</td></tr>
<tr class="separator:a2229caab9b862f9c54b7f3a806125fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a89ef60f3ba737c04708195ca0bb13620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">type</a></td></tr>
<tr class="separator:a89ef60f3ba737c04708195ca0bb13620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd1b9a32f2c7693e603a7c6ea916e4f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">submatrices</a></td></tr>
<tr class="separator:a4bd1b9a32f2c7693e603a7c6ea916e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dbd471077be0ad8325d0f2afe3d43f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">leaf_set</a></td></tr>
<tr class="separator:a61dbd471077be0ad8325d0f2afe3d43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97a8f5e42aba0f1d5faf41f35a27819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">rkmatrix</a></td></tr>
<tr class="separator:aa97a8f5e42aba0f1d5faf41f35a27819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328134c9e9cb2c4b05d5431c0ca8a533"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">fullmatrix</a></td></tr>
<tr class="separator:a328134c9e9cb2c4b05d5431c0ca8a533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a304494c970b5b267be1d8459d51586"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_pointer_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a></td></tr>
<tr class="separator:a4a304494c970b5b267be1d8459d51586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b3a936f1b40e320e96d47471da07ae"><td class="memItemLeft" align="right" valign="top">std::vector&lt; types::global_dof_index &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">row_indices</a></td></tr>
<tr class="separator:a33b3a936f1b40e320e96d47471da07ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30ae65e37ec5e4ccc7de2f6b9ea91e6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; types::global_dof_index &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">col_indices</a></td></tr>
<tr class="separator:ac30ae65e37ec5e4ccc7de2f6b9ea91e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d64145335fc0521603b206a22a67578"><td class="memItemLeft" align="right" valign="top">std::map&lt; types::global_dof_index, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">row_index_global_to_local_map</a></td></tr>
<tr class="separator:a4d64145335fc0521603b206a22a67578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab337c7b4f2f40699b9b7f3ab17a1e056"><td class="memItemLeft" align="right" valign="top">std::map&lt; types::global_dof_index, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">col_index_global_to_local_map</a></td></tr>
<tr class="separator:ab337c7b4f2f40699b9b7f3ab17a1e056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5523463043e4d542eae17d262bd22ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">m</a></td></tr>
<tr class="separator:aa5523463043e4d542eae17d262bd22ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ae2eb472f81f80653ed4411629c2d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">n</a></td></tr>
<tr class="separator:ab5ae2eb472f81f80653ed4411629c2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12da9454687e5ca15837d63e2bf0b595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a12da9454687e5ca15837d63e2bf0b595">Tind</a></td></tr>
<tr class="separator:a12da9454687e5ca15837d63e2bf0b595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d96d0252ef8c873ae06cf87874acaf3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">Sigma_P</a></td></tr>
<tr class="separator:a3d96d0252ef8c873ae06cf87874acaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d341b4e606d1be2d71b8ea636efe7b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">Sigma_R</a></td></tr>
<tr class="separator:a04d341b4e606d1be2d71b8ea636efe7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa659b6df63d533432ec1a24435cd9c40"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">Sigma_F</a></td></tr>
<tr class="separator:aa659b6df63d533432ec1a24435cd9c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa949159fde08b9c728ce2cd4c6b99de6"><td class="memTemplParams" colspan="2"><a id="aa949159fde08b9c728ce2cd4c6b99de6"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:aa949159fde08b9c728ce2cd4c6b99de6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitHMatrixWrtBlockClusterNode</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>)</td></tr>
<tr class="separator:aa949159fde08b9c728ce2cd4c6b99de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b4274a06c4ec21a0c1ee4ed870d3a3"><td class="memTemplParams" colspan="2"><a id="ab5b4274a06c4ec21a0c1ee4ed870d3a3"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ab5b4274a06c4ec21a0c1ee4ed870d3a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitHMatrixWrtBlockClusterNode</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const std::vector&lt; std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *&gt;&gt; &amp;<a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">Sigma_P</a>)</td></tr>
<tr class="separator:ab5b4274a06c4ec21a0c1ee4ed870d3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe123e0f8daa856e4b85e00829398b79"><td class="memTemplParams" colspan="2"><a id="abe123e0f8daa856e4b85e00829398b79"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:abe123e0f8daa856e4b85e00829398b79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitHMatrixWrtBlockClusterNode</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *&gt; &amp;hmat_pair)</td></tr>
<tr class="separator:abe123e0f8daa856e4b85e00829398b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9dff162efb21e08ab5d6fc3bc2219fa"><td class="memTemplParams" colspan="2"><a id="ac9dff162efb21e08ab5d6fc3bc2219fa"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ac9dff162efb21e08ab5d6fc3bc2219fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildren</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const unsigned int fixed_rank_k, bool is_build_index_set_global_to_local_map)</td></tr>
<tr class="separator:ac9dff162efb21e08ab5d6fc3bc2219fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97abbebc640c23d742408edfa3526572"><td class="memTemplParams" colspan="2"><a id="a97abbebc640c23d742408edfa3526572"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a97abbebc640c23d742408edfa3526572"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildren</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const unsigned int fixed_rank_k, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M, bool is_build_index_set_global_to_local_map)</td></tr>
<tr class="separator:a97abbebc640c23d742408edfa3526572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac490314e7c775bf5bbaef5562aad650"><td class="memTemplParams" colspan="2"><a id="aac490314e7c775bf5bbaef5562aad650"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:aac490314e7c775bf5bbaef5562aad650"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildren</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, const unsigned int fixed_rank_k, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M, const std::map&lt; types::global_dof_index, size_t &gt; &amp;row_index_global_to_local_map_for_M, const std::map&lt; types::global_dof_index, size_t &gt; &amp;col_index_global_to_local_map_for_M, bool is_build_index_set_global_to_local_map)</td></tr>
<tr class="separator:aac490314e7c775bf5bbaef5562aad650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d91a693388f0f14c515f7c97c14aed"><td class="memTemplParams" colspan="2"><a id="ab0d91a693388f0f14c515f7c97c14aed"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ab0d91a693388f0f14c515f7c97c14aed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InitAndCreateHMatrixChildren</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::node_const_pointer_type <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">bc_node</a>, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;&amp;H)</td></tr>
<tr class="separator:ab0d91a693388f0f14c515f7c97c14aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac511284701f9f527c0480608242d0619"><td class="memTemplParams" colspan="2"><a id="ac511284701f9f527c0480608242d0619"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ac511284701f9f527c0480608242d0619"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RefineHMatrixWrtExtendedBlockClusterTree</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *starting_hmat, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *current_hmat)</td></tr>
<tr class="separator:ac511284701f9f527c0480608242d0619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47825229983c7fa5755b3be8d5ac03f7"><td class="memTemplParams" colspan="2"><a id="a47825229983c7fa5755b3be8d5ac03f7"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a47825229983c7fa5755b3be8d5ac03f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertHMatBlockToRkMatrix</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat_block, const unsigned int fixed_rank_k, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *hmat_root_block, size_t *calling_counter, const std::string &amp;output_file_base_name)</td></tr>
<tr class="separator:a47825229983c7fa5755b3be8d5ac03f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7e9489e842016dd9815a0490c7667d"><td class="memItemLeft" align="right" valign="top"><a id="aaa7e9489e842016dd9815a0490c7667d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>build_index_set_global_to_local_map</b> (const std::vector&lt; types::global_dof_index &gt; &amp;index_set_as_local_to_global_map, std::map&lt; types::global_dof_index, size_t &gt; &amp;global_to_local_map)</td></tr>
<tr class="separator:aaa7e9489e842016dd9815a0490c7667d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5b4592067610eec18b830482897243"><td class="memTemplParams" colspan="2"><a id="a1b5b4592067610eec18b830482897243"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a1b5b4592067610eec18b830482897243"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_rk_mmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a1b5b4592067610eec18b830482897243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614ba3b92b97d95cb3146db181611a34"><td class="memTemplParams" colspan="2"><a id="a614ba3b92b97d95cb3146db181611a34"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a614ba3b92b97d95cb3146db181611a34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_rk_mmult_for_h_h_mmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M, bool is_M1M2_last_in_M_Sigma_P)</td></tr>
<tr class="separator:a614ba3b92b97d95cb3146db181611a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa94f9688a9443024a2631d2bfae06c8"><td class="memTemplParams" colspan="2"><a id="afa94f9688a9443024a2631d2bfae06c8"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:afa94f9688a9443024a2631d2bfae06c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rk_h_mmult</b> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:afa94f9688a9443024a2631d2bfae06c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b12cf1aa7504c436b84394f2116f6a9"><td class="memTemplParams" colspan="2"><a id="a9b12cf1aa7504c436b84394f2116f6a9"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a9b12cf1aa7504c436b84394f2116f6a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rk_h_mmult_for_h_h_mmult</b> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M, bool is_M1M2_last_in_M_Sigma_P)</td></tr>
<tr class="separator:a9b12cf1aa7504c436b84394f2116f6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ccef980f81f9fb3c63675f3f9c014f"><td class="memTemplParams" colspan="2"><a id="a85ccef980f81f9fb3c63675f3f9c014f"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a85ccef980f81f9fb3c63675f3f9c014f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a85ccef980f81f9fb3c63675f3f9c014f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3866052a5345742ad9f44f11f33989"><td class="memTemplParams" colspan="2"><a id="aea3866052a5345742ad9f44f11f33989"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:aea3866052a5345742ad9f44f11f33989"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:aea3866052a5345742ad9f44f11f33989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897365f6716975f71b528f610498c69b"><td class="memTemplParams" colspan="2"><a id="a897365f6716975f71b528f610498c69b"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a897365f6716975f71b528f610498c69b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_f_mmult_for_h_h_mmult</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M, bool is_M1M2_last_in_M_Sigma_P)</td></tr>
<tr class="separator:a897365f6716975f71b528f610498c69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b0f45b3a6734fef74d90f28fcefbc1"><td class="memTemplParams" colspan="2"><a id="a67b0f45b3a6734fef74d90f28fcefbc1"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a67b0f45b3a6734fef74d90f28fcefbc1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mmult</b> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a67b0f45b3a6734fef74d90f28fcefbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d1ce72cb294b2c4da6536250905a32"><td class="memTemplParams" colspan="2"><a id="a66d1ce72cb294b2c4da6536250905a32"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a66d1ce72cb294b2c4da6536250905a32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mmult</b> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a66d1ce72cb294b2c4da6536250905a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311938523b49a053a8cf16bc96576cdf"><td class="memTemplParams" colspan="2"><a id="a311938523b49a053a8cf16bc96576cdf"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a311938523b49a053a8cf16bc96576cdf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mmult_for_h_h_mmult</b> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M, bool is_M1M2_last_in_M_Sigma_P)</td></tr>
<tr class="separator:a311938523b49a053a8cf16bc96576cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad755e8e3b11e19f553e77bae172ce849"><td class="memTemplParams" colspan="2"><a id="ad755e8e3b11e19f553e77bae172ce849"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ad755e8e3b11e19f553e77bae172ce849"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mmult_phase1_recursion</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; *M, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt; &amp;<a class="el" href="classHMatrix.html#a12da9454687e5ca15837d63e2bf0b595">Tind</a>)</td></tr>
<tr class="separator:ad755e8e3b11e19f553e77bae172ce849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58016ed0bee33836c69eb23970c24df"><td class="memTemplParams" colspan="2"><a id="ac58016ed0bee33836c69eb23970c24df"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:ac58016ed0bee33836c69eb23970c24df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>h_h_mmult_phase2</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt; &amp;target_bc_tree, const unsigned int fixed_rank)</td></tr>
<tr class="separator:ac58016ed0bee33836c69eb23970c24df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec67bee413b9db0bedfe58ddc0d91c1"><td class="memTemplParams" colspan="2"><a id="a4ec67bee413b9db0bedfe58ddc0d91c1"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a4ec67bee413b9db0bedfe58ddc0d91c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_hmatrix_node</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat_dst, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat_src)</td></tr>
<tr class="separator:a4ec67bee413b9db0bedfe58ddc0d91c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e52ecf1ea024322e4318243e922a1c"><td class="memTemplParams" colspan="2"><a id="a10e52ecf1ea024322e4318243e922a1c"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a10e52ecf1ea024322e4318243e922a1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_hmatrix_node</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat_dst, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;&amp;hmat_src)</td></tr>
<tr class="separator:a10e52ecf1ea024322e4318243e922a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ce56e1013c5060804023841e3ac93b"><td class="memTemplParams" colspan="2"><a id="a29ce56e1013c5060804023841e3ac93b"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a29ce56e1013c5060804023841e3ac93b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_hmatrix</b> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat_dst, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;hmat_src)</td></tr>
<tr class="separator:a29ce56e1013c5060804023841e3ac93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eefa50a413f628f9b74c4b7ca7fd118"><td class="memTemplParams" colspan="2"><a id="a9eefa50a413f628f9b74c4b7ca7fd118"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a9eefa50a413f628f9b74c4b7ca7fd118"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>print_h_submatrix_accessor</b> (std::ostream &amp;out, const std::string &amp;name, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M)</td></tr>
<tr class="separator:a9eefa50a413f628f9b74c4b7ca7fd118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee7e6e1599718531085769438a918a7"><td class="memTemplParams" colspan="2"><a id="adee7e6e1599718531085769438a918a7"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:adee7e6e1599718531085769438a918a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>print_h_h_submatrix_mmult_accessor</b> (std::ostream &amp;out, const std::string &amp;name1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M1, const std::string &amp;name2, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim1, Number1 &gt; &amp;M2)</td></tr>
<tr class="separator:adee7e6e1599718531085769438a918a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5ca8dc549783d38371a01ecd621ecb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca8dc549783d38371a01ecd621ecb34">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> =  std::make_unsigned&lt;types::blas_int&gt;::<a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the type for container size. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae3dc35e1aefee2580d27ad2d65c906de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3dc35e1aefee2580d27ad2d65c906de">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. </p>

</div>
</div>
<a id="a6a4dead0321e8df38865bf6fbd0f6e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4dead0321e8df38865bf6fbd0f6e81">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct the hierarchical structure without data from the root node of a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>. </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, and <a class="el" href="classBlockClusterTree.html#a4a4f3b893380d1d7f53b772589a847d2">BlockClusterTree&lt; spacedim, Number &gt;::get_root()</a>.</p>

</div>
</div>
<a id="a4fe44a3aa2b813f593b787f24be56a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe44a3aa2b813f593b787f24be56a1c">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct the hierarchical structure without data from a <a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>. </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>.</p>

</div>
</div>
<a id="a8e7d103ec4f093870f9e792e26d6b915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7d103ec4f093870f9e792e26d6b915">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from the root node of a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a> while copying the data of a global full matrix, which is created on the complete block cluster \(I \times J\). </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, and <a class="el" href="classBlockClusterTree.html#a4a4f3b893380d1d7f53b772589a847d2">BlockClusterTree&lt; spacedim, Number &gt;::get_root()</a>.</p>

</div>
</div>
<a id="abb59b3981e9f32f319479088d786989d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb59b3981e9f32f319479088d786989d">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from a <a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a> while copying the data of a global full matrix, which is created on the complete block cluster \(I \times J\). </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>.</p>

</div>
</div>
<a id="abeb8d0add9bffecafc12f4c6b1dcab8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb8d0add9bffecafc12f4c6b1dcab8e">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from a <code><a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a></code> in a <code><a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a></code> while moving the data from the leaf set of the \(\mathcal{H}\)-matrix <code>H</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bc_node</td><td></td></tr>
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>.</p>

</div>
</div>
<a id="a78aa967d7a99e27cc172f0db3791306b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78aa967d7a99e27cc172f0db3791306b">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from the root node of a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a> while moving the data from the leaf set of the \(\mathcal{H}\)-matrix <code>H</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bct</td><td></td></tr>
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, and <a class="el" href="classBlockClusterTree.html#a4a4f3b893380d1d7f53b772589a847d2">BlockClusterTree&lt; spacedim, Number &gt;::get_root()</a>.</p>

</div>
</div>
<a id="a0b5227e35290f6c9fba1e8948e9a29c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5227e35290f6c9fba1e8948e9a29c3">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deep copy constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>.</p>

</div>
</div>
<a id="a556325d4cdaee699f17aa1be63bb58ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556325d4cdaee699f17aa1be63bb58ee">&#9670;&nbsp;</a></span>HMatrix() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shallow copy constructor.</p>
<p>After the copy operation, the data in the source matrix <code>H</code> are transferred to the current \(\mathcal{H}\)-matrix node and <code>H</code> is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae16c956c1b22eb307e9f360a83f4fa75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16c956c1b22eb307e9f360a83f4fa75">&#9670;&nbsp;</a></span>~HMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::~<a class="el" href="classHMatrix.html">HMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor which releases the memory by recursion. </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a60934e84cc3c9f6c75d011a2005f512a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60934e84cc3c9f6c75d011a2005f512a">&#9670;&nbsp;</a></span>_build_leaf_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_build_leaf_set </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>total_leaf_set</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collect \(\mathcal{H}\)-matrix nodes in the leaf set into a vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_leaf_set</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>.</p>

</div>
</div>
<a id="ab55b568236ffdd71b5378ac6c6ace50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55b568236ffdd71b5378ac6c6ace50a">&#9670;&nbsp;</a></span>_convertToFullMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_convertToFullMatrix </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert an <a class="el" href="classHMatrix.html">HMatrix</a> to a full matrix by recursion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a00bdd40f7fcf5c912c34c427df518300">HMatrix&lt; spacedim, Number &gt;::convertToFullMatrix()</a>.</p>

</div>
</div>
<a id="a2229caab9b862f9c54b7f3a806125fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2229caab9b862f9c54b7f3a806125fba">&#9670;&nbsp;</a></span>_distribute_sigma_r_and_f_to_leaves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_hmat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Restrict each rank-k matrix in the list <code>Sigma_R</code> of <code>starting_hmat</code> to the block as a full matrix.</p>
<p>Restrict each full matrix in the list <code>Sigma_F</code> of <code>starting_hmat</code> to the block as a full matrix.</p>
<p>Restrict each rank-k matrix in the list <code>Sigma_R</code> of <code>starting_hmat</code> to the block as a rank-k matrix.</p>
<p>Restrict each full matrix in the list <code>Sigma_F</code> of <code>starting_hmat</code> to the block as a rank-k matrix.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classRkMatrix.html#a5305306386e47bcded819ce8d7f7935c">RkMatrix&lt; Number &gt;::restrictToFullMatrix()</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a01360c3d9a93154f2e629b6c413aa991">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>.</p>

</div>
</div>
<a id="a8f96186426cd3147d5af32ca84ad25ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f96186426cd3147d5af32ca84ad25ea">&#9670;&nbsp;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the current <a class="el" href="classHMatrix.html">HMatrix</a> <code>A</code> with another <a class="el" href="classHMatrix.html">HMatrix</a> <code>B</code> into <code>C</code>, i.e. whole matrix addition instead of addition limited to a specific block, where <code>C</code> will be truncated to a fixed rank <code>fixed_rank</code>.</p>
<p>This algorithm is intrinsically recursive, i.e. the addition of parent HMatrices will perform the addition of each pair of child HMatrices corresponding to a same block cluster. Strictly speaking, this member function <code>add</code> is not a recursive function, because the class instance which calls <code>add</code> changes from parent to child <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p>N.B.</p>
<ol type="1">
<li>The two operands should have the same partition.</li>
<li>The hierarchical structure of <code>C</code> should be pre-generated.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p><b>Work flow</b></p>
<p>Recursively add each pair of submatrices.</p>
<p>Perform addition of full matrices.</p>
<p>Perform addition of rank-k matrices.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-add-formatted_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="classHMatrix.html#af40d53aabc8bec86fa543638d48ba64e">HMatrix&lt; spacedim, Number &gt;::mmult()</a>.</p>

</div>
</div>
<a id="a9bd48ada567962ab0dc75c31986bd1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd48ada567962ab0dc75c31986bd1a6">&#9670;&nbsp;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the <a class="el" href="classHMatrix.html">HMatrix</a> <code>B</code> into the current <a class="el" href="classHMatrix.html">HMatrix</a> <code>A</code>, i.e. whole matrix addition instead of addition limited to a specific block, where <code>C</code> will be truncated to a fixed rank <code>fixed_rank</code>.</p>
<p>This algorithm is intrinsically recursive, i.e. the addition of parent HMatrices will perform the addition of each pair of child HMatrices corresponding to a same block cluster. Strictly speaking, this member function <code>add</code> is not a recursive function, because the class instance which calls <code>add</code> changes from parent to child <a class="el" href="classHMatrix.html">HMatrix</a>.</p>
<p>N.B. The two operands should have the same partition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p><b>Work flow</b></p>
<p>Recursively add each pair of submatrices.</p>
<p>Perform addition of full matrices.</p>
<p>Perform addition of rank-k matrices.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="a139f32982527ba981e0211b5663e3b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139f32982527ba981e0211b5663e3b43">&#9670;&nbsp;</a></span>build_leaf_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::build_leaf_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build the leaf set of the current \(\mathcal{H}\)-matrix node. </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a60934e84cc3c9f6c75d011a2005f512a">HMatrix&lt; spacedim, Number &gt;::_build_leaf_set()</a>, and <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a27c7390b792e6e47ab2861616a997d99">HMatrix&lt; spacedim, Number &gt;::coarsen_to_subtree()</a>, <a class="el" href="classHMatrix.html#af6fd60090b0de7bdea52fc84ddeb22c3">HMatrix&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees()</a>, <a class="el" href="classHMatrix.html#a6a4dead0321e8df38865bf6fbd0f6e81">HMatrix&lt; spacedim, Number &gt;::HMatrix()</a>, <a class="el" href="classHMatrix.html#af40d53aabc8bec86fa543638d48ba64e">HMatrix&lt; spacedim, Number &gt;::mmult()</a>, <a class="el" href="classHMatrix.html#a83958971f40409b3b2a192b71eae1513">HMatrix&lt; spacedim, Number &gt;::operator=()</a>, <a class="el" href="classHMatrix.html#ad2b353962226c78910d6ddb6b5b8e460">HMatrix&lt; spacedim, Number &gt;::refine_to_supertree()</a>, and <a class="el" href="classHMatrix.html#a83f804163e1695cfb952ddb6b0df2503">HMatrix&lt; spacedim, Number &gt;::reinit()</a>.</p>

</div>
</div>
<a id="ae55bd45587b895bfdb977e7cbea46519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55bd45587b895bfdb977e7cbea46519">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the whole \(\mathcal{H}\)-matrix hierarchy. </p>
<p>Recursively clear submatrices.</p>
<p>Clear the current matrix node.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="aec0815bc9c3654391bb2b3095383e6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0815bc9c3654391bb2b3095383e6cb">&#9670;&nbsp;</a></span>clear_hmat_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::clear_hmat_node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the current \(\mathcal{H}\)-matrix node. </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a12da9454687e5ca15837d63e2bf0b595">HMatrix&lt; spacedim, Number &gt;::Tind</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ae55bd45587b895bfdb977e7cbea46519">HMatrix&lt; spacedim, Number &gt;::clear()</a>.</p>

</div>
</div>
<a id="a525ad4d453f4f496b98cccb341c8b60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525ad4d453f4f496b98cccb341c8b60b">&#9670;&nbsp;</a></span>coarsen_to_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::coarsen_to_partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_pointer_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Coarsen the current \(\mathcal{H}\)-matrix via recursive call so that its leaf set complies with the given partition. Each rank-k matrix in the \(\mathcal{H}\)-matrix structure will be truncated to <code>fixed_rank_k</code>.</p>
<p>Since this is a recursive member function, it does not execute leaf set rebuilding, which is an operation on the overall \(\mathcal{H}\)-matrix hierarchy.</p>
<p>This member function implements the operator \(\mathcal{T}_{P&#39; \leftarrow P}^{\mathcal{H} \leftarrow \mathcal{H}}\) for the case \(T(I \times J, P&#39;) \subset T(I \times J, P)\) in (7.9) in Hackbusch's \(\mathcal{H}\)-matrix book. Because there is no internal check about this, users should ensure this set inclusion relationship.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>N.B. The function call <code>find_pointer_data</code> here involves the comparison of two block cluster nodes, which internally compares the contained two block clusters, which further compares the contained tau node and sigma node pointers. Therefore, at the moment, the inner most comparison is shallow comparison.</p>
<p>The block cluster node associated with the current \(\mathcal{H}\)-matrix node belongs to the given <code>partition</code>. Then \(\mathcal{T}_r^{\mathcal{R} \leftarrow \mathcal{H}}\) will be applied to this \(\mathcal{H}\)-matrix node.</p>
<p>When the block cluster node associated with the current \(\mathcal{H}\)-matrix node does not belong to the <code>partition</code>, recursively call this same member function of its each child.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="generic__functors_8h.html#ad741e5fc6f9f2d7acafe6e5530b1f52e">find_pointer_data()</a>, and <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a27c7390b792e6e47ab2861616a997d99">HMatrix&lt; spacedim, Number &gt;::coarsen_to_subtree()</a>, and <a class="el" href="classHMatrix.html#af6fd60090b0de7bdea52fc84ddeb22c3">HMatrix&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees()</a>.</p>

</div>
</div>
<a id="a27c7390b792e6e47ab2861616a997d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c7390b792e6e47ab2861616a997d99">&#9670;&nbsp;</a></span>coarsen_to_subtree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::coarsen_to_subtree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>subtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Coarsen the current \(\mathcal{H}\)-matrix so that it corresponds to the partition determined by the <code>subtree</code>. Each rank-k matrix in the hierarchical matrix structure will be truncated to <code>fixed_rank_k</code>.</p>
<p>This function calls <code><a class="el" href="classHMatrix.html#a525ad4d453f4f496b98cccb341c8b60b">HMatrix&lt;spacedim, Number&gt;::coarsen_to_partition</a></code> internally. After that, the leaf set is rebuilt.</p>
<p>This member function implements the operator \(\mathcal{T}_{P&#39; \leftarrow P}^{\mathcal{H} \leftarrow \mathcal{H}}\) for the case \(T(I \times J, P&#39;) \subset T(I \times J, P)\) in (7.9) in Hackbusch's \(\mathcal{H}\)-matrix book. Because there is no internal check about this, users should ensure that the given <code>subtree</code> is really a subtree of the block cluster tree associated with this \(\mathcal{H}\)-matrix hierarchy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subtree</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="classHMatrix.html#a525ad4d453f4f496b98cccb341c8b60b">HMatrix&lt; spacedim, Number &gt;::coarsen_to_partition()</a>, and <a class="el" href="classBlockClusterTree.html#a162b396d814b420f96289425529852e9">BlockClusterTree&lt; spacedim, Number &gt;::get_leaf_set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-coarsening_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="af6fd60090b0de7bdea52fc84ddeb22c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6fd60090b0de7bdea52fc84ddeb22c3">&#9670;&nbsp;</a></span>convert_between_different_block_cluster_trees()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k2</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an \(\mathcal{H}\)-matrix between two different block cluster trees \(T\) and \(T&#39;\), where \(T := T(I \times J, P)\) and \(T&#39; := T&#39;(I \times J, P&#39;)\). The two trees have incompatible partitions and do not contain each other. However, they are constructed on the same cluster trees \(T(I)\) and \(T(J)\). This enables us to make a <b>shallow</b> comparison of two block cluster nodes based on the pointer addresses related to the comprising clusters, which is useful for verify the equality of two block cluster nodes.</p>
<p>The procedures of this algorithm are as below. Assume the current \(\mathcal{H}\)-matrix to be converted is associated with the block cluster tree \(T\).</p>
<ol type="1">
<li>Extend \(T\) to be finer than \(T&#39;\), from which we get the new block cluster tree \(T&#39;&#39;\).</li>
<li>Refine the original \(\mathcal{H}\)-matrix with respect to the extended tree \(T&#39;&#39;\).</li>
<li>Get and keep a record of the leaf set of the block cluster tree \(T&#39;\), which will be used for matrix coarsening in the last step.</li>
<li>Extend \(T&#39;\) to the finer block cluster tree \(T&#39;&#39;\), from which we get \(\tilde{T}&#39;\).</li>
<li>Build a new \(\mathcal{H}\)-matrix with respect to \(\tilde{T}&#39;\) with the actual data migrated from the leaf nodes of the original \(\mathcal{H}\)-matrix.</li>
<li>Coarsen the new \(\mathcal{H}\)-matrix to the original partition of \(T&#39;\).</li>
<li>Delete the hierarchy of the original \(\mathcal{H}\)-matrix.</li>
<li>Assign the new \(\mathcal{H}\)-matrix object to the original \(\mathcal{H}\)-matrix object.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bct1</td><td>The block cluster tree which is associated with the current \(\mathcal{H}\)-matrix. </td></tr>
    <tr><td class="paramname">bct2</td><td>The block cluster tree to which the current \(\mathcal{H}\)-matrix is to be converted. </td></tr>
  </table>
  </dd>
</dl>
<p>Make a copy of the leaf set of the target block cluster tree, which will be used for the final coarsening.</p>
<p>Extend the block cluster tree associated with the current \(\mathcal{H}\)-matrix to the coarsest tree which is finer than the target block cluster tree. If the block cluster tree has really been extended, refine the \(\mathcal{H}\)-matrix to its extended block cluster tree.</p>
<p>Extend <code>bct2</code> to the finer partition obtained from <code>bct1</code> as above. N.B. Now the leaf set of <code>bct1</code> after refinement is the same as that of <code>bct2</code> after this extension.</p>
<p>Create a new \(\mathcal{H}\)-matrix with respect to the extended <code>bct2</code>, which accepts the data migrated from the leaf set of the current \(\mathcal{H}\)-matrix.</p>
<dl class="section note">
<dt>Note </dt>
<dd><ul>
<li>
This hierarchical structure of the new \(\mathcal{H}\)-matrix is built with respect to the extended block cluster tree <code>bct2</code>. </li>
<li>
The shallow copy constructor cannot be used here because the new \(\mathcal{H}\)-matrix has a different block cluster tree structure from the current \(\mathcal{H}\)-matrix, even though they have the same partition after tree extension. </li>
</ul>
</dd>
</dl>
<p>Coarsen the new \(\mathcal{H}\)-matrix to the original leaf set of <code>bct2</code>. Then rebuild its leaf set.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The structure of the block cluster tree associated with the \(\mathcal{H}\)-matrix is still same as before, which has more levels than the \(\mathcal{H}\)-matrix. Therefore, we should prune the block cluster tree to make it consistent with the \(\mathcal{H}\)-matrix. </dd>
</dl>
<p>Move the new \(\mathcal{H}\)-matrix to the current \(\mathcal{H}\)-matrix by shallow assignment.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="classHMatrix.html#a525ad4d453f4f496b98cccb341c8b60b">HMatrix&lt; spacedim, Number &gt;::coarsen_to_partition()</a>, <a class="el" href="classBlockClusterTree.html#a3c4a4da89b964559cc02ecbf13ad4a4b">BlockClusterTree&lt; spacedim, Number &gt;::extend_finer_than_partition()</a>, <a class="el" href="classBlockClusterTree.html#adfe18d32a3c05a9209a5cdc9270b47d7">BlockClusterTree&lt; spacedim, Number &gt;::extend_to_finer_partition()</a>, <a class="el" href="classBlockClusterTree.html#a162b396d814b420f96289425529852e9">BlockClusterTree&lt; spacedim, Number &gt;::get_leaf_set()</a>, <a class="el" href="classBlockClusterTree.html#af1663a109b6fd5c67c85e9bb88a54a13">BlockClusterTree&lt; spacedim, Number &gt;::prune_to_partition()</a>, and <a class="el" href="classHMatrix.html#ad2b353962226c78910d6ddb6b5b8e460">HMatrix&lt; spacedim, Number &gt;::refine_to_supertree()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, and <a class="el" href="hmatrix-fine-ntp-to-tp_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a00bdd40f7fcf5c912c34c427df518300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00bdd40f7fcf5c912c34c427df518300">&#9670;&nbsp;</a></span>convertToFullMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::convertToFullMatrix </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an <a class="el" href="classHMatrix.html">HMatrix</a> to a full matrix by calling the internal recursive function.</p>
<dl class="section note">
<dt>Note </dt>
<dd>This function only has the verification purpose. In reality, a large dense matrix cannot be saved as a full matrix. </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, and <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-add-formatted_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a6f24998c7de1d0e336577be41c6281e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f24998c7de1d0e336577be41c6281e3">&#9670;&nbsp;</a></span>determine_mm_split_mode_from_Sigma_P()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tree_8h.html#a922ca07db9633957939f697a65aff11d">TreeNodeSplitMode</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::determine_mm_split_mode_from_Sigma_P </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check the consistency of the tree node split modes which are associated with the \(\mathcal{H}\)-matrix node pairs stored in the list \(\Sigma_P\) of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#aad08ee9bd389abe7b7b76fd0f2cb292e">h_h_mmult_phase1_recursion()</a>.</p>

</div>
</div>
<a id="a01360c3d9a93154f2e629b6c413aa991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01360c3d9a93154f2e629b6c413aa991">&#9670;&nbsp;</a></span>distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Only non-leaf \(\mathcal{H}\)-matrix nodes need to be processed.</p>
<p>Since the current \(\mathcal{H}\)-matrix node has children, its type should be <code>HierarchicalMatrixType</code>.</p>
<p>Distribute matrices in \(\Sigma_b^R\) and \(\Sigma_b^F\) of the current \(\mathcal{H}\)-matrix node to its leaves, which is also a recursive function call.</p>
<p>Distribute matrices in \(\Sigma_b^R\) and \(\Sigma_b^F\) of each child matrix of the current \(\mathcal{H}\)-matrix node to its leaves</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a2229caab9b862f9c54b7f3a806125fba">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>.</p>

</div>
</div>
<a id="ab0f83de878e6079330ec3c374f587a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f83de878e6079330ec3c374f587a04">&#9670;&nbsp;</a></span>find_block_cluster_in_leaf_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;::iterator <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::find_block_cluster_in_leaf_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a block cluster in the leaf set of the current \(\mathcal{H}\)-matrix and returns the iterator of the corresponding \(\mathcal{H}\)-matrix node in the leaf set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_cluster</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>Perform a shallow comparison, i.e. compare by pointer address, of the block clusters.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The data held by those previously found leaf nodes of the source \(\mathcal{H}\)-matrix have already been migrated to the leaf nodes of the new \(\mathcal{H}\)-matrix, which will make the data fields in these leaf nodes being empty. Hence, we will bypass them. </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ab100d1469f662efdbf894a0345b702b8">HMatrix&lt; spacedim, Number &gt;::invert_by_gauss_elim()</a>.</p>

</div>
</div>
<a id="a723cc200afe31148fcc28f0120c5ec54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723cc200afe31148fcc28f0120c5ec54">&#9670;&nbsp;</a></span>find_block_cluster_in_leaf_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt;::const_iterator <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::find_block_cluster_in_leaf_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_cluster</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a block cluster in the leaf set of the current \(\mathcal{H}\)-matrix and returns the iterator of the corresponding \(\mathcal{H}\)-matrix node in the leaf set (const version).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_cluster</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>Perform a shallow comparison, i.e. compare by pointer address, of the block clusters.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The data held by those previously found leaf nodes of the source \(\mathcal{H}\)-matrix have already been migrated to the leaf nodes of the new \(\mathcal{H}\)-matrix, which will make the data fields in these leaf nodes being empty. Hence, we will bypass them. </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>.</p>

</div>
</div>
<a id="a9d914c27d4e990d476a4529b2daa64cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d914c27d4e990d476a4529b2daa64cd">&#9670;&nbsp;</a></span>get_fullmatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_fullmatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the pointer to the full matrix of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-rkmatrix-conversion_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="aed550b5b41a64c6f1bbcde4f8f7eca91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed550b5b41a64c6f1bbcde4f8f7eca91">&#9670;&nbsp;</a></span>get_fullmatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_fullmatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the pointer to the full matrix of the current \(\mathcal{H}\)-matrix node (const version). </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>.</p>

</div>
</div>
<a id="ac5c9102fc04997c1ae3627185379d9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c9102fc04997c1ae3627185379d9bb">&#9670;&nbsp;</a></span>get_leaf_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_leaf_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the leaf set of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ab100d1469f662efdbf894a0345b702b8">HMatrix&lt; spacedim, Number &gt;::invert_by_gauss_elim()</a>.</p>

</div>
</div>
<a id="a851d7bb3632bc1d18538d4d1dd5f6393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851d7bb3632bc1d18538d4d1dd5f6393">&#9670;&nbsp;</a></span>get_leaf_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_leaf_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the leaf set of the current \(\mathcal{H}\)-matrix node (const version). </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>.</p>

</div>
</div>
<a id="aabe735f7712a10ba5325ff116f8ca1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe735f7712a10ba5325ff116f8ca1c7">&#9670;&nbsp;</a></span>get_m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of rows of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>.</p>

</div>
</div>
<a id="abff89130116d62ea4159bc69ca11f8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff89130116d62ea4159bc69ca11f8d5">&#9670;&nbsp;</a></span>get_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::<a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of columns of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>.</p>

</div>
</div>
<a id="a0189de6e276fbd3425c4a7ef132f5e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0189de6e276fbd3425c4a7ef132f5e16">&#9670;&nbsp;</a></span>get_rkmatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_rkmatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the pointer to the rank-k matrix of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-rkmatrix-conversion_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a64c81db6357d0e00b82fd523af001ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c81db6357d0e00b82fd523af001ae5">&#9670;&nbsp;</a></span>get_rkmatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; * <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_rkmatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the pointer to the rank-k matrix of the current \(\mathcal{H}\)-matrix node (const version). </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>.</p>

</div>
</div>
<a id="a0572b2c0484ce618db0034e3bc7988ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0572b2c0484ce618db0034e3bc7988ed">&#9670;&nbsp;</a></span>get_submatrices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_submatrices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the vector of submatrices of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>.</p>

</div>
</div>
<a id="a8f8e9bc437ab86296d78950081ea34cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8e9bc437ab86296d78950081ea34cd">&#9670;&nbsp;</a></span>get_submatrices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; * &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_submatrices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the vector of submatrices of the current \(\mathcal{H}\)-matrix node (const version). </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>.</p>

</div>
</div>
<a id="aadea9fa59f420d22b3b1c939f6b573cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadea9fa59f420d22b3b1c939f6b573cc">&#9670;&nbsp;</a></span>get_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the matrix type of the current \(\mathcal{H}\)-matrix node. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-rkmatrix-conversion_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="ab315324e3ece178943f406823f792746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab315324e3ece178943f406823f792746">&#9670;&nbsp;</a></span>h_h_mmult_cross_split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::h_h_mmult_cross_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc_tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements <code>MM_C</code> in Hackbusch's \(\mathcal{H}\)-matrix book. </p>
<p>Split the block cluster \(b\) in \(T_{\rm ind}\).</p>
<p>Append the initialized child to the list of submatrices of <code>M</code>.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Append the initialized child to the list of submatrices of <code>M</code>.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Iterate over each multiplication subtask.</p>
<p>Create \(\mathcal{H}\)-matrices corresponding to the child block clusters after splitting.</p>
<p>\(\Sigma_{b_s(1)}^P := \Sigma_{b_s(1)}^P \cup \{[\tilde{M}_1(1), \tilde{M}_2(1)], [\tilde{M}_1(2), \tilde{M}_2(3)]\}\)</p>
<p>\(\Sigma_{b_s(2)}^P := \Sigma_{b_s(2)}^P \cup \{[\tilde{M}_1(1), \tilde{M}_2(2)], [\tilde{M}_1(2), \tilde{M}_2(4)]\}\)</p>
<p>\(\Sigma_{b_s(3)}^P := \Sigma_{b_s(3)}^P \cup \{[\tilde{M}_1(3), \tilde{M}_2(1)], [\tilde{M}_1(4), \tilde{M}_2(3)]\}\)</p>
<p>\(\Sigma_{b_s(4)}^P := \Sigma_{b_s(4)}^P \cup \{[\tilde{M}_1(3), \tilde{M}_2(2)], [\tilde{M}_1(4), \tilde{M}_2(4)]\}\)</p>
<p>Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p>Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p>Update the matrix type of the current \(\mathcal{H}\)-matrix.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, and <a class="el" href="block__cluster__tree_8h.html#a16ad2c7c8e746258ce244315d6181c72">split_block_cluster_node()</a>.</p>

</div>
</div>
<a id="a38c88893c6ca784d4e56653d8b0e3e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c88893c6ca784d4e56653d8b0e3e67">&#9670;&nbsp;</a></span>h_h_mmult_horizontal_split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::h_h_mmult_horizontal_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc_tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements <code>MM_H</code> in Hackbusch's \(\mathcal{H}\)-matrix book. </p>
<p>Split the block cluster \(b\) in \(T_{\rm ind}\).</p>
<p>Append the initialized child to the list of submatrices of <code>M</code>.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Iterate over each multiplication subtask.</p>
<p>Create \(\mathcal{H}\)-matrices corresponding to the child block clusters after splitting.</p>
<p>Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p>Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p>Update the matrix type of the current \(\mathcal{H}\)-matrix.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, and <a class="el" href="block__cluster__tree_8h.html#a16ad2c7c8e746258ce244315d6181c72">split_block_cluster_node()</a>.</p>

</div>
</div>
<a id="a168b6eea2e5b27528497850bf5ee2bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168b6eea2e5b27528497850bf5ee2bbe">&#9670;&nbsp;</a></span>h_h_mmult_reduction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::h_h_mmult_reduction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform \(\mathcal{H}\)-matrix MM multiplication reduction. This is (7.21) in Hackbusch's \(\mathcal{H}\)-matrix book. </p>
<p>When one of the operands is either full matrix or rank-k matrix, perform direct multiplication.</p>
<p>Migrate the current H-matrix node pair to the list <code>Sigma_P_cannot_reduced</code>.</p>
<p>Remove the current H-matrix node pair from the original list in <code>M</code>.</p>
<p>Merge the elements in <code>Sigma_P_cannot_reduced</code> back to <code>Sigma_P</code> in <code>M</code> for further processing.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#aad08ee9bd389abe7b7b76fd0f2cb292e">h_h_mmult_phase1_recursion()</a>.</p>

</div>
</div>
<a id="a253c23d09e89a9a37a7d808374b5ae4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253c23d09e89a9a37a7d808374b5ae4e">&#9670;&nbsp;</a></span>h_h_mmult_vertical_split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::h_h_mmult_vertical_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc_tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements <code>MM_V</code> in Hackbusch's \(\mathcal{H}\)-matrix book. </p>
<p>Split the block cluster \(b\) in \(T_{\rm ind}\).</p>
<p>Append the initialized child to the list of submatrices of <code>M</code>.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Iterate over each multiplication subtask.</p>
<p>Create \(\mathcal{H}\)-matrices corresponding to the child block clusters after splitting.</p>
<p>Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p>Remove the current \(\mathcal{H}\)-matrix pair from the list <code>Sigma_P</code> of the current matrix node.</p>
<p>Update the matrix type of the current \(\mathcal{H}\)-matrix.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, and <a class="el" href="block__cluster__tree_8h.html#a16ad2c7c8e746258ce244315d6181c72">split_block_cluster_node()</a>.</p>

</div>
</div>
<a id="ab100d1469f662efdbf894a0345b702b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab100d1469f662efdbf894a0345b702b8">&#9670;&nbsp;</a></span>invert_by_gauss_elim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::invert_by_gauss_elim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_inv_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_root_bct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_inv_root_bct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the inverse of the \(\mathcal{H}\)-matrix node via Gauss elimination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M_inv</td><td></td></tr>
    <tr><td class="paramname">M_root</td><td>The \(\mathcal{H}\)-matrix node from which this recursive function is called for the first time. </td></tr>
    <tr><td class="paramname">M_inv_root</td><td>The \(\mathcal{H}\)-matrix node storing the inverse matrix of <code>M_root</code>. </td></tr>
    <tr><td class="paramname">M_root_bct</td><td>The block cluster tree associated with <code>M_root</code>. </td></tr>
    <tr><td class="paramname">M_inv_root_bct</td><td>The block cluster tree associated with <code>M_inv_root</code>. </td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>If the current matrix block to be handled has a same \(\tau\) cluster and \(\sigma\) cluster and belongs to the leaf set of <code>M_root</code>, directly calculate its inverse as full matrix.</p>
<p>Number of matrix block in a row.</p>
<p>Stage 1: eliminate the lower triangular part of the matrix.</p>
<p>Calculate the inverse of the diagonal block \(M \vert_{\tau[l]\times\tau[l]}\). The formula \(l + l \cdot k\) calculates the 1D index of the diagonal block in <code>submatrices</code>. This is because the submatrices of the current \(\mathcal{H}\)-matrix node is stored in the following order:</p>
<p><code> submatrices = {tau[0]*sigma[0], tau[0]*sigma[1], tau[1]*sigma[0], tau[1]*sigma[1]} </code></p>
<p>Since \(\tau\) is the same as \(\sigma\), we have</p>
<p><code> submatrices = {tau[0]*tau[0], tau[0]*tau[1], tau[1]*tau[0], tau[1]*tau[1]} </code></p>
<p>Hence, the index of <code>tau</code>[0]*tau[0] in <code>submatrices</code> is 0 and the index of <code>tau</code>[1]*tau[1] in <code>submatrices</code> is 3. The former index is calculated as <code>0 + 0 * 2 = 0</code>, while the latter index is calculated as <code>1 + 1 * 2 = 3</code>.</p>
<p>Create subtrees used for matrix multiplication.</p>
<p>Stage 2: eliminate the upper triangular part of the matrix.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ab0f83de878e6079330ec3c374f587a04">HMatrix&lt; spacedim, Number &gt;::find_block_cluster_in_leaf_set()</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classBlockClusterTree.html#a312d01ddb6cf5560d84abf7d254fa2c3">BlockClusterTree&lt; spacedim, Number &gt;::get_eta()</a>, <a class="el" href="classHMatrix.html#ac5c9102fc04997c1ae3627185379d9bb">HMatrix&lt; spacedim, Number &gt;::get_leaf_set()</a>, <a class="el" href="classBlockClusterTree.html#ab00acda5e8fd4c3e381637d8d9322923">BlockClusterTree&lt; spacedim, Number &gt;::get_n_min()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="af40d53aabc8bec86fa543638d48ba64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40d53aabc8bec86fa543638d48ba64e">&#9670;&nbsp;</a></span>mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of two \(\mathcal{H}\)-matrices \(C = A \cdot B\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">bct_a</td><td></td></tr>
    <tr><td class="paramname">bct_b</td><td></td></tr>
    <tr><td class="paramname">bct_c</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section">
<dt>Work flow </dt>
<dd><p class="startdd"></p>
<ul>
<li>
<p class="startli">Release the resource of the result matrix.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Initialize the induced block cluster tree \(T_{\rm ind}\) for the result matrix with a single root node.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Associate with the root node of the induced block cluster tree \(T_{\rm ind}\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Perform recursive multiplication while constructing the induced block cluster tree \(T_{\rm ind}\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">After the construction of the induced block cluster tree \(T_{\rm ind}\), rebuild its leaf set as well as near field and far field sets, and update the tree depth and maximum level.</p>
<p>DEBUG: Print the structure of the \(T_{\rm ind}\) block cluster tree.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Build the leaf set of the result matrix.</p>
<p>DEBUG: Print the structure of the \(T_{\rm ind}\) block cluster tree.</p>
<p class="endli"></p>
</li>
</ul>
</dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="classTreeNode.html#a7bf414928c965e707e0246f7a90a747d">TreeNode&lt; T, N &gt;::get_data_reference()</a>, <a class="el" href="classBlockClusterTree.html#ab00acda5e8fd4c3e381637d8d9322923">BlockClusterTree&lt; spacedim, Number &gt;::get_n_min()</a>, <a class="el" href="classBlockClusterTree.html#a4a4f3b893380d1d7f53b772589a847d2">BlockClusterTree&lt; spacedim, Number &gt;::get_root()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, and <a class="el" href="classHMatrix.html#a12da9454687e5ca15837d63e2bf0b595">HMatrix&lt; spacedim, Number &gt;::Tind</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-hmatrix-mmult-all-coarse-ntp_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a2c72ede65323af5b57a6b16f5774de50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c72ede65323af5b57a6b16f5774de50">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment via shallow copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>.</p>

</div>
</div>
<a id="a83958971f40409b3b2a192b71eae1513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83958971f40409b3b2a192b71eae1513">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment via deep copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, and <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>.</p>

</div>
</div>
<a id="a7e849f7e8f35e3ebdfcb2dbb7ad4ad01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e849f7e8f35e3ebdfcb2dbb7ad4ad01">&#9670;&nbsp;</a></span>print_formatted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::print_formatted </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>zero_string</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>denominator</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the <a class="el" href="classHMatrix.html">HMatrix</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">precision</td><td></td></tr>
    <tr><td class="paramname">scientific</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
    <tr><td class="paramname">zero_string</td><td></td></tr>
    <tr><td class="paramname">denominator</td><td></td></tr>
    <tr><td class="paramname">threshold</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-deep-copy-constructor_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="ad8f87883cf49080706233441c0e09171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f87883cf49080706233441c0e09171">&#9670;&nbsp;</a></span>print_matrix_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::print_matrix_info </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the size of \(\Sigma_b^P\), \(\Sigma_b^R\) and \(\Sigma_b^F\).</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, and <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>.</p>

</div>
</div>
<a id="ad2b353962226c78910d6ddb6b5b8e460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b353962226c78910d6ddb6b5b8e460">&#9670;&nbsp;</a></span>refine_to_supertree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::refine_to_supertree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refine the current \(\mathcal{H}\)-matrix, whose associated block cluster tree has been extended. The operation has no accuracy loss.</p>
<p>This member function implements the operator \(\mathcal{T}_{P&#39; \leftarrow P}^{\mathcal{H} \leftarrow \mathcal{H}}\) for the case \(T(I \times J, P&#39;) \supset T(I \times J, P)\) in (7.9) in Hackbusch's \(\mathcal{H}\)-matrix book. Because there is no internal check about this, users should ensure that the original block cluster tree associated with this \(\mathcal{H}\)-matrix hierarchy has really been extended. </p>
<dl class="section">
<dt>Work flow </dt>
<dd><p class="startdd"></p>
<p>Iterate over the leaf set of the \(\mathcal{H}\)-matrix hierarchy.</p>
<p>Refine from the current \(\mathcal{H}\)-matrix leaf node.</p>
<p>After the refinement operation, we check the number of child matrices of the current \(\mathcal{H}\)-matrix leaf node.</p>
<p>If the current \(\mathcal{H}\)-matrix leaf node has a non-empty collection of submatrices, it has really been refined. Then delete its originally associated matrix data, either a full matrix or a rank-k matrix, and modify its matrix type as <code>HierarchicalMatrixType</code>.</p>
<p>After the refinement operation for all the leaf nodes of the original \(\mathcal{H}\)-matrix hierarchy finishes, rebuild the leaf set of the new \(\mathcal{H}\)-matrix hierarchy.</p>
<p class="enddd"></p>
</dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#af6fd60090b0de7bdea52fc84ddeb22c3">HMatrix&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees()</a>, and <a class="el" href="hmatrix-refinement_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a83f804163e1695cfb952ddb6b0df2503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f804163e1695cfb952ddb6b0df2503">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialize the hierarchical structure without data from the root node of a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bct</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="classBlockClusterTree.html#a4a4f3b893380d1d7f53b772589a847d2">BlockClusterTree&lt; spacedim, Number &gt;::get_root()</a>, and <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>.</p>

</div>
</div>
<a id="a41d20c1839f3d7a756107b8e4defea0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d20c1839f3d7a756107b8e4defea0b">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialize the hierarchical structure without data from a <a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bc_node</td><td></td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, and <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>.</p>

</div>
</div>
<a id="a812e8276888b2ad866edf7ce9b286839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812e8276888b2ad866edf7ce9b286839">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TODO: Construct from a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a> and a Sauter quadrature object/functor. Release the memory and status of the \(\mathcal{H}\)-matrix hierarchy. </p>
<p>The deletion of <code>submatrix</code> will call the destructor of this sub-HMatrix, which will further recursively call the destructor of the submatrices of this sub-HMatrix. Hence, this destructor is intrinsically recursive.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a12da9454687e5ca15837d63e2bf0b595">HMatrix&lt; spacedim, Number &gt;::Tind</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#af40d53aabc8bec86fa543638d48ba64e">HMatrix&lt; spacedim, Number &gt;::mmult()</a>, <a class="el" href="classHMatrix.html#a2c72ede65323af5b57a6b16f5774de50">HMatrix&lt; spacedim, Number &gt;::operator=()</a>, <a class="el" href="classHMatrix.html#a83f804163e1695cfb952ddb6b0df2503">HMatrix&lt; spacedim, Number &gt;::reinit()</a>, and <a class="el" href="classHMatrix.html#ae16c956c1b22eb307e9f360a83f4fa75">HMatrix&lt; spacedim, Number &gt;::~HMatrix()</a>.</p>

</div>
</div>
<a id="a9e023f39b1f8916117a63557895a91b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e023f39b1f8916117a63557895a91b4">&#9670;&nbsp;</a></span>remove_hmat_pair_from_mm_product_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a pair of \(\mathcal{H}\)-matrix nodes from the list of matrix-matrix product subtasks to be performed, i.e. from the list <code><a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix::Sigma_P</a></code>. </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, and <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>.</p>

</div>
</div>
<a id="ae0ab9b3be4ea0ef959da40e81313b2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ab9b3be4ea0ef959da40e81313b2e3">&#9670;&nbsp;</a></span>remove_hmat_pair_from_mm_product_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a pair of \(\mathcal{H}\)-matrix nodes from the list of matrix-matrix product subtasks to be performed, i.e. from the list <code><a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix::Sigma_P</a></code>. </p>

<p class="reference">References <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>.</p>

</div>
</div>
<a id="a64be687cacd167efc12b892aa154dcd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64be687cacd167efc12b892aa154dcd3">&#9670;&nbsp;</a></span>truncate_to_rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::truncate_to_rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a>&#160;</td>
          <td class="paramname"><em>new_rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate all rank-k matrices in the leaf set of the \(\mathcal{H}\)-matrix to rank-k matrices with the given <code>new_rank</code>, while the full matrices in the leaf set, i.e. those near-field matrices, are kept intact.</p>
<dl class="section note">
<dt>Note </dt>
<dd>This method implements the operator \(\mathcal{T}_{r \leftarrow s}^{\mathcal{H}}\) in (7.5) in Hackbusch's \(\mathcal{H}\)-matrix book. </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Do nothing.</p>
<p>Truncate the <a class="el" href="classRkMatrix.html">RkMatrix</a> in-place.</p>

<p class="reference">References <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-truncate-to-fixed-rank_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a72e5255eb5ce46136d0e2b195c82f016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e5255eb5ce46136d0e2b195c82f016">&#9670;&nbsp;</a></span>Tvmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate matrix-vector multiplication as \(y = y + M^T \cdot x\), i.e. the matrix \(M\) is transposed.</p>
<p>Because the matrix \(M\) is transposed, the roles for <code>row_indices</code> and <code>col_indices</code> should be swapped. Also refer to <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix::vmult</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="a166893f3f371d4542cb57aaa33e533d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166893f3f371d4542cb57aaa33e533d1">&#9670;&nbsp;</a></span>Tvmult_local_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tvmult_local_vector </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_index_global_to_local_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_index_global_to_local_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate matrix-vector multiplication as \(y = y + M^T \cdot x\), i.e. the matrix \(M\) is transposed.</p>
<p>Because the matrix \(M\) is transposed, the roles for <code>row_indices</code> and <code>col_indices</code> should be swapped.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The input vectors <code>x</code> and <code>y</code> are to be accessed via local indices with the assistance of <code>row_index_global_to_local_map</code> and <code>col_index_global_to_local_map</code>. </dd>
</dl>
<p>Also refer to <a class="el" href="classHMatrix.html#a2afddab534366617b6be203b3c5238a6">HMatrix::vmult_local_vector</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, and <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>.</p>

</div>
</div>
<a id="aa11b5761aba86606effd14b4bdf31912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11b5761aba86606effd14b4bdf31912">&#9670;&nbsp;</a></span>vmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate matrix-vector multiplication as \(y = y + M \cdot x\).</p>
<dl class="section note">
<dt>Note </dt>
<dd>1. The recursive algorithm for \(\mathcal{H}\)-matrix-vector multiplication needs to collect the results from different components in the leaf set and corresponding vector block in \(x\). More importantly, there will be a series of such results contributing to a same block in the result vector \(y\). Therefore, if the interface of this function is designed with the parameter <code>add</code> as that in the <code>vmult</code> function of <code>LAPACKFullMatrix</code> in deal.ii, in all recursive calls of <code>vmult</code> except the first one, this <code>add</code> flag should be set to <code>true</code>, irrespective of the original flag value passed into the first call of <code>vmult</code>. Hence, we do not include the <code>add</code> flag in the <code>vmult</code> function.<ol type="1">
<li>The input vectors <code>x</code> and <code>y</code> are to be accessed via global DoF indices. </li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

</div>
</div>
<a id="a2afddab534366617b6be203b3c5238a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2afddab534366617b6be203b3c5238a6">&#9670;&nbsp;</a></span>vmult_local_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::vmult_local_vector </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_index_global_to_local_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_index_global_to_local_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate matrix-vector multiplication as \(y = y + M \cdot x\).</p>
<dl class="section note">
<dt>Note </dt>
<dd>1. The recursive algorithm for \(\mathcal{H}\)-matrix-vector multiplication needs to collect the results from different components in the leaf set and corresponding vector block in \(x\). More importantly, there will be a series of such results contributing to a same block in the result vector \(y\). Therefore, if the interface of this function is designed with the parameter <code>add</code> as that in the <code>vmult</code> function of <code>LAPACKFullMatrix</code> in deal.ii, in all recursive calls of <code>vmult</code> except the first one, this <code>add</code> flag should be set to <code>true</code>, irrespective of the original flag value passed into the first call of <code>vmult</code>. Hence, we do not include the <code>add</code> flag in the <code>vmult</code> function.<ol type="1">
<li>The input vectors <code>x</code> and <code>y</code> are to be accessed via local indices with the assistance of <code>row_index_global_to_local_map</code> and <code>col_index_global_to_local_map</code>. </li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>
<p>Restrict vector x to the current matrix block.</p>
<p>Merge back the result vector <code>local_y</code> to <code>y</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, and <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>.</p>

</div>
</div>
<a id="a42f958a13c56d64564d59487e67bc8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f958a13c56d64564d59487e67bc8a2">&#9670;&nbsp;</a></span>write_fullmatrix_leaf_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::write_fullmatrix_leaf_node </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>singular_value_threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write formatted full matrix leaf node to the output stream.</p>
<p>The leaf node is written in the following format:</p>
<blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<p>[list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field,rank</p>
<p>For example,</p>
<blockquote class="doxtable">
<p>[1 2 3 ...],[7 8 9 ...],1,1 </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">singular_value_threshold</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Print index set of cluster \(\tau\).</p>
<p>Print index set of cluster \(\sigma\).</p>
<p>Print the <code>is_near_field</code> flag.</p>
<p>Make a copy of the matrix block and calculate its rank using SVD.</p>
<p>Print the <code>rank</code> flag.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#aaf0ae0960a40ad78a941aee823e80315">HMatrix&lt; spacedim, Number &gt;::write_leaf_set()</a>.</p>

</div>
</div>
<a id="aaf0ae0960a40ad78a941aee823e80315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0ae0960a40ad78a941aee823e80315">&#9670;&nbsp;</a></span>write_leaf_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::write_leaf_set </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>singular_value_threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write formatted leaf set to the output stream as well as the rank of each matrix block by recursion.</p>
<p>Each leaf node is written in the following format:</p>
<blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<p>[list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field,rank</p>
<p>For example,</p>
<blockquote class="doxtable">
<p>[1 2 3 ...],[7 8 9 ...],1,1 </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">singular_value_threshold</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, <a class="el" href="classHMatrix.html#a42f958a13c56d64564d59487e67bc8a2">HMatrix&lt; spacedim, Number &gt;::write_fullmatrix_leaf_node()</a>, and <a class="el" href="classHMatrix.html#ac2c8ccd5763d3952505741c657b6468c">HMatrix&lt; spacedim, Number &gt;::write_rkmatrix_leaf_node()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-bct-struct-with-rank_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="aac1e1ddbfeb133520dcd50c0174aab8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1e1ddbfeb133520dcd50c0174aab8d">&#9670;&nbsp;</a></span>write_leaf_set_by_iteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::write_leaf_set_by_iteration </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>singular_value_threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write formatted leaf set to the output stream as well as the rank of each matrix block by iteration.</p>
<p>Each leaf node is written in the following format:</p>
<blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<p>[list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field,rank</p>
<p>For example,</p>
<blockquote class="doxtable">
<p>[1 2 3 ...],[7 8 9 ...],1,1 </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">singular_value_threshold</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-deep-copy-constructor_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="ac2c8ccd5763d3952505741c657b6468c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c8ccd5763d3952505741c657b6468c">&#9670;&nbsp;</a></span>write_rkmatrix_leaf_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::write_rkmatrix_leaf_node </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write formatted rank-k matrix leaf node to the output stream.</p>
<p>The leaf node is written in the following format:</p>
<blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<p>[list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field,rank</p>
<p>For example,</p>
<blockquote class="doxtable">
<p>[1 2 3 ...],[7 8 9 ...],1,1 </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Print index set of cluster \(\tau\).</p>
<p>Print index set of cluster \(\sigma\).</p>
<p>Print the <code>is_near_field</code> flag.</p>
<p>Print the <code>rank</code> flag.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#aaf0ae0960a40ad78a941aee823e80315">HMatrix&lt; spacedim, Number &gt;::write_leaf_set()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4a304494c970b5b267be1d8459d51586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a304494c970b5b267be1d8459d51586">&#9670;&nbsp;</a></span>bc_node</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt;spacedim, Number&gt;::node_pointer_type <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::bc_node</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the corresponding block cluster node in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="classHMatrix.html#a525ad4d453f4f496b98cccb341c8b60b">HMatrix&lt; spacedim, Number &gt;::coarsen_to_partition()</a>, <a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="classHMatrix.html#ab315324e3ece178943f406823f792746">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_cross_split()</a>, <a class="el" href="classHMatrix.html#a38c88893c6ca784d4e56653d8b0e3e67">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_horizontal_split()</a>, <a class="el" href="classHMatrix.html#a168b6eea2e5b27528497850bf5ee2bbe">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_reduction()</a>, <a class="el" href="classHMatrix.html#a253c23d09e89a9a37a7d808374b5ae4e">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_vertical_split()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="classHMatrix.html#ab100d1469f662efdbf894a0345b702b8">HMatrix&lt; spacedim, Number &gt;::invert_by_gauss_elim()</a>, <a class="el" href="classHMatrix.html#ad8f87883cf49080706233441c0e09171">HMatrix&lt; spacedim, Number &gt;::print_matrix_info()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="classHMatrix.html#a42f958a13c56d64564d59487e67bc8a2">HMatrix&lt; spacedim, Number &gt;::write_fullmatrix_leaf_node()</a>, and <a class="el" href="classHMatrix.html#ac2c8ccd5763d3952505741c657b6468c">HMatrix&lt; spacedim, Number &gt;::write_rkmatrix_leaf_node()</a>.</p>

</div>
</div>
<a id="ab337c7b4f2f40699b9b7f3ab17a1e056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab337c7b4f2f40699b9b7f3ab17a1e056">&#9670;&nbsp;</a></span>col_index_global_to_local_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;types::global_dof_index, size_t&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::col_index_global_to_local_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map from local column indices to global column indices for the cluster \(\sigma\). The set of local column indices is the range \([0, \#\sigma - 1]\). The corresponding set of global column indices is a subset of \(J\).</p>
<dl class="section note">
<dt>Note </dt>
<dd>This mapping is only constructed for H-matrices in the leaf set. </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a2229caab9b862f9c54b7f3a806125fba">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a01360c3d9a93154f2e629b6c413aa991">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, and <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>.</p>

</div>
</div>
<a id="ac30ae65e37ec5e4ccc7de2f6b9ea91e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">&#9670;&nbsp;</a></span>col_indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;types::global_dof_index&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::col_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the vector of global column indices, which is stored as the index set in the cluster \(\sigma\). It is a subset of \(J\). By accessing this vector using indices starting from 0, we actually obtain the mapping from the current matrix's local column indices to the global column indices. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#a2229caab9b862f9c54b7f3a806125fba">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a01360c3d9a93154f2e629b6c413aa991">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>, <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>, <a class="el" href="classHMatrix.html#a166893f3f371d4542cb57aaa33e533d1">HMatrix&lt; spacedim, Number &gt;::Tvmult_local_vector()</a>, <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>, and <a class="el" href="classHMatrix.html#a2afddab534366617b6be203b3c5238a6">HMatrix&lt; spacedim, Number &gt;::vmult_local_vector()</a>.</p>

</div>
</div>
<a id="a328134c9e9cb2c4b05d5431c0ca8a533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328134c9e9cb2c4b05d5431c0ca8a533">&#9670;&nbsp;</a></span>fullmatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt;Number&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::fullmatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the full matrix. It is not null when the current <a class="el" href="classHMatrix.html">HMatrix</a> object belongs to the near field. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#a2229caab9b862f9c54b7f3a806125fba">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="classHMatrix.html#a9d914c27d4e990d476a4529b2daa64cd">HMatrix&lt; spacedim, Number &gt;::get_fullmatrix()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="classHMatrix.html#ab100d1469f662efdbf894a0345b702b8">HMatrix&lt; spacedim, Number &gt;::invert_by_gauss_elim()</a>, <a class="el" href="classHMatrix.html#a7e849f7e8f35e3ebdfcb2dbb7ad4ad01">HMatrix&lt; spacedim, Number &gt;::print_formatted()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>, <a class="el" href="classHMatrix.html#a166893f3f371d4542cb57aaa33e533d1">HMatrix&lt; spacedim, Number &gt;::Tvmult_local_vector()</a>, <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>, and <a class="el" href="classHMatrix.html#a2afddab534366617b6be203b3c5238a6">HMatrix&lt; spacedim, Number &gt;::vmult_local_vector()</a>.</p>

</div>
</div>
<a id="a61dbd471077be0ad8325d0f2afe3d43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61dbd471077be0ad8325d0f2afe3d43f">&#9670;&nbsp;</a></span>leaf_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt; *&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::leaf_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A list of submatrices in the leaf set. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a139f32982527ba981e0211b5663e3b43">HMatrix&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a3e61ba5438c4cf0337664ec4b8562873">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#ab0f83de878e6079330ec3c374f587a04">HMatrix&lt; spacedim, Number &gt;::find_block_cluster_in_leaf_set()</a>, <a class="el" href="classHMatrix.html#ac5c9102fc04997c1ae3627185379d9bb">HMatrix&lt; spacedim, Number &gt;::get_leaf_set()</a>, <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, <a class="el" href="classHMatrix.html#ad2b353962226c78910d6ddb6b5b8e460">HMatrix&lt; spacedim, Number &gt;::refine_to_supertree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, and <a class="el" href="classHMatrix.html#aac1e1ddbfeb133520dcd50c0174aab8d">HMatrix&lt; spacedim, Number &gt;::write_leaf_set_by_iteration()</a>.</p>

</div>
</div>
<a id="aa5523463043e4d542eae17d262bd22ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5523463043e4d542eae17d262bd22ad">&#9670;&nbsp;</a></span>m</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::m</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of rows in the matrix. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="classHMatrix.html#a00bdd40f7fcf5c912c34c427df518300">HMatrix&lt; spacedim, Number &gt;::convertToFullMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, <a class="el" href="classHMatrix.html#aabe735f7712a10ba5325ff116f8ca1c7">HMatrix&lt; spacedim, Number &gt;::get_m()</a>, <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="classHMatrix.html#ab100d1469f662efdbf894a0345b702b8">HMatrix&lt; spacedim, Number &gt;::invert_by_gauss_elim()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>, <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>, <a class="el" href="classHMatrix.html#a166893f3f371d4542cb57aaa33e533d1">HMatrix&lt; spacedim, Number &gt;::Tvmult_local_vector()</a>, <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>, and <a class="el" href="classHMatrix.html#a2afddab534366617b6be203b3c5238a6">HMatrix&lt; spacedim, Number &gt;::vmult_local_vector()</a>.</p>

</div>
</div>
<a id="ab5ae2eb472f81f80653ed4411629c2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ae2eb472f81f80653ed4411629c2d1">&#9670;&nbsp;</a></span>n</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMatrix.html#a5ca8dc549783d38371a01ecd621ecb34">size_type</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::n</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of columns in the matrix. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="classHMatrix.html#a00bdd40f7fcf5c912c34c427df518300">HMatrix&lt; spacedim, Number &gt;::convertToFullMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, <a class="el" href="classHMatrix.html#abff89130116d62ea4159bc69ca11f8d5">HMatrix&lt; spacedim, Number &gt;::get_n()</a>, <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="classHMatrix.html#ab100d1469f662efdbf894a0345b702b8">HMatrix&lt; spacedim, Number &gt;::invert_by_gauss_elim()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>, <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>, <a class="el" href="classHMatrix.html#a166893f3f371d4542cb57aaa33e533d1">HMatrix&lt; spacedim, Number &gt;::Tvmult_local_vector()</a>, <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>, and <a class="el" href="classHMatrix.html#a2afddab534366617b6be203b3c5238a6">HMatrix&lt; spacedim, Number &gt;::vmult_local_vector()</a>.</p>

</div>
</div>
<a id="aa97a8f5e42aba0f1d5faf41f35a27819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97a8f5e42aba0f1d5faf41f35a27819">&#9670;&nbsp;</a></span>rkmatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt;Number&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::rkmatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the rank-k matrix. It is not null when the current <a class="el" href="classHMatrix.html">HMatrix</a> object belongs to the far field. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#a2229caab9b862f9c54b7f3a806125fba">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a0189de6e276fbd3425c4a7ef132f5e16">HMatrix&lt; spacedim, Number &gt;::get_rkmatrix()</a>, <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="classHMatrix.html#a7e849f7e8f35e3ebdfcb2dbb7ad4ad01">HMatrix&lt; spacedim, Number &gt;::print_formatted()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>, <a class="el" href="classHMatrix.html#a64be687cacd167efc12b892aa154dcd3">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank()</a>, <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>, <a class="el" href="classHMatrix.html#a166893f3f371d4542cb57aaa33e533d1">HMatrix&lt; spacedim, Number &gt;::Tvmult_local_vector()</a>, <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>, and <a class="el" href="classHMatrix.html#a2afddab534366617b6be203b3c5238a6">HMatrix&lt; spacedim, Number &gt;::vmult_local_vector()</a>.</p>

</div>
</div>
<a id="a4d64145335fc0521603b206a22a67578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d64145335fc0521603b206a22a67578">&#9670;&nbsp;</a></span>row_index_global_to_local_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;types::global_dof_index, size_t&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::row_index_global_to_local_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map from local row indices to global row indices for the cluster \(\tau\). The set of local row indices is the range \([0, \#\tau - 1]\). The corresponding set of global row indices is a subset of \(I\).</p>
<dl class="section note">
<dt>Note </dt>
<dd>This mapping is only constructed for H-matrices in the leaf set. </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a2229caab9b862f9c54b7f3a806125fba">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a01360c3d9a93154f2e629b6c413aa991">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, and <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>.</p>

</div>
</div>
<a id="a33b3a936f1b40e320e96d47471da07ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b3a936f1b40e320e96d47471da07ae">&#9670;&nbsp;</a></span>row_indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;types::global_dof_index&gt;* <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::row_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the vector of global row indices, which is stored as the index in the cluster \(\tau\). It is a subset of \(I\). By accessing this vector using indices starting from 0, we actually obtain the mapping from the current matrix's local row indices to the global row indices. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#a2229caab9b862f9c54b7f3a806125fba">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a01360c3d9a93154f2e629b6c413aa991">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>, <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>, <a class="el" href="classHMatrix.html#a166893f3f371d4542cb57aaa33e533d1">HMatrix&lt; spacedim, Number &gt;::Tvmult_local_vector()</a>, <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>, and <a class="el" href="classHMatrix.html#a2afddab534366617b6be203b3c5238a6">HMatrix&lt; spacedim, Number &gt;::vmult_local_vector()</a>.</p>

</div>
</div>
<a id="aa659b6df63d533432ec1a24435cd9c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa659b6df63d533432ec1a24435cd9c40">&#9670;&nbsp;</a></span>Sigma_F</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt;Number&gt; *&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Sigma_F</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of full matrix pointers used in \(\mathcal{H}\)-matrix multiplication. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a2229caab9b862f9c54b7f3a806125fba">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a3e61ba5438c4cf0337664ec4b8562873">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a01360c3d9a93154f2e629b6c413aa991">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="classHMatrix.html#ad8f87883cf49080706233441c0e09171">HMatrix&lt; spacedim, Number &gt;::print_matrix_info()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, and <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>.</p>

</div>
</div>
<a id="a3d96d0252ef8c873ae06cf87874acaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d96d0252ef8c873ae06cf87874acaf3">&#9670;&nbsp;</a></span>Sigma_P</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt;<a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt; *&gt; &gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Sigma_P</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of pairs of pointers to \(\mathcal{H}\)-matrix nodes for multiplication. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a3e61ba5438c4cf0337664ec4b8562873">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a6f24998c7de1d0e336577be41c6281e3">HMatrix&lt; spacedim, Number &gt;::determine_mm_split_mode_from_Sigma_P()</a>, <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#aad08ee9bd389abe7b7b76fd0f2cb292e">h_h_mmult_phase1_recursion()</a>, <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, <a class="el" href="classHMatrix.html#a168b6eea2e5b27528497850bf5ee2bbe">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_reduction()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="classHMatrix.html#ad8f87883cf49080706233441c0e09171">HMatrix&lt; spacedim, Number &gt;::print_matrix_info()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="classHMatrix.html#a9e023f39b1f8916117a63557895a91b4">HMatrix&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list()</a>, and <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>.</p>

</div>
</div>
<a id="a04d341b4e606d1be2d71b8ea636efe7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d341b4e606d1be2d71b8ea636efe7b">&#9670;&nbsp;</a></span>Sigma_R</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classRkMatrix.html">RkMatrix</a>&lt;Number&gt; *&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Sigma_R</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of rank-k matrix pointers used in \(\mathcal{H}\)-matrix multiplication. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a2229caab9b862f9c54b7f3a806125fba">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a3e61ba5438c4cf0337664ec4b8562873">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a01360c3d9a93154f2e629b6c413aa991">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode()</a>, <a class="el" href="classHMatrix.html#ad8f87883cf49080706233441c0e09171">HMatrix&lt; spacedim, Number &gt;::print_matrix_info()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, and <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>.</p>

</div>
</div>
<a id="a4bd1b9a32f2c7693e603a7c6ea916e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd1b9a32f2c7693e603a7c6ea916e4f">&#9670;&nbsp;</a></span>submatrices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classHMatrix.html">HMatrix</a>&lt;spacedim, Number&gt; *&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::submatrices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A list of submatrices of type <a class="el" href="classHMatrix.html">HMatrix</a>. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a60934e84cc3c9f6c75d011a2005f512a">HMatrix&lt; spacedim, Number &gt;::_build_leaf_set()</a>, <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#a2229caab9b862f9c54b7f3a806125fba">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#ae55bd45587b895bfdb977e7cbea46519">HMatrix&lt; spacedim, Number &gt;::clear()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="classHMatrix.html#a525ad4d453f4f496b98cccb341c8b60b">HMatrix&lt; spacedim, Number &gt;::coarsen_to_partition()</a>, <a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h.html#af4b3e4f5b78b4b6a9885325225eba0a1">copy_hmatrix()</a>, <a class="el" href="hmatrix_8h.html#a3e61ba5438c4cf0337664ec4b8562873">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a01360c3d9a93154f2e629b6c413aa991">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#a0572b2c0484ce618db0034e3bc7988ed">HMatrix&lt; spacedim, Number &gt;::get_submatrices()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="classHMatrix.html#ab100d1469f662efdbf894a0345b702b8">HMatrix&lt; spacedim, Number &gt;::invert_by_gauss_elim()</a>, <a class="el" href="classHMatrix.html#a7e849f7e8f35e3ebdfcb2dbb7ad4ad01">HMatrix&lt; spacedim, Number &gt;::print_formatted()</a>, <a class="el" href="classHMatrix.html#ad8f87883cf49080706233441c0e09171">HMatrix&lt; spacedim, Number &gt;::print_matrix_info()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="classHMatrix.html#a64be687cacd167efc12b892aa154dcd3">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank()</a>, <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>, <a class="el" href="classHMatrix.html#a166893f3f371d4542cb57aaa33e533d1">HMatrix&lt; spacedim, Number &gt;::Tvmult_local_vector()</a>, <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>, <a class="el" href="classHMatrix.html#a2afddab534366617b6be203b3c5238a6">HMatrix&lt; spacedim, Number &gt;::vmult_local_vector()</a>, and <a class="el" href="classHMatrix.html#aaf0ae0960a40ad78a941aee823e80315">HMatrix&lt; spacedim, Number &gt;::write_leaf_set()</a>.</p>

</div>
</div>
<a id="a12da9454687e5ca15837d63e2bf0b595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12da9454687e5ca15837d63e2bf0b595">&#9670;&nbsp;</a></span>Tind</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt;spacedim, Number&gt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::Tind</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Block cluster tree when this matrix is the product of two \(\mathcal{H}\)-matrices. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a3e61ba5438c4cf0337664ec4b8562873">copy_hmatrix_node()</a>, <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, <a class="el" href="classHMatrix.html#af40d53aabc8bec86fa543638d48ba64e">HMatrix&lt; spacedim, Number &gt;::mmult()</a>, and <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>.</p>

</div>
</div>
<a id="a89ef60f3ba737c04708195ca0bb13620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ef60f3ba737c04708195ca0bb13620">&#9670;&nbsp;</a></span>type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a> <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix type. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a60934e84cc3c9f6c75d011a2005f512a">HMatrix&lt; spacedim, Number &gt;::_build_leaf_set()</a>, <a class="el" href="classHMatrix.html#ab55b568236ffdd71b5378ac6c6ace50a">HMatrix&lt; spacedim, Number &gt;::_convertToFullMatrix()</a>, <a class="el" href="classHMatrix.html#a2229caab9b862f9c54b7f3a806125fba">HMatrix&lt; spacedim, Number &gt;::_distribute_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#ae55bd45587b895bfdb977e7cbea46519">HMatrix&lt; spacedim, Number &gt;::clear()</a>, <a class="el" href="classHMatrix.html#aec0815bc9c3654391bb2b3095383e6cb">HMatrix&lt; spacedim, Number &gt;::clear_hmat_node()</a>, <a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix()</a>, <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a01360c3d9a93154f2e629b6c413aa991">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="classHMatrix.html#aadea9fa59f420d22b3b1c939f6b573cc">HMatrix&lt; spacedim, Number &gt;::get_type()</a>, <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2()</a>, <a class="el" href="classHMatrix.html#a168b6eea2e5b27528497850bf5ee2bbe">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_reduction()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="classHMatrix.html#ab100d1469f662efdbf894a0345b702b8">HMatrix&lt; spacedim, Number &gt;::invert_by_gauss_elim()</a>, <a class="el" href="classHMatrix.html#a7e849f7e8f35e3ebdfcb2dbb7ad4ad01">HMatrix&lt; spacedim, Number &gt;::print_formatted()</a>, <a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a812e8276888b2ad866edf7ce9b286839">HMatrix&lt; spacedim, Number &gt;::release()</a>, <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>, <a class="el" href="classHMatrix.html#a64be687cacd167efc12b892aa154dcd3">HMatrix&lt; spacedim, Number &gt;::truncate_to_rank()</a>, <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>, <a class="el" href="classHMatrix.html#a166893f3f371d4542cb57aaa33e533d1">HMatrix&lt; spacedim, Number &gt;::Tvmult_local_vector()</a>, <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>, <a class="el" href="classHMatrix.html#a2afddab534366617b6be203b3c5238a6">HMatrix&lt; spacedim, Number &gt;::vmult_local_vector()</a>, <a class="el" href="classHMatrix.html#a42f958a13c56d64564d59487e67bc8a2">HMatrix&lt; spacedim, Number &gt;::write_fullmatrix_leaf_node()</a>, <a class="el" href="classHMatrix.html#aaf0ae0960a40ad78a941aee823e80315">HMatrix&lt; spacedim, Number &gt;::write_leaf_set()</a>, <a class="el" href="classHMatrix.html#aac1e1ddbfeb133520dcd50c0174aab8d">HMatrix&lt; spacedim, Number &gt;::write_leaf_set_by_iteration()</a>, and <a class="el" href="classHMatrix.html#ac2c8ccd5763d3952505741c657b6468c">HMatrix&lt; spacedim, Number &gt;::write_rkmatrix_leaf_node()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/jihuan/Projects/deal.ii/program/dealii-9.1.1/examples/laplace-bem/include/<a class="el" href="hmatrix_8h_source.html">hmatrix.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
