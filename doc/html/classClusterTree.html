<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>laplace-bem: ClusterTree&lt; spacedim, Number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    skipTags: ["script","noscript","style","textarea","pre","code"],
    processEscapes: false,
    processEnvironments: true,
    preview: "TeX"
  },
  TeX: {
    Macros: {
      intd: "\\,{\\rm d}",
      diff: "{\\rm d}",
      Diff: "{\\rm D}",
      pdiff: "\\partial",
      DD: ["\\frac{\\diff}{\\diff #2}\\left( #1 \\right)", 2],
      Dd: ["\\frac{\\diff #1}{\\diff #2}", 2],
      PD: ["\\frac{\\pdiff}{\\pdiff #2}\\left( #1 \\right)", 2],
      Pd: ["\\frac{\\pdiff #1}{\\pdiff #2}", 2],
      rme: "{\\rm e}",
      rmi: "{\\rm i}",
      rmj: "{\\rm j}",
      vect: ["\\boldsymbol{#1}", 1],
      dform: ["\\overset{\\rightharpoonup}{\\boldsymbol{#1}}", 1],
      cochain: ["\\overset{\\rightharpoonup}{#1}", 1],
      Abs: ["\\big\\lvert#1\\big\\rvert", 1],
      abs: ["\\lvert#1\\rvert", 1],
      Norm: ["\\big\\lVert#1\\big\\rVert", 1],
      norm: ["\\lVert#1\\rVert", 1],
      normvect: "\\vect{n}",
      ouset: ["\\overset{#3}{\\underset{#2}{#1}}", 3],
      cscript: ["\\;\\; #1", 1],
      suchthat: "\\textit{S.T.\\;}",
      prefstar: "\\ast",
      restrict: "\\big\\vert",
      sgn: "{\\rm sgn}",
      erf: "{\\rm erf}",
      Bd: "{\\rm Bd}",
      Int: "{\\rm Int}",
      rank: "{\\rm rank}",
      divergence: "{\\rm div}",
      grad: "{\\rm grad}",
      tr: "{\\rm tr}",
      span: "{\\rm span}"
    },
    extensions: ["AMScd.js"],
    equationNumbers: { autoNumber: "AMS" }
  },
  "HTML-CSS": {
     availableFonts: ["STIX","TeX"],
     preferredFont: "TeX",
     webFont: "TeX",
     imageFont: "TeX",
     showMathMenu: true
  },
  MMLorHTML: {
    prefer: {
      MSIE:    "MML",
      Firefox: "MML",
      Opera:   "HTML",
      other:   "HTML"
    }
  }
});
</script><script type="text/javascript" src="http://localhost/js/MathJax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">laplace-bem
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Solve Laplace problem using the boundary element method (BEM)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classClusterTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ClusterTree&lt; spacedim, Number &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for cluster tree.  
 <a href="classClusterTree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cluster__tree_8h_source.html">cluster_tree.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ClusterTree&lt; spacedim, Number &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classClusterTree__inherit__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div class="dynheader">
Collaboration diagram for ClusterTree&lt; spacedim, Number &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classClusterTree__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab12442ec2508818e1663df6c5a137b05"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classBinaryTreeNode.html">BinaryTreeNode</a>&lt; <a class="el" href="classCluster.html">Cluster</a>&lt; spacedim, Number &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#ab12442ec2508818e1663df6c5a137b05">node_value_type</a></td></tr>
<tr class="separator:ab12442ec2508818e1663df6c5a137b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bb0fdc7ac559d7844d04a00ab3e9de"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classBinaryTreeNode.html">BinaryTreeNode</a>&lt; <a class="el" href="classCluster.html">Cluster</a>&lt; spacedim, Number &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a></td></tr>
<tr class="separator:ae4bb0fdc7ac559d7844d04a00ab3e9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb805fbc20c01a71fa6a00adc959542c"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classBinaryTreeNode.html">BinaryTreeNode</a>&lt; <a class="el" href="classCluster.html">Cluster</a>&lt; spacedim, Number &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#acb805fbc20c01a71fa6a00adc959542c">node_const_pointer_type</a></td></tr>
<tr class="separator:acb805fbc20c01a71fa6a00adc959542c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257ebe4c6eab6581a0b65ba62487ae2c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classBinaryTreeNode.html">BinaryTreeNode</a>&lt; <a class="el" href="classCluster.html">Cluster</a>&lt; spacedim, Number &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a257ebe4c6eab6581a0b65ba62487ae2c">node_reference_type</a></td></tr>
<tr class="separator:a257ebe4c6eab6581a0b65ba62487ae2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40955dbfdb9b0beec67a0ecf6810c8f"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classBinaryTreeNode.html">BinaryTreeNode</a>&lt; <a class="el" href="classCluster.html">Cluster</a>&lt; spacedim, Number &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#ac40955dbfdb9b0beec67a0ecf6810c8f">node_const_reference_type</a></td></tr>
<tr class="separator:ac40955dbfdb9b0beec67a0ecf6810c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7875a0c5ba927d1d3c5f5212d1d524d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classCluster.html">Cluster</a>&lt; spacedim, Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#ab7875a0c5ba927d1d3c5f5212d1d524d">data_value_type</a></td></tr>
<tr class="separator:ab7875a0c5ba927d1d3c5f5212d1d524d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fee1708c95c5575fce3029b79d32a8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classCluster.html">Cluster</a>&lt; spacedim, Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a87fee1708c95c5575fce3029b79d32a8">data_pointer_type</a></td></tr>
<tr class="separator:a87fee1708c95c5575fce3029b79d32a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac425245d60967a91905245003e5d46b1"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classCluster.html">Cluster</a>&lt; spacedim, Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#ac425245d60967a91905245003e5d46b1">data_const_pointer_type</a></td></tr>
<tr class="separator:ac425245d60967a91905245003e5d46b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47bb5a21c1468972b1c2ede0e8aa28c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classCluster.html">Cluster</a>&lt; spacedim, Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#ae47bb5a21c1468972b1c2ede0e8aa28c">data_reference_type</a></td></tr>
<tr class="separator:ae47bb5a21c1468972b1c2ede0e8aa28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d171cbb6b0a8367b4be0d2b87bc9ba8"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classCluster.html">Cluster</a>&lt; spacedim, Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a1d171cbb6b0a8367b4be0d2b87bc9ba8">data_const_reference_type</a></td></tr>
<tr class="separator:a1d171cbb6b0a8367b4be0d2b87bc9ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a28b31e2fbe58c74eff89a1a8e2124e10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a28b31e2fbe58c74eff89a1a8e2124e10">ClusterTree</a> ()</td></tr>
<tr class="separator:a28b31e2fbe58c74eff89a1a8e2124e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21fda96c7d405825a853f8759c0cc4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#ae21fda96c7d405825a853f8759c0cc4c">ClusterTree</a> (const std::vector&lt; types::global_dof_index &gt; &amp;index_set, const unsigned int <a class="el" href="classClusterTree.html#a5af4448800c4ddc98121706754bfe3f9">n_min</a>)</td></tr>
<tr class="separator:ae21fda96c7d405825a853f8759c0cc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587c465f14f7fa0e0e6a82aa8733452f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a587c465f14f7fa0e0e6a82aa8733452f">ClusterTree</a> (const std::vector&lt; types::global_dof_index &gt; &amp;index_set, const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;all_support_points, const unsigned int <a class="el" href="classClusterTree.html#a5af4448800c4ddc98121706754bfe3f9">n_min</a>)</td></tr>
<tr class="separator:a587c465f14f7fa0e0e6a82aa8733452f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd518db632c62cfafb61e9ef56097c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a3fd518db632c62cfafb61e9ef56097c7">ClusterTree</a> (const std::vector&lt; types::global_dof_index &gt; &amp;index_set, const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;all_support_points, const std::vector&lt; Number &gt; &amp;cell_size_at_dofs, const unsigned int <a class="el" href="classClusterTree.html#a5af4448800c4ddc98121706754bfe3f9">n_min</a>)</td></tr>
<tr class="separator:a3fd518db632c62cfafb61e9ef56097c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d41a3a87bee15fe2d0b39a42f705d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a40d41a3a87bee15fe2d0b39a42f705d2">ClusterTree</a> (const <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp;cluster_tree)</td></tr>
<tr class="separator:a40d41a3a87bee15fe2d0b39a42f705d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b0ac0f6474de90d4fb528b6ed28db6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#ad1b0ac0f6474de90d4fb528b6ed28db6">~ClusterTree</a> ()</td></tr>
<tr class="separator:ad1b0ac0f6474de90d4fb528b6ed28db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc8b94ebdc4e5efb885940204f614e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a2dc8b94ebdc4e5efb885940204f614e1">release</a> ()</td></tr>
<tr class="separator:a2dc8b94ebdc4e5efb885940204f614e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4e51a1a09f759f085ab140db914af9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a3a4e51a1a09f759f085ab140db914af9">operator=</a> (const <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp;cluster_tree)</td></tr>
<tr class="separator:a3a4e51a1a09f759f085ab140db914af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9700796d8fb849b3171c0c7d461a2380"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a9700796d8fb849b3171c0c7d461a2380">operator=</a> (<a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp;&amp;cluster_tree)</td></tr>
<tr class="separator:a9700796d8fb849b3171c0c7d461a2380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa514c3b75864d5f7be72315a30079cfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#aa514c3b75864d5f7be72315a30079cfe">partition</a> ()</td></tr>
<tr class="separator:aa514c3b75864d5f7be72315a30079cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5657415b4b0519f045f3139d1d63e85d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a5657415b4b0519f045f3139d1d63e85d">partition</a> (const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;all_support_points)</td></tr>
<tr class="separator:a5657415b4b0519f045f3139d1d63e85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2682986352bb1e44bc73ebfc5a9fdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a4d2682986352bb1e44bc73ebfc5a9fdf">partition</a> (const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;all_support_points, const std::vector&lt; Number &gt; &amp;cell_size_at_dofs)</td></tr>
<tr class="separator:a4d2682986352bb1e44bc73ebfc5a9fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13132bfc3ca8b70af8c80066565b0adb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a13132bfc3ca8b70af8c80066565b0adb">get_root</a> () const</td></tr>
<tr class="separator:a13132bfc3ca8b70af8c80066565b0adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17a96da7f2e5391d3e49028b2aba894"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#af17a96da7f2e5391d3e49028b2aba894">get_leaf_set</a> ()</td></tr>
<tr class="separator:af17a96da7f2e5391d3e49028b2aba894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf8f03d5f34305d3c34ae4c360f50ae"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#afbf8f03d5f34305d3c34ae4c360f50ae">get_leaf_set</a> () const</td></tr>
<tr class="separator:afbf8f03d5f34305d3c34ae4c360f50ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7dc037d01b3e15f1d6b4eacac59cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a1e7dc037d01b3e15f1d6b4eacac59cb1">build_leaf_set</a> ()</td></tr>
<tr class="separator:a1e7dc037d01b3e15f1d6b4eacac59cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403e59575a89a3e86e8d7092a8815aa5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a403e59575a89a3e86e8d7092a8815aa5">get_n_min</a> () const</td></tr>
<tr class="separator:a403e59575a89a3e86e8d7092a8815aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd8dd175c4459338d76a8cb879afccf"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a2bd8dd175c4459338d76a8cb879afccf">get_depth</a> () const</td></tr>
<tr class="separator:a2bd8dd175c4459338d76a8cb879afccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1125039b1915ebad94247d6888df31"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a3c1125039b1915ebad94247d6888df31">get_max_level</a> () const</td></tr>
<tr class="separator:a3c1125039b1915ebad94247d6888df31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80051449b7324121fb0a27d5ce7c9a1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#af80051449b7324121fb0a27d5ce7c9a1">get_node_num</a> () const</td></tr>
<tr class="separator:af80051449b7324121fb0a27d5ce7c9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa9705d3fecd5b405b804331ea031570c"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#aa9705d3fecd5b405b804331ea031570c">child_num</a> = 2</td></tr>
<tr class="separator:aa9705d3fecd5b405b804331ea031570c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8b650f0c7cc83adbde5aad9556a57ac3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a8b650f0c7cc83adbde5aad9556a57ac3">partition_from_cluster_node</a> (<a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a> current_cluster_node, std::vector&lt; <a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a> &gt; &amp;leaf_set_wrt_current_node)</td></tr>
<tr class="separator:a8b650f0c7cc83adbde5aad9556a57ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3636b1686d72909611a6d516f5ee47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a6d3636b1686d72909611a6d516f5ee47">partition_from_cluster_node</a> (<a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a> current_cluster_node, const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;all_support_points, std::vector&lt; <a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a> &gt; &amp;leaf_set_wrt_current_node)</td></tr>
<tr class="separator:a6d3636b1686d72909611a6d516f5ee47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b853c36834044df5283fca9e03d39d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a8b853c36834044df5283fca9e03d39d2">partition_from_cluster_node</a> (<a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a> current_cluster_node, const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;all_support_points, const std::vector&lt; Number &gt; &amp;cell_size_at_dofs, std::vector&lt; <a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a> &gt; &amp;leaf_set_wrt_current_node)</td></tr>
<tr class="separator:a8b853c36834044df5283fca9e03d39d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a47a5916039b17a75cda800520ac130b6"><td class="memItemLeft" align="right" valign="top"><a id="a47a5916039b17a75cda800520ac130b6"></a>
<a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>root_node</b></td></tr>
<tr class="separator:a47a5916039b17a75cda800520ac130b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53275a95d4085912bde71f85ef39067"><td class="memItemLeft" align="right" valign="top"><a id="aa53275a95d4085912bde71f85ef39067"></a>
std::vector&lt; <a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>leaf_set</b></td></tr>
<tr class="separator:aa53275a95d4085912bde71f85ef39067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051df20340ed3f0e4bc0ee1fb1119f9f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a051df20340ed3f0e4bc0ee1fb1119f9f">depth</a></td></tr>
<tr class="separator:a051df20340ed3f0e4bc0ee1fb1119f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77800bb9f86c689821ba4d549ce97a58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a77800bb9f86c689821ba4d549ce97a58">max_level</a></td></tr>
<tr class="separator:a77800bb9f86c689821ba4d549ce97a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af4448800c4ddc98121706754bfe3f9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a5af4448800c4ddc98121706754bfe3f9">n_min</a></td></tr>
<tr class="separator:a5af4448800c4ddc98121706754bfe3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b352489be3ca9217d31966c24ee02a1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a6b352489be3ca9217d31966c24ee02a1">node_num</a></td></tr>
<tr class="separator:a6b352489be3ca9217d31966c24ee02a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a67abb576193ee1ad87882a2b748df865"><td class="memTemplParams" colspan="2">template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a67abb576193ee1ad87882a2b748df865"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classClusterTree.html#a67abb576193ee1ad87882a2b748df865">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim1, Number1 &gt; &amp;cluster_tree)</td></tr>
<tr class="separator:a67abb576193ee1ad87882a2b748df865"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int spacedim, typename Number = double&gt;<br />
class ClusterTree&lt; spacedim, Number &gt;</h3>

<p>Class for cluster tree. </p>
<p>A cluster tree is a binary tree which holds a hierarchy of linked nodes with the type <a class="el" href="classBinaryTreeNode.html" title="Class for binary tree node. ">BinaryTreeNode</a>. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac425245d60967a91905245003e5d46b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac425245d60967a91905245003e5d46b1">&#9670;&nbsp;</a></span>data_const_pointer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classCluster.html">Cluster</a>&lt;spacedim, Number&gt;* <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html#ac425245d60967a91905245003e5d46b1">data_const_pointer_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Const pointer type for the content held by a node in the <a class="el" href="classClusterTree.html" title="Class for cluster tree. ">ClusterTree</a>. </p>

</div>
</div>
<a id="a1d171cbb6b0a8367b4be0d2b87bc9ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d171cbb6b0a8367b4be0d2b87bc9ba8">&#9670;&nbsp;</a></span>data_const_reference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classCluster.html">Cluster</a>&lt;spacedim, Number&gt;&amp; <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html#a1d171cbb6b0a8367b4be0d2b87bc9ba8">data_const_reference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Const reference type for the content held by a node in the <a class="el" href="classClusterTree.html" title="Class for cluster tree. ">ClusterTree</a>. </p>

</div>
</div>
<a id="a87fee1708c95c5575fce3029b79d32a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fee1708c95c5575fce3029b79d32a8">&#9670;&nbsp;</a></span>data_pointer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classCluster.html">Cluster</a>&lt;spacedim, Number&gt;* <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html#a87fee1708c95c5575fce3029b79d32a8">data_pointer_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer type for the content held by a node in the <a class="el" href="classClusterTree.html" title="Class for cluster tree. ">ClusterTree</a>. </p>

</div>
</div>
<a id="ae47bb5a21c1468972b1c2ede0e8aa28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47bb5a21c1468972b1c2ede0e8aa28c">&#9670;&nbsp;</a></span>data_reference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classCluster.html">Cluster</a>&lt;spacedim, Number&gt;&amp; <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html#ae47bb5a21c1468972b1c2ede0e8aa28c">data_reference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reference type for the content held by a node in the <a class="el" href="classClusterTree.html" title="Class for cluster tree. ">ClusterTree</a>. </p>

</div>
</div>
<a id="ab7875a0c5ba927d1d3c5f5212d1d524d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7875a0c5ba927d1d3c5f5212d1d524d">&#9670;&nbsp;</a></span>data_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classCluster.html">Cluster</a>&lt;spacedim, Number&gt; <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html#ab7875a0c5ba927d1d3c5f5212d1d524d">data_value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data type for the content held by a node in the <a class="el" href="classClusterTree.html" title="Class for cluster tree. ">ClusterTree</a>. </p>

</div>
</div>
<a id="acb805fbc20c01a71fa6a00adc959542c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb805fbc20c01a71fa6a00adc959542c">&#9670;&nbsp;</a></span>node_const_pointer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classBinaryTreeNode.html">BinaryTreeNode</a>&lt;<a class="el" href="classCluster.html">Cluster</a>&lt;spacedim, Number&gt; &gt;* <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html#acb805fbc20c01a71fa6a00adc959542c">node_const_pointer_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Const pointer type for a node in the <a class="el" href="classClusterTree.html" title="Class for cluster tree. ">ClusterTree</a>. </p>

</div>
</div>
<a id="ac40955dbfdb9b0beec67a0ecf6810c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40955dbfdb9b0beec67a0ecf6810c8f">&#9670;&nbsp;</a></span>node_const_reference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classBinaryTreeNode.html">BinaryTreeNode</a>&lt;<a class="el" href="classCluster.html">Cluster</a>&lt;spacedim, Number&gt; &gt;&amp; <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html#ac40955dbfdb9b0beec67a0ecf6810c8f">node_const_reference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Const reference type for a node in the <a class="el" href="classClusterTree.html" title="Class for cluster tree. ">ClusterTree</a>. </p>

</div>
</div>
<a id="ae4bb0fdc7ac559d7844d04a00ab3e9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4bb0fdc7ac559d7844d04a00ab3e9de">&#9670;&nbsp;</a></span>node_pointer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classBinaryTreeNode.html">BinaryTreeNode</a>&lt;<a class="el" href="classCluster.html">Cluster</a>&lt;spacedim, Number&gt; &gt;* <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer type for a node in the <a class="el" href="classClusterTree.html" title="Class for cluster tree. ">ClusterTree</a>. </p>

</div>
</div>
<a id="a257ebe4c6eab6581a0b65ba62487ae2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257ebe4c6eab6581a0b65ba62487ae2c">&#9670;&nbsp;</a></span>node_reference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classBinaryTreeNode.html">BinaryTreeNode</a>&lt;<a class="el" href="classCluster.html">Cluster</a>&lt;spacedim, Number&gt; &gt;&amp; <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html#a257ebe4c6eab6581a0b65ba62487ae2c">node_reference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reference type for a node in the <a class="el" href="classClusterTree.html" title="Class for cluster tree. ">ClusterTree</a>. </p>

</div>
</div>
<a id="ab12442ec2508818e1663df6c5a137b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12442ec2508818e1663df6c5a137b05">&#9670;&nbsp;</a></span>node_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classBinaryTreeNode.html">BinaryTreeNode</a>&lt;<a class="el" href="classCluster.html">Cluster</a>&lt;spacedim, Number&gt; &gt; <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html#ab12442ec2508818e1663df6c5a137b05">node_value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data type for a node in the <a class="el" href="classClusterTree.html" title="Class for cluster tree. ">ClusterTree</a>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a28b31e2fbe58c74eff89a1a8e2124e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b31e2fbe58c74eff89a1a8e2124e10">&#9670;&nbsp;</a></span>ClusterTree() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html">ClusterTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor, which initializes an empty binary tree. </p>

</div>
</div>
<a id="ae21fda96c7d405825a853f8759c0cc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21fda96c7d405825a853f8759c0cc4c">&#9670;&nbsp;</a></span>ClusterTree() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html">ClusterTree</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from only an index set without support point and the partition will be only based on the cardinality of the index set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_set</td><td></td></tr>
    <tr><td class="paramname">n_min</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a587c465f14f7fa0e0e6a82aa8733452f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587c465f14f7fa0e0e6a82aa8733452f">&#9670;&nbsp;</a></span>ClusterTree() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html">ClusterTree</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor from a full index set and associated support point coordinates.</p>
<p>This constructor will create the root node of the cluster tree based on the given data. There is no mesh cell size correction for the cluster diameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_set</td><td>The full DoF index set, which will be assigned to the root node. </td></tr>
    <tr><td class="paramname">all_support_points</td><td>All the support points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fd518db632c62cfafb61e9ef56097c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd518db632c62cfafb61e9ef56097c7">&#9670;&nbsp;</a></span>ClusterTree() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html">ClusterTree</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; types::global_dof_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_size_at_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor from a full index set and associated support point coordinates.</p>
<p>This constructor will create the root node of the cluster tree based on the given data. There is mesh cell size correction for the cluster diameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_set</td><td>The full DoF index set, which will be assigned to the root node. </td></tr>
    <tr><td class="paramname">all_support_points</td><td>All the support points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40d41a3a87bee15fe2d0b39a42f705d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d41a3a87bee15fe2d0b39a42f705d2">&#9670;&nbsp;</a></span>ClusterTree() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html">ClusterTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster_tree</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1b0ac0f6474de90d4fb528b6ed28db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b0ac0f6474de90d4fb528b6ed28db6">&#9670;&nbsp;</a></span>~ClusterTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::~<a class="el" href="classClusterTree.html">ClusterTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor which recursively destroys every node in the cluster tree. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1e7dc037d01b3e15f1d6b4eacac59cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7dc037d01b3e15f1d6b4eacac59cb1">&#9670;&nbsp;</a></span>build_leaf_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::build_leaf_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build the leaf set by tree recursion. </p>

<p class="reference">Referenced by <a class="el" href="classClusterTree.html#a40d41a3a87bee15fe2d0b39a42f705d2">ClusterTree&lt; spacedim, double &gt;::ClusterTree()</a>, and <a class="el" href="classClusterTree.html#a3a4e51a1a09f759f085ab140db914af9">ClusterTree&lt; spacedim, double &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a2bd8dd175c4459338d76a8cb879afccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd8dd175c4459338d76a8cb879afccf">&#9670;&nbsp;</a></span>get_depth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::get_depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the tree depth. </p>

</div>
</div>
<a id="af17a96da7f2e5391d3e49028b2aba894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17a96da7f2e5391d3e49028b2aba894">&#9670;&nbsp;</a></span>get_leaf_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a> &gt; &amp; <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::get_leaf_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the block cluster list. </p>

<p class="reference">Referenced by <a class="el" href="block-cluster-tree_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="afbf8f03d5f34305d3c34ae4c360f50ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf8f03d5f34305d3c34ae4c360f50ae">&#9670;&nbsp;</a></span>get_leaf_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; typename <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a> &gt; &amp; <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::get_leaf_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the block cluster list (const version). </p>

</div>
</div>
<a id="a3c1125039b1915ebad94247d6888df31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1125039b1915ebad94247d6888df31">&#9670;&nbsp;</a></span>get_max_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::get_max_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the maximum tree level. </p>

</div>
</div>
<a id="a403e59575a89a3e86e8d7092a8815aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403e59575a89a3e86e8d7092a8815aa5">&#9670;&nbsp;</a></span>get_n_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::get_n_min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the minimum cluster size. </p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#a61d415eda9bfffa9e0aa5492b461edab">BlockClusterTree&lt; 3 &gt;::BlockClusterTree()</a>.</p>

</div>
</div>
<a id="af80051449b7324121fb0a27d5ce7c9a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80051449b7324121fb0a27d5ce7c9a1">&#9670;&nbsp;</a></span>get_node_num()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::get_node_num </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total number of clusters in the tree. </p>

</div>
</div>
<a id="a13132bfc3ca8b70af8c80066565b0adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13132bfc3ca8b70af8c80066565b0adb">&#9670;&nbsp;</a></span>get_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a> <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::get_root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the pointer to the root node of the cluster tree. </p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#a61d415eda9bfffa9e0aa5492b461edab">BlockClusterTree&lt; 3 &gt;::BlockClusterTree()</a>, <a class="el" href="classClusterTree.html#a40d41a3a87bee15fe2d0b39a42f705d2">ClusterTree&lt; spacedim, double &gt;::ClusterTree()</a>, and <a class="el" href="classClusterTree.html#a3a4e51a1a09f759f085ab140db914af9">ClusterTree&lt; spacedim, double &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a3a4e51a1a09f759f085ab140db914af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4e51a1a09f759f085ab140db914af9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp; <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deep assignment operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster_tree</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">Referenced by <a class="el" href="classClusterTree.html#a3a4e51a1a09f759f085ab140db914af9">ClusterTree&lt; spacedim, double &gt;::operator=()</a>, and <a class="el" href="classClusterTree.html#a2dc8b94ebdc4e5efb885940204f614e1">ClusterTree&lt; spacedim, double &gt;::release()</a>.</p>

</div>
</div>
<a id="a9700796d8fb849b3171c0c7d461a2380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9700796d8fb849b3171c0c7d461a2380">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp; <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>cluster_tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shallow assignment operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster_tree</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aa514c3b75864d5f7be72315a30079cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa514c3b75864d5f7be72315a30079cfe">&#9670;&nbsp;</a></span>partition() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::partition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a pure cardinality based recursive partition, which will ultimately be used in constructing an \(\mathcal{H}^p\) matrix for example.</p>
<dl class="section note">
<dt>Note </dt>
<dd><ol type="1">
<li>If the initial complete cluster index set \(I\) is sorted, which is usually \([0, 1, \cdots, N]\), the cardinality based cluster partition produces cluster index sets following the same order, i.e. the cardinality based partition is order preserving.</li>
<li>If the initial complete cluster index set \(I\) is also continuous, i.e. it is a continuous integer array, the cardinality based cluster partition also produces continuous cluster index sets. Hence, the cardinality based partition is continuity preserving.  </li>
</ol>
</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classLaplaceBEM_1_1Erichsen1996Efficient_1_1Example2.html#a4eda45fd98684daa5f951e74c27f0d84">LaplaceBEM::Erichsen1996Efficient::Example2::build_slp_only()</a>, and <a class="el" href="bct-copy-constructor_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a5657415b4b0519f045f3139d1d63e85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5657415b4b0519f045f3139d1d63e85d">&#9670;&nbsp;</a></span>partition() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_support_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a recursive partition dependent on the coordinates of DoF support points by starting from the root node.</p>
<p>In this version, there is no mesh cell size correction to the cluster diameter and cluster pair distance.</p>
<dl class="section note">
<dt>Note </dt>
<dd><ol type="1">
<li>If the initial complete cluster index set \(I\) is sorted, which is usually \([0, 1, \cdots, N]\), the support point coordinates based partition is also order preserving. This is because the two child clusters of the current cluster are built by scanning the index set of the current cluster from beginning to end.</li>
<li>The support point coordinates based partition is not continuity preserving.  </li>
</ol>
</dd>
</dl>

</div>
</div>
<a id="a4d2682986352bb1e44bc73ebfc5a9fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2682986352bb1e44bc73ebfc5a9fdf">&#9670;&nbsp;</a></span>partition() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_size_at_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a recursive partition dependent on the coordinates of DoF support points by starting from the root node.</p>
<p>In this version, there is mesh cell size correction to the cluster diameter and cluster pair distance.</p>
<dl class="section note">
<dt>Note </dt>
<dd><ol type="1">
<li>If the initial complete cluster index set \(I\) is sorted, which is usually \([0, 1, \cdots, N]\), the support point coordinates based partition is also order preserving. This is because the two child clusters of the current cluster are built by scanning the index set of the current cluster from beginning to end.</li>
<li>The support point coordinates based partition is not continuity preserving.  </li>
</ol>
</dd>
</dl>

</div>
</div>
<a id="a8b650f0c7cc83adbde5aad9556a57ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b650f0c7cc83adbde5aad9556a57ac3">&#9670;&nbsp;</a></span>partition_from_cluster_node() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::partition_from_cluster_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a>&#160;</td>
          <td class="paramname"><em>current_cluster_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaf_set_wrt_current_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a pure cardinality based recursive partition by starting from a cluster node.</p>
<dl class="section note">
<dt>Note </dt>
<dd><ol type="1">
<li>If the initial complete cluster index set \(I\) is sorted, which is usually \([0, 1, \cdots, N]\), the cardinality based cluster partition produces cluster index sets following the same order, i.e. the cardinality based partition is order preserving.</li>
<li>If the initial complete cluster index set \(I\) is also continuous, i.e. it is a continuous integer array, the cardinality based cluster partition also produces continuous cluster index sets. Hence, the cardinality based partition is continuity preserving.  </li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_cluster_node</td><td></td></tr>
    <tr><td class="paramname">leaf_set_wrt_current_node</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>When the cardinality of the current cluster is large enough, continue the partition.</p>
<p>Declare the two child index sets.</p>
<p>Split the index set of the current node into halves.</p>
<p>Calculate the splitting index in the middle of the index set, which is to be used for constructing half-closed and half-open subintervals.</p>
<p>Construct the left child index set.</p>
<p>Construct the right child index set.</p>
<p>Append this new node as the left child of the current cluster node.</p>
<p>Continue the recursive partition by starting from this child node.</p>
<p>Merge the leaf set wrt. the child cluster node into the leaf set of the current cluster node.</p>
<p>Append this new node as the right child of the current cluster node.</p>
<p>Continue the recursive partition by starting from this child node.</p>
<p>Merge the leaf set wrt. the child cluster node into the leaf set of the current cluster node.</p>

<p class="reference">Referenced by <a class="el" href="classClusterTree.html#aa514c3b75864d5f7be72315a30079cfe">ClusterTree&lt; spacedim, double &gt;::partition()</a>, and <a class="el" href="classClusterTree.html#a8b650f0c7cc83adbde5aad9556a57ac3">ClusterTree&lt; spacedim, double &gt;::partition_from_cluster_node()</a>.</p>

</div>
</div>
<a id="a6d3636b1686d72909611a6d516f5ee47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3636b1686d72909611a6d516f5ee47">&#9670;&nbsp;</a></span>partition_from_cluster_node() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::partition_from_cluster_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a>&#160;</td>
          <td class="paramname"><em>current_cluster_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaf_set_wrt_current_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a recursive partition dependent on the coordinates of DoF support points by starting from a cluster node.</p>
<p>In this version, there is no mesh cell size correction to the cluster diameter and cluster pair distance.</p>
<dl class="section note">
<dt>Note </dt>
<dd><ol type="1">
<li>If the initial complete cluster index set \(I\) is sorted, which is usually \([0, 1, \cdots, N]\), the support point coordinates based partition is also order preserving. This is because the two child clusters of the current cluster are built by scanning the index set of the current cluster from beginning to end.</li>
<li>The support point coordinates based partition is not continuity preserving.  </li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">all_support_points</td><td>All the support points. </td></tr>
  </table>
  </dd>
</dl>
<p>When the size/cardinality of the current cluster is large enough, continue the partition.</p>
<p>Divide the bounding box of the current cluster into halves.</p>
<p>Declare the two child index sets.</p>
<p>Determine to which child index set each support point in the original bounding box belongs to.</p>
<p>If the support point associated with the current DoF index belongs to the left child box, add this DoF index to the left child index set.</p>
<p>Otherwise, add this DoF index to the right child index set.</p>
<p>N.B. During the creation of the new child cluster, its bounding box will be recalculated, which may be smaller than the child bounding box obtained from the previous bounding box geometric bisection.</p>
<p>Append this new node as the left child of the current cluster node.</p>
<p>Continue the recursive partition by starting from this child node.</p>
<p>Merge the leaf set wrt. the child cluster node into the leaf set of the current cluster node.</p>
<p>N.B. During the creation of the new child cluster, its bounding box will be recalculated, which may be smaller than the child bounding box obtained from the previous bounding box geometric bisection.</p>
<p>Append this new node as the right child of the current cluster node.</p>
<p>Continue the recursive partition by starting from this child node.</p>
<p>Merge the leaf set wrt. the child cluster node into the leaf set of the current cluster node.</p>

</div>
</div>
<a id="a8b853c36834044df5283fca9e03d39d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b853c36834044df5283fca9e03d39d2">&#9670;&nbsp;</a></span>partition_from_cluster_node() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::partition_from_cluster_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a>&#160;</td>
          <td class="paramname"><em>current_cluster_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_size_at_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classClusterTree.html#ae4bb0fdc7ac559d7844d04a00ab3e9de">node_pointer_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaf_set_wrt_current_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a recursive partition dependent on the coordinates of DoF support points by starting from a cluster node.</p>
<p>In this version, there is mesh cell size correction to the cluster diameter and cluster pair distance.</p>
<dl class="section note">
<dt>Note </dt>
<dd><ol type="1">
<li>If the initial complete cluster index set \(I\) is sorted, which is usually \([0, 1, \cdots, N]\), the support point coordinates based partition is also order preserving. This is because the two child clusters of the current cluster are built by scanning the index set of the current cluster from beginning to end.</li>
<li>The support point coordinates based partition is not continuity preserving.  </li>
</ol>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">all_support_points</td><td>All the support points. </td></tr>
  </table>
  </dd>
</dl>
<p>When the size/cardinality of the current cluster is large enough, continue the partition.</p>
<p>Divide the bounding box of the current cluster into halves.</p>
<p>Declare the two child index sets.</p>
<p>Determine to which child index set each support point in the original bounding box belongs to.</p>
<p>If the support point associated with the current DoF index belongs to the left child box, add this DoF index to the left child index set.</p>
<p>Otherwise, add this DoF index to the right child index set.</p>
<p>N.B. During the creation of the new child cluster, its bounding box will be recalculated, which may be smaller than the child bounding box obtained from the previous bounding box geometric bisection.</p>
<p>Append this new node as the left child of the current cluster node.</p>
<p>Continue the recursive partition by starting from this child node.</p>
<p>Merge the leaf set wrt. the child cluster node into the leaf set of the current cluster node.</p>
<p>N.B. During the creation of the new child cluster, its bounding box will be recalculated, which may be smaller than the child bounding box obtained from the previous bounding box geometric bisection.</p>
<p>Append this new node as the right child of the current cluster node.</p>
<p>Continue the recursive partition by starting from this child node.</p>
<p>Merge the leaf set wrt. the child cluster node into the leaf set of the current cluster node.</p>

</div>
</div>
<a id="a2dc8b94ebdc4e5efb885940204f614e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc8b94ebdc4e5efb885940204f614e1">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the memory and status of the cluster tree hierarchy. </p>

<p class="reference">Referenced by <a class="el" href="classClusterTree.html#a3a4e51a1a09f759f085ab140db914af9">ClusterTree&lt; spacedim, double &gt;::operator=()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a67abb576193ee1ad87882a2b748df865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67abb576193ee1ad87882a2b748df865">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;int spacedim1, typename Number1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim1, Number1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print a whole cluster tree using recursion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">cluster_tree</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa9705d3fecd5b405b804331ea031570c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9705d3fecd5b405b804331ea031570c">&#9670;&nbsp;</a></span>child_num</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::child_num = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of children in a cluster tree.</p>
<p>At present, only binary tree is allowed. </p>

</div>
</div>
<a id="a051df20340ed3f0e4bc0ee1fb1119f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051df20340ed3f0e4bc0ee1fb1119f9f">&#9670;&nbsp;</a></span>depth</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::depth</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Depth of the tree, which is the maximum level plus one. </p>

<p class="reference">Referenced by <a class="el" href="classClusterTree.html#ae21fda96c7d405825a853f8759c0cc4c">ClusterTree&lt; spacedim, double &gt;::ClusterTree()</a>, <a class="el" href="classClusterTree.html#a2bd8dd175c4459338d76a8cb879afccf">ClusterTree&lt; spacedim, double &gt;::get_depth()</a>, <a class="el" href="classClusterTree.html#a3a4e51a1a09f759f085ab140db914af9">ClusterTree&lt; spacedim, double &gt;::operator=()</a>, <a class="el" href="classClusterTree.html#aa514c3b75864d5f7be72315a30079cfe">ClusterTree&lt; spacedim, double &gt;::partition()</a>, and <a class="el" href="classClusterTree.html#a2dc8b94ebdc4e5efb885940204f614e1">ClusterTree&lt; spacedim, double &gt;::release()</a>.</p>

</div>
</div>
<a id="a77800bb9f86c689821ba4d549ce97a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77800bb9f86c689821ba4d549ce97a58">&#9670;&nbsp;</a></span>max_level</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::max_level</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum level of the cluster tree, which is <code>depth</code> - 1. </p>

<p class="reference">Referenced by <a class="el" href="classClusterTree.html#ae21fda96c7d405825a853f8759c0cc4c">ClusterTree&lt; spacedim, double &gt;::ClusterTree()</a>, <a class="el" href="classClusterTree.html#a3c1125039b1915ebad94247d6888df31">ClusterTree&lt; spacedim, double &gt;::get_max_level()</a>, <a class="el" href="classClusterTree.html#a3a4e51a1a09f759f085ab140db914af9">ClusterTree&lt; spacedim, double &gt;::operator=()</a>, <a class="el" href="classClusterTree.html#aa514c3b75864d5f7be72315a30079cfe">ClusterTree&lt; spacedim, double &gt;::partition()</a>, and <a class="el" href="classClusterTree.html#a2dc8b94ebdc4e5efb885940204f614e1">ClusterTree&lt; spacedim, double &gt;::release()</a>.</p>

</div>
</div>
<a id="a5af4448800c4ddc98121706754bfe3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af4448800c4ddc98121706754bfe3f9">&#9670;&nbsp;</a></span>n_min</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::n_min</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Minimum cluster size, which is used as the condition for stopping box division. </p>

<p class="reference">Referenced by <a class="el" href="classClusterTree.html#a403e59575a89a3e86e8d7092a8815aa5">ClusterTree&lt; spacedim, double &gt;::get_n_min()</a>, <a class="el" href="classClusterTree.html#a3a4e51a1a09f759f085ab140db914af9">ClusterTree&lt; spacedim, double &gt;::operator=()</a>, <a class="el" href="classClusterTree.html#a8b650f0c7cc83adbde5aad9556a57ac3">ClusterTree&lt; spacedim, double &gt;::partition_from_cluster_node()</a>, and <a class="el" href="classClusterTree.html#a2dc8b94ebdc4e5efb885940204f614e1">ClusterTree&lt; spacedim, double &gt;::release()</a>.</p>

</div>
</div>
<a id="a6b352489be3ca9217d31966c24ee02a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b352489be3ca9217d31966c24ee02a1">&#9670;&nbsp;</a></span>node_num</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::node_num</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of clusters in the tree. </p>

<p class="reference">Referenced by <a class="el" href="classClusterTree.html#ae21fda96c7d405825a853f8759c0cc4c">ClusterTree&lt; spacedim, double &gt;::ClusterTree()</a>, <a class="el" href="classClusterTree.html#af80051449b7324121fb0a27d5ce7c9a1">ClusterTree&lt; spacedim, double &gt;::get_node_num()</a>, <a class="el" href="classClusterTree.html#a3a4e51a1a09f759f085ab140db914af9">ClusterTree&lt; spacedim, double &gt;::operator=()</a>, <a class="el" href="classClusterTree.html#a8b650f0c7cc83adbde5aad9556a57ac3">ClusterTree&lt; spacedim, double &gt;::partition_from_cluster_node()</a>, and <a class="el" href="classClusterTree.html#a2dc8b94ebdc4e5efb885940204f614e1">ClusterTree&lt; spacedim, double &gt;::release()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/jihuan/Projects/deal.ii/program/dealii-9.1.1/examples/laplace-bem/include/<a class="el" href="cluster__tree_8h_source.html">cluster_tree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
