<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>laplace-bem: BlockClusterTree&lt; spacedim, Number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    skipTags: ["script","noscript","style","textarea","pre","code"],
    processEscapes: false,
    processEnvironments: true,
    preview: "TeX"
  },
  TeX: {
    Macros: {
      intd: "\\,{\\rm d}",
      diff: "{\\rm d}",
      Diff: "{\\rm D}",
      pdiff: "\\partial",
      DD: ["\\frac{\\diff}{\\diff #2}\\left( #1 \\right)", 2],
      Dd: ["\\frac{\\diff #1}{\\diff #2}", 2],
      PD: ["\\frac{\\pdiff}{\\pdiff #2}\\left( #1 \\right)", 2],
      Pd: ["\\frac{\\pdiff #1}{\\pdiff #2}", 2],
      rme: "{\\rm e}",
      rmi: "{\\rm i}",
      rmj: "{\\rm j}",
      vect: ["\\boldsymbol{#1}", 1],
      dform: ["\\overset{\\rightharpoonup}{\\boldsymbol{#1}}", 1],
      cochain: ["\\overset{\\rightharpoonup}{#1}", 1],
      Abs: ["\\big\\lvert#1\\big\\rvert", 1],
      abs: ["\\lvert#1\\rvert", 1],
      Norm: ["\\big\\lVert#1\\big\\rVert", 1],
      norm: ["\\lVert#1\\rVert", 1],
      normvect: "\\vect{n}",
      ouset: ["\\overset{#3}{\\underset{#2}{#1}}", 3],
      cscript: ["\\;\\; #1", 1],
      suchthat: "\\textit{S.T.\\;}",
      prefstar: "\\ast",
      restrict: "\\big\\vert",
      sgn: "{\\rm sgn}",
      erf: "{\\rm erf}",
      Bd: "{\\rm Bd}",
      Int: "{\\rm Int}",
      rank: "{\\rm rank}",
      divergence: "{\\rm div}",
      grad: "{\\rm grad}",
      tr: "{\\rm tr}",
      span: "{\\rm span}"
    },
    extensions: ["AMScd.js"],
    equationNumbers: { autoNumber: "AMS" }
  },
  "HTML-CSS": {
     availableFonts: ["STIX","TeX"],
     preferredFont: "TeX",
     webFont: "TeX",
     imageFont: "TeX",
     showMathMenu: true
  },
  MMLorHTML: {
    prefer: {
      MSIE:    "MML",
      Firefox: "MML",
      Opera:   "HTML",
      other:   "HTML"
    }
  }
});
</script><script type="text/javascript" src="http://localhost/js/MathJax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">laplace-bem
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Solve Laplace problem using the boundary element method (BEM)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classBlockClusterTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BlockClusterTree&lt; spacedim, Number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__hierarchical__matrices.html">Hierarchical matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for block cluster tree.  
 <a href="classBlockClusterTree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="block__cluster__tree_8h_source.html">block_cluster_tree.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for BlockClusterTree&lt; spacedim, Number &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classBlockClusterTree__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a960c20eac27464dedd804261f185c61f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTreeNode.html">TreeNode</a>&lt; <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt;, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">child_num</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a960c20eac27464dedd804261f185c61f">node_value_type</a></td></tr>
<tr class="separator:a960c20eac27464dedd804261f185c61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe6521e231371ee47687fc4ada1734a"><td class="memItemLeft" align="right" valign="top"><a id="a0fe6521e231371ee47687fc4ada1734a"></a>
typedef <a class="el" href="classTreeNode.html">TreeNode</a>&lt; <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt;, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">child_num</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>node_pointer_type</b></td></tr>
<tr class="separator:a0fe6521e231371ee47687fc4ada1734a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae009f8c6e64ac756770678366cf5e924"><td class="memItemLeft" align="right" valign="top"><a id="ae009f8c6e64ac756770678366cf5e924"></a>
typedef const <a class="el" href="classTreeNode.html">TreeNode</a>&lt; <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt;, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">child_num</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>node_const_pointer_type</b></td></tr>
<tr class="separator:ae009f8c6e64ac756770678366cf5e924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff2ef08707f864bce5da02be6f9f8a9"><td class="memItemLeft" align="right" valign="top"><a id="acff2ef08707f864bce5da02be6f9f8a9"></a>
typedef <a class="el" href="classTreeNode.html">TreeNode</a>&lt; <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt;, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">child_num</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>node_reference_type</b></td></tr>
<tr class="separator:acff2ef08707f864bce5da02be6f9f8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5dc9f60e63b4024045d1c0c41f92f5a"><td class="memItemLeft" align="right" valign="top"><a id="ac5dc9f60e63b4024045d1c0c41f92f5a"></a>
typedef const <a class="el" href="classTreeNode.html">TreeNode</a>&lt; <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt;, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">child_num</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>node_const_reference_type</b></td></tr>
<tr class="separator:ac5dc9f60e63b4024045d1c0c41f92f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d03fe184a7f7838111b27cdae056a62"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a4d03fe184a7f7838111b27cdae056a62">data_value_type</a></td></tr>
<tr class="separator:a4d03fe184a7f7838111b27cdae056a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0480a48aa335fd1adeec9ffdc8086193"><td class="memItemLeft" align="right" valign="top"><a id="a0480a48aa335fd1adeec9ffdc8086193"></a>
typedef <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>data_pointer_type</b></td></tr>
<tr class="separator:a0480a48aa335fd1adeec9ffdc8086193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179b726b207148de1b866d5c36915809"><td class="memItemLeft" align="right" valign="top"><a id="a179b726b207148de1b866d5c36915809"></a>
typedef const <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>data_const_pointer_type</b></td></tr>
<tr class="separator:a179b726b207148de1b866d5c36915809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62869615d2fd6ec6bf58163e3b36bca1"><td class="memItemLeft" align="right" valign="top"><a id="a62869615d2fd6ec6bf58163e3b36bca1"></a>
typedef <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>data_reference_type</b></td></tr>
<tr class="separator:a62869615d2fd6ec6bf58163e3b36bca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae82489506a1d2a0ff3cf0a4039b9f9"><td class="memItemLeft" align="right" valign="top"><a id="a3ae82489506a1d2a0ff3cf0a4039b9f9"></a>
typedef const <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim, Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>data_const_reference_type</b></td></tr>
<tr class="separator:a3ae82489506a1d2a0ff3cf0a4039b9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a967049a8deecb49c36492ffdf64349cd"><td class="memItemLeft" align="right" valign="top"><a id="a967049a8deecb49c36492ffdf64349cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DeclException2</b> (ExcClusterLevelMismatch, unsigned int, unsigned int,&lt;&lt; &quot;The level of cluster tau &quot;&lt;&lt; arg1&lt;&lt; &quot; is different from that of cluster sigma&quot;&lt;&lt; arg2&lt;&lt; &quot; which is not allowed in a level preserving construction of a block cluster tree.&quot;)</td></tr>
<tr class="separator:a967049a8deecb49c36492ffdf64349cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a000c439b578bcf4fa28b7f3edd6079e9"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">child_num</a> = 4</td></tr>
<tr class="separator:a000c439b578bcf4fa28b7f3edd6079e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac1111e02e99c25545857e6ce85c73fa0"><td class="memItemLeft" align="right" valign="top"><a id="ac1111e02e99c25545857e6ce85c73fa0"></a>
<a class="el" href="classTreeNode.html">node_pointer_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>root_node</b></td></tr>
<tr class="separator:ac1111e02e99c25545857e6ce85c73fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a070c8bebf3afb8eac8348be3cae226"><td class="memItemLeft" align="right" valign="top"><a id="a4a070c8bebf3afb8eac8348be3cae226"></a>
std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>leaf_set</b></td></tr>
<tr class="separator:a4a070c8bebf3afb8eac8348be3cae226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ff2520dacea664e08437b3bc54034a"><td class="memItemLeft" align="right" valign="top"><a id="a91ff2520dacea664e08437b3bc54034a"></a>
std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>near_field_set</b></td></tr>
<tr class="separator:a91ff2520dacea664e08437b3bc54034a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb80508e2eceac6545cdbac7310fcaa3"><td class="memItemLeft" align="right" valign="top"><a id="afb80508e2eceac6545cdbac7310fcaa3"></a>
std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>far_field_set</b></td></tr>
<tr class="separator:afb80508e2eceac6545cdbac7310fcaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47a6ccabcf386897ea3fa4341827c25"><td class="memItemLeft" align="right" valign="top"><a id="ab47a6ccabcf386897ea3fa4341827c25"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>n_min</b></td></tr>
<tr class="separator:ab47a6ccabcf386897ea3fa4341827c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa858180dc35e877eb64ab2afd1baef"><td class="memItemLeft" align="right" valign="top"><a id="affa858180dc35e877eb64ab2afd1baef"></a>
Number&#160;</td><td class="memItemRight" valign="bottom"><b>eta</b></td></tr>
<tr class="separator:affa858180dc35e877eb64ab2afd1baef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77349ec9ccb36d45af3f176a93516897"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a77349ec9ccb36d45af3f176a93516897">depth</a></td></tr>
<tr class="separator:a77349ec9ccb36d45af3f176a93516897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9151f138713d01c53ac17f004c7e6b62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a9151f138713d01c53ac17f004c7e6b62">max_level</a></td></tr>
<tr class="separator:a9151f138713d01c53ac17f004c7e6b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75757146cea0aa0e9271b760b1d76307"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a75757146cea0aa0e9271b760b1d76307">node_num</a></td></tr>
<tr class="separator:a75757146cea0aa0e9271b760b1d76307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc01af98989bb71246fa2cd4d7307da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a8dc01af98989bb71246fa2cd4d7307da">is_subtree</a></td></tr>
<tr class="separator:a8dc01af98989bb71246fa2cd4d7307da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6ead7d49add78a2462eb039f00bf7f6a"><td class="memTemplParams" colspan="2">template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a6ead7d49add78a2462eb039f00bf7f6a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a6ead7d49add78a2462eb039f00bf7f6a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt; &amp;block_cluster_tree)</td></tr>
<tr class="separator:a6ead7d49add78a2462eb039f00bf7f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f70501fa33bdb6761b998978b59f1b0"><td class="memTemplParams" colspan="2"><a id="a3f70501fa33bdb6761b998978b59f1b0"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a3f70501fa33bdb6761b998978b59f1b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>split_block_cluster_node</b> (<a class="el" href="classTreeNode.html">TreeNode</a>&lt; <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim1, Number1 &gt;, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::<a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">child_num</a> &gt; *bc_node, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt; &amp;bc_tree, const <a class="el" href="tree_8h.html#a922ca07db9633957939f697a65aff11d">TreeNodeSplitMode</a> split_mode, const bool if_add_child_nodes_to_leaf_set)</td></tr>
<tr class="separator:a3f70501fa33bdb6761b998978b59f1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75196d39c6db593dfdaa17f0f0cd8042"><td class="memTemplParams" colspan="2"><a id="a75196d39c6db593dfdaa17f0f0cd8042"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a75196d39c6db593dfdaa17f0f0cd8042"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>prune_to_partition_recursion</b> (<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt; &amp;bct, const std::vector&lt; <a class="el" href="classTreeNode.html">TreeNode</a>&lt; <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim1, Number1 &gt;, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::<a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">child_num</a> &gt; *&gt; &amp;<a class="el" href="classBlockClusterTree.html#a3ca42421f732c20fc07bdf5d5ab94319">partition</a>, <a class="el" href="classTreeNode.html">TreeNode</a>&lt; <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim1, Number1 &gt;, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::<a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">child_num</a> &gt; *bc_node)</td></tr>
<tr class="separator:a75196d39c6db593dfdaa17f0f0cd8042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be1a37fb4e8389d1035c532102aa20b"><td class="memTemplParams" colspan="2"><a id="a4be1a37fb4e8389d1035c532102aa20b"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a4be1a37fb4e8389d1035c532102aa20b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTreeNode.html">TreeNode</a>&lt; <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim1, Number1 &gt;, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::<a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">child_num</a> &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_bc_node_in_partition_intersect_current_bc_node</b> (<a class="el" href="classTreeNode.html">TreeNode</a>&lt; <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim1, Number1 &gt;, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::<a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">child_num</a> &gt; *current_bc_node, const std::vector&lt; <a class="el" href="classTreeNode.html">TreeNode</a>&lt; <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim1, Number1 &gt;, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::<a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">child_num</a> &gt; *&gt; &amp;<a class="el" href="classBlockClusterTree.html#a3ca42421f732c20fc07bdf5d5ab94319">partition</a>)</td></tr>
<tr class="separator:a4be1a37fb4e8389d1035c532102aa20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5de5c860d62a2e28791afdbb2e2d72"><td class="memTemplParams" colspan="2"><a id="a1b5de5c860d62a2e28791afdbb2e2d72"></a>
template&lt;int spacedim1, typename Number1 &gt; </td></tr>
<tr class="memitem:a1b5de5c860d62a2e28791afdbb2e2d72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTreeNode.html">TreeNode</a>&lt; <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim1, Number1 &gt;, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::<a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">child_num</a> &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_bc_node_in_partition_proper_subset_of_current_bc_node</b> (<a class="el" href="classTreeNode.html">TreeNode</a>&lt; <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim1, Number1 &gt;, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::<a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">child_num</a> &gt; *current_bc_node, const std::vector&lt; <a class="el" href="classTreeNode.html">TreeNode</a>&lt; <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt; spacedim1, Number1 &gt;, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt;::<a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">child_num</a> &gt; *&gt; &amp;<a class="el" href="classBlockClusterTree.html#a3ca42421f732c20fc07bdf5d5ab94319">partition</a>)</td></tr>
<tr class="separator:a1b5de5c860d62a2e28791afdbb2e2d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b1ec6a9e81c252b1994c5a99c44af4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a20b1ec6a9e81c252b1994c5a99c44af4">BlockClusterTree</a> ()</td></tr>
<tr class="separator:a20b1ec6a9e81c252b1994c5a99c44af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d415eda9bfffa9e0aa5492b461edab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a61d415eda9bfffa9e0aa5492b461edab">BlockClusterTree</a> (const <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp;TI, const <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp;TJ, const unsigned int n_min=0)</td></tr>
<tr class="separator:a61d415eda9bfffa9e0aa5492b461edab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3073c9b5669e356c9c37ccd0a13ed8b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a3073c9b5669e356c9c37ccd0a13ed8b3">BlockClusterTree</a> (typename <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classTreeNode.html">node_pointer_type</a> tau_root_node, typename <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classTreeNode.html">node_pointer_type</a> sigma_root_node, const unsigned int n_min=1)</td></tr>
<tr class="separator:a3073c9b5669e356c9c37ccd0a13ed8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6087e8fe7dc3d737ff6b4cd97070fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#ace6087e8fe7dc3d737ff6b4cd97070fc">BlockClusterTree</a> (<a class="el" href="classTreeNode.html">node_pointer_type</a> bc_node, const unsigned int n_min)</td></tr>
<tr class="separator:ace6087e8fe7dc3d737ff6b4cd97070fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522ad51298f5b58b948e435a9e2d2a40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a522ad51298f5b58b948e435a9e2d2a40">BlockClusterTree</a> (<a class="el" href="classTreeNode.html">node_pointer_type</a> bc_node, const Number eta, const unsigned int n_min)</td></tr>
<tr class="separator:a522ad51298f5b58b948e435a9e2d2a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb93288ece0e153eb5843d1df21a2a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#aefb93288ece0e153eb5843d1df21a2a6">BlockClusterTree</a> (const <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp;TI, const <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp;TJ, const Number eta, const unsigned int n_min)</td></tr>
<tr class="separator:aefb93288ece0e153eb5843d1df21a2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c31aecfd91383f8b96601fd2b63dd62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a1c31aecfd91383f8b96601fd2b63dd62">BlockClusterTree</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct)</td></tr>
<tr class="separator:a1c31aecfd91383f8b96601fd2b63dd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3bb67cdcb7868237063c8003d4079ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#ae3bb67cdcb7868237063c8003d4079ab">BlockClusterTree</a> (<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&amp;bct)</td></tr>
<tr class="separator:ae3bb67cdcb7868237063c8003d4079ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85553cc442e419b8d707720312118328"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a85553cc442e419b8d707720312118328">operator=</a> (const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;bct)</td></tr>
<tr class="separator:a85553cc442e419b8d707720312118328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa635be81dfabed3ba455a17de3b65c2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#aa635be81dfabed3ba455a17de3b65c2e">operator=</a> (<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&amp;bct)</td></tr>
<tr class="separator:aa635be81dfabed3ba455a17de3b65c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b969867200b06f3416647c3e4f9f61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a43b969867200b06f3416647c3e4f9f61">~BlockClusterTree</a> ()</td></tr>
<tr class="separator:a43b969867200b06f3416647c3e4f9f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0415fe94fd480bbb985a45dc691e2bed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a0415fe94fd480bbb985a45dc691e2bed">release</a> ()</td></tr>
<tr class="separator:a0415fe94fd480bbb985a45dc691e2bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4227d666cd2872fbbfb4eec69e66313"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#ab4227d666cd2872fbbfb4eec69e66313">clear</a> ()</td></tr>
<tr class="separator:ab4227d666cd2872fbbfb4eec69e66313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10f54639969bc4aacd6aa27cf315610"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#ab10f54639969bc4aacd6aa27cf315610">partition_tensor_product</a> ()</td></tr>
<tr class="separator:ab10f54639969bc4aacd6aa27cf315610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e40b3884535eae57d00c078ec782459"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a0e40b3884535eae57d00c078ec782459">partition_coarse_non_tensor_product</a> ()</td></tr>
<tr class="separator:a0e40b3884535eae57d00c078ec782459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d23af20c52c7b32eb080bd54556206"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#ac6d23af20c52c7b32eb080bd54556206">partition_fine_non_tensor_product</a> ()</td></tr>
<tr class="separator:ac6d23af20c52c7b32eb080bd54556206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca42421f732c20fc07bdf5d5ab94319"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a3ca42421f732c20fc07bdf5d5ab94319">partition</a> (const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;all_support_points)</td></tr>
<tr class="separator:a3ca42421f732c20fc07bdf5d5ab94319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075983197c805c6451aa00502dc30e76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a075983197c805c6451aa00502dc30e76">partition</a> (const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;all_support_points, const std::vector&lt; Number &gt; &amp;cell_size_at_dofs)</td></tr>
<tr class="separator:a075983197c805c6451aa00502dc30e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4a4da89b964559cc02ecbf13ad4a4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a3c4a4da89b964559cc02ecbf13ad4a4b">extend_finer_than_partition</a> (const std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;<a class="el" href="classBlockClusterTree.html#a3ca42421f732c20fc07bdf5d5ab94319">partition</a>)</td></tr>
<tr class="separator:a3c4a4da89b964559cc02ecbf13ad4a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe18d32a3c05a9209a5cdc9270b47d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#adfe18d32a3c05a9209a5cdc9270b47d7">extend_to_finer_partition</a> (const std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;<a class="el" href="classBlockClusterTree.html#a3ca42421f732c20fc07bdf5d5ab94319">partition</a>)</td></tr>
<tr class="separator:adfe18d32a3c05a9209a5cdc9270b47d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd771b68a4c7195151f6dc02e8ec7e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a6fd771b68a4c7195151f6dc02e8ec7e9">prune_descendants_from_node</a> (<a class="el" href="classTreeNode.html">node_pointer_type</a> bc_node)</td></tr>
<tr class="separator:a6fd771b68a4c7195151f6dc02e8ec7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1663a109b6fd5c67c85e9bb88a54a13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#af1663a109b6fd5c67c85e9bb88a54a13">prune_to_partition</a> (const std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;<a class="el" href="classBlockClusterTree.html#a3ca42421f732c20fc07bdf5d5ab94319">partition</a>, const bool is_partition_in_bct)</td></tr>
<tr class="separator:af1663a109b6fd5c67c85e9bb88a54a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4f3b893380d1d7f53b772589a847d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTreeNode.html">node_pointer_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a4a4f3b893380d1d7f53b772589a847d2">get_root</a> () const</td></tr>
<tr class="separator:a4a4f3b893380d1d7f53b772589a847d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162b396d814b420f96289425529852e9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a162b396d814b420f96289425529852e9">get_leaf_set</a> ()</td></tr>
<tr class="separator:a162b396d814b420f96289425529852e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c3d1ad3aa983ea1d0b711914664b4c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a38c3d1ad3aa983ea1d0b711914664b4c">get_leaf_set</a> () const</td></tr>
<tr class="separator:a38c3d1ad3aa983ea1d0b711914664b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3396fbedf6ec07cce9c23a62b2c30b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a1b3396fbedf6ec07cce9c23a62b2c30b">build_leaf_set</a> ()</td></tr>
<tr class="separator:a1b3396fbedf6ec07cce9c23a62b2c30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef01b51b0530536bc5481492d4719375"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#aef01b51b0530536bc5481492d4719375">write_leaf_set</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:aef01b51b0530536bc5481492d4719375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652b1c53dff2794e2f18343bf3988e19"><td class="memTemplParams" colspan="2">template&lt;typename Number1  = double&gt; </td></tr>
<tr class="memitem:a652b1c53dff2794e2f18343bf3988e19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a652b1c53dff2794e2f18343bf3988e19">write_leaf_set</a> (std::ostream &amp;out, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;matrix, const Number1 singular_value_threshold=0.) const</td></tr>
<tr class="separator:a652b1c53dff2794e2f18343bf3988e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f61b31f1e9cf869831fa4c8232df81"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a82f61b31f1e9cf869831fa4c8232df81">get_near_field_set</a> ()</td></tr>
<tr class="separator:a82f61b31f1e9cf869831fa4c8232df81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac71437177d14012c12f7b4f354cdd1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a6ac71437177d14012c12f7b4f354cdd1">get_near_field_set</a> () const</td></tr>
<tr class="separator:a6ac71437177d14012c12f7b4f354cdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2980726dc3789773b5cd3c04df5e69a3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a2980726dc3789773b5cd3c04df5e69a3">get_far_field_set</a> ()</td></tr>
<tr class="separator:a2980726dc3789773b5cd3c04df5e69a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93763855c84100e1a9da3080737295f4"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a93763855c84100e1a9da3080737295f4">get_far_field_set</a> () const</td></tr>
<tr class="separator:a93763855c84100e1a9da3080737295f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00acda5e8fd4c3e381637d8d9322923"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#ab00acda5e8fd4c3e381637d8d9322923">get_n_min</a> () const</td></tr>
<tr class="separator:ab00acda5e8fd4c3e381637d8d9322923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312d01ddb6cf5560d84abf7d254fa2c3"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a312d01ddb6cf5560d84abf7d254fa2c3">get_eta</a> () const</td></tr>
<tr class="separator:a312d01ddb6cf5560d84abf7d254fa2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c57acfcc5dfbbef04f028e6b9c749d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#ab6c57acfcc5dfbbef04f028e6b9c749d">get_depth</a> () const</td></tr>
<tr class="separator:ab6c57acfcc5dfbbef04f028e6b9c749d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9dbea25751771830c72d09efacacb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a7f9dbea25751771830c72d09efacacb2">calc_depth_and_max_level</a> ()</td></tr>
<tr class="separator:a7f9dbea25751771830c72d09efacacb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404693ef7dfdbc383705c38105c75e14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a404693ef7dfdbc383705c38105c75e14">get_max_level</a> () const</td></tr>
<tr class="separator:a404693ef7dfdbc383705c38105c75e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042e040d2f6dfcbbfd70b43b8967c6f6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a042e040d2f6dfcbbfd70b43b8967c6f6">get_node_num</a> () const</td></tr>
<tr class="separator:a042e040d2f6dfcbbfd70b43b8967c6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02be4a882acca918386ad024769925bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a02be4a882acca918386ad024769925bc">set_node_num</a> (unsigned int <a class="el" href="classBlockClusterTree.html#a75757146cea0aa0e9271b760b1d76307">node_num</a>)</td></tr>
<tr class="separator:a02be4a882acca918386ad024769925bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9920e5b215fbfe2aa9f54980d3b30a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#aec9920e5b215fbfe2aa9f54980d3b30a">increase_node_num</a> (unsigned int increased_node_num=1)</td></tr>
<tr class="separator:aec9920e5b215fbfe2aa9f54980d3b30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e55e3ac56bffa31f251d4f07ae7e51"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#ae0e55e3ac56bffa31f251d4f07ae7e51">decrease_node_num</a> (unsigned int decreased_node_num=1)</td></tr>
<tr class="separator:ae0e55e3ac56bffa31f251d4f07ae7e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286bd48cc863cbba7c9ad53b6bdb12ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a286bd48cc863cbba7c9ad53b6bdb12ca">categorize_near_and_far_field_sets</a> ()</td></tr>
<tr class="separator:a286bd48cc863cbba7c9ad53b6bdb12ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77f8167ce49871f5751b8dcf8c93153"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#ae77f8167ce49871f5751b8dcf8c93153">partition_tensor_product_from_block_cluster_node</a> (<a class="el" href="classTreeNode.html">node_pointer_type</a> current_block_cluster_node, std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;leaf_set_wrt_current_node)</td></tr>
<tr class="separator:ae77f8167ce49871f5751b8dcf8c93153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b6c204f3f1d5ff7c71a07b26ca9d09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a61b6c204f3f1d5ff7c71a07b26ca9d09">partition_coarse_non_tensor_product_from_block_cluster_node</a> (<a class="el" href="classTreeNode.html">node_pointer_type</a> current_block_cluster_node, std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;leaf_set_wrt_current_node)</td></tr>
<tr class="separator:a61b6c204f3f1d5ff7c71a07b26ca9d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6354696477c8cae61d362b5ec707034"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#aa6354696477c8cae61d362b5ec707034">partition_fine_non_tensor_product_from_block_cluster_node</a> (<a class="el" href="classTreeNode.html">node_pointer_type</a> current_block_cluster_node, std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;leaf_set_wrt_current_node)</td></tr>
<tr class="separator:aa6354696477c8cae61d362b5ec707034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafad0fae48bf7c462e8e943b76893fc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#aafad0fae48bf7c462e8e943b76893fc0">partition_fine_non_tensor_product_from_block_cluster_node_N</a> (<a class="el" href="classTreeNode.html">node_pointer_type</a> current_block_cluster_node, std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;leaf_set_wrt_current_node)</td></tr>
<tr class="separator:aafad0fae48bf7c462e8e943b76893fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdeb6723e01b5eaf11281e2c1c1cf566"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#afdeb6723e01b5eaf11281e2c1c1cf566">partition_fine_non_tensor_product_from_block_cluster_node_Nstar</a> (<a class="el" href="classTreeNode.html">node_pointer_type</a> current_block_cluster_node, std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;leaf_set_wrt_current_node)</td></tr>
<tr class="separator:afdeb6723e01b5eaf11281e2c1c1cf566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11fb277e43c33f2a399dc6b1c14b998"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#ad11fb277e43c33f2a399dc6b1c14b998">partition_from_block_cluster_node</a> (<a class="el" href="classTreeNode.html">node_pointer_type</a> current_block_cluster_node, const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;all_support_points, std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;leaf_set_wrt_current_node)</td></tr>
<tr class="separator:ad11fb277e43c33f2a399dc6b1c14b998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425583a70d63ddbf9341a31b736bd0fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a425583a70d63ddbf9341a31b736bd0fe">partition_from_block_cluster_node</a> (<a class="el" href="classTreeNode.html">node_pointer_type</a> current_block_cluster_node, const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;all_support_points, const std::vector&lt; Number &gt; &amp;cell_size_at_dofs, std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;leaf_set_wrt_current_node)</td></tr>
<tr class="separator:a425583a70d63ddbf9341a31b736bd0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a99684ebd9ed470a79e56b73374068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTreeNode.html">node_pointer_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a97a99684ebd9ed470a79e56b73374068">find_leaf_bc_node_not_subset_of_bc_nodes_in_partition</a> (const std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;<a class="el" href="classBlockClusterTree.html#a3ca42421f732c20fc07bdf5d5ab94319">partition</a>, typename std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt;::const_iterator &amp;it_for_desired_bc_node) const</td></tr>
<tr class="separator:a97a99684ebd9ed470a79e56b73374068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4782e1e817b6e6265bff43baf2b1dbaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTreeNode.html">node_pointer_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockClusterTree.html#a4782e1e817b6e6265bff43baf2b1dbaa">find_leaf_bc_node_not_in_partition</a> (const std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;<a class="el" href="classBlockClusterTree.html#a3ca42421f732c20fc07bdf5d5ab94319">partition</a>, typename std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt;::const_iterator &amp;it_for_desired_bc_node) const</td></tr>
<tr class="separator:a4782e1e817b6e6265bff43baf2b1dbaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int spacedim, typename Number = double&gt;<br />
class BlockClusterTree&lt; spacedim, Number &gt;</h3>

<p>Class for block cluster tree. </p>
<p>A block cluster tree is a quad-tree which holds a hierarchy of doubly linked nodes with the type <a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a>. Because a node in the block cluster tree has four children, the template argument <code>T</code> required by <code><a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a></code> should be 4. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a4d03fe184a7f7838111b27cdae056a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d03fe184a7f7838111b27cdae056a62">&#9670;&nbsp;</a></span>data_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classBlockCluster.html">BlockCluster</a>&lt;spacedim, Number&gt; <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classBlockClusterTree.html#a4d03fe184a7f7838111b27cdae056a62">data_value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data type of the data held by a tree node. </p>

</div>
</div>
<a id="a960c20eac27464dedd804261f185c61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960c20eac27464dedd804261f185c61f">&#9670;&nbsp;</a></span>node_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTreeNode.html">TreeNode</a>&lt;<a class="el" href="classBlockCluster.html">BlockCluster</a>&lt;spacedim, Number&gt;, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt;spacedim, Number&gt;::<a class="el" href="classBlockClusterTree.html#a000c439b578bcf4fa28b7f3edd6079e9">child_num</a>&gt; <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classBlockClusterTree.html#a960c20eac27464dedd804261f185c61f">node_value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data type of the tree node. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a20b1ec6a9e81c252b1994c5a99c44af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b1ec6a9e81c252b1994c5a99c44af4">&#9670;&nbsp;</a></span>BlockClusterTree() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor, which initializes an empty quad-tree. </p>

</div>
</div>
<a id="a61d415eda9bfffa9e0aa5492b461edab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d415eda9bfffa9e0aa5492b461edab">&#9670;&nbsp;</a></span>BlockClusterTree() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>TI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>TJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_min</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from two cluster trees built from pure cardinality based partition, which has no admissibility condition.</p>
<p>After construction, there is only one node in the block cluster tree, i.e. tree hierarchy is not built.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TI</td><td></td></tr>
    <tr><td class="paramname">TJ</td><td></td></tr>
    <tr><td class="paramname">n_min</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="tree_8h.html#a330672af8616e2ac4eb794536a8dab29">CreateTreeNode()</a>, <a class="el" href="classClusterTree.html#a403e59575a89a3e86e8d7092a8815aa5">ClusterTree&lt; spacedim, Number &gt;::get_n_min()</a>, and <a class="el" href="classClusterTree.html#a13132bfc3ca8b70af8c80066565b0adb">ClusterTree&lt; spacedim, Number &gt;::get_root()</a>.</p>

</div>
</div>
<a id="a3073c9b5669e356c9c37ccd0a13ed8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3073c9b5669e356c9c37ccd0a13ed8b3">&#9670;&nbsp;</a></span>BlockClusterTree() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a> </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classTreeNode.html">node_pointer_type</a>&#160;</td>
          <td class="paramname"><em>tau_root_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classTreeNode.html">node_pointer_type</a>&#160;</td>
          <td class="paramname"><em>sigma_root_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_min</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from two cluster nodes, whose Cartesian product is the root node of the block cluster tree.</p>
<p>After construction, there is only one node in the block cluster tree, i.e. tree hierarchy is not built.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tau_root_node</td><td></td></tr>
    <tr><td class="paramname">sigma_root_node</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="tree_8h.html#a330672af8616e2ac4eb794536a8dab29">CreateTreeNode()</a>.</p>

</div>
</div>
<a id="ace6087e8fe7dc3d737ff6b4cd97070fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6087e8fe7dc3d737ff6b4cd97070fc">&#9670;&nbsp;</a></span>BlockClusterTree() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">node_pointer_type</a>&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a block cluster subtree by initializing from a block cluster node.</p>
<p>The constructed block cluster subtree simply takes over an existing block cluster node in a block cluster tree which has been built before.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bc_node</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a1b3396fbedf6ec07cce9c23a62b2c30b">BlockClusterTree&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="classBlockClusterTree.html#a7f9dbea25751771830c72d09efacacb2">BlockClusterTree&lt; spacedim, Number &gt;::calc_depth_and_max_level()</a>, <a class="el" href="classBlockClusterTree.html#a286bd48cc863cbba7c9ad53b6bdb12ca">BlockClusterTree&lt; spacedim, Number &gt;::categorize_near_and_far_field_sets()</a>, <a class="el" href="tree_8h.html#a0242ff1112ca2bb585990416bd04a666">CountTreeNodes()</a>, and <a class="el" href="classBlockClusterTree.html#a75757146cea0aa0e9271b760b1d76307">BlockClusterTree&lt; spacedim, Number &gt;::node_num</a>.</p>

</div>
</div>
<a id="a522ad51298f5b58b948e435a9e2d2a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522ad51298f5b58b948e435a9e2d2a40">&#9670;&nbsp;</a></span>BlockClusterTree() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">node_pointer_type</a>&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a block cluster subtree by initializing from a block cluster node. This version has the admissibility condition.</p>
<p>The constructed block cluster subtree simply takes over an existing block cluster node in a block cluster tree which has been built before.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bc_node</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a1b3396fbedf6ec07cce9c23a62b2c30b">BlockClusterTree&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="classBlockClusterTree.html#a7f9dbea25751771830c72d09efacacb2">BlockClusterTree&lt; spacedim, Number &gt;::calc_depth_and_max_level()</a>, <a class="el" href="classBlockClusterTree.html#a286bd48cc863cbba7c9ad53b6bdb12ca">BlockClusterTree&lt; spacedim, Number &gt;::categorize_near_and_far_field_sets()</a>, <a class="el" href="tree_8h.html#a0242ff1112ca2bb585990416bd04a666">CountTreeNodes()</a>, and <a class="el" href="classBlockClusterTree.html#a75757146cea0aa0e9271b760b1d76307">BlockClusterTree&lt; spacedim, Number &gt;::node_num</a>.</p>

</div>
</div>
<a id="aefb93288ece0e153eb5843d1df21a2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb93288ece0e153eb5843d1df21a2a6">&#9670;&nbsp;</a></span>BlockClusterTree() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>TI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classClusterTree.html">ClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>TJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from two cluster trees and admissibility condition.</p>
<p>The Cartesian product of the two clusters in the root nodes of \(T(I)\) and \(T(J)\) becomes the data in the root node of the block cluster tree.</p>
<p>After construction, there is only one node in the block cluster tree, i.e. tree hierarchy is not built. </p>

<p class="reference">References <a class="el" href="tree_8h.html#a330672af8616e2ac4eb794536a8dab29">CreateTreeNode()</a>, <a class="el" href="classClusterTree.html#a403e59575a89a3e86e8d7092a8815aa5">ClusterTree&lt; spacedim, Number &gt;::get_n_min()</a>, and <a class="el" href="classClusterTree.html#a13132bfc3ca8b70af8c80066565b0adb">ClusterTree&lt; spacedim, Number &gt;::get_root()</a>.</p>

</div>
</div>
<a id="a1c31aecfd91383f8b96601fd2b63dd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c31aecfd91383f8b96601fd2b63dd62">&#9670;&nbsp;</a></span>BlockClusterTree() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor for <code><a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a></code>, which realizes deep copy internally.</p>
<dl class="section note">
<dt>Note </dt>
<dd>Because this is deep copy, the constructed block cluster tree is a new tree but never a subtree of an existing block cluster tree. Hence, the data field <code>is_subtree</code> is set to <code>false</code>. </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bct</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a1b3396fbedf6ec07cce9c23a62b2c30b">BlockClusterTree&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="classBlockClusterTree.html#a286bd48cc863cbba7c9ad53b6bdb12ca">BlockClusterTree&lt; spacedim, Number &gt;::categorize_near_and_far_field_sets()</a>, <a class="el" href="tree_8h.html#a19010552004cddb2c5629712435b79c2">CopyTree()</a>, and <a class="el" href="classBlockClusterTree.html#a4a4f3b893380d1d7f53b772589a847d2">BlockClusterTree&lt; spacedim, Number &gt;::get_root()</a>.</p>

</div>
</div>
<a id="ae3bb67cdcb7868237063c8003d4079ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3bb67cdcb7868237063c8003d4079ab">&#9670;&nbsp;</a></span>BlockClusterTree() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>bct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor via shallow copy.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The data members of the input <code>bct</code> must be cleared before exiting this constructor. Otherwise, when <code>bct</code> is out of its range, the data associated with the current block cluster tree will also be destroyed, which is undesired. </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bct</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a85553cc442e419b8d707720312118328">BlockClusterTree&lt; spacedim, Number &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a43b969867200b06f3416647c3e4f9f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b969867200b06f3416647c3e4f9f61">&#9670;&nbsp;</a></span>~BlockClusterTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::~<a class="el" href="classBlockClusterTree.html">BlockClusterTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor which recursively destroys every node in the block cluster tree. </p>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#ab4227d666cd2872fbbfb4eec69e66313">BlockClusterTree&lt; spacedim, Number &gt;::clear()</a>, <a class="el" href="classBlockClusterTree.html#a8dc01af98989bb71246fa2cd4d7307da">BlockClusterTree&lt; spacedim, Number &gt;::is_subtree</a>, and <a class="el" href="classBlockClusterTree.html#a0415fe94fd480bbb985a45dc691e2bed">BlockClusterTree&lt; spacedim, Number &gt;::release()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1b3396fbedf6ec07cce9c23a62b2c30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3396fbedf6ec07cce9c23a62b2c30b">&#9670;&nbsp;</a></span>build_leaf_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::build_leaf_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build the leaf set by tree recursion. </p>

<p class="reference">References <a class="el" href="tree_8h.html#ade4e0de136e8a9c2ad63dc993f179f73">GetTreeLeaves()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#ace6087e8fe7dc3d737ff6b4cd97070fc">BlockClusterTree&lt; spacedim, Number &gt;::BlockClusterTree()</a>, <a class="el" href="classBlockClusterTree.html#a85553cc442e419b8d707720312118328">BlockClusterTree&lt; spacedim, Number &gt;::operator=()</a>, and <a class="el" href="classBlockClusterTree.html#af1663a109b6fd5c67c85e9bb88a54a13">BlockClusterTree&lt; spacedim, Number &gt;::prune_to_partition()</a>.</p>

</div>
</div>
<a id="a7f9dbea25751771830c72d09efacacb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9dbea25751771830c72d09efacacb2">&#9670;&nbsp;</a></span>calc_depth_and_max_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::calc_depth_and_max_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the depth. </p>

<p class="reference">References <a class="el" href="tree_8h.html#a9880a9179821bf75db4aa7b241d6306c">calc_depth()</a>, <a class="el" href="classBlockClusterTree.html#a77349ec9ccb36d45af3f176a93516897">BlockClusterTree&lt; spacedim, Number &gt;::depth</a>, and <a class="el" href="classBlockClusterTree.html#a9151f138713d01c53ac17f004c7e6b62">BlockClusterTree&lt; spacedim, Number &gt;::max_level</a>.</p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#ace6087e8fe7dc3d737ff6b4cd97070fc">BlockClusterTree&lt; spacedim, Number &gt;::BlockClusterTree()</a>, <a class="el" href="classBlockClusterTree.html#a3ca42421f732c20fc07bdf5d5ab94319">BlockClusterTree&lt; spacedim, Number &gt;::partition()</a>, <a class="el" href="classBlockClusterTree.html#a0e40b3884535eae57d00c078ec782459">BlockClusterTree&lt; spacedim, Number &gt;::partition_coarse_non_tensor_product()</a>, <a class="el" href="classBlockClusterTree.html#ac6d23af20c52c7b32eb080bd54556206">BlockClusterTree&lt; spacedim, Number &gt;::partition_fine_non_tensor_product()</a>, <a class="el" href="classBlockClusterTree.html#ab10f54639969bc4aacd6aa27cf315610">BlockClusterTree&lt; spacedim, Number &gt;::partition_tensor_product()</a>, and <a class="el" href="classBlockClusterTree.html#af1663a109b6fd5c67c85e9bb88a54a13">BlockClusterTree&lt; spacedim, Number &gt;::prune_to_partition()</a>.</p>

</div>
</div>
<a id="a286bd48cc863cbba7c9ad53b6bdb12ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286bd48cc863cbba7c9ad53b6bdb12ca">&#9670;&nbsp;</a></span>categorize_near_and_far_field_sets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::categorize_near_and_far_field_sets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Categorize the leaf set into near field set and far field set. </p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#ace6087e8fe7dc3d737ff6b4cd97070fc">BlockClusterTree&lt; spacedim, Number &gt;::BlockClusterTree()</a>, <a class="el" href="classBlockClusterTree.html#a85553cc442e419b8d707720312118328">BlockClusterTree&lt; spacedim, Number &gt;::operator=()</a>, <a class="el" href="classBlockClusterTree.html#a3ca42421f732c20fc07bdf5d5ab94319">BlockClusterTree&lt; spacedim, Number &gt;::partition()</a>, <a class="el" href="classBlockClusterTree.html#a0e40b3884535eae57d00c078ec782459">BlockClusterTree&lt; spacedim, Number &gt;::partition_coarse_non_tensor_product()</a>, <a class="el" href="classBlockClusterTree.html#ac6d23af20c52c7b32eb080bd54556206">BlockClusterTree&lt; spacedim, Number &gt;::partition_fine_non_tensor_product()</a>, <a class="el" href="classBlockClusterTree.html#ab10f54639969bc4aacd6aa27cf315610">BlockClusterTree&lt; spacedim, Number &gt;::partition_tensor_product()</a>, and <a class="el" href="classBlockClusterTree.html#af1663a109b6fd5c67c85e9bb88a54a13">BlockClusterTree&lt; spacedim, Number &gt;::prune_to_partition()</a>.</p>

</div>
</div>
<a id="ab4227d666cd2872fbbfb4eec69e66313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4227d666cd2872fbbfb4eec69e66313">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the data field of the block cluster tree because its memory has been migrated to another object via shallow copy. </p>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a77349ec9ccb36d45af3f176a93516897">BlockClusterTree&lt; spacedim, Number &gt;::depth</a>, <a class="el" href="classBlockClusterTree.html#a8dc01af98989bb71246fa2cd4d7307da">BlockClusterTree&lt; spacedim, Number &gt;::is_subtree</a>, <a class="el" href="classBlockClusterTree.html#a9151f138713d01c53ac17f004c7e6b62">BlockClusterTree&lt; spacedim, Number &gt;::max_level</a>, and <a class="el" href="classBlockClusterTree.html#a75757146cea0aa0e9271b760b1d76307">BlockClusterTree&lt; spacedim, Number &gt;::node_num</a>.</p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#a85553cc442e419b8d707720312118328">BlockClusterTree&lt; spacedim, Number &gt;::operator=()</a>, <a class="el" href="classBlockClusterTree.html#a0415fe94fd480bbb985a45dc691e2bed">BlockClusterTree&lt; spacedim, Number &gt;::release()</a>, and <a class="el" href="classBlockClusterTree.html#a43b969867200b06f3416647c3e4f9f61">BlockClusterTree&lt; spacedim, Number &gt;::~BlockClusterTree()</a>.</p>

</div>
</div>
<a id="ae0e55e3ac56bffa31f251d4f07ae7e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e55e3ac56bffa31f251d4f07ae7e51">&#9670;&nbsp;</a></span>decrease_node_num()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::decrease_node_num </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>decreased_node_num</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrease the total number of nodes in the tree. </p>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a75757146cea0aa0e9271b760b1d76307">BlockClusterTree&lt; spacedim, Number &gt;::node_num</a>.</p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#a6fd771b68a4c7195151f6dc02e8ec7e9">BlockClusterTree&lt; spacedim, Number &gt;::prune_descendants_from_node()</a>.</p>

</div>
</div>
<a id="a3c4a4da89b964559cc02ecbf13ad4a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4a4da89b964559cc02ecbf13ad4a4b">&#9670;&nbsp;</a></span>extend_finer_than_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::extend_finer_than_partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>partition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extend the current block cluster tree to be finer than the given partition.</p>
<p>This member functions implements (7.10a) in Hackbusch's \(\mathcal{H}\)-matrix book.</p>
<dl class="section note">
<dt>Note </dt>
<dd><b>This algorithm iterates over each element in the leaf set of the block cluster tree to be extended. During the iteration, because leaf nodes may be further split into smaller ones, the leaf set is not a constant. Hence, the leaf set should be updated immediately whenever a block cluster node is split. This behavior is different from other functions such as <code><a class="el" href="classHMatrix.html#ad2b353962226c78910d6ddb6b5b8e460">HMatrix&lt;spacedim, Number&gt;::refine_to_supertree</a></code>, the leaf set of of which will be built after the whole tree hierarchy has been constructed.</b>  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the block cluster tree has really been extended. </dd></dl>
<p>Iterate over the leaf set of the current block cluster tree and look for a block cluster which is not contained by any block cluster in the given partition.</p>
<p>Flag variable indicating whether the current block cluster tree has actually been extended. If true, the leaf set of the current block cluster tree has been modified during the extension, which needs a further re-categorization into the near field set and the far field set.</p>
<p>Enter the loop by selecting a block cluster node from the leaf set which is not contained in any block cluster nodes in the given partition.</p>
<p>Because the selected block cluster node in the leaf set is about to be split, we delete the current block cluster node from the leaf set here and add its children to the leaf set later on during calling <code>split_block_cluster_node</code>.</p>
<p>Select a block cluster node in the given partition, whose index set has a nonempty intersection with the index set of the current block cluster node.</p>
<p>Because the given partition is a covering of the complete block cluster index set \(I \times J\), such block cluster node must exist. Hence we make an assertion here.</p>
<p>Extend the current block cluster node by splitting its \(\tau\) node, which is horizontal split, then make Cartesian product with its \(\sigma\) node. The newly created block cluster nodes are appended to the leaf set.</p>
<p>Extend the current block cluster node by splitting its \(\sigma\) node, which is vertical split, then make Cartesian product with its \(\tau\) node. The newly created block cluster nodes are appended to the leaf set.</p>
<p>Extend the current block cluster node by splitting its \(\tau\) node, which is horizontal split, then make Cartesian product with its \(\sigma\) node. The newly created block cluster nodes are appended to the leaf set.</p>
<p>Extend the current block cluster node by splitting its \(\sigma\) node, which is vertical split, then make Cartesian product with its \(\tau\) node. The newly created block cluster nodes are appended to the leaf set.</p>
<p>Update the maximum level and depth of the current tree if necessary.</p>
<p>After block cluster tree extension, re-categorize the near field set and far field set based on the new leaf set. N.B. The value of <code>n_min</code> and <code>eta</code> does not change. Meanwhile, <code>depth</code> and <code>max_level</code> have been updated during previous procedures.</p>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a97a99684ebd9ed470a79e56b73374068">BlockClusterTree&lt; spacedim, Number &gt;::find_leaf_bc_node_not_subset_of_bc_nodes_in_partition()</a>, and <a class="el" href="classTreeNode.html#a7bf414928c965e707e0246f7a90a747d">TreeNode&lt; T, N &gt;::get_data_reference()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#af6fd60090b0de7bdea52fc84ddeb22c3">HMatrix&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees()</a>, and <a class="el" href="bct-extend-finer-than-partition_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="adfe18d32a3c05a9209a5cdc9270b47d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe18d32a3c05a9209a5cdc9270b47d7">&#9670;&nbsp;</a></span>extend_to_finer_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::extend_to_finer_partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>partition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extend the current block cluster tree to the given finer partition.</p>
<p>This member functions implements (7.10b) in Hackbusch's \(\mathcal{H}\)-matrix book.</p>
<dl class="section note">
<dt>Note </dt>
<dd><b>This algorithm iterates over each element in the leaf set of the block cluster tree to be extended. During the iteration, because leaf nodes may be further split into smaller ones, the leaf set is not a constant. Hence, the leaf set should be updated immediately whenever a block cluster node is split. This behavior is different from other functions such as <code><a class="el" href="classHMatrix.html#ad2b353962226c78910d6ddb6b5b8e460">HMatrix&lt;spacedim, Number&gt;::refine_to_supertree</a></code>, the leaf set of of which will be built after the whole tree hierarchy has been constructed.</b>  </dd>
</dl>
<p>Iterate over the leaf set of the current block cluster tree and look for a block cluster which does not belong to the partition.</p>
<p>Enter the loop by selecting a block cluster node from the leaf set, which does not belong to the given partition.</p>
<p>Because the selected block cluster node in the leaf set is about to be split, we delete the current block cluster node from the leaf set here and add its children to the leaf set later on during calling <code>split_block_cluster_node</code>.</p>
<p>Select a block cluster node in the given partition, whose index set is a proper subset of the index set of the current block cluster node.</p>
<p>Because the partition is a covering of the complete block cluster index set \(I \times J\) and it is finer than the leaf set of the current block cluster tree, such block cluster node must exist. Hence we make an assertion here.</p>
<p>Here we ensure that the level difference between \(\tau\) and \(\sigma\) clusters is at most 1.</p>
<p>Extend the current block cluster node by splitting its \(\tau\) node, which is horizontal split, then make Cartesian product with its \(\sigma\) node. The newly created block cluster nodes are appended to the leaf set.</p>
<p>Extend the current block cluster node by splitting its \(\sigma\) node, which is vertical split, then make Cartesian product with its \(\tau\) node. The newly created block cluster nodes are appended to the leaf set.</p>
<p>Extend the current block cluster node by splitting its \(\tau\) node, which is horizontal split, then make Cartesian product with its \(\sigma\) node. The newly created block cluster nodes are appended to the leaf set.</p>
<p>Extend the current block cluster node by splitting its \(\sigma\) node, which is vertical split, then make Cartesian product with its \(\tau\) node. The newly created block cluster nodes are appended to the leaf set.</p>
<p>Update the maximum level and depth of the current tree if necessary.</p>
<p>After block cluster tree extension, re-categorize the near field set and far field set based on the new leaf set. N.B. The value of <code>n_min</code> and <code>eta</code> does not change. Meanwhile, <code>depth</code> and <code>max_level</code> have been updated during previous procedures.</p>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a4782e1e817b6e6265bff43baf2b1dbaa">BlockClusterTree&lt; spacedim, Number &gt;::find_leaf_bc_node_not_in_partition()</a>, and <a class="el" href="classTreeNode.html#a7bf414928c965e707e0246f7a90a747d">TreeNode&lt; T, N &gt;::get_data_reference()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#af6fd60090b0de7bdea52fc84ddeb22c3">HMatrix&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees()</a>, and <a class="el" href="bct-extend-to-finer-partition_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a4782e1e817b6e6265bff43baf2b1dbaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4782e1e817b6e6265bff43baf2b1dbaa">&#9670;&nbsp;</a></span>find_leaf_bc_node_not_in_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classTreeNode.html">node_pointer_type</a> <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::find_leaf_bc_node_not_in_partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt;::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>it_for_desired_bc_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find a block cluster node in the leaf set of the current block cluster tree, which does not belong to the partition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td>the given partition. </td></tr>
    <tr><td class="paramname">it_for_desired_bc_node</td><td>the returned iterator which points to the selected block cluster node in the leaf set of the current block cluster tree. N.B. Only when the returned pointer is not <code>nullptr</code>, this iterator is meaningful. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the selected block cluster node. </dd></dl>
<dl class="section">
<dt>Work flow </dt>
<dd><p class="startdd"></p>
<p>Iterate over each block cluster node in the leaf set of the current block cluster tree.</p>
<p>Iterate over each block cluster node in the given partition.</p>
<p>When the index set of the current block cluster node is equal to the index set of some block cluster node in the given partition, terminate the inner loop and jump to the next leaf node for checking.</p>
<p>Here the desired block cluster node in the leaf set is found. Then exist the outer loop and the iterator <code>it_for_desired_bc_node</code> now pointing to this node will also be returned.</p>
<p class="enddd"></p>
</dd>
</dl>

<p class="reference">References <a class="el" href="classTreeNode.html#a7bf414928c965e707e0246f7a90a747d">TreeNode&lt; T, N &gt;::get_data_reference()</a>, and <a class="el" href="block__cluster_8h.html#a770daa1c7399aa72cfb7e1e7dc65b6bb">is_equal()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#adfe18d32a3c05a9209a5cdc9270b47d7">BlockClusterTree&lt; spacedim, Number &gt;::extend_to_finer_partition()</a>.</p>

</div>
</div>
<a id="a97a99684ebd9ed470a79e56b73374068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a99684ebd9ed470a79e56b73374068">&#9670;&nbsp;</a></span>find_leaf_bc_node_not_subset_of_bc_nodes_in_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classTreeNode.html">node_pointer_type</a> <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::find_leaf_bc_node_not_subset_of_bc_nodes_in_partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt;::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>it_for_desired_bc_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find a block cluster node in the leaf set of the current block cluster tree, which is not a subset of any block cluster in the given partition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td>the given partition. </td></tr>
    <tr><td class="paramname">it_for_desired_bc_node</td><td>the returned iterator which points to the selected block cluster node in the leaf set of the current block cluster tree. N.B. Only when the returned pointer is not <code>nullptr</code>, this iterator is meaningful. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the selected block cluster node. </dd></dl>
<dl class="section">
<dt>Work flow </dt>
<dd><p class="startdd"></p>
<p>Iterate over each block cluster node in the leaf set of the current block cluster tree.</p>
<p>Iterate over each block cluster node in the given partition.</p>
<p>When the index set of the current block cluster node in the leaf set is a subset of the index set of some block cluster node in the given partition, terminate the inner loop and jump to the next leaf node for checking.</p>
<p>Here the desired block cluster node in the leaf set is found. Then exist the outer loop and the iterator <code>it_for_desired_bc_node</code> now pointing to this node will also be returned.</p>
<p class="enddd"></p>
</dd>
</dl>

<p class="reference">References <a class="el" href="classTreeNode.html#a7bf414928c965e707e0246f7a90a747d">TreeNode&lt; T, N &gt;::get_data_reference()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#a3c4a4da89b964559cc02ecbf13ad4a4b">BlockClusterTree&lt; spacedim, Number &gt;::extend_finer_than_partition()</a>.</p>

</div>
</div>
<a id="ab6c57acfcc5dfbbef04f028e6b9c749d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c57acfcc5dfbbef04f028e6b9c749d">&#9670;&nbsp;</a></span>get_depth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::get_depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the tree depth. </p>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a77349ec9ccb36d45af3f176a93516897">BlockClusterTree&lt; spacedim, Number &gt;::depth</a>.</p>

</div>
</div>
<a id="a312d01ddb6cf5560d84abf7d254fa2c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312d01ddb6cf5560d84abf7d254fa2c3">&#9670;&nbsp;</a></span>get_eta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::get_eta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the admissibility parameter. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ab100d1469f662efdbf894a0345b702b8">HMatrix&lt; spacedim, Number &gt;::invert_by_gauss_elim()</a>.</p>

</div>
</div>
<a id="a2980726dc3789773b5cd3c04df5e69a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2980726dc3789773b5cd3c04df5e69a3">&#9670;&nbsp;</a></span>get_far_field_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp; <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::get_far_field_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the block cluster list which belongs to the far field. </p>

</div>
</div>
<a id="a93763855c84100e1a9da3080737295f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93763855c84100e1a9da3080737295f4">&#9670;&nbsp;</a></span>get_far_field_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp; <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::get_far_field_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the block cluster list which belongs to the far field (const version). </p>

</div>
</div>
<a id="a162b396d814b420f96289425529852e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162b396d814b420f96289425529852e9">&#9670;&nbsp;</a></span>get_leaf_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp; <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::get_leaf_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the block cluster list. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#a27c7390b792e6e47ab2861616a997d99">HMatrix&lt; spacedim, Number &gt;::coarsen_to_subtree()</a>, <a class="el" href="classHMatrix.html#af6fd60090b0de7bdea52fc84ddeb22c3">HMatrix&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees()</a>, and <a class="el" href="bct-extend-finer-than-partition_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a38c3d1ad3aa983ea1d0b711914664b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c3d1ad3aa983ea1d0b711914664b4c">&#9670;&nbsp;</a></span>get_leaf_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp; <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::get_leaf_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the block cluster list (const version). </p>

</div>
</div>
<a id="a404693ef7dfdbc383705c38105c75e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404693ef7dfdbc383705c38105c75e14">&#9670;&nbsp;</a></span>get_max_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::get_max_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the maximum level of the tree. </p>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a9151f138713d01c53ac17f004c7e6b62">BlockClusterTree&lt; spacedim, Number &gt;::max_level</a>.</p>

</div>
</div>
<a id="ab00acda5e8fd4c3e381637d8d9322923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00acda5e8fd4c3e381637d8d9322923">&#9670;&nbsp;</a></span>get_n_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::get_n_min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the minimum cluster size. </p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#ab100d1469f662efdbf894a0345b702b8">HMatrix&lt; spacedim, Number &gt;::invert_by_gauss_elim()</a>, and <a class="el" href="classHMatrix.html#af40d53aabc8bec86fa543638d48ba64e">HMatrix&lt; spacedim, Number &gt;::mmult()</a>.</p>

</div>
</div>
<a id="a82f61b31f1e9cf869831fa4c8232df81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f61b31f1e9cf869831fa4c8232df81">&#9670;&nbsp;</a></span>get_near_field_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp; <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::get_near_field_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the block cluster list which belongs to the near field. </p>

</div>
</div>
<a id="a6ac71437177d14012c12f7b4f354cdd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac71437177d14012c12f7b4f354cdd1">&#9670;&nbsp;</a></span>get_near_field_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp; <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::get_near_field_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the block cluster list which belongs to the near field (const version). </p>

</div>
</div>
<a id="a042e040d2f6dfcbbfd70b43b8967c6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042e040d2f6dfcbbfd70b43b8967c6f6">&#9670;&nbsp;</a></span>get_node_num()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::get_node_num </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total number of clusters in the tree. </p>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a75757146cea0aa0e9271b760b1d76307">BlockClusterTree&lt; spacedim, Number &gt;::node_num</a>.</p>

</div>
</div>
<a id="a4a4f3b893380d1d7f53b772589a847d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4f3b893380d1d7f53b772589a847d2">&#9670;&nbsp;</a></span>get_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::<a class="el" href="classTreeNode.html">node_pointer_type</a> <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::get_root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the pointer to the root node of the block cluster tree. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#ae77f8167ce49871f5751b8dcf8c93153">BlockClusterTree&lt; spacedim, Number &gt;::partition_tensor_product_from_block_cluster_node()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#a1c31aecfd91383f8b96601fd2b63dd62">BlockClusterTree&lt; spacedim, Number &gt;::BlockClusterTree()</a>, <a class="el" href="classHMatrix.html#a6a4dead0321e8df38865bf6fbd0f6e81">HMatrix&lt; spacedim, Number &gt;::HMatrix()</a>, <a class="el" href="classHMatrix.html#af40d53aabc8bec86fa543638d48ba64e">HMatrix&lt; spacedim, Number &gt;::mmult()</a>, <a class="el" href="classBlockClusterTree.html#a85553cc442e419b8d707720312118328">BlockClusterTree&lt; spacedim, Number &gt;::operator=()</a>, and <a class="el" href="classHMatrix.html#a83f804163e1695cfb952ddb6b0df2503">HMatrix&lt; spacedim, Number &gt;::reinit()</a>.</p>

</div>
</div>
<a id="aec9920e5b215fbfe2aa9f54980d3b30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9920e5b215fbfe2aa9f54980d3b30a">&#9670;&nbsp;</a></span>increase_node_num()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::increase_node_num </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>increased_node_num</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increase the total number of nodes in the tree. </p>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a75757146cea0aa0e9271b760b1d76307">BlockClusterTree&lt; spacedim, Number &gt;::node_num</a>.</p>

</div>
</div>
<a id="a85553cc442e419b8d707720312118328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85553cc442e419b8d707720312118328">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp; <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>bct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloaded assignment operator with deep copy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bct</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>If the current block cluster tree is a subtree of an existing block cluster tree, clear its data members instead of releasing their memory.</p>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a1b3396fbedf6ec07cce9c23a62b2c30b">BlockClusterTree&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="classBlockClusterTree.html#a286bd48cc863cbba7c9ad53b6bdb12ca">BlockClusterTree&lt; spacedim, Number &gt;::categorize_near_and_far_field_sets()</a>, <a class="el" href="classBlockClusterTree.html#ab4227d666cd2872fbbfb4eec69e66313">BlockClusterTree&lt; spacedim, Number &gt;::clear()</a>, <a class="el" href="tree_8h.html#a19010552004cddb2c5629712435b79c2">CopyTree()</a>, <a class="el" href="classBlockClusterTree.html#a77349ec9ccb36d45af3f176a93516897">BlockClusterTree&lt; spacedim, Number &gt;::depth</a>, <a class="el" href="classBlockClusterTree.html#a4a4f3b893380d1d7f53b772589a847d2">BlockClusterTree&lt; spacedim, Number &gt;::get_root()</a>, <a class="el" href="classBlockClusterTree.html#a8dc01af98989bb71246fa2cd4d7307da">BlockClusterTree&lt; spacedim, Number &gt;::is_subtree</a>, <a class="el" href="classBlockClusterTree.html#a9151f138713d01c53ac17f004c7e6b62">BlockClusterTree&lt; spacedim, Number &gt;::max_level</a>, <a class="el" href="classBlockClusterTree.html#a75757146cea0aa0e9271b760b1d76307">BlockClusterTree&lt; spacedim, Number &gt;::node_num</a>, and <a class="el" href="classBlockClusterTree.html#a0415fe94fd480bbb985a45dc691e2bed">BlockClusterTree&lt; spacedim, Number &gt;::release()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#ae3bb67cdcb7868237063c8003d4079ab">BlockClusterTree&lt; spacedim, Number &gt;::BlockClusterTree()</a>.</p>

</div>
</div>
<a id="aa635be81dfabed3ba455a17de3b65c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa635be81dfabed3ba455a17de3b65c2e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp; <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>bct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloaded assignment operator with shallow copy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bct</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#ab4227d666cd2872fbbfb4eec69e66313">BlockClusterTree&lt; spacedim, Number &gt;::clear()</a>, <a class="el" href="classBlockClusterTree.html#a77349ec9ccb36d45af3f176a93516897">BlockClusterTree&lt; spacedim, Number &gt;::depth</a>, <a class="el" href="classBlockClusterTree.html#a8dc01af98989bb71246fa2cd4d7307da">BlockClusterTree&lt; spacedim, Number &gt;::is_subtree</a>, <a class="el" href="classBlockClusterTree.html#a9151f138713d01c53ac17f004c7e6b62">BlockClusterTree&lt; spacedim, Number &gt;::max_level</a>, <a class="el" href="classBlockClusterTree.html#a75757146cea0aa0e9271b760b1d76307">BlockClusterTree&lt; spacedim, Number &gt;::node_num</a>, and <a class="el" href="classBlockClusterTree.html#a0415fe94fd480bbb985a45dc691e2bed">BlockClusterTree&lt; spacedim, Number &gt;::release()</a>.</p>

</div>
</div>
<a id="a3ca42421f732c20fc07bdf5d5ab94319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca42421f732c20fc07bdf5d5ab94319">&#9670;&nbsp;</a></span>partition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_support_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a recursive partition by starting from the root node. The evaluation of the admissibility condition has no mesh cell size correction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">all_support_points</td><td>All the support points. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a7f9dbea25751771830c72d09efacacb2">BlockClusterTree&lt; spacedim, Number &gt;::calc_depth_and_max_level()</a>, <a class="el" href="classBlockClusterTree.html#a286bd48cc863cbba7c9ad53b6bdb12ca">BlockClusterTree&lt; spacedim, Number &gt;::categorize_near_and_far_field_sets()</a>, and <a class="el" href="classBlockClusterTree.html#ad11fb277e43c33f2a399dc6b1c14b998">BlockClusterTree&lt; spacedim, Number &gt;::partition_from_block_cluster_node()</a>.</p>

<p class="reference">Referenced by <a class="el" href="block__cluster__tree_8h.html#a6ae11dfea883425641ebd2683cd482b6">find_bc_node_in_partition_intersect_current_bc_node()</a>, <a class="el" href="block-cluster-tree_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="block__cluster__tree_8h.html#a3b2f90afbf0d192ac657f6fab5a87294">prune_to_partition_recursion()</a>.</p>

</div>
</div>
<a id="a075983197c805c6451aa00502dc30e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075983197c805c6451aa00502dc30e76">&#9670;&nbsp;</a></span>partition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_size_at_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a recursive partition by starting from the root node. The evaluation of the admissibility condition has mesh cell size correction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">all_support_points</td><td>All the support points. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a7f9dbea25751771830c72d09efacacb2">BlockClusterTree&lt; spacedim, Number &gt;::calc_depth_and_max_level()</a>, <a class="el" href="classBlockClusterTree.html#a286bd48cc863cbba7c9ad53b6bdb12ca">BlockClusterTree&lt; spacedim, Number &gt;::categorize_near_and_far_field_sets()</a>, and <a class="el" href="classBlockClusterTree.html#ad11fb277e43c33f2a399dc6b1c14b998">BlockClusterTree&lt; spacedim, Number &gt;::partition_from_block_cluster_node()</a>.</p>

</div>
</div>
<a id="a0e40b3884535eae57d00c078ec782459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e40b3884535eae57d00c078ec782459">&#9670;&nbsp;</a></span>partition_coarse_non_tensor_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::partition_coarse_non_tensor_product </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a recursive partition in coarse non-tensor product form without the admissibility condition because the two comprising cluster trees are built from pure cardinality based partition. </p>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a7f9dbea25751771830c72d09efacacb2">BlockClusterTree&lt; spacedim, Number &gt;::calc_depth_and_max_level()</a>, <a class="el" href="classBlockClusterTree.html#a286bd48cc863cbba7c9ad53b6bdb12ca">BlockClusterTree&lt; spacedim, Number &gt;::categorize_near_and_far_field_sets()</a>, and <a class="el" href="classBlockClusterTree.html#a61b6c204f3f1d5ff7c71a07b26ca9d09">BlockClusterTree&lt; spacedim, Number &gt;::partition_coarse_non_tensor_product_from_block_cluster_node()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bct-extend-finer-than-partition_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a61b6c204f3f1d5ff7c71a07b26ca9d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b6c204f3f1d5ff7c71a07b26ca9d09">&#9670;&nbsp;</a></span>partition_coarse_non_tensor_product_from_block_cluster_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::partition_coarse_non_tensor_product_from_block_cluster_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">node_pointer_type</a>&#160;</td>
          <td class="paramname"><em>current_block_cluster_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaf_set_wrt_current_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a recursive non-tensor product type coarse partition by starting from a block cluster node in the tree.</p>
<p>No admissibility condition is enabled in this situation, because the two comprising cluster trees are built from pure cardinality based partition.</p>
<p>Reference: Section 2.2.2 in Hackbusch, W. 1999. A Sparse Matrix Arithmetic Based on H-Matrices. Part I: Introduction to H-Matrices. Computing 62 (2): 89108. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_block_cluster_node</td><td></td></tr>
    <tr><td class="paramname">leaf_set_wrt_current_node</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Push back the current cluster node, which is small, to the leaf set and set its split mode as <code>UnsplitMode</code>.</p>
<p>Make sure that the two clusters \(\tau\) and \(\sigma\) have the same level in their respective cluster trees, i.e. level preserving property should be satisfied.</p>
<p>Create a new block cluster node as child. Then append this new node as one of the children of the current block cluster node. Finally, recursively partition from this node if the two component clusters have the same indices, i.e. \(I_1 \times I_1\) and \(I_2 \times I_2\); otherwise, for \(I_1 \times I_2\) and \(I_2 \times I_1\), stop the recursion and directly add them to the leaf set.</p>
<p>Append this new node as one of the children of the current block cluster node.</p>
<p>Handle the case for \(I_1 \times I_1\) and \(I_2 \times I_2\).</p>
<p>Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.</p>
<p>Handle the case for \(I_1 \times I_2\) and \(I_2 \times I_1\). Because the recursion stops here, we need to check and update its near field property.</p>
<p>Make sure the current block cluster have four children, which is ensured by the non-tensor product construction.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The second argument <code><a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>&lt;spacedim</code>, Number&gt;::child_num should be wrapped between the brackets, otherwise, the program cannot be compiled. </dd>
</dl>
<p>Set the split mode of the current block cluster node as cross.</p>

<p class="reference">References <a class="el" href="classTreeNode.html#aaa2ba047902c4e2fccffe3424a0c665b">TreeNode&lt; T, N &gt;::get_data_pointer()</a>, and <a class="el" href="classTreeNode.html#a0aec2b9142e931aaaa15d1c451ed9b46">TreeNode&lt; T, N &gt;::set_split_mode()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#a0e40b3884535eae57d00c078ec782459">BlockClusterTree&lt; spacedim, Number &gt;::partition_coarse_non_tensor_product()</a>.</p>

</div>
</div>
<a id="ac6d23af20c52c7b32eb080bd54556206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d23af20c52c7b32eb080bd54556206">&#9670;&nbsp;</a></span>partition_fine_non_tensor_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::partition_fine_non_tensor_product </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a recursive partition in fine non-tensor product form without the admissibility condition because the two comprising cluster trees are built from pure cardinality based partition. </p>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a7f9dbea25751771830c72d09efacacb2">BlockClusterTree&lt; spacedim, Number &gt;::calc_depth_and_max_level()</a>, <a class="el" href="classBlockClusterTree.html#a286bd48cc863cbba7c9ad53b6bdb12ca">BlockClusterTree&lt; spacedim, Number &gt;::categorize_near_and_far_field_sets()</a>, and <a class="el" href="classBlockClusterTree.html#aa6354696477c8cae61d362b5ec707034">BlockClusterTree&lt; spacedim, Number &gt;::partition_fine_non_tensor_product_from_block_cluster_node()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bct-copy-constructor_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="aa6354696477c8cae61d362b5ec707034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6354696477c8cae61d362b5ec707034">&#9670;&nbsp;</a></span>partition_fine_non_tensor_product_from_block_cluster_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::partition_fine_non_tensor_product_from_block_cluster_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">node_pointer_type</a>&#160;</td>
          <td class="paramname"><em>current_block_cluster_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaf_set_wrt_current_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a recursive non-tensor product type fine partition of \(\mathcal{M}_{\mathcal{H},k}\) type by starting from a block cluster node in the tree.</p>
<p>No admissibility condition is enabled in this situation, because the two comprising cluster trees are built from pure cardinality based partition.</p>
<p>Reference: Section 5 in Hackbusch, W. 1999. A Sparse Matrix Arithmetic Based on H-Matrices. Part I: Introduction to H-Matrices. Computing 62 (2): 89108. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_block_cluster_node</td><td></td></tr>
    <tr><td class="paramname">leaf_set_wrt_current_node</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Push back the current cluster node, which is small, to the leaf set and set its split mode as <code>UnsplitMode</code>.</p>
<p>Set the split mode of the current block cluster node as cross.</p>
<p>Make sure that the two clusters \(\tau\) and \(\sigma\) have the same level in their respective cluster trees, i.e. level preserving property should be satisfied.</p>
<p>Create a new block cluster node as child. Then append this new node as one of the children of the current block cluster node. Finally, recursively partition from this node using the fine non-tensor product method if the two component clusters have the same indices, i.e. \(I_1 \times I_1\) and \(I_2 \times I_2\); for \(I_1 \times I_2\), recursively partition from it using the \(\mathcal{N}\)-type partition method; for \(I_2 \times I_1\), recursively partition from it using the \(\mathcal{N}^*\)-type partition method.</p>
<p>Append this new node as one of the children of the current block cluster node.</p>
<p>Handle the case for \(I_1 \times I_1\) and \(I_2 \times I_2\) by recursively applying the fine non-tensor product partition method itself.</p>
<p>Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.</p>
<p>Handle the case for \(I_1 \times I_2\) and perform the \(\mathcal{N}\)-type recursive partition.</p>
<p>Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.</p>
<p>Handle the case for \(I_2 \times I_1\) and perform the \(\mathcal{N}^*\)-type recursive partition.</p>
<p>Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.</p>
<p>This case can never happen.</p>
<p>Make sure the current block cluster have four children, which is ensured by the fine non-tensor product construction.</p>
<dl class="section note">
<dt>Note </dt>
<dd><b>The second argument <code><a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>&lt;spacedim</code>, Number&gt;::child_num should be wrapped between the brackets, otherwise, the program cannot be compiled.</b> </dd>
</dl>

<p class="reference">References <a class="el" href="classTreeNode.html#aaa2ba047902c4e2fccffe3424a0c665b">TreeNode&lt; T, N &gt;::get_data_pointer()</a>, and <a class="el" href="classTreeNode.html#a0aec2b9142e931aaaa15d1c451ed9b46">TreeNode&lt; T, N &gt;::set_split_mode()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#ac6d23af20c52c7b32eb080bd54556206">BlockClusterTree&lt; spacedim, Number &gt;::partition_fine_non_tensor_product()</a>.</p>

</div>
</div>
<a id="aafad0fae48bf7c462e8e943b76893fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafad0fae48bf7c462e8e943b76893fc0">&#9670;&nbsp;</a></span>partition_fine_non_tensor_product_from_block_cluster_node_N()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::partition_fine_non_tensor_product_from_block_cluster_node_N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">node_pointer_type</a>&#160;</td>
          <td class="paramname"><em>current_block_cluster_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaf_set_wrt_current_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a recursive non-tensor product type fine partition of \(\mathcal{M}_{\mathcal{N},k}\) type by starting from a block cluster node in the tree.</p>
<p>No admissibility condition is enabled in this situation, because the two comprising cluster trees are built from pure cardinality based partition.</p>
<p>Reference: Section 5 in Hackbusch, W. 1999. A Sparse Matrix Arithmetic Based on H-Matrices. Part I: Introduction to H-Matrices. Computing 62 (2): 89108. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_block_cluster_node</td><td></td></tr>
    <tr><td class="paramname">leaf_set_wrt_current_node</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Push back the current cluster node, which is small, to the leaf set and set its split mode as <code>UnsplitMode</code>.</p>
<p>Make sure that the two clusters \(\tau\) and \(\sigma\) have the same level in their respective cluster trees, i.e. level preserving property should be satisfied.</p>
<p>Create a new block cluster node as child. Then append this new node as one of the children of the current block cluster node. Finally, recursively partition from this node if it is on the bottom left corner, i.e. it is the \(I_2 \times I_1\) block cluster; otherwise, for \(I_1 \times I_1\), \(I_1 \times I_2\) and \(I_2 \times I_2\), stop the recursion and directly add them to the leaf set.</p>
<p>Append this new node as one of the children of the current block cluster node.</p>
<p>Handle the case for \(I_2 \times I_1\) and perform the \(\mathcal{N}\)-type recursive partition.</p>
<p>Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.</p>
<p>Handle the case for \(I_1 \times I_1\), \(I_1 \times I_2\) and \(I_2 \times I_2\). Because the recursion stops here, we need to check and update its near field property.</p>
<p>Make sure the current block cluster have four children, which is ensured by the fine non-tensor product \(\mathcal{N}\)-type construction.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The second argument <code><a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>&lt;spacedim</code>, Number&gt;::child_num should be wrapped between the brackets, otherwise, the program cannot be compiled. </dd>
</dl>
<p>Set the split mode of the current block cluster node as cross.</p>

<p class="reference">References <a class="el" href="classTreeNode.html#aaa2ba047902c4e2fccffe3424a0c665b">TreeNode&lt; T, N &gt;::get_data_pointer()</a>, and <a class="el" href="classTreeNode.html#a0aec2b9142e931aaaa15d1c451ed9b46">TreeNode&lt; T, N &gt;::set_split_mode()</a>.</p>

</div>
</div>
<a id="afdeb6723e01b5eaf11281e2c1c1cf566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdeb6723e01b5eaf11281e2c1c1cf566">&#9670;&nbsp;</a></span>partition_fine_non_tensor_product_from_block_cluster_node_Nstar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::partition_fine_non_tensor_product_from_block_cluster_node_Nstar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">node_pointer_type</a>&#160;</td>
          <td class="paramname"><em>current_block_cluster_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaf_set_wrt_current_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a recursive non-tensor product type fine partition of \(\mathcal{M}_{\mathcal{N}^*,k}\) type by starting from a block cluster node in the tree.</p>
<p>No admissibility condition is enabled in this situation, because the two comprising cluster trees are built from pure cardinality based partition.</p>
<p>Reference: Section 5 in Hackbusch, W. 1999. A Sparse Matrix Arithmetic Based on H-Matrices. Part I: Introduction to H-Matrices. Computing 62 (2): 89108. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_block_cluster_node</td><td></td></tr>
    <tr><td class="paramname">leaf_set_wrt_current_node</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Push back the current cluster node, which is small, to the leaf set and set its split mode as <code>UnsplitMode</code>.</p>
<p>Make sure that the two clusters \(\tau\) and \(\sigma\) have the same level in their respective cluster trees, i.e. level preserving property should be satisfied.</p>
<p>Create a new block cluster node as child. Then append this new node as one of the children of the current block cluster node. Finally, recursively partition from this node if it is on the top right corner, i.e. it is the \(I_1 \times I_2\) block cluster; otherwise, for \(I_1 \times I_1\), \(I_2 \times I_1\) and \(I_2 \times I_2\), stop the recursion and directly add them to the leaf set.</p>
<p>Append this new node as one of the children of the current block cluster node.</p>
<p>Handle the case for \(I_1 \times I_2\) and perform the \(\mathcal{N}^*\)-type recursive partition.</p>
<p>Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.</p>
<p>Handle the case for \(I_1 \times I_1\), \(I_2 \times I_1\) and \(I_2 \times I_2\). Because the recursion stops here, we need to check and update its near field property.</p>
<p>Make sure the current block cluster have four children, which is ensured by the fine non-tensor product \(\mathcal{N}^*\)-type construction.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The second argument <code><a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>&lt;spacedim</code>, Number&gt;::child_num should be wrapped between the brackets, otherwise, the program cannot be compiled. </dd>
</dl>
<p>Set the split mode of the current block cluster node as cross.</p>

<p class="reference">References <a class="el" href="classTreeNode.html#aaa2ba047902c4e2fccffe3424a0c665b">TreeNode&lt; T, N &gt;::get_data_pointer()</a>, and <a class="el" href="classTreeNode.html#a0aec2b9142e931aaaa15d1c451ed9b46">TreeNode&lt; T, N &gt;::set_split_mode()</a>.</p>

</div>
</div>
<a id="ad11fb277e43c33f2a399dc6b1c14b998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11fb277e43c33f2a399dc6b1c14b998">&#9670;&nbsp;</a></span>partition_from_block_cluster_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::partition_from_block_cluster_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">node_pointer_type</a>&#160;</td>
          <td class="paramname"><em>current_block_cluster_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaf_set_wrt_current_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a recursive partition by starting from a block cluster node in the tree.</p>
<p>N.B. The evaluation of the admissibility condition has no mesh cell size correction.</p>
<p>The algorithm performs an iteration over all the children of the current block cluster \(b = \tau \times \sigma\). Because the map \(S\) for generating the children of \(b\) is realized from a tensor product of the children of \(\tau\) and \(\sigma\), the algorithm contains nested double loops.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_block_cluster_node</td><td>The pointer to the block cluster node in the tree, from which the admissible partition will be performed. </td></tr>
    <tr><td class="paramname">all_support_points</td><td>Spatial coordinates for all the support points. </td></tr>
    <tr><td class="paramname">leaf_set</td><td>A list of block cluster node pointers which comprise the leaf set with respect to <code>current_block_cluster_node</code>. </td></tr>
  </table>
  </dd>
</dl>
<p>Push back the current cluster node, which is small, to the leaf set and set its split mode as <code>UnsplitMode</code>.</p>
<p>Make sure that the two clusters \(\tau\) and \(\sigma\) have the same level in their respective cluster trees, i.e. level preserving property should be satisfied.</p>
<p>Create a new block cluster node as child and recursively partition from it.</p>
<p>Append this new node as one of the children of the current block cluster node.</p>
<p>Update the total number of nodes in the tree.</p>
<p>Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.</p>
<p>Make sure the current block cluster have four children, which is ensured by the tensor product construction.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The second argument <code><a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>&lt;spacedim</code>, Number&gt;::child_num should be wrapped between the brackets, otherwise, the program cannot be compiled. </dd>
</dl>
<p>Set the split mode of the current block cluster node as cross.</p>

<p class="reference">References <a class="el" href="classTreeNode.html#aaa2ba047902c4e2fccffe3424a0c665b">TreeNode&lt; T, N &gt;::get_data_pointer()</a>, and <a class="el" href="classTreeNode.html#a0aec2b9142e931aaaa15d1c451ed9b46">TreeNode&lt; T, N &gt;::set_split_mode()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#a3ca42421f732c20fc07bdf5d5ab94319">BlockClusterTree&lt; spacedim, Number &gt;::partition()</a>.</p>

</div>
</div>
<a id="a425583a70d63ddbf9341a31b736bd0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425583a70d63ddbf9341a31b736bd0fe">&#9670;&nbsp;</a></span>partition_from_block_cluster_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::partition_from_block_cluster_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">node_pointer_type</a>&#160;</td>
          <td class="paramname"><em>current_block_cluster_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_size_at_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaf_set_wrt_current_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above but the evaluation of the admissibility condition has mesh cell size correction. </p>
<p>Push back the current cluster node, which is small, to the leaf set and set its split mode as <code>UnsplitMode</code>.</p>
<p>Make sure that the two clusters \(\tau\) and \(\sigma\) have the same level in their respective cluster trees, i.e. level preserving property should be satisfied.</p>
<p>Create a new block cluster node as child and recursively partition from it.</p>
<p>Append this new node as one of the children of the current block cluster node.</p>
<p>Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.</p>
<p>Make sure the current block cluster have four children, which is ensured by the tensor product construction.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The second argument <code><a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>&lt;spacedim</code>, Number&gt;::child_num should be wrapped between the brackets, otherwise, the program cannot be compiled. </dd>
</dl>
<p>Set the split mode of the current block cluster node as cross.</p>

<p class="reference">References <a class="el" href="classTreeNode.html#aaa2ba047902c4e2fccffe3424a0c665b">TreeNode&lt; T, N &gt;::get_data_pointer()</a>, and <a class="el" href="classTreeNode.html#a0aec2b9142e931aaaa15d1c451ed9b46">TreeNode&lt; T, N &gt;::set_split_mode()</a>.</p>

</div>
</div>
<a id="ab10f54639969bc4aacd6aa27cf315610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10f54639969bc4aacd6aa27cf315610">&#9670;&nbsp;</a></span>partition_tensor_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::partition_tensor_product </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a recursive partition in tensor product form without the admissibility condition because the two comprising cluster trees are built from pure cardinality based partition. </p>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a7f9dbea25751771830c72d09efacacb2">BlockClusterTree&lt; spacedim, Number &gt;::calc_depth_and_max_level()</a>, <a class="el" href="classBlockClusterTree.html#a286bd48cc863cbba7c9ad53b6bdb12ca">BlockClusterTree&lt; spacedim, Number &gt;::categorize_near_and_far_field_sets()</a>, and <a class="el" href="classBlockClusterTree.html#ae77f8167ce49871f5751b8dcf8c93153">BlockClusterTree&lt; spacedim, Number &gt;::partition_tensor_product_from_block_cluster_node()</a>.</p>

<p class="reference">Referenced by <a class="el" href="block-cluster-tree-hp_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="ae77f8167ce49871f5751b8dcf8c93153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77f8167ce49871f5751b8dcf8c93153">&#9670;&nbsp;</a></span>partition_tensor_product_from_block_cluster_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::partition_tensor_product_from_block_cluster_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">node_pointer_type</a>&#160;</td>
          <td class="paramname"><em>current_block_cluster_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaf_set_wrt_current_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a recursive tensor product type partition by starting from a block cluster node in the tree.</p>
<p>No admissibility condition is enabled in this situation, because the two comprising cluster trees are built from pure cardinality based partition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_block_cluster_node</td><td></td></tr>
    <tr><td class="paramname">leaf_set_wrt_current_node</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Push back the current cluster node, which is small, to the leaf set and set its split mode as <code>UnsplitMode</code>.</p>
<p>Make sure that the two clusters \(\tau\) and \(\sigma\) have the same level in their respective cluster trees, i.e. level preserving property should be satisfied.</p>
<p>Create a new block cluster node as child and recursively partition from it.</p>
<p>Append this new node as one of the children of the current block cluster node.</p>
<p>Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.</p>
<p>Make sure the current block cluster have four children, which is ensured by the tensor product construction.</p>
<dl class="section note">
<dt>Note </dt>
<dd>The second argument <code><a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>&lt;spacedim</code>, Number&gt;::child_num should be wrapped between the brackets, otherwise, the program cannot be compiled. </dd>
</dl>
<p>Set the split mode of the current block cluster node as cross.</p>

<p class="reference">References <a class="el" href="classTreeNode.html#aaa2ba047902c4e2fccffe3424a0c665b">TreeNode&lt; T, N &gt;::get_data_pointer()</a>, and <a class="el" href="classTreeNode.html#a0aec2b9142e931aaaa15d1c451ed9b46">TreeNode&lt; T, N &gt;::set_split_mode()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#a4a4f3b893380d1d7f53b772589a847d2">BlockClusterTree&lt; spacedim, Number &gt;::get_root()</a>, and <a class="el" href="classBlockClusterTree.html#ab10f54639969bc4aacd6aa27cf315610">BlockClusterTree&lt; spacedim, Number &gt;::partition_tensor_product()</a>.</p>

</div>
</div>
<a id="a6fd771b68a4c7195151f6dc02e8ec7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd771b68a4c7195151f6dc02e8ec7e9">&#9670;&nbsp;</a></span>prune_descendants_from_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::prune_descendants_from_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">node_pointer_type</a>&#160;</td>
          <td class="paramname"><em>bc_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prune the descendants of the given block cluster node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bc_node</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the block cluster tree is really pruned. </dd></dl>
<p>Delete the subtree emanating from each child node of the current block cluster node in the partition.</p>
<p>Update the block cluster node status including number of children and split mode.</p>

<p class="reference">References <a class="el" href="tree_8h.html#a0242ff1112ca2bb585990416bd04a666">CountTreeNodes()</a>, <a class="el" href="classBlockClusterTree.html#ae0e55e3ac56bffa31f251d4f07ae7e51">BlockClusterTree&lt; spacedim, Number &gt;::decrease_node_num()</a>, <a class="el" href="tree_8h.html#a95dd5928a5634c270b46685504798903">DeleteTree()</a>, <a class="el" href="classTreeNode.html#a077cb5cc974f94ff431c69cc2ca5957f">TreeNode&lt; T, N &gt;::get_child_num()</a>, <a class="el" href="classTreeNode.html#ad3b1833452c787d2146a4beb3587c531">TreeNode&lt; T, N &gt;::get_child_pointer()</a>, <a class="el" href="classTreeNode.html#a68c80783a2900d01a37fc33f14951e66">TreeNode&lt; T, N &gt;::set_child_num()</a>, <a class="el" href="classTreeNode.html#a3d2f374424a723cb72409857ee5237bc">TreeNode&lt; T, N &gt;::set_child_pointer()</a>, and <a class="el" href="classTreeNode.html#a0aec2b9142e931aaaa15d1c451ed9b46">TreeNode&lt; T, N &gt;::set_split_mode()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#af1663a109b6fd5c67c85e9bb88a54a13">BlockClusterTree&lt; spacedim, Number &gt;::prune_to_partition()</a>, and <a class="el" href="block__cluster__tree_8h.html#a3b2f90afbf0d192ac657f6fab5a87294">prune_to_partition_recursion()</a>.</p>

</div>
</div>
<a id="af1663a109b6fd5c67c85e9bb88a54a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1663a109b6fd5c67c85e9bb88a54a13">&#9670;&nbsp;</a></span>prune_to_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::prune_to_partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTreeNode.html">node_pointer_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_partition_in_bct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prune all those block cluster nodes which are descendants of the block cluster nodes in the given partition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td></td></tr>
    <tr><td class="paramname">is_partition_in_bct</td><td>Whether the block cluster nodes in the given <code>partition</code> are contained in this block cluster tree. </td></tr>
  </table>
  </dd>
</dl>
<p>If the block cluster nodes in the given <code>partition</code> are contained in this block cluster tree, we directly prune their descendants.</p>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a1b3396fbedf6ec07cce9c23a62b2c30b">BlockClusterTree&lt; spacedim, Number &gt;::build_leaf_set()</a>, <a class="el" href="classBlockClusterTree.html#a7f9dbea25751771830c72d09efacacb2">BlockClusterTree&lt; spacedim, Number &gt;::calc_depth_and_max_level()</a>, <a class="el" href="classBlockClusterTree.html#a286bd48cc863cbba7c9ad53b6bdb12ca">BlockClusterTree&lt; spacedim, Number &gt;::categorize_near_and_far_field_sets()</a>, and <a class="el" href="classBlockClusterTree.html#a6fd771b68a4c7195151f6dc02e8ec7e9">BlockClusterTree&lt; spacedim, Number &gt;::prune_descendants_from_node()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classHMatrix.html#af6fd60090b0de7bdea52fc84ddeb22c3">HMatrix&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees()</a>.</p>

</div>
</div>
<a id="a0415fe94fd480bbb985a45dc691e2bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0415fe94fd480bbb985a45dc691e2bed">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the memory of the block cluster tree. </p>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#ab4227d666cd2872fbbfb4eec69e66313">BlockClusterTree&lt; spacedim, Number &gt;::clear()</a>, and <a class="el" href="tree_8h.html#a95dd5928a5634c270b46685504798903">DeleteTree()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#a85553cc442e419b8d707720312118328">BlockClusterTree&lt; spacedim, Number &gt;::operator=()</a>, and <a class="el" href="classBlockClusterTree.html#a43b969867200b06f3416647c3e4f9f61">BlockClusterTree&lt; spacedim, Number &gt;::~BlockClusterTree()</a>.</p>

</div>
</div>
<a id="a02be4a882acca918386ad024769925bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02be4a882acca918386ad024769925bc">&#9670;&nbsp;</a></span>set_node_num()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::set_node_num </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>node_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the total number of nodes in the tree. </p>

<p class="reference">References <a class="el" href="classBlockClusterTree.html#a75757146cea0aa0e9271b760b1d76307">BlockClusterTree&lt; spacedim, Number &gt;::node_num</a>.</p>

</div>
</div>
<a id="aef01b51b0530536bc5481492d4719375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef01b51b0530536bc5481492d4719375">&#9670;&nbsp;</a></span>write_leaf_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::write_leaf_set </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write formatted leaf set to the output stream.</p>
<p>Each leaf node is written in the following format:</p>
<blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<p>[list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field</p>
<p>For example,</p>
<blockquote class="doxtable">
<p>[1 2 3 ...],[7 8 9 ...],1 </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Print index set of cluster \(\tau\).</p>
<p>Print index set of cluster \(\sigma\).</p>
<p>Print the <code>is_near_field</code> flag.</p>

<p class="reference">Referenced by <a class="el" href="bct-extend-finer-than-partition_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a652b1c53dff2794e2f18343bf3988e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652b1c53dff2794e2f18343bf3988e19">&#9670;&nbsp;</a></span>write_leaf_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::write_leaf_set </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number1&#160;</td>
          <td class="paramname"><em>singular_value_threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write formatted leaf set to the output stream as well as the rank of each matrix block.</p>
<p>Each leaf node is written in the following format:</p>
<blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<p>[list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field,rank</p>
<p>For example,</p>
<blockquote class="doxtable">
<p>[1 2 3 ...],[7 8 9 ...],1,1 </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Print index set of cluster \(\tau\).</p>
<p>Print index set of cluster \(\sigma\).</p>
<p>Print the <code>is_near_field</code> flag.</p>
<p>Make a local copy of the matrix block and calculate its rank using SVD.</p>
<p>Print the <code>rank</code> flag.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a6ead7d49add78a2462eb039f00bf7f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ead7d49add78a2462eb039f00bf7f6a">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;int spacedim1, typename Number1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim1, Number1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_cluster_tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print a whole block cluster tree using recursion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">block_cluster_tree</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a000c439b578bcf4fa28b7f3edd6079e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000c439b578bcf4fa28b7f3edd6079e9">&#9670;&nbsp;</a></span>child_num</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::child_num = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of children in a block cluster tree.</p>
<p>At present, only quad-tree is allowed. </p>

</div>
</div>
<a id="a77349ec9ccb36d45af3f176a93516897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77349ec9ccb36d45af3f176a93516897">&#9670;&nbsp;</a></span>depth</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::depth</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Depth of the tree, which is the maximum level plus one. </p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#a7f9dbea25751771830c72d09efacacb2">BlockClusterTree&lt; spacedim, Number &gt;::calc_depth_and_max_level()</a>, <a class="el" href="classBlockClusterTree.html#ab4227d666cd2872fbbfb4eec69e66313">BlockClusterTree&lt; spacedim, Number &gt;::clear()</a>, <a class="el" href="classBlockClusterTree.html#ab6c57acfcc5dfbbef04f028e6b9c749d">BlockClusterTree&lt; spacedim, Number &gt;::get_depth()</a>, and <a class="el" href="classBlockClusterTree.html#a85553cc442e419b8d707720312118328">BlockClusterTree&lt; spacedim, Number &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a8dc01af98989bb71246fa2cd4d7307da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc01af98989bb71246fa2cd4d7307da">&#9670;&nbsp;</a></span>is_subtree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::is_subtree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the current block cluster tree is a subtree is an existing tree. </p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#ab4227d666cd2872fbbfb4eec69e66313">BlockClusterTree&lt; spacedim, Number &gt;::clear()</a>, <a class="el" href="classBlockClusterTree.html#a85553cc442e419b8d707720312118328">BlockClusterTree&lt; spacedim, Number &gt;::operator=()</a>, and <a class="el" href="classBlockClusterTree.html#a43b969867200b06f3416647c3e4f9f61">BlockClusterTree&lt; spacedim, Number &gt;::~BlockClusterTree()</a>.</p>

</div>
</div>
<a id="a9151f138713d01c53ac17f004c7e6b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9151f138713d01c53ac17f004c7e6b62">&#9670;&nbsp;</a></span>max_level</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::max_level</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum node level in the tree, which is <code>depth</code> - 1. </p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#a7f9dbea25751771830c72d09efacacb2">BlockClusterTree&lt; spacedim, Number &gt;::calc_depth_and_max_level()</a>, <a class="el" href="classBlockClusterTree.html#ab4227d666cd2872fbbfb4eec69e66313">BlockClusterTree&lt; spacedim, Number &gt;::clear()</a>, <a class="el" href="classBlockClusterTree.html#a404693ef7dfdbc383705c38105c75e14">BlockClusterTree&lt; spacedim, Number &gt;::get_max_level()</a>, and <a class="el" href="classBlockClusterTree.html#a85553cc442e419b8d707720312118328">BlockClusterTree&lt; spacedim, Number &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a75757146cea0aa0e9271b760b1d76307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75757146cea0aa0e9271b760b1d76307">&#9670;&nbsp;</a></span>node_num</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_num</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of block clusters in the tree. </p>

<p class="reference">Referenced by <a class="el" href="classBlockClusterTree.html#ace6087e8fe7dc3d737ff6b4cd97070fc">BlockClusterTree&lt; spacedim, Number &gt;::BlockClusterTree()</a>, <a class="el" href="classBlockClusterTree.html#ab4227d666cd2872fbbfb4eec69e66313">BlockClusterTree&lt; spacedim, Number &gt;::clear()</a>, <a class="el" href="classBlockClusterTree.html#ae0e55e3ac56bffa31f251d4f07ae7e51">BlockClusterTree&lt; spacedim, Number &gt;::decrease_node_num()</a>, <a class="el" href="classBlockClusterTree.html#a042e040d2f6dfcbbfd70b43b8967c6f6">BlockClusterTree&lt; spacedim, Number &gt;::get_node_num()</a>, <a class="el" href="classBlockClusterTree.html#aec9920e5b215fbfe2aa9f54980d3b30a">BlockClusterTree&lt; spacedim, Number &gt;::increase_node_num()</a>, <a class="el" href="classBlockClusterTree.html#a85553cc442e419b8d707720312118328">BlockClusterTree&lt; spacedim, Number &gt;::operator=()</a>, and <a class="el" href="classBlockClusterTree.html#a02be4a882acca918386ad024769925bc">BlockClusterTree&lt; spacedim, Number &gt;::set_node_num()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/jihuan/Projects/deal.ii/program/dealii-9.1.1/examples/laplace-bem/include/<a class="el" href="block__cluster__tree_8h_source.html">block_cluster_tree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
