<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>laplace-bem: /home/jihuan/Projects/deal.ii/program/dealii-9.1.1/examples/laplace-bem/include/hmatrix.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    skipTags: ["script","noscript","style","textarea","pre","code"],
    processEscapes: false,
    processEnvironments: true,
    preview: "TeX"
  },
  TeX: {
    Macros: {
      intd: "\\,{\\rm d}",
      diff: "{\\rm d}",
      Diff: "{\\rm D}",
      pdiff: "\\partial",
      DD: ["\\frac{\\diff}{\\diff #2}\\left( #1 \\right)", 2],
      Dd: ["\\frac{\\diff #1}{\\diff #2}", 2],
      PD: ["\\frac{\\pdiff}{\\pdiff #2}\\left( #1 \\right)", 2],
      Pd: ["\\frac{\\pdiff #1}{\\pdiff #2}", 2],
      rme: "{\\rm e}",
      rmi: "{\\rm i}",
      rmj: "{\\rm j}",
      vect: ["\\boldsymbol{#1}", 1],
      dform: ["\\overset{\\rightharpoonup}{\\boldsymbol{#1}}", 1],
      cochain: ["\\overset{\\rightharpoonup}{#1}", 1],
      Abs: ["\\big\\lvert#1\\big\\rvert", 1],
      abs: ["\\lvert#1\\rvert", 1],
      Norm: ["\\big\\lVert#1\\big\\rVert", 1],
      norm: ["\\lVert#1\\rVert", 1],
      normvect: "\\vect{n}",
      ouset: ["\\overset{#3}{\\underset{#2}{#1}}", 3],
      cscript: ["\\;\\; #1", 1],
      suchthat: "\\textit{S.T.\\;}",
      prefstar: "\\ast",
      restrict: "\\big\\vert",
      sgn: "{\\rm sgn}",
      erf: "{\\rm erf}",
      Bd: "{\\rm Bd}",
      Int: "{\\rm Int}",
      rank: "{\\rm rank}",
      divergence: "{\\rm div}",
      grad: "{\\rm grad}",
      tr: "{\\rm tr}",
      span: "{\\rm span}"
    },
    extensions: ["AMScd.js"],
    equationNumbers: { autoNumber: "AMS" }
  },
  "HTML-CSS": {
     availableFonts: ["STIX","TeX"],
     preferredFont: "TeX",
     webFont: "TeX",
     imageFont: "TeX",
     showMathMenu: true
  },
  MMLorHTML: {
    prefer: {
      MSIE:    "MML",
      Firefox: "MML",
      Opera:   "HTML",
      other:   "HTML"
    }
  }
});
</script><script type="text/javascript" src="http://localhost/js/MathJax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">laplace-bem
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Solve Laplace problem using the boundary element method (BEM)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">hmatrix.h File Reference<div class="ingroups"><a class="el" href="group__hierarchical__matrices.html">Hierarchical matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Definition of hierarchical matrix.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;deal.II/base/logstream.h&gt;</code><br />
<code>#include &lt;deal.II/lac/full_matrix.h&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="block__cluster_8h_source.html">block_cluster.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="block__cluster__tree_8h_source.html">block_cluster_tree.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="generic__functors_8h_source.html">generic_functors.h</a>&quot;</code><br />
<code>#include &quot;lapack_full_matrix_ext.h&quot;</code><br />
<code>#include &quot;<a class="el" href="rkmatrix_8h_source.html">rkmatrix.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for hmatrix.h:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="hmatrix_8h__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="hmatrix_8h__dep__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</div>
<p><a href="hmatrix_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html">HMatrix&lt; spacedim, Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac04719e202c88f36e4533fe1d326a494"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a> { <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, 
<a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, 
<a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, 
<a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>
 }</td></tr>
<tr class="separator:ac04719e202c88f36e4533fe1d326a494"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a42e2d29cc860fddf6697fc294d76460a"><td class="memItemLeft" align="right" valign="top"><a id="a42e2d29cc860fddf6697fc294d76460a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DeclException1</b> (ExcInvalidHMatrixType, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a>,&lt;&lt; &quot;Invalid <a class="el" href="classHMatrix.html">HMatrix</a> type &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:a42e2d29cc860fddf6697fc294d76460a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21892e360616f81dd5ad1c7089f9eaab"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a21892e360616f81dd5ad1c7089f9eaab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type bc_node)</td></tr>
<tr class="separator:a21892e360616f81dd5ad1c7089f9eaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d510b10595b78a40764950441bcbaf"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ae5d510b10595b78a40764950441bcbaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ae5d510b10595b78a40764950441bcbaf">InitHMatrixWrtBlockClusterNode</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type bc_node, const std::vector&lt; std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&gt;&gt; &amp;Sigma_P)</td></tr>
<tr class="separator:ae5d510b10595b78a40764950441bcbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1d1afba43d1a66f46ee4799a9904a2"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a0f1d1afba43d1a66f46ee4799a9904a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a0f1d1afba43d1a66f46ee4799a9904a2">InitHMatrixWrtBlockClusterNode</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type bc_node, const std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&gt; &amp;hmat_pair)</td></tr>
<tr class="separator:a0f1d1afba43d1a66f46ee4799a9904a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e47eb35744c93b8955b6d564e5bf9a"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a65e47eb35744c93b8955b6d564e5bf9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a65e47eb35744c93b8955b6d564e5bf9a">InitAndCreateHMatrixChildrenWithoutAlloc</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type bc_node, const bool is_build_index_set_global_to_local_map=true)</td></tr>
<tr class="separator:a65e47eb35744c93b8955b6d564e5bf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317e4841d6bb5b60883a7e21027a8893"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a317e4841d6bb5b60883a7e21027a8893"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type bc_node, const unsigned int fixed_rank_k, bool is_build_index_set_global_to_local_map=true)</td></tr>
<tr class="separator:a317e4841d6bb5b60883a7e21027a8893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b56a9e943f5632f50d08f4e892b1787"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a2b56a9e943f5632f50d08f4e892b1787"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a2b56a9e943f5632f50d08f4e892b1787">InitAndCreateHMatrixChildren</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type bc_node, const unsigned int fixed_rank_k, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, bool is_build_index_set_global_to_local_map=true)</td></tr>
<tr class="separator:a2b56a9e943f5632f50d08f4e892b1787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b547084e856ac11a021c104331400cf"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a6b547084e856ac11a021c104331400cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a6b547084e856ac11a021c104331400cf">InitAndCreateHMatrixChildren</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type bc_node, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, bool is_build_index_set_global_to_local_map=true)</td></tr>
<tr class="separator:a6b547084e856ac11a021c104331400cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53120559ced904c076a4914af3e9423a"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a53120559ced904c076a4914af3e9423a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a53120559ced904c076a4914af3e9423a">InitAndCreateHMatrixChildren</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type bc_node, const unsigned int fixed_rank_k, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, const std::map&lt; types::global_dof_index, size_t &gt; &amp;row_index_global_to_local_map_for_M, const std::map&lt; types::global_dof_index, size_t &gt; &amp;col_index_global_to_local_map_for_M, bool is_build_index_set_global_to_local_map=true)</td></tr>
<tr class="separator:a53120559ced904c076a4914af3e9423a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427e26a795634442821a7baf5f34a8ed"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a427e26a795634442821a7baf5f34a8ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a427e26a795634442821a7baf5f34a8ed">InitAndCreateHMatrixChildren</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type bc_node, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, const std::map&lt; types::global_dof_index, size_t &gt; &amp;row_index_global_to_local_map_for_M, const std::map&lt; types::global_dof_index, size_t &gt; &amp;col_index_global_to_local_map_for_M, bool is_build_index_set_global_to_local_map=true)</td></tr>
<tr class="separator:a427e26a795634442821a7baf5f34a8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf5008e3967b1029d5b766290c98139"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a9cf5008e3967b1029d5b766290c98139"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a9cf5008e3967b1029d5b766290c98139">InitAndCreateHMatrixChildren</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type bc_node, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;H)</td></tr>
<tr class="separator:a9cf5008e3967b1029d5b766290c98139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090df12c1646d637bc390fa6dae55f24"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a090df12c1646d637bc390fa6dae55f24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *starting_hmat, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *current_hmat)</td></tr>
<tr class="separator:a090df12c1646d637bc390fa6dae55f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b0f4d71b52952d99ee7ecb0eb033cb"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a13b0f4d71b52952d99ee7ecb0eb033cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat_block, const unsigned int fixed_rank_k, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat_root_block=nullptr, size_t *calling_counter=nullptr, const std::string &amp;output_file_base_name=std::string(&quot;hmat-bct&quot;))</td></tr>
<tr class="separator:a13b0f4d71b52952d99ee7ecb0eb033cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee9050ba0b224929bcbf99484385a59"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:afee9050ba0b224929bcbf99484385a59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:afee9050ba0b224929bcbf99484385a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b93b5c19ef281408c6ed1e6460462e5"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a9b93b5c19ef281408c6ed1e6460462e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a9b93b5c19ef281408c6ed1e6460462e5">h_rk_mmult</a> (const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a9b93b5c19ef281408c6ed1e6460462e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0d61778a104b7e1452c3b9be60b5e4"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a4d0d61778a104b7e1452c3b9be60b5e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a4d0d61778a104b7e1452c3b9be60b5e4">h_rk_mTmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a4d0d61778a104b7e1452c3b9be60b5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbe51ba1fe5ea83d5910d1f893d589f"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:acfbe51ba1fe5ea83d5910d1f893d589f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#acfbe51ba1fe5ea83d5910d1f893d589f">h_rk_mTmult</a> (const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:acfbe51ba1fe5ea83d5910d1f893d589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84df06910d958d84ac8c544f9a8423a8"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a84df06910d958d84ac8c544f9a8423a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M, bool is_M1M2_last_in_M_Sigma_P=true)</td></tr>
<tr class="separator:a84df06910d958d84ac8c544f9a8423a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d344d3d2c8db0c93690bf7cbd4a4459"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a5d344d3d2c8db0c93690bf7cbd4a4459"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult</a> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a5d344d3d2c8db0c93690bf7cbd4a4459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e90e9592ce3d05bdea99a9b93d7606"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:af5e90e9592ce3d05bdea99a9b93d7606"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#af5e90e9592ce3d05bdea99a9b93d7606">rk_h_mmult</a> (const Number alpha, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:af5e90e9592ce3d05bdea99a9b93d7606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca19ab9519b7b1aa1b9660dbfa8fe604"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:aca19ab9519b7b1aa1b9660dbfa8fe604"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#aca19ab9519b7b1aa1b9660dbfa8fe604">rk_h_mTmult</a> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:aca19ab9519b7b1aa1b9660dbfa8fe604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2eac81199c6e3cdf57242dfae682841"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ab2eac81199c6e3cdf57242dfae682841"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ab2eac81199c6e3cdf57242dfae682841">rk_h_mTmult</a> (const Number alpha, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:ab2eac81199c6e3cdf57242dfae682841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43aef4fd52ce71103baa047f549293c6"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a43aef4fd52ce71103baa047f549293c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M, bool is_M1M2_last_in_M_Sigma_P=true)</td></tr>
<tr class="separator:a43aef4fd52ce71103baa047f549293c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae495fd6b480f203cf797e7e86e996313"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ae495fd6b480f203cf797e7e86e996313"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:ae495fd6b480f203cf797e7e86e996313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb4579cb7d6a65805c548aa9c3f97b9"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:aceb4579cb7d6a65805c548aa9c3f97b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#aceb4579cb7d6a65805c548aa9c3f97b9">h_f_mmult</a> (const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:aceb4579cb7d6a65805c548aa9c3f97b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5bc5080b3c7e065e70fdba10faae55"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a8c5bc5080b3c7e065e70fdba10faae55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a8c5bc5080b3c7e065e70fdba10faae55">h_f_mTmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a8c5bc5080b3c7e065e70fdba10faae55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2ffe1ccde0ac2a90b63cfdd92a5235"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a3a2ffe1ccde0ac2a90b63cfdd92a5235"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a3a2ffe1ccde0ac2a90b63cfdd92a5235">h_f_mTmult</a> (const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a3a2ffe1ccde0ac2a90b63cfdd92a5235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723281b6cf62859890ec5ee49555c908"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a723281b6cf62859890ec5ee49555c908"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a723281b6cf62859890ec5ee49555c908">h_f_mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a723281b6cf62859890ec5ee49555c908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398869486c36312aefc9c22f395fc494"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a398869486c36312aefc9c22f395fc494"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a398869486c36312aefc9c22f395fc494">h_f_mmult</a> (const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a398869486c36312aefc9c22f395fc494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f0b303f7933e220bb976db96536ef9"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ac9f0b303f7933e220bb976db96536ef9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ac9f0b303f7933e220bb976db96536ef9">h_f_mTmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:ac9f0b303f7933e220bb976db96536ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4df594f8278dbd00a4d098f6e591f68"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ab4df594f8278dbd00a4d098f6e591f68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ab4df594f8278dbd00a4d098f6e591f68">h_f_mTmult</a> (const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:ab4df594f8278dbd00a4d098f6e591f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374070dba133f2152e9c44ce10947f20"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a374070dba133f2152e9c44ce10947f20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M, bool is_M1M2_last_in_M_Sigma_P=true)</td></tr>
<tr class="separator:a374070dba133f2152e9c44ce10947f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b25e6262a25b27f374cab704407437"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a37b25e6262a25b27f374cab704407437"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult</a> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a37b25e6262a25b27f374cab704407437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a2ebfa11a73c83d768089617e308d8"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a34a2ebfa11a73c83d768089617e308d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a34a2ebfa11a73c83d768089617e308d8">f_h_mmult</a> (const Number alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a34a2ebfa11a73c83d768089617e308d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf140473681cc5ea3ab57fafdc986357"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:acf140473681cc5ea3ab57fafdc986357"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#acf140473681cc5ea3ab57fafdc986357">f_h_mTmult</a> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:acf140473681cc5ea3ab57fafdc986357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9fbb4b9a0e5e87096e8d8f833cbb76"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a8d9fbb4b9a0e5e87096e8d8f833cbb76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a8d9fbb4b9a0e5e87096e8d8f833cbb76">f_h_mTmult</a> (const Number alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a8d9fbb4b9a0e5e87096e8d8f833cbb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2138cf7f25917862b5353a6ceee9ea11"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a2138cf7f25917862b5353a6ceee9ea11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a2138cf7f25917862b5353a6ceee9ea11">f_h_mmult</a> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a2138cf7f25917862b5353a6ceee9ea11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951849a7b68e93f385c9e1fa0c4c251d"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a951849a7b68e93f385c9e1fa0c4c251d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a951849a7b68e93f385c9e1fa0c4c251d">f_h_mmult</a> (const Number alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a951849a7b68e93f385c9e1fa0c4c251d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942dd3cabbf54bd4e6bc5a922746b257"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a942dd3cabbf54bd4e6bc5a922746b257"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a942dd3cabbf54bd4e6bc5a922746b257">f_h_mTmult</a> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a942dd3cabbf54bd4e6bc5a922746b257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e6b54a178a7a0149f5ad6336e4e49c"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ae7e6b54a178a7a0149f5ad6336e4e49c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ae7e6b54a178a7a0149f5ad6336e4e49c">f_h_mTmult</a> (const Number alpha, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:ae7e6b54a178a7a0149f5ad6336e4e49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242e7e3da010e972783e20326ae15a36"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a242e7e3da010e972783e20326ae15a36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M, bool is_M1M2_last_in_M_Sigma_P=true)</td></tr>
<tr class="separator:a242e7e3da010e972783e20326ae15a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad08ee9bd389abe7b7b76fd0f2cb292e"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:aad08ee9bd389abe7b7b76fd0f2cb292e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#aad08ee9bd389abe7b7b76fd0f2cb292e">h_h_mmult_phase1_recursion</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;Tind)</td></tr>
<tr class="separator:aad08ee9bd389abe7b7b76fd0f2cb292e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199fb48349b9486624a3c55c5aece3f4"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a199fb48349b9486624a3c55c5aece3f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;target_bc_tree, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a199fb48349b9486624a3c55c5aece3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b842125056627d38c5aee3a077e596c"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a2b842125056627d38c5aee3a077e596c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a2b842125056627d38c5aee3a077e596c">h_h_mmult_from_leaf_node</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a2b842125056627d38c5aee3a077e596c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb1a4bfe1f72bde6920f716eb9314a0"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a7cb1a4bfe1f72bde6920f716eb9314a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a7cb1a4bfe1f72bde6920f716eb9314a0">h_h_mmult_from_leaf_node</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a7cb1a4bfe1f72bde6920f716eb9314a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d49e86d3c8b5596b1b603793818276"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:ab9d49e86d3c8b5596b1b603793818276"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ab9d49e86d3c8b5596b1b603793818276">h_h_mTmult_from_leaf_node</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const unsigned int fixed_rank)</td></tr>
<tr class="separator:ab9d49e86d3c8b5596b1b603793818276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8abc06deedda9951406d65af89e42f"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a9b8abc06deedda9951406d65af89e42f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a9b8abc06deedda9951406d65af89e42f">h_h_mTmult_from_leaf_node</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a9b8abc06deedda9951406d65af89e42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6534ff122b0835d0313d94264794b601"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a6534ff122b0835d0313d94264794b601"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a6534ff122b0835d0313d94264794b601">h_h_mmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a6534ff122b0835d0313d94264794b601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed620dee37feefb517062f960c9810e"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a0ed620dee37feefb517062f960c9810e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a0ed620dee37feefb517062f960c9810e">h_h_mmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a0ed620dee37feefb517062f960c9810e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8855023aa4832e4119c6ead1115d4beb"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a8855023aa4832e4119c6ead1115d4beb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a8855023aa4832e4119c6ead1115d4beb">h_h_mTmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a8855023aa4832e4119c6ead1115d4beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6025a164b80c84f13121a5b6af3fab7b"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a6025a164b80c84f13121a5b6af3fab7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a6025a164b80c84f13121a5b6af3fab7b">h_h_mTmult_level_conserving</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M0, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, const Number alpha, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a6025a164b80c84f13121a5b6af3fab7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eeb0a11d6f43231a21267b2b45fefb2"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a1eeb0a11d6f43231a21267b2b45fefb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat_dst, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat_src)</td></tr>
<tr class="separator:a1eeb0a11d6f43231a21267b2b45fefb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e61ba5438c4cf0337664ec4b8562873"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a3e61ba5438c4cf0337664ec4b8562873"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a3e61ba5438c4cf0337664ec4b8562873">copy_hmatrix_node</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat_dst, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;hmat_src)</td></tr>
<tr class="separator:a3e61ba5438c4cf0337664ec4b8562873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b3e4f5b78b4b6a9885325225eba0a1"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:af4b3e4f5b78b4b6a9885325225eba0a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#af4b3e4f5b78b4b6a9885325225eba0a1">copy_hmatrix</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat_dst, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat_src)</td></tr>
<tr class="separator:af4b3e4f5b78b4b6a9885325225eba0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb67e27b0623d39d9b974fe43b56c349"><td class="memTemplParams" colspan="2"><a id="abb67e27b0623d39d9b974fe43b56c349"></a>
template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:abb67e27b0623d39d9b974fe43b56c349"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>print_h_submatrix_accessor</b> (std::ostream &amp;out, const std::string &amp;name, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M)</td></tr>
<tr class="separator:abb67e27b0623d39d9b974fe43b56c349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a2429426558ca0d6982f97b3669bf3"><td class="memTemplParams" colspan="2"><a id="a78a2429426558ca0d6982f97b3669bf3"></a>
template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a78a2429426558ca0d6982f97b3669bf3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>print_h_h_submatrix_mmult_accessor</b> (std::ostream &amp;out, const std::string &amp;name1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const std::string &amp;name2, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2)</td></tr>
<tr class="separator:a78a2429426558ca0d6982f97b3669bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b34ad37e3ad46b0fc514ad4a428e18"><td class="memTemplParams" colspan="2"><a id="a88b34ad37e3ad46b0fc514ad4a428e18"></a>
template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a88b34ad37e3ad46b0fc514ad4a428e18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hmatrix_solve_lu</b> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;L, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;U, Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b)</td></tr>
<tr class="separator:a88b34ad37e3ad46b0fc514ad4a428e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d08a58ab3946a4c2912f3b0af531f7"><td class="memTemplParams" colspan="2"><a id="aa4d08a58ab3946a4c2912f3b0af531f7"></a>
template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:aa4d08a58ab3946a4c2912f3b0af531f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hmatrix_solve_cholesky</b> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;L, Vector&lt; Number &gt; &amp;x, const Vector&lt; Number &gt; &amp;b)</td></tr>
<tr class="separator:aa4d08a58ab3946a4c2912f3b0af531f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Definition of hierarchical matrix. </p>
<dl class="section date"><dt>Date</dt><dd>2021-06-06 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jihuan Tian </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac04719e202c88f36e4533fe1d326a494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04719e202c88f36e4533fe1d326a494">&#9670;&nbsp;</a></span>HMatrixType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix type of an HMaxtrix, which can be full matrix in the near field, rank-k matrix in the far field and hierarchical matrix which does not belong to the leaf set of a block cluster tree. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924"></a>FullMatrixType&#160;</td><td class="fielddoc"><p>FullMatrixType. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c"></a>RkMatrixType&#160;</td><td class="fielddoc"><p>RkMatrixType. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d"></a>HierarchicalMatrixType&#160;</td><td class="fielddoc"><p>HierarchicalType. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7"></a>UndefinedMatrixType&#160;</td><td class="fielddoc"><p>UndefinedMatrixType. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a13b0f4d71b52952d99ee7ecb0eb033cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b0f4d71b52952d99ee7ecb0eb033cb">&#9670;&nbsp;</a></span>convertHMatBlockToRkMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void convertHMatBlockToRkMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat_root_block</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>calling_counter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_file_base_name</em> = <code>std::string(&quot;hmat-bct&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an \(\mathcal{H}\)-matrix block <code>hmat_block</code> recursively into a rank-k matrix or a full matrix, which depends on whether the block cluster associated with <code>hmat_block</code> is large or not.</p>
<p>Generally speaking, this method can be considered as the agglomeration of all descendants of <code>hmat_block</code>.</p>
<dl class="section note">
<dt>Note </dt>
<dd>This method implements the operator \(\mathcal{T}_r^{\mathcal{R} \leftarrow \mathcal{H}}\), i.e. the algorithm \(Convert\_H\) in (7.8) in Hackbusch's \(\mathcal{H}\)-matrix book. </dd>
</dl>
<p>This \(\mathcal{H}\)-matrix block is implemented as a node in a whole \(\mathcal{H}\)-matrix hierarchy. This conversion algorithm will recursively descend in the hierarchical matrices for processing:</p>
<ol type="1">
<li>when the current matrix block belongs to the near field set \(P^-\), it is represented as a full matrix and no operations will be applied to it;</li>
<li>when it belongs to the far field set \(P^+\), it is already a rank-k matrix, which will then be truncated to the given <code>fixed_rank_k</code>;</li>
<li><p class="startli">when it is not a leaf, i.e. it is a hierarchical matrix, this function will be called recursively for each of its children. After that,</p>
<p class="startli">a. if the block cluster related to the current matrix is large, pairwise agglomeration for rank-k matrices will be performed and a rank-k matrix will be obtained with the given rank <code>fixed_rank_k</code>;</p>
<p class="startli">b. if the block cluster related to the current matrix is small, agglomeration of full matrices will be performed and a full matrix will be obtained.</p>
</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat_block</td><td>the pointer to the current matrix block from which the recursion will start. </td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td>the fixed rank to which the rank-k matrices in the far field set will be truncated. </td></tr>
    <tr><td class="paramname">hmat_root_block</td><td>the pointer to the root \(\mathcal{H}\)-matrix block, which is only used for exporting matrix partition structure for further visualization. </td></tr>
    <tr><td class="paramname">calling_counter</td><td>the pointer to the counter which records the current total number of calling times of this function. Its value will be used to construct the name of the output file, which stores the matrix partition structure. </td></tr>
    <tr><td class="paramname">output_file_base_name</td><td>the based name of the output file which stores the matrix partition structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section">
<dt>Work flow </dt>
<dd><p class="startdd"></p>
<p>When the current \(\mathcal{H}\)-matrix block belongs to the leaf set.</p>
<p>When the current \(\mathcal{H}\)-matrix belongs to the near field set, it should be of a full matrix type. Therefore, we make an assertion here. After that we do nothing, since a near field node should always be represented as a full matrix, thus the rank truncation should not be applied.</p>
<p>When the current \(\mathcal{H}\)-matrix belongs to the far field set, it should be of a rank-k matrix type. Therefore, we make an assertion here. After that the rank-k matrix block is truncated to the specified rank.</p>
<p>When the current \(\mathcal{H}\)-matrix block does not belong to the leaf set, recursively convert each child of it to rank-k matrix if possible.</p>
<p>When the current \(\mathcal{H}\)-matrix block belongs to the near field set, we perform the operation of full matrix agglomeration.</p>
<dl class="section note">
<dt>Note </dt>
<dd><p class="startdd">Normally, this case cannot happen because when an \(\mathcal{H}\)-matrix block belongs to the near field, it is represented as a full matrix and belongs to the leaf set. However, this contradicts the precondition that the current \(\mathcal{H}\)-matrix block does not belong to the leaf set.</p>
<p class="enddd">But still this situation may happen during the conversion of an \(\mathcal{H}\)-matrix to a different block cluster tree. </p>
</dd>
</dl>
<p><b>The general work flow for the agglomeration of a set of full matrix blocks is as below.</b></p>
<ol type="1">
<li><p class="startli">Create a large full matrix on the heap and assemble all submatrices into it which depends on the split mode of the block cluster.</p>
<p class="startli">a. When it is <code>CrossSplitMode</code>, apply agglomeration of four full submatrices.</p>
<p class="startli">b. When the split mode is <code>HorizontalSplitMode</code>, apply agglomeration of two full submatrices via vertical stacking.</p>
<p class="startli">c. When the split mode is <code>VerticalSplitMode</code>, apply agglomeration of two full submatrices via horizontal stacking.</p>
</li>
<li>Delete all submatrices associated with the current \(\mathcal{H}\)-matrix and clear the <code>std::vector</code> storing submatrix pointers.</li>
<li>Associate the new large full matrix with the current \(\mathcal{H}\)-matrix.</li>
<li>Update the \(\mathcal{H}\)-matrix type as <code>FullMatrix</code>.</li>
</ol>
<p><b>About matrix assembly for <code>CrossSplitMode</b></code> </p>
<p>Let the block cluster associated with the current \(\mathcal{H}\)-matrix is \(\tau \times \sigma\). Assume the clusters are partitioned as \(\tau = [\tau_1, \tau_2]\) and \(\sigma = [\sigma_1, \sigma_2]\). Then the ordering of the child block clusters are \(\tau_1 \times \sigma_1, \tau_1 \times \sigma_2, \tau_2 \times \sigma_1, \tau_2 \times \sigma_2\).</p>
<p>Build the map from the global DoF indices to the local row indices of the current \(\mathcal{H}\)-matrix node, if necessary.</p>
<p>Build the map from the global DoF indices to the local column indices of the current \(\mathcal{H}\)-matrix node, if necessary.</p>
<p>When the current \(\mathcal{H}\)-matrix block belongs to the far field set, perform the pairwise matrix agglomeration of rank-k submatrices or full submatrices, which has been implemented into the constructor of <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>.</p>
<p>Build the map from the global DoF indices to the local row indices of the current \(\mathcal{H}\)-matrix node, if necessary.</p>
<p>Build the map from the global DoF indices to the local column indices of the current \(\mathcal{H}\)-matrix node, if necessary.</p>
<p>If the children of the current \(\mathcal{H}\)-matrix block are rank-k matrices, perform the pairwise rank-k matrix agglomeration directly.</p>
<p>If the children of the current \(\mathcal{H}\)-matrix block are full matrices, firstly convert all of them into rank-k matrices, then perform the pairwise rank-k matrix agglomeration.</p>
<p>Other cases are invalid.</p>
<p>If the children of the current \(\mathcal{H}\)-matrix block are rank-k matrices, perform the pairwise rank-k matrix agglomeration directly.</p>
<p>If the children of the current \(\mathcal{H}\)-matrix block are full matrices, firstly convert all of them into rank-k matrices, then perform the pairwise rank-k matrix agglomeration.</p>
<p>Other cases are invalid.</p>
<p>If the children of the current \(\mathcal{H}\)-matrix block are rank-k matrices, perform the pairwise rank-k matrix agglomeration directly.</p>
<p>If the children of the current \(\mathcal{H}\)-matrix block are full matrices, firstly convert all of them into rank-k matrices, then perform the pairwise rank-k matrix agglomeration.</p>
<p>Other cases are invalid.</p>
<p>Visualize the partition structure if a not-null pointer to the root \(\mathcal{H}\)-matrix node and a a not-null pointer to a <code>calling_counter</code> are provided.</p>
<p class="enddd"></p>
</dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-rkmatrix-conversion_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="af4b3e4f5b78b4b6a9885325225eba0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b3e4f5b78b4b6a9885325225eba0a1">&#9670;&nbsp;</a></span>copy_hmatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void copy_hmatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively copy an \(\mathcal{H}\)-matrix into the target matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M_dst</td><td></td></tr>
    <tr><td class="paramname">M_src</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Copy the current \(\mathcal{H}\)-matrix node.</p>
<p>Recursively copy child \(\mathcal{H}\)-matrix nodes.</p>
<p>Create a corresponding child \(\mathcal{H}\)-matrix node on the heap and push it back into the <code>submatrices</code> list of the current \(\mathcal{H}\)-matrix node.</p>

<p class="reference">References <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, <a class="el" href="classHMatrix.html#a71690997092a4142799b2fa2dbf53db4">HMatrix&lt; spacedim, Number &gt;::parent</a>, and <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>.</p>

</div>
</div>
<a id="a1eeb0a11d6f43231a21267b2b45fefb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eeb0a11d6f43231a21267b2b45fefb2">&#9670;&nbsp;</a></span>copy_hmatrix_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void copy_hmatrix_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deep copy an \(\mathcal{H}\)-matrix node into the target node, i.e. the copy is limited within the current node without recursion into its descendants. This function will be called by <code>copy_hmatrix</code>.</p>
<p>N.B. Do not copy the list <code>submatrices</code> from the source submatrix, because newly created child matrices will be pushed back into this list.</p>
<p>Do not copy the list <code>leaf_set</code>. After the whole \(\mathcal{H}\)-matrix hierarchy has been constructed, the leaf set will be built in the constructor.</p>
<p>Do not copy the working data: <code>Sigma_P</code>, <code>Sigma_F</code>, <code>Sigma_R</code> and <code>Tind</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat_dst</td><td></td></tr>
    <tr><td class="paramname">hmat_src</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Copy the rank-k matrix in the source submatrix if it is not <code>NULL</code>.</p>
<p>Copy the full matrix in the source submatrix if it is not <code>NULL</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a64c851dd63ba1a466c19f451be369475">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#af4b3e4f5b78b4b6a9885325225eba0a1">copy_hmatrix()</a>.</p>

</div>
</div>
<a id="a3e61ba5438c4cf0337664ec4b8562873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e61ba5438c4cf0337664ec4b8562873">&#9670;&nbsp;</a></span>copy_hmatrix_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void copy_hmatrix_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>hmat_src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shallow copy an \(\mathcal{H}\)-matrix node into the target node, i.e. the copy is limited within the current node without recursion into its descendants. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat_dst</td><td></td></tr>
    <tr><td class="paramname">hmat_src</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a71690997092a4142799b2fa2dbf53db4">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a64c851dd63ba1a466c19f451be369475">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, <a class="el" href="classHMatrix.html#a12da9454687e5ca15837d63e2bf0b595">HMatrix&lt; spacedim, Number &gt;::Tind</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a37b25e6262a25b27f374cab704407437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b25e6262a25b27f374cab704407437">&#9670;&nbsp;</a></span>f_h_mmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of a full matrix and a \(\mathcal{H}\)-matrix. A full matrix is returned in <code>M</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classLAPACKFullMatrixExt.html#a74d566120461e1a2437b9fd9a070633f">LAPACKFullMatrixExt&lt; Number &gt;::fill_row()</a>, <a class="el" href="classLAPACKFullMatrixExt.html#abc010374ccacc6d1e482196af807d247">LAPACKFullMatrixExt&lt; Number &gt;::get_row()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a6534ff122b0835d0313d94264794b601">h_h_mmult_level_conserving()</a>, and <a class="el" href="fullmatrix-hmatrix-mmult_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a34a2ebfa11a73c83d768089617e308d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a2ebfa11a73c83d768089617e308d8">&#9670;&nbsp;</a></span>f_h_mmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of a full matrix and a \(\mathcal{H}\)-matrix and the result is scaled by a factor. A full matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>
<p><b>Since the following <code>Tvmult</code> will compute \(y = y + M^T x\), <code>result_vect</code> should be reset to zero beforehand.</b></p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classLAPACKFullMatrixExt.html#a74d566120461e1a2437b9fd9a070633f">LAPACKFullMatrixExt&lt; Number &gt;::fill_row()</a>, <a class="el" href="classLAPACKFullMatrixExt.html#abc010374ccacc6d1e482196af807d247">LAPACKFullMatrixExt&lt; Number &gt;::get_row()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>.</p>

</div>
</div>
<a id="a2138cf7f25917862b5353a6ceee9ea11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2138cf7f25917862b5353a6ceee9ea11">&#9670;&nbsp;</a></span>f_h_mmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of a full matrix and a \(\mathcal{H}\)-matrix. A rank-k matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p><b>The creation of the rank-k matrix <code>M1_rk</code> from <code>M1</code> will modify <code>M1</code> internally. Hence, we make a copy of <code>M1</code> here.</b></p>

<p class="reference">References <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, and <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>.</p>

</div>
</div>
<a id="a951849a7b68e93f385c9e1fa0c4c251d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951849a7b68e93f385c9e1fa0c4c251d">&#9670;&nbsp;</a></span>f_h_mmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of a full matrix and a \(\mathcal{H}\)-matrix and the result is scaled by a factor. A rank-k matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p><b>The creation of the rank-k matrix <code>M1_rk</code> from <code>M1</code> will modify <code>M1</code> internally. Hence, we make a copy of <code>M1</code> here.</b></p>

<p class="reference">References <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, and <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>.</p>

</div>
</div>
<a id="a242e7e3da010e972783e20326ae15a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242e7e3da010e972783e20326ae15a36">&#9670;&nbsp;</a></span>f_h_mmult_for_h_h_mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mmult_for_h_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_M1M2_last_in_M_Sigma_P</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of two \(\mathcal{H}\)-matrices, where the first one is of <code>FullMatrixType</code>. An \(\mathcal{H}\)-matrix is returned in <code>M</code>, which is either of <code>FullMatrixType</code> or <code>RkMatrixType</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">is_M1M2_last_in_M_Sigma_P</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Full matrix is returned.</p>
<p>Rank-k matrix is returned.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a9e023f39b1f8916117a63557895a91b4">HMatrix&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="acf140473681cc5ea3ab57fafdc986357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf140473681cc5ea3ab57fafdc986357">&#9670;&nbsp;</a></span>f_h_mTmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mTmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of a full matrix and a \(\mathcal{H}\)-matrix with the second operand being transposed. A full matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classLAPACKFullMatrixExt.html#a74d566120461e1a2437b9fd9a070633f">LAPACKFullMatrixExt&lt; Number &gt;::fill_row()</a>, <a class="el" href="classLAPACKFullMatrixExt.html#abc010374ccacc6d1e482196af807d247">LAPACKFullMatrixExt&lt; Number &gt;::get_row()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a8855023aa4832e4119c6ead1115d4beb">h_h_mTmult_level_conserving()</a>.</p>

</div>
</div>
<a id="a8d9fbb4b9a0e5e87096e8d8f833cbb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9fbb4b9a0e5e87096e8d8f833cbb76">&#9670;&nbsp;</a></span>f_h_mTmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mTmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of a full matrix and a \(\mathcal{H}\)-matrix with the second operand being transposed, the result of which will be scaled by a factor. A full matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classLAPACKFullMatrixExt.html#a74d566120461e1a2437b9fd9a070633f">LAPACKFullMatrixExt&lt; Number &gt;::fill_row()</a>, <a class="el" href="classLAPACKFullMatrixExt.html#abc010374ccacc6d1e482196af807d247">LAPACKFullMatrixExt&lt; Number &gt;::get_row()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

</div>
</div>
<a id="a942dd3cabbf54bd4e6bc5a922746b257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942dd3cabbf54bd4e6bc5a922746b257">&#9670;&nbsp;</a></span>f_h_mTmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mTmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of a full matrix and a \(\mathcal{H}\)-matrix with the second operand being transposed. A rank-k matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p><b>The creation of the rank-k matrix <code>M1_rk</code> from <code>M1</code> will modify <code>M1</code> internally. Hence, we make a copy of <code>M1</code> here.</b></p>

<p class="reference">References <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, and <a class="el" href="hmatrix_8h.html#aca19ab9519b7b1aa1b9660dbfa8fe604">rk_h_mTmult()</a>.</p>

</div>
</div>
<a id="ae7e6b54a178a7a0149f5ad6336e4e49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e6b54a178a7a0149f5ad6336e4e49c">&#9670;&nbsp;</a></span>f_h_mTmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mTmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of a full matrix and a \(\mathcal{H}\)-matrix with the second operand being transposed. The result will be scaled by a factor. A rank-k matrix is returned in <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p><b>The creation of the rank-k matrix <code>M1_rk</code> from <code>M1</code> will modify <code>M1</code> internally. Hence, we make a copy of <code>M1</code> here.</b></p>

<p class="reference">References <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, and <a class="el" href="hmatrix_8h.html#aca19ab9519b7b1aa1b9660dbfa8fe604">rk_h_mTmult()</a>.</p>

</div>
</div>
<a id="ae495fd6b480f203cf797e7e86e996313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae495fd6b480f203cf797e7e86e996313">&#9670;&nbsp;</a></span>h_f_mmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the second one is a full matrix and the result is also represented as a full matrix because the associated block cluster node \(\tau\times\rho\) is small.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classLAPACKFullMatrixExt.html#a497a2e73b69f5b07cedb729330e95667">LAPACKFullMatrixExt&lt; Number &gt;::fill_col()</a>, <a class="el" href="classLAPACKFullMatrixExt.html#a1d1f6836c88ae08fa79bf6c63f7a3184">LAPACKFullMatrixExt&lt; Number &gt;::get_column()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a6534ff122b0835d0313d94264794b601">h_h_mmult_level_conserving()</a>, and <a class="el" href="hmatrix-fullmatrix-mmult_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="aceb4579cb7d6a65805c548aa9c3f97b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb4579cb7d6a65805c548aa9c3f97b9">&#9670;&nbsp;</a></span>h_f_mmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes with the result scaled by a factor. The second operand is a full matrix and the result is also represented as a full matrix because the associated block cluster node \(\tau\times\rho\) is small.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classLAPACKFullMatrixExt.html#a497a2e73b69f5b07cedb729330e95667">LAPACKFullMatrixExt&lt; Number &gt;::fill_col()</a>, <a class="el" href="classLAPACKFullMatrixExt.html#a1d1f6836c88ae08fa79bf6c63f7a3184">LAPACKFullMatrixExt&lt; Number &gt;::get_column()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

</div>
</div>
<a id="a723281b6cf62859890ec5ee49555c908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723281b6cf62859890ec5ee49555c908">&#9670;&nbsp;</a></span>h_f_mmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the second one is a full matrix and the result is represented as a rank-k matrix because the associated block cluster is large.</p>
<p>The second matrix <code>M2</code> will be firstly converted to a rank-k matrix. Then its multiplication with <code>M1</code> will be carried by calling <code>h_rk_mmult</code>. Since the conversion from a full matrix to a rank-k matrix will modify the original data, a copy of <code>M2</code> will be created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a local copy of the full matrix <code>M2</code>.</p>
<p>Convert the full matrix <code>M2</code> to a rank-k matrix.</p>

<p class="reference">References <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, and <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>.</p>

</div>
</div>
<a id="a398869486c36312aefc9c22f395fc494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398869486c36312aefc9c22f395fc494">&#9670;&nbsp;</a></span>h_f_mmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes with the result scaled by a factor. The second operand is a full matrix and the result is represented as a rank-k matrix because the associated block cluster is large.</p>
<p>The second matrix <code>M2</code> will be firstly converted to a rank-k matrix. Then its multiplication with <code>M1</code> will be carried by calling <code>h_rk_mmult</code>. Since the conversion from a full matrix to a rank-k matrix will modify the original data, a copy of <code>M2</code> will be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a local copy of the full matrix <code>M2</code>.</p>
<p>Convert the full matrix <code>M2</code> to a rank-k matrix.</p>

<p class="reference">References <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, and <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>.</p>

</div>
</div>
<a id="a374070dba133f2152e9c44ce10947f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374070dba133f2152e9c44ce10947f20">&#9670;&nbsp;</a></span>h_f_mmult_for_h_h_mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mmult_for_h_h_mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_M1M2_last_in_M_Sigma_P</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of two \(\mathcal{H}\)-matrices, where the second one is of <code>FullMatrixType</code>. An \(\mathcal{H}\)-matrix is returned in <code>M</code>, which is either of <code>FullMatrixType</code> or <code>RkMatrixType</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">is_M1M2_last_in_M_Sigma_P</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Full matrix is returned.</p>
<p>Rank-k matrix is returned.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a9e023f39b1f8916117a63557895a91b4">HMatrix&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a8c5bc5080b3c7e065e70fdba10faae55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5bc5080b3c7e065e70fdba10faae55">&#9670;&nbsp;</a></span>h_f_mTmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mTmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes with the second operand being transposed, where the second one is a full matrix and the result is also represented as a full matrix because the associated block cluster node \(\tau\times\rho\) is small.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classLAPACKFullMatrixExt.html#a497a2e73b69f5b07cedb729330e95667">LAPACKFullMatrixExt&lt; Number &gt;::fill_col()</a>, <a class="el" href="classLAPACKFullMatrixExt.html#abc010374ccacc6d1e482196af807d247">LAPACKFullMatrixExt&lt; Number &gt;::get_row()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a8855023aa4832e4119c6ead1115d4beb">h_h_mTmult_level_conserving()</a>.</p>

</div>
</div>
<a id="a3a2ffe1ccde0ac2a90b63cfdd92a5235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2ffe1ccde0ac2a90b63cfdd92a5235">&#9670;&nbsp;</a></span>h_f_mTmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mTmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes with the second operand being transposed, where the second one is a full matrix and the result is also represented as a full matrix because the associated block cluster node \(\tau\times\rho\) is small. The result will be scaled by a factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classLAPACKFullMatrixExt.html#a497a2e73b69f5b07cedb729330e95667">LAPACKFullMatrixExt&lt; Number &gt;::fill_col()</a>, <a class="el" href="classLAPACKFullMatrixExt.html#abc010374ccacc6d1e482196af807d247">LAPACKFullMatrixExt&lt; Number &gt;::get_row()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

</div>
</div>
<a id="ac9f0b303f7933e220bb976db96536ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f0b303f7933e220bb976db96536ef9">&#9670;&nbsp;</a></span>h_f_mTmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mTmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes with the second operand being transposed, where the second one is a full matrix and the result is represented as a rank-k matrix because the associated block cluster is large.</p>
<p>The second matrix <code>M2</code> will be firstly converted to a rank-k matrix. Then its multiplication with <code>M1</code> will be carried by calling <code>h_rk_mTmult</code>. Since the conversion from a full matrix to a rank-k matrix will modify the original data, a copy of <code>M2</code> will be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a local copy of the full matrix <code>M2</code>.</p>
<p>Convert the full matrix <code>M2</code> to a rank-k matrix.</p>

<p class="reference">References <a class="el" href="hmatrix_8h.html#a4d0d61778a104b7e1452c3b9be60b5e4">h_rk_mTmult()</a>, and <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>.</p>

</div>
</div>
<a id="ab4df594f8278dbd00a4d098f6e591f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4df594f8278dbd00a4d098f6e591f68">&#9670;&nbsp;</a></span>h_f_mTmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mTmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes with the second operand being transposed, where the second one is a full matrix and the result is represented as a rank-k matrix because the associated block cluster is large. The result will be scaled by a factor.</p>
<p>The second matrix <code>M2</code> will be firstly converted to a rank-k matrix. Then its multiplication with <code>M1</code> will be carried by calling <code>h_rk_mTmult</code>. Since the conversion from a full matrix to a rank-k matrix will modify the original data, a copy of <code>M2</code> will be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a local copy of the full matrix <code>M2</code>.</p>
<p>Convert the full matrix <code>M2</code> to a rank-k matrix.</p>

<p class="reference">References <a class="el" href="hmatrix_8h.html#a4d0d61778a104b7e1452c3b9be60b5e4">h_rk_mTmult()</a>, and <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>.</p>

</div>
</div>
<a id="a2b842125056627d38c5aee3a077e596c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b842125056627d38c5aee3a077e596c">&#9670;&nbsp;</a></span>h_h_mmult_from_leaf_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mmult_from_leaf_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(\mathcal{H}\)-matrix- \(\mathcal{H}\)-matrix multiplication when the product matrix belongs to the leaf set of the target block cluster tree.</p>
<p>This function implements the recursive <code>MMR</code> algorithm in (7.26) in Hackbusch's \(\mathcal{H}\)-matrix book.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M0</td><td>The initial product matrix on the block cluster node \(\tau_0\times\rho_0\).</td></tr>
    <tr><td class="paramname">M</td><td>The current product matrix \(M\) on the block cluster node \(\tau\times\rho\), which will assembles the contribution from \(M_1 \cdot M_2\). For the first call of this function, <code>M</code> is the same as <code>M0</code>. </td></tr>
    <tr><td class="paramname">M1</td><td>The first operand of the multiplication, which is built upon the block cluster node \(\tau\times\sigma\). </td></tr>
    <tr><td class="paramname">M2</td><td>The second operand of the multiplication, which is built upon the block cluster node \(\sigma\times\rho\). </td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a block cluster node \(\tau\times\rho\) for the current local product matrix <code>Z</code>. Since this block cluster node will not be connected with other block cluster nodes in a block cluster tree, it has neither parent nor children and its level is set to zero.</p>
<p>Set the <code>is_near_field</code> flag of the block cluster node for the current local product matrix <code>Z</code> according to the matrix type of the initial leaf node matrix <code>M0</code>, i.e. it inherits the <code>is_near_field</code> flag of the block cluster node for <code>M0</code>.</p>
<p>Create the local \(\mathcal{H}\)-matrix <code>Z</code> associated with the current block cluster node. During its initialization, memory will be allocated for <code>Z</code> depending on its matrix type.</p>
<p>When either operand <code>M1</code> or <code>M2</code> is a leaf node, directly evaluation of their multiplication can be performed.</p>
<p><b>When we perform submatrix multiplication, we use a higher specified rank, since the results will be assembled into the larger matrix <code>Z</code> via pairwise formatted addition, during which the actual matrix rank may increase.</b></p>
<p>Assemble the local matrix <code>Z</code> to the product matrix <code>M</code>.</p>
<p>When the original matrix <code>M0</code> belongs to the near field, assemble the full matrix stored in <code>Z</code> directly into <code>M</code>.</p>
<p>When the original matrix <code>M0</code> does not belong to the near field, assemble the rank-k matrix stored in <code>Z</code> into <code>M</code> by first embedding then formatted addition, which has been implemented in the member function <code>assemble_from_rkmatrix</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a6534ff122b0835d0313d94264794b601">h_h_mmult_level_conserving()</a>.</p>

</div>
</div>
<a id="a7cb1a4bfe1f72bde6920f716eb9314a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb1a4bfe1f72bde6920f716eb9314a0">&#9670;&nbsp;</a></span>h_h_mmult_from_leaf_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mmult_from_leaf_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(\mathcal{H}\)-matrix- \(\mathcal{H}\)-matrix multiplication with the result scaled by a factor, when the product matrix belongs to the leaf set of the target block cluster tree.</p>
<p>This function implements the recursive <code>MMR</code> algorithm in (7.26) in Hackbusch's \(\mathcal{H}\)-matrix book.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M0</td><td>The initial product matrix on the block cluster node \(\tau_0\times\rho_0\).</td></tr>
    <tr><td class="paramname">M</td><td>The current product matrix \(M\) on the block cluster node \(\tau\times\rho\), which will assembles the contribution from \(M_1 \cdot M_2\). For the first call of this function, <code>M</code> is the same as <code>M0</code>. </td></tr>
    <tr><td class="paramname">M1</td><td>The first operand of the multiplication, which is built upon the block cluster node \(\tau\times\sigma\). </td></tr>
    <tr><td class="paramname">M2</td><td>The second operand of the multiplication, which is built upon the block cluster node \(\sigma\times\rho\). </td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a block cluster node \(\tau\times\rho\) for the current local product matrix <code>Z</code>. Since this block cluster node will not be connected with other block cluster nodes in a block cluster tree, it has neither parent nor children and its level is set to zero.</p>
<p>Set the <code>is_near_field</code> flag of the block cluster node for the current local product matrix <code>Z</code> according to the matrix type of the initial leaf node matrix <code>M0</code>, i.e. it inherits the <code>is_near_field</code> flag of the block cluster node for <code>M0</code>.</p>
<p>Create the local \(\mathcal{H}\)-matrix <code>Z</code> associated with the current block cluster node. During its initialization, memory will be allocated for <code>Z</code> depending on its matrix type.</p>
<p>When either operand <code>M1</code> or <code>M2</code> is a leaf node, directly evaluation of their multiplication can be performed.</p>
<p><b>When we perform submatrix multiplication, we use a higher specified rank, since the results will be assembled into the larger matrix <code>Z</code> via pairwise formatted addition, during which the actual matrix rank may increase.</b></p>
<p>Assemble the local matrix <code>Z</code> to the product matrix <code>M</code>.</p>
<p>When the original matrix <code>M0</code> belongs to the near field, assemble the full matrix stored in <code>Z</code> directly into <code>M</code>.</p>
<p>When the original matrix <code>M0</code> does not belong to the near field, assemble the rank-k matrix stored in <code>Z</code> into <code>M</code> by first embedding then formatted addition, which has been implemented in the member function <code>assemble_from_rkmatrix</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>.</p>

</div>
</div>
<a id="a6534ff122b0835d0313d94264794b601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6534ff122b0835d0313d94264794b601">&#9670;&nbsp;</a></span>h_h_mmult_level_conserving() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of two level-conserving \(\mathcal{H}\)-matrices and the result will be added to the target matrix <code>M</code>, i.e. \(M = M + M_1 M_2\).</p>
<dl class="section note">
<dt>Note </dt>
<dd>It is required that an empty result matrix <code>M</code> should be created first with respect to a block cluster tree. </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M0</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, <a class="el" href="hmatrix_8h.html#a2b842125056627d38c5aee3a077e596c">h_h_mmult_from_leaf_node()</a>, <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a0ed620dee37feefb517062f960c9810e">h_h_mmult_level_conserving()</a>, and <a class="el" href="hmatrix-hmatrix-mmult-level-conserving-all-coarse-ntp_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a0ed620dee37feefb517062f960c9810e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed620dee37feefb517062f960c9810e">&#9670;&nbsp;</a></span>h_h_mmult_level_conserving() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of two level-conserving \(\mathcal{H}\)-matrices with a factor multiplied to the matrix product and the result will be added to the target matrix <code>M</code>, i.e. \(M = M + \alpha \cdot M_1 M_2\).</p>
<dl class="section note">
<dt>Note </dt>
<dd>It is required that an empty result matrix <code>M</code> should be created first with respect to a block cluster tree. </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M0</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, <a class="el" href="hmatrix_8h.html#a2b842125056627d38c5aee3a077e596c">h_h_mmult_from_leaf_node()</a>, <a class="el" href="hmatrix_8h.html#a6534ff122b0835d0313d94264794b601">h_h_mmult_level_conserving()</a>, <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="aad08ee9bd389abe7b7b76fd0f2cb292e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad08ee9bd389abe7b7b76fd0f2cb292e">&#9670;&nbsp;</a></span>h_h_mmult_phase1_recursion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mmult_phase1_recursion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>Tind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>There are still multiplication subtasks stored in <code>Sigma_P</code> to be handled recursively.</p>
<p>After previous reduction and splitting, the matrix multiplication for the current \(\mathcal{H}\)-matrix node should be replaced by the multiplication subtasks for submatrices. These subtasks are recorded as \(\mathcal{H}\)-matrix node pairs which are stored in \(\Sigma_b^P\) of the submatrices.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a6f24998c7de1d0e336577be41c6281e3">HMatrix&lt; spacedim, Number &gt;::determine_mm_split_mode_from_Sigma_P()</a>, <a class="el" href="classHMatrix.html#a168b6eea2e5b27528497850bf5ee2bbe">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_reduction()</a>, and <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>.</p>

</div>
</div>
<a id="a199fb48349b9486624a3c55c5aece3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199fb48349b9486624a3c55c5aece3f4">&#9670;&nbsp;</a></span>h_h_mmult_phase2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mmult_phase2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_bc_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collect terms in <code>Sigma_R</code> and <code>Sigma_F</code> for the leaf nodes.</p>
<p>Here we make sure that \(\mathcal{H}\)-matrix pairs in the list \(\Sigma_b^P\) have all been processed and erased, hence the list should be empty.</p>
<p>Perform pairwise formatted addition for the list of rank-k matrices stored in the list \(\Sigma_b^R\), the result of which will be assigned to the <code>rkmatrix</code> field of the current \(\mathcal{H}\)-matrix leaf node.</p>
<p>Clear the list \(\Sigma_b^R\) after adding all of its rank-k matrices.</p>
<p>Clear the list \(\Sigma_b^F\) after adding all of its full matrices.</p>
<p><b>Important</b>: Distribute matrices stored in \(\Sigma_b^R\) and \(\Sigma_b^F\) of each <b>non-leaf node</b> to the leaf nodes which are its descendants.</p>
<p>Convert the calculated product matrix to the specified matrix structure.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#af6fd60090b0de7bdea52fc84ddeb22c3">HMatrix&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees()</a>, <a class="el" href="classHMatrix.html#a66979dbdf56155c63f0706649e8545b9">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, <a class="el" href="classHMatrix.html#a12da9454687e5ca15837d63e2bf0b595">HMatrix&lt; spacedim, Number &gt;::Tind</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="ab9d49e86d3c8b5596b1b603793818276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d49e86d3c8b5596b1b603793818276">&#9670;&nbsp;</a></span>h_h_mTmult_from_leaf_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mTmult_from_leaf_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(\mathcal{H}\)-matrix- \(\mathcal{H}\)-matrix multiplication with the second operand transposed, when the product matrix belongs to the leaf set of the target block cluster tree.</p>
<p>This function implements the recursive <code>MMR</code> algorithm in (7.26) in Hackbusch's \(\mathcal{H}\)-matrix book.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M0</td><td>The initial product matrix on the block cluster node \(\tau_0\times\rho_0\). </td></tr>
    <tr><td class="paramname">M</td><td>The current product matrix \(M\) on the block cluster node \(\tau\times\rho\), which will assembles the contribution from \(M_1 \cdot M_2\). For the first call of this function, <code>M</code> is the same as <code>M0</code>. </td></tr>
    <tr><td class="paramname">M1</td><td>The first operand of the multiplication, which is built upon the block cluster node \(\tau\times\sigma\). </td></tr>
    <tr><td class="paramname">M2</td><td>The second operand of the multiplication, which is built upon the block cluster node \(\rho\times\sigma\). </td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a block cluster node \(\tau\times\rho\) for the current local product matrix <code>Z</code>. Since this block cluster node will not be connected with other block cluster nodes in a block cluster tree, it has neither parent nor children and its level is set to zero.</p>
<p>Set the <code>is_near_field</code> flag of the block cluster node for the current local product matrix <code>Z</code> according to the matrix type of the initial leaf node matrix <code>M0</code>, i.e. it inherits the <code>is_near_field</code> flag of the block cluster node for <code>M0</code>.</p>
<p>Create the local \(\mathcal{H}\)-matrix <code>Z</code> associated with the current block cluster node. During its initialization, memory will be allocated for <code>Z</code> depending on its matrix type.</p>
<p>When either operand <code>M1</code> or <code>M2</code> is a leaf node, directly evaluation of their multiplication can be performed.</p>
<p><b>When we perform submatrix multiplication, we use a higher specified rank, since the results will be assembled into the larger matrix <code>Z</code> via pairwise formatted addition, during which the actual matrix rank may increase.</b></p>
<p>Assemble the local matrix <code>Z</code> to the product matrix <code>M</code>.</p>
<p>When the original matrix <code>M0</code> belongs to the near field, assemble the full matrix stored in <code>Z</code> directly into <code>M</code>.</p>
<p>When the original matrix <code>M0</code> does not belong to the near field, assemble the rank-k matrix stored in <code>Z</code> into <code>M</code> by first embedding then formatted addition, which has been implemented in the member function <code>assemble_from_rkmatrix</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a8855023aa4832e4119c6ead1115d4beb">h_h_mTmult_level_conserving()</a>.</p>

</div>
</div>
<a id="a9b8abc06deedda9951406d65af89e42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8abc06deedda9951406d65af89e42f">&#9670;&nbsp;</a></span>h_h_mTmult_from_leaf_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mTmult_from_leaf_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(\mathcal{H}\)-matrix- \(\mathcal{H}\)-matrix multiplication with the second operand transposed, when the product matrix belongs to the leaf set of the target block cluster tree.</p>
<p>This function implements the recursive <code>MMR</code> algorithm in (7.26) in Hackbusch's \(\mathcal{H}\)-matrix book.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M0</td><td>The initial product matrix on the block cluster node \(\tau_0\times\rho_0\). </td></tr>
    <tr><td class="paramname">M</td><td>The current product matrix \(M\) on the block cluster node \(\tau\times\rho\), which will assembles the contribution from \(M_1 \cdot M_2\). For the first call of this function, <code>M</code> is the same as <code>M0</code>. </td></tr>
    <tr><td class="paramname">M1</td><td>The first operand of the multiplication, which is built upon the block cluster node \(\tau\times\sigma\). </td></tr>
    <tr><td class="paramname">M2</td><td>The second operand of the multiplication, which is built upon the block cluster node \(\rho\times\sigma\). </td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a block cluster node \(\tau\times\rho\) for the current local product matrix <code>Z</code>. Since this block cluster node will not be connected with other block cluster nodes in a block cluster tree, it has neither parent nor children and its level is set to zero.</p>
<p>Set the <code>is_near_field</code> flag of the block cluster node for the current local product matrix <code>Z</code> according to the matrix type of the initial leaf node matrix <code>M0</code>, i.e. it inherits the <code>is_near_field</code> flag of the block cluster node for <code>M0</code>.</p>
<p>Create the local \(\mathcal{H}\)-matrix <code>Z</code> associated with the current block cluster node. During its initialization, memory will be allocated for <code>Z</code> depending on its matrix type.</p>
<p>When either operand <code>M1</code> or <code>M2</code> is a leaf node, directly evaluation of their multiplication can be performed.</p>
<p><b>When we perform submatrix multiplication, we use a higher specified rank, since the results will be assembled into the larger matrix <code>Z</code> via pairwise formatted addition, during which the actual matrix rank may increase.</b></p>
<p>Assemble the local matrix <code>Z</code> to the product matrix <code>M</code>.</p>
<p>When the original matrix <code>M0</code> belongs to the near field, assemble the full matrix stored in <code>Z</code> directly into <code>M</code>.</p>
<p>When the original matrix <code>M0</code> does not belong to the near field, assemble the rank-k matrix stored in <code>Z</code> into <code>M</code> by first embedding then formatted addition, which has been implemented in the member function <code>assemble_from_rkmatrix</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>.</p>

</div>
</div>
<a id="a8855023aa4832e4119c6ead1115d4beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8855023aa4832e4119c6ead1115d4beb">&#9670;&nbsp;</a></span>h_h_mTmult_level_conserving() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mTmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of two level-conserving \(\mathcal{H}\)-matrices with the second operand transposed. The result will be added to the target matrix <code>M</code>, i.e. \(M = M + M_1 M_2^T\).</p>
<dl class="section note">
<dt>Note </dt>
<dd>It is required that an empty result matrix <code>M</code> should be created first with respect to a block cluster tree. </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M0</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h.html#acf140473681cc5ea3ab57fafdc986357">f_h_mTmult()</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#a8c5bc5080b3c7e065e70fdba10faae55">h_f_mTmult()</a>, <a class="el" href="hmatrix_8h.html#ab9d49e86d3c8b5596b1b603793818276">h_h_mTmult_from_leaf_node()</a>, <a class="el" href="hmatrix_8h.html#a4d0d61778a104b7e1452c3b9be60b5e4">h_rk_mTmult()</a>, <a class="el" href="hmatrix_8h.html#aca19ab9519b7b1aa1b9660dbfa8fe604">rk_h_mTmult()</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a6025a164b80c84f13121a5b6af3fab7b">h_h_mTmult_level_conserving()</a>, and <a class="el" href="hmatrix-hmatrix-mTmult-level-conserving-all-coarse-ntp_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a6025a164b80c84f13121a5b6af3fab7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6025a164b80c84f13121a5b6af3fab7b">&#9670;&nbsp;</a></span>h_h_mTmult_level_conserving() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mTmult_level_conserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of two level-conserving \(\mathcal{H}\)-matrices with the second operand transposed. The result will multiplied by a factor and then added to the target matrix <code>M</code>, i.e. \(M = M + \alpha \cdot M_1 M_2^T\).</p>
<dl class="section note">
<dt>Note </dt>
<dd>It is required that an empty result matrix <code>M</code> should be created first with respect to a block cluster tree. </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M0</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">fixed_rank</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a8f96186426cd3147d5af32ca84ad25ea">HMatrix&lt; spacedim, Number &gt;::add()</a>, <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="hmatrix_8h.html#acf140473681cc5ea3ab57fafdc986357">f_h_mTmult()</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#a8c5bc5080b3c7e065e70fdba10faae55">h_f_mTmult()</a>, <a class="el" href="hmatrix_8h.html#ab9d49e86d3c8b5596b1b603793818276">h_h_mTmult_from_leaf_node()</a>, <a class="el" href="hmatrix_8h.html#a8855023aa4832e4119c6ead1115d4beb">h_h_mTmult_level_conserving()</a>, <a class="el" href="hmatrix_8h.html#a4d0d61778a104b7e1452c3b9be60b5e4">h_rk_mTmult()</a>, <a class="el" href="hmatrix_8h.html#aca19ab9519b7b1aa1b9660dbfa8fe604">rk_h_mTmult()</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="afee9050ba0b224929bcbf99484385a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee9050ba0b224929bcbf99484385a59">&#9670;&nbsp;</a></span>h_rk_mmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_rk_mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the second one <code>M2</code> has <code>RkMatrixType</code> and the result will also be a rank-k matrix.</p>
<p>The arithmetic operation to be performed is </p><p class="formulaDsp">
\[ M = M_1 \cdot M_2 = M_1 (A B^T) = (M_1 A) B^T = A&#39; B^T, \]
</p>
<p> where \(A&#39; = M_1 A\) is calculated as a series of \(\mathcal{H}\)-matrix-vector multiplications. For details, </p><p class="formulaDsp">
\[ M_1 A = M_1 \begin{bmatrix} a_{\sigma,1} &amp; \cdots &amp; a_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_1 a_{\sigma,1} &amp; \cdots &amp; M_1 a_{\sigma,r} \end{bmatrix} = \begin{bmatrix} a&#39;_{\tau,1} &amp; \cdots &amp; a&#39;_{\tau,r} \end{bmatrix}. \]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a temporary <code>Vector</code> storing a column \(a_{\sigma,j}\) in the <code>A</code> component of <code>M2</code> and another <code>Vector</code> \(a&#39;_{\tau,j}\) storing the matrix-vector product \(M_1 \cdot a_{\sigma,j}\).</p>
<p>Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M2</code>. Its <code>B</code> component matrix is the same as that of <code>M2</code>.</p>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>
<p>Then we calculate the <code>A</code> component matrix of <code>M</code>, which is <code>M1*M2</code>.A.</p>
<p>Fill the result vector into the <code>A</code> component matrix of <code>M</code>.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classRkMatrix.html#a7e4a8f0500daba627665c6a5ed8888d9">RkMatrix&lt; Number &gt;::formal_rank</a>, <a class="el" href="classRkMatrix.html#a8ca8898bcfedeee135437833f83b144c">RkMatrix&lt; Number &gt;::m</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classRkMatrix.html#a06d3b6636bb423c391c66e4ccc722687">RkMatrix&lt; Number &gt;::n</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classRkMatrix.html#a5457372194e8009bffc7b88f11b95d03">RkMatrix&lt; Number &gt;::reinit()</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a723281b6cf62859890ec5ee49555c908">h_f_mmult()</a>, <a class="el" href="hmatrix_8h.html#a6534ff122b0835d0313d94264794b601">h_h_mmult_level_conserving()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, and <a class="el" href="hmatrix-rkmatrix-mmult_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a9b93b5c19ef281408c6ed1e6460462e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b93b5c19ef281408c6ed1e6460462e5">&#9670;&nbsp;</a></span>h_rk_mmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_rk_mmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes and the result is scaled by a factor, where the second one <code>M2</code> has <code>RkMatrixType</code> and the result will also be a rank-k matrix.</p>
<p>The arithmetic operation to be performed is </p><p class="formulaDsp">
\[ M = \alpha \cdot M_1 \cdot M_2 = \alpha \cdot M_1 (A B^T) = \alpha \cdot (M_1 A) B^T = \alpha \cdot A&#39; B^T, \]
</p>
<p> where \(A&#39; = M_1 A\) is calculated as a series of \(\mathcal{H}\)-matrix-vector multiplications. For details, </p><p class="formulaDsp">
\[ M_1 A = M_1 \begin{bmatrix} a_{\sigma,1} &amp; \cdots &amp; a_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_1 a_{\sigma,1} &amp; \cdots &amp; M_1 a_{\sigma,r} \end{bmatrix} = \begin{bmatrix} a&#39;_{\tau,1} &amp; \cdots &amp; a&#39;_{\tau,r} \end{bmatrix}. \]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a temporary <code>Vector</code> storing a column \(a_{\sigma,j}\) in the <code>A</code> component of <code>M2</code> and another <code>Vector</code> \(a&#39;_{\tau,j}\) storing the matrix-vector product \(M_1 \cdot a_{\sigma,j}\).</p>
<p>Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M2</code>. Its <code>B</code> component matrix is the same as that of <code>M2</code>.</p>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>
<p>Then we calculate the <code>A</code> component matrix of <code>M</code>, which is <code>M1*M2</code>.A.</p>
<p><b>Since the following <code>vmult</code> will compute \(y = y + M x\), <code>result_vect</code> should be reset to zero beforehand.</b></p>
<p>Fill the result vector into the <code>A</code> component matrix of <code>M</code>.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classRkMatrix.html#a7e4a8f0500daba627665c6a5ed8888d9">RkMatrix&lt; Number &gt;::formal_rank</a>, <a class="el" href="classRkMatrix.html#a8ca8898bcfedeee135437833f83b144c">RkMatrix&lt; Number &gt;::m</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classRkMatrix.html#a06d3b6636bb423c391c66e4ccc722687">RkMatrix&lt; Number &gt;::n</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classRkMatrix.html#a5457372194e8009bffc7b88f11b95d03">RkMatrix&lt; Number &gt;::reinit()</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

</div>
</div>
<a id="a84df06910d958d84ac8c544f9a8423a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84df06910d958d84ac8c544f9a8423a8">&#9670;&nbsp;</a></span>h_rk_mmult_for_h_h_mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_rk_mmult_for_h_h_mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_M1M2_last_in_M_Sigma_P</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the second one <code>M2</code> has <code>RkMatrixType</code> and the result will also be a rank-k matrix. This function is to be called by the matrix-matrix multiplication function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a9e023f39b1f8916117a63557895a91b4">HMatrix&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list()</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a4d0d61778a104b7e1452c3b9be60b5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0d61778a104b7e1452c3b9be60b5e4">&#9670;&nbsp;</a></span>h_rk_mTmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_rk_mTmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes with the second operand being transposed, where the second operand <code>M2</code> has <code>RkMatrixType</code> and the result will also be a rank-k matrix.</p>
<p>The arithmetic operation to be performed is </p><p class="formulaDsp">
\[ M = M_1 \cdot M_2^T = M_1 (A B^T)^T = (M_1 B) A^T = A&#39; B&#39;^T, \]
</p>
<p> where \(A&#39; = M_1 B\) is calculated as a series of \(\mathcal{H}\)-matrix-vector multiplications, and \(B&#39; = A\). For details, </p><p class="formulaDsp">
\[ M_1 B = M_1 \begin{bmatrix} b_{\sigma,1} &amp; \cdots &amp; b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_1 b_{\sigma,1} &amp; \cdots &amp; M_1 b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} b&#39;_{\tau,1} &amp; \cdots &amp; b&#39;_{\tau,r} \end{bmatrix}. \]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a temporary <code>Vector</code> storing a column \(b_{\sigma,j}\) in the <code>B</code> component of <code>M2</code> and another <code>Vector</code> \(b&#39;_{\tau,j}\) storing the matrix-vector product \(M_1 \cdot b_{\sigma,j}\).</p>
<p>Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M2</code>. Its <code>B</code> component matrix is the same as that of <code>M2</code>.</p>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>
<p>Then we calculate the <code>A</code> component matrix of <code>M</code>, which is <code>M1*M2</code>.B.</p>
<p>Fill the result vector into the <code>A</code> component matrix of <code>M</code>.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classRkMatrix.html#a7e4a8f0500daba627665c6a5ed8888d9">RkMatrix&lt; Number &gt;::formal_rank</a>, <a class="el" href="classRkMatrix.html#a8ca8898bcfedeee135437833f83b144c">RkMatrix&lt; Number &gt;::m</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classRkMatrix.html#a06d3b6636bb423c391c66e4ccc722687">RkMatrix&lt; Number &gt;::n</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classRkMatrix.html#a5457372194e8009bffc7b88f11b95d03">RkMatrix&lt; Number &gt;::reinit()</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#ac9f0b303f7933e220bb976db96536ef9">h_f_mTmult()</a>, and <a class="el" href="hmatrix_8h.html#a8855023aa4832e4119c6ead1115d4beb">h_h_mTmult_level_conserving()</a>.</p>

</div>
</div>
<a id="acfbe51ba1fe5ea83d5910d1f893d589f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbe51ba1fe5ea83d5910d1f893d589f">&#9670;&nbsp;</a></span>h_rk_mTmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_rk_mTmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes with the second operand being transposed, where the second operand <code>M2</code> has <code>RkMatrixType</code> and the result will also be a rank-k matrix. The result will be scaled by a factor.</p>
<p>The arithmetic operation to be performed is </p><p class="formulaDsp">
\[ M = \alpha \cdot M_1 \cdot M_2^T = \alpha \cdot M_1 (A B^T)^T = \alpha \cdot (M_1 B) A^T = \alpha \cdot A&#39; B&#39;^T, \]
</p>
<p> where \(A&#39; = M_1 B\) is calculated as a series of \(\mathcal{H}\)-matrix-vector multiplications, and \(B&#39; = A\). For details, </p><p class="formulaDsp">
\[ M_1 B = M_1 \begin{bmatrix} b_{\sigma,1} &amp; \cdots &amp; b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_1 b_{\sigma,1} &amp; \cdots &amp; M_1 b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} b&#39;_{\tau,1} &amp; \cdots &amp; b&#39;_{\tau,r} \end{bmatrix}. \]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a temporary <code>Vector</code> storing a column \(b_{\sigma,j}\) in the <code>B</code> component of <code>M2</code> and another <code>Vector</code> \(b&#39;_{\tau,j}\) storing the matrix-vector product \(M_1 \cdot b_{\sigma,j}\).</p>
<p>Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M2</code>. Its <code>B</code> component matrix is the same as that of <code>M2</code>.</p>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>
<p>Then we calculate the <code>A</code> component matrix of <code>M</code>, which is <code>M1*M2</code>.B.</p>
<p>Fill the result vector into the <code>A</code> component matrix of <code>M</code>.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classRkMatrix.html#a7e4a8f0500daba627665c6a5ed8888d9">RkMatrix&lt; Number &gt;::formal_rank</a>, <a class="el" href="classRkMatrix.html#a8ca8898bcfedeee135437833f83b144c">RkMatrix&lt; Number &gt;::m</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classRkMatrix.html#a06d3b6636bb423c391c66e4ccc722687">RkMatrix&lt; Number &gt;::n</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classRkMatrix.html#a5457372194e8009bffc7b88f11b95d03">RkMatrix&lt; Number &gt;::reinit()</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

</div>
</div>
<a id="a317e4841d6bb5b60883a7e21027a8893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317e4841d6bb5b60883a7e21027a8893">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildren() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_build_index_set_global_to_local_map</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively construct the children of an \(\mathcal{H}\)-matrix with respect to a block cluster tree by starting from a tree node which is associated with the current \(\mathcal{H}\)-matrix.</p>
<p>The matrices in the leaf set are initialized with zero values. The rank of the near field matrices are predefined fixed values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td>Pointer to the current \(\mathcal{H}\)-matrix node, <b>which has already been created on the heap but with its internal data left empty.</b> </td></tr>
    <tr><td class="paramname">bc_node</td><td>Pointer to a <a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>, which is to be associated with <code>hmat</code>. </td></tr>
  </table>
  </dd>
</dl>
<p>Link <code>hmat</code> with <code>bc_node</code>.</p>
<p>Link row and column indices stored in the clusters \(\tau\) and \(\sigma\) respectively.</p>
<p>Update the matrix dimension of <code>hmat</code>.</p>
<p>When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>.</p>
<p>Then we will continue constructing its hierarchical submatrices.</p>
<p>Create an empty <a class="el" href="classHMatrix.html">HMatrix</a> on the heap.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Set the pointer to the parent \(\mathcal{H}\)-matrix node of the current child \(\mathcal{H}\)-matrix node.</p>
<p>Build the maps from global row and column indices respectively to local indices.</p>
<p>Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, <code>hmat</code> should be represented as a <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>. When the block cluster belongs to the far field, <code>hmat</code> should be represented as an <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the current \(\mathcal{H}\)-matrix.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classTreeNode.html#a077cb5cc974f94ff431c69cc2ca5957f">TreeNode&lt; T, N &gt;::get_child_num()</a>, <a class="el" href="classTreeNode.html#ad3b1833452c787d2146a4beb3587c531">TreeNode&lt; T, N &gt;::get_child_pointer()</a>, <a class="el" href="classTreeNode.html#a7bf414928c965e707e0246f7a90a747d">TreeNode&lt; T, N &gt;::get_data_reference()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a71690997092a4142799b2fa2dbf53db4">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a64c851dd63ba1a466c19f451be369475">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a2b56a9e943f5632f50d08f4e892b1787">InitAndCreateHMatrixChildren()</a>.</p>

</div>
</div>
<a id="a2b56a9e943f5632f50d08f4e892b1787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b56a9e943f5632f50d08f4e892b1787">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildren() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_build_index_set_global_to_local_map</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively construct the children of an \(\mathcal{H}\)-matrix with respect to a block cluster tree by starting from a tree node which is associated with the current \(\mathcal{H}\)-matrix.</p>
<p>The matrices in the leaf set are initialized with the data in the given global full matrix <code>M</code>, which is created on the complete block cluster index set \(I \times J\) and whose elements should be accessed via indices stored in the block cluster. The rank of the far field matrices are predefined fixed values.</p>
<p>During the recursive calling of this function, the source data matrix <code>M</code> is kept intact, which will not be restricted to small matrix blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td>Pointer to the current \(\mathcal{H}\)-matrix node, <b>which has already been created on the heap but with its internal data left empty.</b> </td></tr>
    <tr><td class="paramname">bc_node</td><td>Pointer to a <a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>, which is to be associated with <code>hmat</code>. </td></tr>
    <tr><td class="paramname">M</td><td>The global full matrix containing all the data required to initialize the \(\mathcal{H}\)-matrix. </td></tr>
  </table>
  </dd>
</dl>
<p>Link <code>hmat</code> with <code>bc_node</code>.</p>
<p>Link row and column indices.</p>
<p>Update the matrix dimension of <code>hmat</code>.</p>
<p>When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>. Then we will continue constructing hierarchical submatrices.</p>
<p>Create an empty <a class="el" href="classHMatrix.html">HMatrix</a> on the heap.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Set the pointer to the parent \(\mathcal{H}\)-matrix node of the current child \(\mathcal{H}\)-matrix node.</p>
<p>Build the maps from global row and column indices respectively to local indices.</p>
<p>Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, <code>hmat</code> should be represented as a <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>. When the block cluster belongs to the far field, <code>hmat</code> should be represented as an <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the current \(\mathcal{H}\)-matrix.</p>
<p>Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classTreeNode.html#a077cb5cc974f94ff431c69cc2ca5957f">TreeNode&lt; T, N &gt;::get_child_num()</a>, <a class="el" href="classTreeNode.html#ad3b1833452c787d2146a4beb3587c531">TreeNode&lt; T, N &gt;::get_child_pointer()</a>, <a class="el" href="classTreeNode.html#a7bf414928c965e707e0246f7a90a747d">TreeNode&lt; T, N &gt;::get_data_reference()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a71690997092a4142799b2fa2dbf53db4">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a64c851dd63ba1a466c19f451be369475">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a6b547084e856ac11a021c104331400cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b547084e856ac11a021c104331400cf">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildren() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_build_index_set_global_to_local_map</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively construct the children of an \(\mathcal{H}\)-matrix with respect to a block cluster tree by starting from a tree node which is associated with the current \(\mathcal{H}\)-matrix. There is no rank truncation to the rank-k matrices.</p>
<p>The matrices in the leaf set are initialized with the data in the given global full matrix <code>M</code>, which is created on the complete block cluster index set \(I \times J\) and whose elements should be accessed via indices stored in the block cluster.</p>
<p>During the recursive calling of this function, the source data matrix <code>M</code> is kept intact, which will not be restricted to small matrix blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td>Pointer to the current \(\mathcal{H}\)-matrix node, <b>which has already been created on the heap but with its internal data left empty.</b> </td></tr>
    <tr><td class="paramname">bc_node</td><td>Pointer to a <a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>, which is to be associated with <code>hmat</code>. </td></tr>
    <tr><td class="paramname">M</td><td>The global full matrix containing all the data required to initialize the \(\mathcal{H}\)-matrix. </td></tr>
    <tr><td class="paramname">is_build_index_set_global_to_local_map</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Link <code>hmat</code> with <code>bc_node</code>.</p>
<p>Link row and column indices.</p>
<p>Update the matrix dimension of <code>hmat</code>.</p>
<p>When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>. Then we will continue constructing hierarchical submatrices.</p>
<p>Create an empty <a class="el" href="classHMatrix.html">HMatrix</a> on the heap.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Set the pointer to the parent \(\mathcal{H}\)-matrix node of the current child \(\mathcal{H}\)-matrix node.</p>
<p>Build the maps from global row and column indices respectively to local indices.</p>
<p>Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, <code>hmat</code> should be represented as a <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>. When the block cluster belongs to the far field, <code>hmat</code> should be represented as an <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the current \(\mathcal{H}\)-matrix.</p>
<p>Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classTreeNode.html#a077cb5cc974f94ff431c69cc2ca5957f">TreeNode&lt; T, N &gt;::get_child_num()</a>, <a class="el" href="classTreeNode.html#ad3b1833452c787d2146a4beb3587c531">TreeNode&lt; T, N &gt;::get_child_pointer()</a>, <a class="el" href="classTreeNode.html#a7bf414928c965e707e0246f7a90a747d">TreeNode&lt; T, N &gt;::get_data_reference()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a71690997092a4142799b2fa2dbf53db4">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a64c851dd63ba1a466c19f451be369475">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a53120559ced904c076a4914af3e9423a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53120559ced904c076a4914af3e9423a">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildren() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_index_global_to_local_map_for_M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_index_global_to_local_map_for_M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_build_index_set_global_to_local_map</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively construct the children of an \(\mathcal{H}\)-matrix with respect to a block cluster tree by starting from a tree node which is associated with the current \(\mathcal{H}\)-matrix.</p>
<p>The matrices in the leaf set are initialized with the data in the given full matrix <code>M</code>, which is created on the block cluster index set \(\tau \times \sigma\) associated with the current \(\mathcal{H}\)-matrix. Hence, this full matrix is just a block of the original global full matrix created on the block cluster index set \(I \times J\). The rank of the far field matrices are predefined fixed values.</p>
<p>During the recursive calling of this function, the source data matrix <code>M</code> is kept intact, which will not be restricted to small matrix blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td>Pointer to the current \(\mathcal{H}\)-matrix node, <b>which has already been created on the heap but with its internal data left empty.</b> </td></tr>
    <tr><td class="paramname">bc_node</td><td>Pointer to a <a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>, which is to be associated with <code>hmat</code>. </td></tr>
    <tr><td class="paramname">M</td><td>The full matrix, as a submatrix of the global full matrix, containing all the data required to initialize the \(\mathcal{H}\)-matrix. </td></tr>
    <tr><td class="paramname">row_index_global_to_local_map_for_M</td><td>The map from the global row indices to the local indices of the matrix associated the \(\mathcal{H}\)-matrix when first calling this recursive function. </td></tr>
    <tr><td class="paramname">col_index_global_to_local_map_for_M</td><td>The map from the global column indices to the local indices of the matrix associated the \(\mathcal{H}\)-matrix when first calling this recursive function. </td></tr>
  </table>
  </dd>
</dl>
<p>Link <code>hmat</code> with <code>bc_node</code>.</p>
<p>Link row and column indices.</p>
<p>Update the matrix dimension of <code>hmat</code>.</p>
<p>When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>. Then we will continue constructing hierarchical submatrices.</p>
<p>Create an empty <a class="el" href="classHMatrix.html">HMatrix</a> on the heap.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Set the pointer to the parent \(\mathcal{H}\)-matrix node of the current child \(\mathcal{H}\)-matrix node.</p>
<p>Build the maps from global row and column indices respectively to local indices.</p>
<p>Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, <code>hmat</code> should be represented as a <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>. When the block cluster belongs to the far field, <code>hmat</code> should be represented as an <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the current \(\mathcal{H}\)-matrix.</p>
<p>Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classTreeNode.html#a077cb5cc974f94ff431c69cc2ca5957f">TreeNode&lt; T, N &gt;::get_child_num()</a>, <a class="el" href="classTreeNode.html#ad3b1833452c787d2146a4beb3587c531">TreeNode&lt; T, N &gt;::get_child_pointer()</a>, <a class="el" href="classTreeNode.html#a7bf414928c965e707e0246f7a90a747d">TreeNode&lt; T, N &gt;::get_data_reference()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a71690997092a4142799b2fa2dbf53db4">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a64c851dd63ba1a466c19f451be369475">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a427e26a795634442821a7baf5f34a8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427e26a795634442821a7baf5f34a8ed">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildren() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_index_global_to_local_map_for_M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_index_global_to_local_map_for_M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_build_index_set_global_to_local_map</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively construct the children of an \(\mathcal{H}\)-matrix with respect to a block cluster tree by starting from a tree node which is associated with the current \(\mathcal{H}\)-matrix. There is no rank truncation to the rank-k matrices.</p>
<p>The matrices in the leaf set are initialized with the data in the given full matrix <code>M</code>, which is created on the block cluster index set \(\tau \times \sigma\) associated with the current \(\mathcal{H}\)-matrix. Hence, this full matrix is just a block of the original global full matrix created on the block cluster index set \(I \times J\).</p>
<p>During the recursive calling of this function, the source data matrix <code>M</code> is kept intact, which will not be restricted to small matrix blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td>Pointer to the current \(\mathcal{H}\)-matrix node, <b>which has already been created on the heap but with its internal data left empty.</b> </td></tr>
    <tr><td class="paramname">bc_node</td><td>Pointer to a <a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>, which is to be associated with <code>hmat</code>. </td></tr>
    <tr><td class="paramname">M</td><td>The full matrix, as a submatrix of the global full matrix, containing all the data required to initialize the \(\mathcal{H}\)-matrix. </td></tr>
    <tr><td class="paramname">row_index_global_to_local_map_for_M</td><td>The map from the global row indices to the local indices of the matrix associated the \(\mathcal{H}\)-matrix when first calling this recursive function. </td></tr>
    <tr><td class="paramname">col_index_global_to_local_map_for_M</td><td>The map from the global column indices to the local indices of the matrix associated the \(\mathcal{H}\)-matrix when first calling this recursive function. </td></tr>
  </table>
  </dd>
</dl>
<p>Link <code>hmat</code> with <code>bc_node</code>.</p>
<p>Link row and column indices.</p>
<p>Update the matrix dimension of <code>hmat</code>.</p>
<p>When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>. Then we will continue constructing hierarchical submatrices.</p>
<p>Create an empty <a class="el" href="classHMatrix.html">HMatrix</a> on the heap.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Set the pointer to the parent \(\mathcal{H}\)-matrix node of the current child \(\mathcal{H}\)-matrix node.</p>
<p>Build the maps from global row and column indices respectively to local indices.</p>
<p>Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, <code>hmat</code> should be represented as a <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>. When the block cluster belongs to the far field, <code>hmat</code> should be represented as an <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the current \(\mathcal{H}\)-matrix.</p>
<p>Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classTreeNode.html#a077cb5cc974f94ff431c69cc2ca5957f">TreeNode&lt; T, N &gt;::get_child_num()</a>, <a class="el" href="classTreeNode.html#ad3b1833452c787d2146a4beb3587c531">TreeNode&lt; T, N &gt;::get_child_pointer()</a>, <a class="el" href="classTreeNode.html#a7bf414928c965e707e0246f7a90a747d">TreeNode&lt; T, N &gt;::get_data_reference()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a71690997092a4142799b2fa2dbf53db4">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a64c851dd63ba1a466c19f451be369475">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a9cf5008e3967b1029d5b766290c98139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf5008e3967b1029d5b766290c98139">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildren() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively construct the children of an \(\mathcal{H}\)-matrix node with respect to a block cluster tree by starting from a tree node which is associated with the current \(\mathcal{H}\)-matrix node.</p>
<p>The matrices in the leaf set take the data migrated from the leaf set of the given \(\mathcal{H}\)-matrix <code>H</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Link <code>hmat</code> with <code>bc_node</code>.</p>
<p>Link row and column indices stored in the clusters \(\tau\) and \(\sigma\) respectively..</p>
<p>Update the matrix dimension of <code>hmat</code>.</p>
<p>When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>.</p>
<p>Then we will continue constructing its hierarchical submatrices.</p>
<p>Create an empty <a class="el" href="classHMatrix.html">HMatrix</a> on the heap.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Set the pointer to the parent \(\mathcal{H}\)-matrix node of the current child \(\mathcal{H}\)-matrix node.</p>
<p>When the current \(\mathcal{H}\)-matrix node is a leaf, migrate the data from the leaf set of <code>H</code> to it.</p>
<p>Shallow copy the found \(\mathcal{H}\)-matrix node in the leaf set to the current \(\mathcal{H}\)-matrix node.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classTreeNode.html#a077cb5cc974f94ff431c69cc2ca5957f">TreeNode&lt; T, N &gt;::get_child_num()</a>, <a class="el" href="classTreeNode.html#ad3b1833452c787d2146a4beb3587c531">TreeNode&lt; T, N &gt;::get_child_pointer()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a71690997092a4142799b2fa2dbf53db4">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a64c851dd63ba1a466c19f451be369475">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a65e47eb35744c93b8955b6d564e5bf9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e47eb35744c93b8955b6d564e5bf9a">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildrenWithoutAlloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildrenWithoutAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_build_index_set_global_to_local_map</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively construct the children of an \(\mathcal{H}\)-matrix with respect to a block cluster tree by starting from a tree node which is to be associated with the current \(\mathcal{H}\)-matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td>Pointer to the current \(\mathcal{H}\)-matrix node, <b>which has already been created on the heap but with its internal data left empty.</b> </td></tr>
    <tr><td class="paramname">bc_node</td><td>Pointer to a <a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>, which is to be associated with <code>hmat</code>. </td></tr>
  </table>
  </dd>
</dl>
<p>Link <code>hmat</code> with <code>bc_node</code>.</p>
<p>Link row and column indices stored in the clusters \(\tau\) and \(\sigma\) respectively.</p>
<p>Update the matrix dimension of <code>hmat</code>.</p>
<p>When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>.</p>
<p>Then we will continue constructing its hierarchical submatrices.</p>
<p>Create an empty <a class="el" href="classHMatrix.html">HMatrix</a> on the heap.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Set the pointer to the parent \(\mathcal{H}\)-matrix node of the current child \(\mathcal{H}\)-matrix node.</p>
<p>Build the maps from global row and column indices respectively to local indices.</p>
<p>Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, <code>hmat</code> should be represented as a <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>. When the block cluster belongs to the far field, <code>hmat</code> should be represented as an <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the current \(\mathcal{H}\)-matrix.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classTreeNode.html#a077cb5cc974f94ff431c69cc2ca5957f">TreeNode&lt; T, N &gt;::get_child_num()</a>, <a class="el" href="classTreeNode.html#ad3b1833452c787d2146a4beb3587c531">TreeNode&lt; T, N &gt;::get_child_pointer()</a>, <a class="el" href="classTreeNode.html#a7bf414928c965e707e0246f7a90a747d">TreeNode&lt; T, N &gt;::get_data_reference()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a71690997092a4142799b2fa2dbf53db4">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a64c851dd63ba1a466c19f451be369475">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a21892e360616f81dd5ad1c7089f9eaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21892e360616f81dd5ad1c7089f9eaab">&#9670;&nbsp;</a></span>InitHMatrixWrtBlockClusterNode() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitHMatrixWrtBlockClusterNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize an \(\mathcal{H}\)-matrix node with respect to a block cluster node. The list \(\Sigma_b^P\) is set to empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">bc_node</td><td></td></tr>
    <tr><td class="paramname">Sigma_P</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Link <code>hmat</code> with <code>bc_node</code>.</p>
<p>Link row and column indices stored in the clusters \(\tau\) and \(\sigma\) respectively.</p>
<p>Update the matrix dimension of <code>hmat</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, and <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>.</p>

</div>
</div>
<a id="ae5d510b10595b78a40764950441bcbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d510b10595b78a40764950441bcbaf">&#9670;&nbsp;</a></span>InitHMatrixWrtBlockClusterNode() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitHMatrixWrtBlockClusterNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma_P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize an \(\mathcal{H}\)-matrix node with respect to a block cluster node. Its member list \(\Sigma_b^P\) will be merged with the given <code>Sigma_P</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">bc_node</td><td></td></tr>
    <tr><td class="paramname">Sigma_P</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Link <code>hmat</code> with <code>bc_node</code>.</p>
<p>Link row and column indices stored in the clusters \(\tau\) and \(\sigma\) respectively.</p>
<p>Update the matrix dimension of <code>hmat</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, and <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>.</p>

</div>
</div>
<a id="a0f1d1afba43d1a66f46ee4799a9904a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1d1afba43d1a66f46ee4799a9904a2">&#9670;&nbsp;</a></span>InitHMatrixWrtBlockClusterNode() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitHMatrixWrtBlockClusterNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_pair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize an \(\mathcal{H}\)-matrix node with respect to a block cluster node. The given <code>hmat_pair</code> will be appended to the list \(\Sigma_b^P\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">bc_node</td><td></td></tr>
    <tr><td class="paramname">hmat_pair</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Link <code>hmat</code> with <code>bc_node</code>.</p>
<p>Link row and column indices stored in the clusters \(\tau\) and \(\sigma\) respectively.</p>
<p>Update the matrix dimension of <code>hmat</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, and <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>.</p>

</div>
</div>
<a id="a090df12c1646d637bc390fa6dae55f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090df12c1646d637bc390fa6dae55f24">&#9670;&nbsp;</a></span>RefineHMatrixWrtExtendedBlockClusterTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RefineHMatrixWrtExtendedBlockClusterTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>current_hmat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refine an \(\mathcal{H}\)-matrix node with respect to its associated block cluster tree which has already been extended to be finer than the original tree. The \(\mathcal{H}\)-matrix node should be of either <code>FullMatrixType</code> or <code>RkMatrixType</code>, i.e. it belongs to the leaf set of the block cluster tree before extension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting_hmat</td><td>The pointer to the initial \(\mathcal{H}\)-matrix node from which this recursive function is called for the first time, i.e. the \(\mathcal{H}\)-matrix node from which the refinement begins. </td></tr>
    <tr><td class="paramname">current_hmat</td><td>The pointer to the current \(\mathcal{H}\)-matrix node being handled during the recursion. For the first time of calling this function, <code>current_hmat</code> is the same as <code>starting_hmat</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section">
<dt>Work flow </dt>
<dd><p class="startdd">Because the \(\mathcal{H}\)-matrix node from which the refinement begins belongs to the leaf set of the original block cluster tree, its \(\mathcal{H}\)-matrix type can only be <code>FullMatrixType</code> or <code>RkMatrixType</code>. Therefore, we make an assertion here.</p>
<p>Determine the total number of children of the current \(\mathcal{H}\)-matrix node by querying its associated block cluster node. We do it like this is because the block cluster tree has already been extended which contains a set of child node, while the hierarchy of H-matrices has still not been extended yet.</p>
<p>If the associated block cluster node of the current \(\mathcal{H}\)-matrix node has children, we firstly update the \(\mathcal{H}\)-matrix type for the current \(\mathcal{H}\)-matrix node as <code>HierarchicalMatrix</code> and this is only performed when the current \(\mathcal{H}\)-matrix node is not the starting \(\mathcal{H}\)-matrix node, because the original matrix type of the starting \(\mathcal{H}\)-matrix node will be used later during restriction operations to the current block cluster.</p>
<p>For each of the children, create an empty \(\mathcal{H}\)-matrix node on the heap and append it to the list of submatrices of the current \(\mathcal{H}\)-matrix.</p>
<p>Link the child \(\mathcal{H}\)-matrix node with the corresponding block cluster node.</p>
<p>Link row and column indices of the child \(\mathcal{H}\)-matrix node to those index sets stored in clusters.</p>
<p>Update the matrix dimension of the child \(\mathcal{H}\)-matrix node.</p>
<p>Set the pointer to the parent \(\mathcal{H}\)-matrix node of the current child \(\mathcal{H}\)-matrix node.</p>
<p>Recursively call the function.</p>
<p>When the current \(\mathcal{H}\)-matrix node has no children, i.e. it belongs to the leaf set of the extended block cluster tree.</p>
<p>If the current \(\mathcal{H}\)-matrix node is still the same as the starting \(\mathcal{H}\)-matrix node, there is no actual refinement work to be done.</p>
<p>Update the current \(\mathcal{H}\)-matrix node type according to the identity of the block cluster node: when the block cluster belongs to the near field, <code>current_hmat</code> should be represented as a full matrix <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>; when the block cluster belongs to the far field, <code>current_hmat</code> should be represented as a rank-k matrix <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the corresponding field of the current \(\mathcal{H}\)-matrix.</p>
<p>Fill the current full matrix with the data extracted from the starting \(\mathcal{H}\)-matrix node. This is actually a restriction of the starting \(\mathcal{H}\)-matrix node to the current \(\mathcal{H}\)-matrix node.</p>
<p>Fill the current rank-k matrix with the data extracted from the starting \(\mathcal{H}\)-matrix node.</p>
<p class="enddd"></p>
</dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a71690997092a4142799b2fa2dbf53db4">HMatrix&lt; spacedim, Number &gt;::parent</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a64c851dd63ba1a466c19f451be369475">HMatrix&lt; spacedim, Number &gt;::submatrix_index</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a5d344d3d2c8db0c93690bf7cbd4a4459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d344d3d2c8db0c93690bf7cbd4a4459">&#9670;&nbsp;</a></span>rk_h_mmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rk_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the first one <code>M1</code> has <code>RkMatrixType</code> and the result is also a rank-k matrix.</p>
<p>The arithmetic operation to be performed is </p><p class="formulaDsp">
\[ M = M_1 \cdot M_2 = (A B^T) M_2 = A (B^T M_2) = A B&#39;^T, \]
</p>
<p> where \(B&#39; = M_2^T B\) is calculated as a series of transposed \(\mathcal{H}\)-matrix-vector multiplications. For details, </p><p class="formulaDsp">
\[ M_2^T B = M_2^T \begin{bmatrix} b_{\sigma,1} &amp; \cdots &amp; b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_2^T b_{\sigma,1} &amp; \cdots &amp; M_2^T b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} b&#39;_{\rho,1} &amp; \cdots &amp; b&#39;_{\rho,r} \end{bmatrix}. \]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a temporary <code>Vector</code> storing a column \(b_{\sigma,j}\) in the <code>B</code> component of <code>M1</code> and another <code>Vector</code> \(b&#39;_{\rho,j}\) storing the matrix-vector product \(M_2^T \cdot b_{\sigma,j}\).</p>
<p>Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M1_rk</code>. Its <code>A</code> component matrix is the same as that of <code>M1_rk</code>.</p>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>
<p>Then we calculate the <code>B</code> component matrix of <code>M</code>, which is <code>M2^T*M1_rk</code>.B.</p>
<p>Fill the result vector into the <code>B</code> component matrix of <code>M</code>.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classRkMatrix.html#a7e4a8f0500daba627665c6a5ed8888d9">RkMatrix&lt; Number &gt;::formal_rank</a>, <a class="el" href="classRkMatrix.html#a8ca8898bcfedeee135437833f83b144c">RkMatrix&lt; Number &gt;::m</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classRkMatrix.html#a06d3b6636bb423c391c66e4ccc722687">RkMatrix&lt; Number &gt;::n</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classRkMatrix.html#a5457372194e8009bffc7b88f11b95d03">RkMatrix&lt; Number &gt;::reinit()</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a2138cf7f25917862b5353a6ceee9ea11">f_h_mmult()</a>, <a class="el" href="hmatrix_8h.html#a6534ff122b0835d0313d94264794b601">h_h_mmult_level_conserving()</a>, <a class="el" href="rkmatrix-hmatrix-mmult_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>.</p>

</div>
</div>
<a id="af5e90e9592ce3d05bdea99a9b93d7606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e90e9592ce3d05bdea99a9b93d7606">&#9670;&nbsp;</a></span>rk_h_mmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rk_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes and the result is scaled by a factor, where the first one <code>M1</code> has <code>RkMatrixType</code> and the result is also a rank-k matrix.</p>
<p>The arithmetic operation to be performed is </p><p class="formulaDsp">
\[ M = \alpha \cdot M_1 \cdot M_2 = \alpha \cdot (A B^T) M_2 = \alpha \cdot A (B^T M_2) = \alpha \cdot A B&#39;^T, \]
</p>
<p> where \(B&#39; = M_2^T B\) is calculated as a series of transposed \(\mathcal{H}\)-matrix-vector multiplications. For details, </p><p class="formulaDsp">
\[ M_2^T B = M_2^T \begin{bmatrix} b_{\sigma,1} &amp; \cdots &amp; b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_2^T b_{\sigma,1} &amp; \cdots &amp; M_2^T b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} b&#39;_{\rho,1} &amp; \cdots &amp; b&#39;_{\rho,r} \end{bmatrix}. \]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a temporary <code>Vector</code> storing a column \(b_{\sigma,j}\) in the <code>B</code> component of <code>M1</code> and another <code>Vector</code> \(b&#39;_{\rho,j}\) storing the matrix-vector product \(M_2^T \cdot b_{\sigma,j}\).</p>
<p>Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M1_rk</code>. Its <code>A</code> component matrix is the same as that of <code>M1_rk</code>.</p>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>
<p>Then we calculate the <code>B</code> component matrix of <code>M</code>, which is <code>M2^T*M1_rk</code>.B.</p>
<p><b>Since the following <code>Tvmult</code> will compute \(y = y + M^T x\), <code>result_vect</code> should be reset to zero beforehand.</b></p>
<p>Fill the result vector into the <code>B</code> component matrix of <code>M</code>.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classRkMatrix.html#a7e4a8f0500daba627665c6a5ed8888d9">RkMatrix&lt; Number &gt;::formal_rank</a>, <a class="el" href="classRkMatrix.html#a8ca8898bcfedeee135437833f83b144c">RkMatrix&lt; Number &gt;::m</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classRkMatrix.html#a06d3b6636bb423c391c66e4ccc722687">RkMatrix&lt; Number &gt;::n</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classRkMatrix.html#a5457372194e8009bffc7b88f11b95d03">RkMatrix&lt; Number &gt;::reinit()</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#a72e5255eb5ce46136d0e2b195c82f016">HMatrix&lt; spacedim, Number &gt;::Tvmult()</a>.</p>

</div>
</div>
<a id="a43aef4fd52ce71103baa047f549293c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43aef4fd52ce71103baa047f549293c6">&#9670;&nbsp;</a></span>rk_h_mmult_for_h_h_mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rk_h_mmult_for_h_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_M1M2_last_in_M_Sigma_P</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the first one <code>M1</code> has <code>RkMatrixType</code> and the result will also be a rank-k matrix. This function is to be called by the matrix-matrix multiplication function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a9e023f39b1f8916117a63557895a91b4">HMatrix&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list()</a>, <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="aca19ab9519b7b1aa1b9660dbfa8fe604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca19ab9519b7b1aa1b9660dbfa8fe604">&#9670;&nbsp;</a></span>rk_h_mTmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rk_h_mTmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes with the second operand being transposed, where the first operand <code>M1</code> has <code>RkMatrixType</code> and the result is also a rank-k matrix.</p>
<p>The arithmetic operation to be performed is </p><p class="formulaDsp">
\[ M = M_1 \cdot M_2^T = (A B^T) M_2^T = A (B^T M_2^T) = A B&#39;^T, \]
</p>
<p> where \(B&#39; = M_2 B\) is calculated as a series of \(\mathcal{H}\)-matrix-vector multiplications. For details, </p><p class="formulaDsp">
\[ M_2 B = M_2 \begin{bmatrix} b_{\sigma,1} &amp; \cdots &amp; b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_2 b_{\sigma,1} &amp; \cdots &amp; M_2 b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} b&#39;_{\rho,1} &amp; \cdots &amp; b&#39;_{\rho,r} \end{bmatrix}. \]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a temporary <code>Vector</code> storing a column \(b_{\sigma,j}\) in the <code>B</code> component of <code>M1</code> and another <code>Vector</code> \(b&#39;_{\rho,j}\) storing the matrix-vector product \(M_2 \cdot b_{\sigma,j}\).</p>
<p>Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M1_rk</code>. Its <code>A</code> component matrix is the same as that of <code>M1_rk</code>.</p>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>
<p>Then we calculate the <code>B</code> component matrix of <code>M</code>, which is <code>M2*M1_rk</code>.B.</p>
<p>Fill the result vector into the <code>B</code> component matrix of <code>M</code>.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classRkMatrix.html#a7e4a8f0500daba627665c6a5ed8888d9">RkMatrix&lt; Number &gt;::formal_rank</a>, <a class="el" href="classRkMatrix.html#a8ca8898bcfedeee135437833f83b144c">RkMatrix&lt; Number &gt;::m</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classRkMatrix.html#a06d3b6636bb423c391c66e4ccc722687">RkMatrix&lt; Number &gt;::n</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classRkMatrix.html#a5457372194e8009bffc7b88f11b95d03">RkMatrix&lt; Number &gt;::reinit()</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a942dd3cabbf54bd4e6bc5a922746b257">f_h_mTmult()</a>, and <a class="el" href="hmatrix_8h.html#a8855023aa4832e4119c6ead1115d4beb">h_h_mTmult_level_conserving()</a>.</p>

</div>
</div>
<a id="ab2eac81199c6e3cdf57242dfae682841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2eac81199c6e3cdf57242dfae682841">&#9670;&nbsp;</a></span>rk_h_mTmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rk_h_mTmult </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes with the second operand being transposed, where the first operand <code>M1</code> has <code>RkMatrixType</code> and the result is also a rank-k matrix. The result will be scaled by a factor.</p>
<p>The arithmetic operation to be performed is </p><p class="formulaDsp">
\[ M = \alpha \cdot M_1 \cdot M_2^T = \alpha \cdot (A B^T) M_2^T = \alpha \cdot A (B^T M_2^T) = \alpha \cdot A B&#39;^T, \]
</p>
<p> where \(B&#39; = M_2 B\) is calculated as a series of \(\mathcal{H}\)-matrix-vector multiplications. For details, </p><p class="formulaDsp">
\[ M_2 B = M_2 \begin{bmatrix} b_{\sigma,1} &amp; \cdots &amp; b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_2 b_{\sigma,1} &amp; \cdots &amp; M_2 b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} b&#39;_{\rho,1} &amp; \cdots &amp; b&#39;_{\rho,r} \end{bmatrix}. \]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a temporary <code>Vector</code> storing a column \(b_{\sigma,j}\) in the <code>B</code> component of <code>M1</code> and another <code>Vector</code> \(b&#39;_{\rho,j}\) storing the matrix-vector product \(M_2 \cdot b_{\sigma,j}\).</p>
<p>Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M1_rk</code>. Its <code>A</code> component matrix is the same as that of <code>M1_rk</code>.</p>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>
<p>Then we calculate the <code>B</code> component matrix of <code>M</code>, which is <code>M2*M1_rk</code>.B.</p>
<p>Fill the result vector into the <code>B</code> component matrix of <code>M</code>.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classRkMatrix.html#a7e4a8f0500daba627665c6a5ed8888d9">RkMatrix&lt; Number &gt;::formal_rank</a>, <a class="el" href="classRkMatrix.html#a8ca8898bcfedeee135437833f83b144c">RkMatrix&lt; Number &gt;::m</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classRkMatrix.html#a06d3b6636bb423c391c66e4ccc722687">RkMatrix&lt; Number &gt;::n</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classRkMatrix.html#a5457372194e8009bffc7b88f11b95d03">RkMatrix&lt; Number &gt;::reinit()</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#aa11b5761aba86606effd14b4bdf31912">HMatrix&lt; spacedim, Number &gt;::vmult()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
