<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>laplace-bem: /home/jihuan/Projects/deal.ii/program/dealii-9.1.1/examples/laplace-bem/include/hmatrix.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/noUndefined.js"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    skipTags: ["script","noscript","style","textarea","pre","code"],
    processEscapes: false,
    processEnvironments: true,
    preview: "TeX"
  },
  TeX: {
    Macros: {
      intd: "\\,{\\rm d}",
      diff: "{\\rm d}",
      Diff: "{\\rm D}",
      pdiff: "\\partial",
      DD: ["\\frac{\\diff}{\\diff #2}\\left( #1 \\right)", 2],
      Dd: ["\\frac{\\diff #1}{\\diff #2}", 2],
      PD: ["\\frac{\\pdiff}{\\pdiff #2}\\left( #1 \\right)", 2],
      Pd: ["\\frac{\\pdiff #1}{\\pdiff #2}", 2],
      rme: "{\\rm e}",
      rmi: "{\\rm i}",
      rmj: "{\\rm j}",
      vect: ["\\boldsymbol{#1}", 1],
      dform: ["\\overset{\\rightharpoonup}{\\boldsymbol{#1}}", 1],
      cochain: ["\\overset{\\rightharpoonup}{#1}", 1],
      Abs: ["\\big\\lvert#1\\big\\rvert", 1],
      abs: ["\\lvert#1\\rvert", 1],
      Norm: ["\\big\\lVert#1\\big\\rVert", 1],
      norm: ["\\lVert#1\\rVert", 1],
      normvect: "\\vect{n}",
      ouset: ["\\overset{#3}{\\underset{#2}{#1}}", 3],
      cscript: ["\\;\\; #1", 1],
      suchthat: "\\textit{S.T.\\;}",
      prefstar: "\\ast",
      restrict: "\\big\\vert",
      sgn: "{\\rm sgn}",
      erf: "{\\rm erf}",
      Bd: "{\\rm Bd}",
      Int: "{\\rm Int}",
      rank: "{\\rm rank}",
      divergence: "{\\rm div}",
      grad: "{\\rm grad}",
      tr: "{\\rm tr}",
      span: "{\\rm span}"
    },
    extensions: ["AMScd.js"],
    equationNumbers: { autoNumber: "AMS" }
  },
  "HTML-CSS": {
     availableFonts: ["STIX","TeX"],
     preferredFont: "TeX",
     webFont: "TeX",
     imageFont: "TeX",
     showMathMenu: true
  },
  MMLorHTML: {
    prefer: {
      MSIE:    "MML",
      Firefox: "MML",
      Opera:   "HTML",
      other:   "HTML"
    }
  }
});
</script><script type="text/javascript" src="http://localhost/js/MathJax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">laplace-bem
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Solve Laplace problem using the boundary element method (BEM)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">hmatrix.h File Reference<div class="ingroups"><a class="el" href="group__hierarchical__matrices.html">Hierarchical matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Definition of hierarchical matrix.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;deal.II/base/logstream.h&gt;</code><br />
<code>#include &lt;deal.II/lac/full_matrix.h&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="block__cluster_8h_source.html">block_cluster.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="block__cluster__tree_8h_source.html">block_cluster_tree.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="generic__functors_8h_source.html">generic_functors.h</a>&quot;</code><br />
<code>#include &quot;lapack_full_matrix_ext.h&quot;</code><br />
<code>#include &quot;<a class="el" href="rkmatrix_8h_source.html">rkmatrix.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for hmatrix.h:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="hmatrix_8h__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="hmatrix_8h__dep__incl.svg" width="100%" height="483"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
</div>
<p><a href="hmatrix_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMatrix.html">HMatrix&lt; spacedim, Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac04719e202c88f36e4533fe1d326a494"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a> { <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, 
<a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, 
<a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, 
<a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>
 }</td></tr>
<tr class="separator:ac04719e202c88f36e4533fe1d326a494"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a42e2d29cc860fddf6697fc294d76460a"><td class="memItemLeft" align="right" valign="top"><a id="a42e2d29cc860fddf6697fc294d76460a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DeclException1</b> (ExcInvalidHMatrixType, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a>,&lt;&lt; &quot;Invalid <a class="el" href="classHMatrix.html">HMatrix</a> type &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:a42e2d29cc860fddf6697fc294d76460a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21892e360616f81dd5ad1c7089f9eaab"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a21892e360616f81dd5ad1c7089f9eaab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a21892e360616f81dd5ad1c7089f9eaab">InitHMatrixWrtBlockClusterNode</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type bc_node)</td></tr>
<tr class="separator:a21892e360616f81dd5ad1c7089f9eaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d510b10595b78a40764950441bcbaf"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ae5d510b10595b78a40764950441bcbaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ae5d510b10595b78a40764950441bcbaf">InitHMatrixWrtBlockClusterNode</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type bc_node, const std::vector&lt; std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&gt;&gt; &amp;Sigma_P)</td></tr>
<tr class="separator:ae5d510b10595b78a40764950441bcbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1d1afba43d1a66f46ee4799a9904a2"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a0f1d1afba43d1a66f46ee4799a9904a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a0f1d1afba43d1a66f46ee4799a9904a2">InitHMatrixWrtBlockClusterNode</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type bc_node, const std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&gt; &amp;hmat_pair)</td></tr>
<tr class="separator:a0f1d1afba43d1a66f46ee4799a9904a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317e4841d6bb5b60883a7e21027a8893"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a317e4841d6bb5b60883a7e21027a8893"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type bc_node, const unsigned int fixed_rank_k, bool is_build_index_set_global_to_local_map=true)</td></tr>
<tr class="separator:a317e4841d6bb5b60883a7e21027a8893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b56a9e943f5632f50d08f4e892b1787"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a2b56a9e943f5632f50d08f4e892b1787"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a2b56a9e943f5632f50d08f4e892b1787">InitAndCreateHMatrixChildren</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type bc_node, const unsigned int fixed_rank_k, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, bool is_build_index_set_global_to_local_map=true)</td></tr>
<tr class="separator:a2b56a9e943f5632f50d08f4e892b1787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53120559ced904c076a4914af3e9423a"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a53120559ced904c076a4914af3e9423a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a53120559ced904c076a4914af3e9423a">InitAndCreateHMatrixChildren</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type bc_node, const unsigned int fixed_rank_k, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M, const std::map&lt; types::global_dof_index, size_t &gt; &amp;row_index_global_to_local_map_for_M, const std::map&lt; types::global_dof_index, size_t &gt; &amp;col_index_global_to_local_map_for_M, bool is_build_index_set_global_to_local_map=true)</td></tr>
<tr class="separator:a53120559ced904c076a4914af3e9423a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf5008e3967b1029d5b766290c98139"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a9cf5008e3967b1029d5b766290c98139"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a9cf5008e3967b1029d5b766290c98139">InitAndCreateHMatrixChildren</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat, typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type bc_node, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;H)</td></tr>
<tr class="separator:a9cf5008e3967b1029d5b766290c98139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090df12c1646d637bc390fa6dae55f24"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a090df12c1646d637bc390fa6dae55f24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a090df12c1646d637bc390fa6dae55f24">RefineHMatrixWrtExtendedBlockClusterTree</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *starting_hmat, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *current_hmat)</td></tr>
<tr class="separator:a090df12c1646d637bc390fa6dae55f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b0f4d71b52952d99ee7ecb0eb033cb"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a13b0f4d71b52952d99ee7ecb0eb033cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a13b0f4d71b52952d99ee7ecb0eb033cb">convertHMatBlockToRkMatrix</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat_block, const unsigned int fixed_rank_k, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *hmat_root_block=nullptr, size_t *calling_counter=nullptr, const std::string &amp;output_file_base_name=std::string(&quot;hmat-bct&quot;))</td></tr>
<tr class="separator:a13b0f4d71b52952d99ee7ecb0eb033cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee9050ba0b224929bcbf99484385a59"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:afee9050ba0b224929bcbf99484385a59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:afee9050ba0b224929bcbf99484385a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84df06910d958d84ac8c544f9a8423a8"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a84df06910d958d84ac8c544f9a8423a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M, bool is_M1M2_last_in_M_Sigma_P=true)</td></tr>
<tr class="separator:a84df06910d958d84ac8c544f9a8423a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d344d3d2c8db0c93690bf7cbd4a4459"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a5d344d3d2c8db0c93690bf7cbd4a4459"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult</a> (const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a5d344d3d2c8db0c93690bf7cbd4a4459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43aef4fd52ce71103baa047f549293c6"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a43aef4fd52ce71103baa047f549293c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M, bool is_M1M2_last_in_M_Sigma_P=true)</td></tr>
<tr class="separator:a43aef4fd52ce71103baa047f549293c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae495fd6b480f203cf797e7e86e996313"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ae495fd6b480f203cf797e7e86e996313"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:ae495fd6b480f203cf797e7e86e996313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723281b6cf62859890ec5ee49555c908"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a723281b6cf62859890ec5ee49555c908"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a723281b6cf62859890ec5ee49555c908">h_f_mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a723281b6cf62859890ec5ee49555c908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374070dba133f2152e9c44ce10947f20"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a374070dba133f2152e9c44ce10947f20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M, bool is_M1M2_last_in_M_Sigma_P=true)</td></tr>
<tr class="separator:a374070dba133f2152e9c44ce10947f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b25e6262a25b27f374cab704407437"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a37b25e6262a25b27f374cab704407437"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult</a> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a37b25e6262a25b27f374cab704407437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2138cf7f25917862b5353a6ceee9ea11"><td class="memTemplParams" colspan="2"><a id="a2138cf7f25917862b5353a6ceee9ea11"></a>
template&lt;int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a2138cf7f25917862b5353a6ceee9ea11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>f_h_mmult</b> (const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2, <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;M)</td></tr>
<tr class="separator:a2138cf7f25917862b5353a6ceee9ea11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242e7e3da010e972783e20326ae15a36"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a242e7e3da010e972783e20326ae15a36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult</a> (const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M1, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M2, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M, bool is_M1M2_last_in_M_Sigma_P=true)</td></tr>
<tr class="separator:a242e7e3da010e972783e20326ae15a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad08ee9bd389abe7b7b76fd0f2cb292e"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:aad08ee9bd389abe7b7b76fd0f2cb292e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#aad08ee9bd389abe7b7b76fd0f2cb292e">h_h_mmult_phase1_recursion</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *M, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;Tind)</td></tr>
<tr class="separator:aad08ee9bd389abe7b7b76fd0f2cb292e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199fb48349b9486624a3c55c5aece3f4"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a199fb48349b9486624a3c55c5aece3f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a199fb48349b9486624a3c55c5aece3f4">h_h_mmult_phase2</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M, <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;target_bc_tree, const unsigned int fixed_rank)</td></tr>
<tr class="separator:a199fb48349b9486624a3c55c5aece3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eeb0a11d6f43231a21267b2b45fefb2"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a1eeb0a11d6f43231a21267b2b45fefb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat_dst, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat_src)</td></tr>
<tr class="separator:a1eeb0a11d6f43231a21267b2b45fefb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e61ba5438c4cf0337664ec4b8562873"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a3e61ba5438c4cf0337664ec4b8562873"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#a3e61ba5438c4cf0337664ec4b8562873">copy_hmatrix_node</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat_dst, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;hmat_src)</td></tr>
<tr class="separator:a3e61ba5438c4cf0337664ec4b8562873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b3e4f5b78b4b6a9885325225eba0a1"><td class="memTemplParams" colspan="2">template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:af4b3e4f5b78b4b6a9885325225eba0a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="hmatrix_8h.html#af4b3e4f5b78b4b6a9885325225eba0a1">copy_hmatrix</a> (<a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat_dst, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;hmat_src)</td></tr>
<tr class="separator:af4b3e4f5b78b4b6a9885325225eba0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb67e27b0623d39d9b974fe43b56c349"><td class="memTemplParams" colspan="2"><a id="abb67e27b0623d39d9b974fe43b56c349"></a>
template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:abb67e27b0623d39d9b974fe43b56c349"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>print_h_submatrix_accessor</b> (std::ostream &amp;out, const std::string &amp;name, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M)</td></tr>
<tr class="separator:abb67e27b0623d39d9b974fe43b56c349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a2429426558ca0d6982f97b3669bf3"><td class="memTemplParams" colspan="2"><a id="a78a2429426558ca0d6982f97b3669bf3"></a>
template&lt;int spacedim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a78a2429426558ca0d6982f97b3669bf3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>print_h_h_submatrix_mmult_accessor</b> (std::ostream &amp;out, const std::string &amp;name1, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M1, const std::string &amp;name2, const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;M2)</td></tr>
<tr class="separator:a78a2429426558ca0d6982f97b3669bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Definition of hierarchical matrix. </p>
<dl class="section date"><dt>Date</dt><dd>2021-06-06 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jihuan Tian </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac04719e202c88f36e4533fe1d326a494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04719e202c88f36e4533fe1d326a494">&#9670;&nbsp;</a></span>HMatrixType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494">HMatrixType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix type of an HMaxtrix, which can be full matrix in the near field, rank-k matrix in the far field and hierarchical matrix which does not belong to the leaf set of a block cluster tree. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924"></a>FullMatrixType&#160;</td><td class="fielddoc"><p>FullMatrixType. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c"></a>RkMatrixType&#160;</td><td class="fielddoc"><p>RkMatrixType. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d"></a>HierarchicalMatrixType&#160;</td><td class="fielddoc"><p>HierarchicalType. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7"></a>UndefinedMatrixType&#160;</td><td class="fielddoc"><p>UndefinedMatrixType. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a13b0f4d71b52952d99ee7ecb0eb033cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b0f4d71b52952d99ee7ecb0eb033cb">&#9670;&nbsp;</a></span>convertHMatBlockToRkMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void convertHMatBlockToRkMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat_root_block</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>calling_counter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_file_base_name</em> = <code>std::string(&quot;hmat-bct&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an \(\mathcal{H}\)-matrix block <code>hmat_block</code> recursively into a rank-k matrix or a full matrix, which depends on whether the block cluster associated with <code>hmat_block</code> is large or not.</p>
<p>Generally speaking, this method can be considered as the agglomeration of all descendants of <code>hmat_block</code>.</p>
<dl class="section note">
<dt>Note </dt>
<dd>This method implements the operator \(\mathcal{T}_r^{\mathcal{R} \leftarrow \mathcal{H}}\), i.e. the algorithm \(Convert\_H\) in (7.8) in Hackbusch's \(\mathcal{H}\)-matrix book. </dd>
</dl>
<p>This \(\mathcal{H}\)-matrix block is implemented as a node in a whole \(\mathcal{H}\)-matrix hierarchy. This conversion algorithm will recursively descend in the hierarchical matrices for processing:</p>
<ol type="1">
<li>when the current matrix block belongs to the near field set \(P^-\), it is represented as a full matrix and no operations will be applied to it;</li>
<li>when it belongs to the far field set \(P^+\), it is already a rank-k matrix, which will then be truncated to the given <code>fixed_rank_k</code>;</li>
<li><p class="startli">when it is not a leaf, i.e. it is a hierarchical matrix, this function will be called recursively for each of its children. After that,</p>
<p class="startli">a. if the block cluster related to the current matrix is large, pairwise agglomeration for rank-k matrices will be performed and a rank-k matrix will be obtained with the given rank <code>fixed_rank_k</code>;</p>
<p class="startli">b. if the block cluster related to the current matrix is small, agglomeration of full matrices will be performed and a full matrix will be obtained.</p>
</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat_block</td><td>the pointer to the current matrix block from which the recursion will start. </td></tr>
    <tr><td class="paramname">fixed_rank_k</td><td>the fixed rank to which the rank-k matrices in the far field set will be truncated. </td></tr>
    <tr><td class="paramname">hmat_root_block</td><td>the pointer to the root \(\mathcal{H}\)-matrix block, which is only used for exporting matrix partition structure for further visualization. </td></tr>
    <tr><td class="paramname">calling_counter</td><td>the pointer to the counter which records the current total number of calling times of this function. Its value will be used to construct the name of the output file, which stores the matrix partition structure. </td></tr>
    <tr><td class="paramname">output_file_base_name</td><td>the based name of the output file which stores the matrix partition structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section">
<dt>Work flow </dt>
<dd><p class="startdd"></p>
<p>When the current \(\mathcal{H}\)-matrix block belongs to the leaf set.</p>
<p>When the current \(\mathcal{H}\)-matrix belongs to the near field set, it should be of a full matrix type. Therefore, we make an assertion here. After that we do nothing, since a near field node should always be represented as a full matrix, thus the rank truncation should not be applied.</p>
<p>When the current \(\mathcal{H}\)-matrix belongs to the far field set, it should be of a rank-k matrix type. Therefore, we make an assertion here. After that the rank-k matrix block is truncated to the specified rank.</p>
<p>When the current \(\mathcal{H}\)-matrix block does not belong to the leaf set, recursively convert each child of it to rank-k matrix if possible.</p>
<p>When the current \(\mathcal{H}\)-matrix block belongs to the near field set, we perform the operation of full matrix agglomeration.</p>
<dl class="section note">
<dt>Note </dt>
<dd><p class="startdd">Normally, this case cannot happen because when an \(\mathcal{H}\)-matrix block belongs to the near field, it is represented as a full matrix and belongs to the leaf set. However, this contradicts the precondition that the current \(\mathcal{H}\)-matrix block does not belong to the leaf set.</p>
<p class="enddd">But still this situation may happen during the conversion of an \(\mathcal{H}\)-matrix to a different block cluster tree. </p>
</dd>
</dl>
<p><b>The general work flow for the agglomeration of a set of full matrix blocks is as below.</b></p>
<ol type="1">
<li><p class="startli">Create a large full matrix on the heap and assemble all submatrices into it which depends on the split mode of the block cluster.</p>
<p class="startli">a. When it is <code>CrossSplitMode</code>, apply agglomeration of four full submatrices.</p>
<p class="startli">b. When the split mode is <code>HorizontalSplitMode</code>, apply agglomeration of two full submatrices via vertical stacking.</p>
<p class="startli">c. When the split mode is <code>VerticalSplitMode</code>, apply agglomeration of two full submatrices via horizontal stacking.</p>
</li>
<li>Delete all submatrices associated with the current \(\mathcal{H}\)-matrix and clear the <code>std::vector</code> storing submatrix pointers.</li>
<li>Associate the new large full matrix with the current \(\mathcal{H}\)-matrix.</li>
<li>Update the \(\mathcal{H}\)-matrix type as <code>FullMatrix</code>.</li>
</ol>
<p><b>About matrix assembly for <code>CrossSplitMode</b></code> </p>
<p>Let the block cluster associated with the current \(\mathcal{H}\)-matrix is \(\tau \times \sigma\). Assume the clusters are partitioned as \(\tau = [\tau_1, \tau_2]\) and \(\sigma = [\sigma_1, \sigma_2]\). Then the ordering of the child block clusters are \(\tau_1 \times \sigma_1, \tau_1 \times \sigma_2, \tau_2 \times \sigma_1, \tau_2 \times \sigma_2\).</p>
<p>Build the map from the global DoF indices to the local row indices of the current \(\mathcal{H}\)-matrix node, if necessary.</p>
<p>Build the map from the global DoF indices to the local column indices of the current \(\mathcal{H}\)-matrix node, if necessary.</p>
<p>When the current \(\mathcal{H}\)-matrix block belongs to the far field set, perform the pairwise matrix agglomeration of rank-k submatrices or full submatrices, which has been implemented into the constructor of <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>.</p>
<p>Build the map from the global DoF indices to the local row indices of the current \(\mathcal{H}\)-matrix node, if necessary.</p>
<p>Build the map from the global DoF indices to the local column indices of the current \(\mathcal{H}\)-matrix node, if necessary.</p>
<p>If the children of the current \(\mathcal{H}\)-matrix block are rank-k matrices, perform the pairwise rank-k matrix agglomeration directly.</p>
<p>If the children of the current \(\mathcal{H}\)-matrix block are full matrices, firstly convert all of them into rank-k matrices, then perform the pairwise rank-k matrix agglomeration.</p>
<p>Other cases are invalid.</p>
<p>If the children of the current \(\mathcal{H}\)-matrix block are rank-k matrices, perform the pairwise rank-k matrix agglomeration directly.</p>
<p>If the children of the current \(\mathcal{H}\)-matrix block are full matrices, firstly convert all of them into rank-k matrices, then perform the pairwise rank-k matrix agglomeration.</p>
<p>Other cases are invalid.</p>
<p>If the children of the current \(\mathcal{H}\)-matrix block are rank-k matrices, perform the pairwise rank-k matrix agglomeration directly.</p>
<p>If the children of the current \(\mathcal{H}\)-matrix block are full matrices, firstly convert all of them into rank-k matrices, then perform the pairwise rank-k matrix agglomeration.</p>
<p>Other cases are invalid.</p>
<p>Visualize the partition structure if a not-null pointer to the root \(\mathcal{H}\)-matrix node and a a not-null pointer to a <code>calling_counter</code> are provided.</p>
<p class="enddd"></p>
</dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>, and <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7">UndefinedMatrixType</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix-rkmatrix-conversion_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="af4b3e4f5b78b4b6a9885325225eba0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b3e4f5b78b4b6a9885325225eba0a1">&#9670;&nbsp;</a></span>copy_hmatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void copy_hmatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively copy an \(\mathcal{H}\)-matrix into the target matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M_dst</td><td></td></tr>
    <tr><td class="paramname">M_src</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Copy the current \(\mathcal{H}\)-matrix node.</p>
<p>Recursively copy child \(\mathcal{H}\)-matrix nodes.</p>
<p>Create a corresponding child \(\mathcal{H}\)-matrix node on the heap and push it back into the <code>submatrices</code> list of the current \(\mathcal{H}\)-matrix node.</p>

<p class="reference">References <a class="el" href="hmatrix_8h.html#a1eeb0a11d6f43231a21267b2b45fefb2">copy_hmatrix_node()</a>, and <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>.</p>

</div>
</div>
<a id="a1eeb0a11d6f43231a21267b2b45fefb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eeb0a11d6f43231a21267b2b45fefb2">&#9670;&nbsp;</a></span>copy_hmatrix_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void copy_hmatrix_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shallow copy an \(\mathcal{H}\)-matrix node into the target node, i.e. the copy is limited within the current node without recursion into its descendants. This function will be called by <code>copy_hmatrix</code>.</p>
<p>N.B. Do not copy the list <code>submatrices</code> from the source submatrix, because newly created child matrices will be pushed back into this list.</p>
<p>Do not copy the list <code>leaf_set</code>. After the whole \(\mathcal{H}\)-matrix hierarchy has been constructed, the leaf set will be built in the constructor.</p>
<p>Do not copy the working data: <code>Sigma_P</code>, <code>Sigma_F</code>, <code>Sigma_R</code> and <code>Tind</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat_dst</td><td></td></tr>
    <tr><td class="paramname">hmat_src</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Copy the rank-k matrix in the source submatrix if it is not <code>NULL</code>.</p>
<p>Copy the full matrix in the source submatrix if it is not <code>NULL</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#af4b3e4f5b78b4b6a9885325225eba0a1">copy_hmatrix()</a>.</p>

</div>
</div>
<a id="a3e61ba5438c4cf0337664ec4b8562873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e61ba5438c4cf0337664ec4b8562873">&#9670;&nbsp;</a></span>copy_hmatrix_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void copy_hmatrix_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>hmat_src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deep copy an \(\mathcal{H}\)-matrix node into the target node, i.e. the copy is limited within the current node without recursion into its descendants. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat_dst</td><td></td></tr>
    <tr><td class="paramname">hmat_src</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, <a class="el" href="classHMatrix.html#a12da9454687e5ca15837d63e2bf0b595">HMatrix&lt; spacedim, Number &gt;::Tind</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a37b25e6262a25b27f374cab704407437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b25e6262a25b27f374cab704407437">&#9670;&nbsp;</a></span>f_h_mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classLAPACKFullMatrixExt.html#a127d66494b154288d3c0c4c7f865650f">LAPACKFullMatrixExt&lt; Number &gt;::fill_row()</a>, <a class="el" href="classLAPACKFullMatrixExt.html#abc010374ccacc6d1e482196af807d247">LAPACKFullMatrixExt&lt; Number &gt;::get_row()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#a166893f3f371d4542cb57aaa33e533d1">HMatrix&lt; spacedim, Number &gt;::Tvmult_local_vector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a242e7e3da010e972783e20326ae15a36">f_h_mmult_for_h_h_mmult()</a>, and <a class="el" href="fullmatrix-hmatrix-mmult_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a242e7e3da010e972783e20326ae15a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242e7e3da010e972783e20326ae15a36">&#9670;&nbsp;</a></span>f_h_mmult_for_h_h_mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void f_h_mmult_for_h_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_M1M2_last_in_M_Sigma_P</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Full matrix is returned.</p>
<p>Rank-k matrix is returned.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classHMatrix.html#a9e023f39b1f8916117a63557895a91b4">HMatrix&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="ae495fd6b480f203cf797e7e86e996313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae495fd6b480f203cf797e7e86e996313">&#9670;&nbsp;</a></span>h_f_mmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the second one is a full matrix and the result is also represented as a full matrix because the associated block cluster node \(\tau\times\rho\) is small. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classLAPACKFullMatrixExt.html#a15180c6e8165380739735b6a7e4d1c32">LAPACKFullMatrixExt&lt; Number &gt;::fill_col()</a>, <a class="el" href="classLAPACKFullMatrixExt.html#a1d1f6836c88ae08fa79bf6c63f7a3184">LAPACKFullMatrixExt&lt; Number &gt;::get_column()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#a2afddab534366617b6be203b3c5238a6">HMatrix&lt; spacedim, Number &gt;::vmult_local_vector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a374070dba133f2152e9c44ce10947f20">h_f_mmult_for_h_h_mmult()</a>, and <a class="el" href="hmatrix-fullmatrix-mmult_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a723281b6cf62859890ec5ee49555c908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723281b6cf62859890ec5ee49555c908">&#9670;&nbsp;</a></span>h_f_mmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the second one is a full matrix and the result is represented as a rank-k matrix because the associated block cluster is large.</p>
<p>The second matrix <code>M2</code> will be firstly converted to a rank-k matrix. Then its multiplication with <code>M1</code> will be carried by calling <code>h_rk_mmult</code>. Since the conversion from a full matrix to a rank-k matrix will modify the original data, a copy of <code>M2</code> will be created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a local copy of the full matrix <code>M2</code>.</p>
<p>Convert the full matrix <code>M2</code> to a rank-k matrix.</p>

<p class="reference">References <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, and <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>.</p>

</div>
</div>
<a id="a374070dba133f2152e9c44ce10947f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374070dba133f2152e9c44ce10947f20">&#9670;&nbsp;</a></span>h_f_mmult_for_h_h_mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_f_mmult_for_h_h_mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_M1M2_last_in_M_Sigma_P</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Full matrix is returned.</p>
<p>Rank-k matrix is returned.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ae495fd6b480f203cf797e7e86e996313">h_f_mmult()</a>, <a class="el" href="classHMatrix.html#a9e023f39b1f8916117a63557895a91b4">HMatrix&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="aad08ee9bd389abe7b7b76fd0f2cb292e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad08ee9bd389abe7b7b76fd0f2cb292e">&#9670;&nbsp;</a></span>h_h_mmult_phase1_recursion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mmult_phase1_recursion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>Tind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>There are still multiplication subtasks stored in <code>Sigma_P</code> to be handled recursively.</p>
<p>After previous reduction and splitting, the matrix multiplication for the current \(\mathcal{H}\)-matrix node should be replaced by the multiplication subtasks for submatrices. These subtasks are recorded as \(\mathcal{H}\)-matrix node pairs which are stored in \(\Sigma_b^P\) of the submatrices.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a6f24998c7de1d0e336577be41c6281e3">HMatrix&lt; spacedim, Number &gt;::determine_mm_split_mode_from_Sigma_P()</a>, <a class="el" href="classHMatrix.html#a168b6eea2e5b27528497850bf5ee2bbe">HMatrix&lt; spacedim, Number &gt;::h_h_mmult_reduction()</a>, and <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>.</p>

</div>
</div>
<a id="a199fb48349b9486624a3c55c5aece3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199fb48349b9486624a3c55c5aece3f4">&#9670;&nbsp;</a></span>h_h_mmult_phase2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_h_mmult_phase2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_bc_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collect terms in <code>Sigma_R</code> and <code>Sigma_F</code> for the leaf nodes.</p>
<p>Here we make sure that \(\mathcal{H}\)-matrix pairs in the list \(\Sigma_b^P\) have all been processed and erased.</p>
<p>Perform pairwise formatted addition for the list of rank-k matrices.</p>
<p>Distribute matrices stored in \(\Sigma_b^R\) and \(\Sigma_b^F\) of each non-leaf node to its leaf nodes.</p>
<p>Convert the calculated product matrix to the specified matrix structure.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#af6fd60090b0de7bdea52fc84ddeb22c3">HMatrix&lt; spacedim, Number &gt;::convert_between_different_block_cluster_trees()</a>, <a class="el" href="classHMatrix.html#a01360c3d9a93154f2e629b6c413aa991">HMatrix&lt; spacedim, Number &gt;::distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves()</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classHMatrix.html#a61dbd471077be0ad8325d0f2afe3d43f">HMatrix&lt; spacedim, Number &gt;::leaf_set</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, <a class="el" href="classHMatrix.html#a12da9454687e5ca15837d63e2bf0b595">HMatrix&lt; spacedim, Number &gt;::Tind</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="afee9050ba0b224929bcbf99484385a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee9050ba0b224929bcbf99484385a59">&#9670;&nbsp;</a></span>h_rk_mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_rk_mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the second one <code>M2</code> has <code>RkMatrixType</code> and the result will also be a rank-k matrix.</p>
<p>The arithmetic operation to be performed is </p><p class="formulaDsp">
\[ M = M_1 \cdot M_2 = M_1 (A B^T) = (M_1 A) B^T = A&#39; B^T, \]
</p>
<p> where \(A&#39; = M_1 A\) is calculated as a series of \(\mathcal{H}\)-matrix-vector multiplications. For details, </p><p class="formulaDsp">
\[ M_1 A = M_1 \begin{bmatrix} a_{\sigma,1} &amp; \cdots &amp; a_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_1 a_{\sigma,1} &amp; \cdots &amp; M_1 a_{\sigma,r} \end{bmatrix} = \begin{bmatrix} a&#39;_{\tau,1} &amp; \cdots &amp; a&#39;_{\tau,r} \end{bmatrix}. \]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a temporary <code>Vector</code> storing a column \(a_{\sigma,j}\) in the <code>A</code> component of <code>M2</code> and another <code>Vector</code> \(a&#39;_{\tau,j}\) storing the matrix-vector product \(M_1 \cdot a_{\sigma,j}\).</p>
<p>Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M2</code>. Its <code>B</code> component matrix is the same as that of <code>M2</code>.</p>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>
<p>Then we calculate the <code>A</code> component matrix of <code>M</code>, which is <code>M1*M2</code>.A.</p>
<p>Fill the result vector into the <code>A</code> component matrix of <code>M</code>.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classRkMatrix.html#a7e4a8f0500daba627665c6a5ed8888d9">RkMatrix&lt; Number &gt;::formal_rank</a>, <a class="el" href="classRkMatrix.html#a8ca8898bcfedeee135437833f83b144c">RkMatrix&lt; Number &gt;::m</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classRkMatrix.html#a06d3b6636bb423c391c66e4ccc722687">RkMatrix&lt; Number &gt;::n</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classRkMatrix.html#a5457372194e8009bffc7b88f11b95d03">RkMatrix&lt; Number &gt;::reinit()</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#a2afddab534366617b6be203b3c5238a6">HMatrix&lt; spacedim, Number &gt;::vmult_local_vector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a723281b6cf62859890ec5ee49555c908">h_f_mmult()</a>, <a class="el" href="hmatrix_8h.html#a84df06910d958d84ac8c544f9a8423a8">h_rk_mmult_for_h_h_mmult()</a>, and <a class="el" href="hmatrix-rkmatrix-mmult_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a id="a84df06910d958d84ac8c544f9a8423a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84df06910d958d84ac8c544f9a8423a8">&#9670;&nbsp;</a></span>h_rk_mmult_for_h_h_mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void h_rk_mmult_for_h_h_mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_M1M2_last_in_M_Sigma_P</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the second one <code>M2</code> has <code>RkMatrixType</code> and the result will also be a rank-k matrix. This function is to be called by the matrix-matrix multiplication function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="hmatrix_8h.html#afee9050ba0b224929bcbf99484385a59">h_rk_mmult()</a>, <a class="el" href="classHMatrix.html#a9e023f39b1f8916117a63557895a91b4">HMatrix&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list()</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a317e4841d6bb5b60883a7e21027a8893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317e4841d6bb5b60883a7e21027a8893">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildren() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_build_index_set_global_to_local_map</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively construct the children of an \(\mathcal{H}\)-matrix with respect to a block cluster tree by starting from a tree node which is associated with the current \(\mathcal{H}\)-matrix.</p>
<p>The matrices in the leaf set are initialized with zero values. The rank of the near field matrices are predefined fixed values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td>Pointer to the current \(\mathcal{H}\)-matrix node, <b>which has already been created on the heap but with its internal data left empty.</b> </td></tr>
    <tr><td class="paramname">bc_node</td><td>Pointer to a <a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>, which is to be associated with <code>hmat</code>. </td></tr>
  </table>
  </dd>
</dl>
<p>Link <code>hmat</code> with <code>bc_node</code>.</p>
<p>Link row and column indices stored in the clusters \(\tau\) and \(\sigma\) respectively.</p>
<p>Update the matrix dimension of <code>hmat</code>.</p>
<p>When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>.</p>
<p>Then we will continue constructing its hierarchical submatrices.</p>
<p>Create an empty <a class="el" href="classHMatrix.html">HMatrix</a> on the heap.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Build the maps from global row and column indices respectively to local indices.</p>
<p>Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, <code>hmat</code> should be represented as a <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>. When the block cluster belongs to the far field, <code>hmat</code> should be represented as an <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the current \(\mathcal{H}\)-matrix.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classTreeNode.html#a077cb5cc974f94ff431c69cc2ca5957f">TreeNode&lt; T, N &gt;::get_child_num()</a>, <a class="el" href="classTreeNode.html#ad3b1833452c787d2146a4beb3587c531">TreeNode&lt; T, N &gt;::get_child_pointer()</a>, <a class="el" href="classTreeNode.html#a7bf414928c965e707e0246f7a90a747d">TreeNode&lt; T, N &gt;::get_data_reference()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a2b56a9e943f5632f50d08f4e892b1787">InitAndCreateHMatrixChildren()</a>.</p>

</div>
</div>
<a id="a2b56a9e943f5632f50d08f4e892b1787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b56a9e943f5632f50d08f4e892b1787">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildren() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_build_index_set_global_to_local_map</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively construct the children of an \(\mathcal{H}\)-matrix with respect to a block cluster tree by starting from a tree node which is associated with the current \(\mathcal{H}\)-matrix.</p>
<p>The matrices in the leaf set are initialized with the data in the given global full matrix <code>M</code>, which is created on the complete block cluster index set \(I \times J\) and whose elements should be accessed via indices stored in the block cluster. The rank of the near field matrices are predefined fixed values.</p>
<p>During the recursive calling of this function, the source data matrix <code>M</code> is kept intact, which will not be restricted to small matrix blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td>Pointer to the current \(\mathcal{H}\)-matrix node, <b>which has already been created on the heap but with its internal data left empty.</b> </td></tr>
    <tr><td class="paramname">bc_node</td><td>Pointer to a <a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>, which is to be associated with <code>hmat</code>. </td></tr>
    <tr><td class="paramname">M</td><td>The global full matrix containing all the data required to initialize the \(\mathcal{H}\)-matrix. </td></tr>
  </table>
  </dd>
</dl>
<p>Link <code>hmat</code> with <code>bc_node</code>.</p>
<p>Link row and column indices.</p>
<p>Update the matrix dimension of <code>hmat</code>.</p>
<p>When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>. Then we will continue constructing hierarchical submatrices.</p>
<p>Create an empty <a class="el" href="classHMatrix.html">HMatrix</a> on the heap.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Build the maps from global row and column indices respectively to local indices.</p>
<p>Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, <code>hmat</code> should be represented as a <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>. When the block cluster belongs to the far field, <code>hmat</code> should be represented as an <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the current \(\mathcal{H}\)-matrix.</p>
<p>Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classTreeNode.html#a077cb5cc974f94ff431c69cc2ca5957f">TreeNode&lt; T, N &gt;::get_child_num()</a>, <a class="el" href="classTreeNode.html#ad3b1833452c787d2146a4beb3587c531">TreeNode&lt; T, N &gt;::get_child_pointer()</a>, <a class="el" href="classTreeNode.html#a7bf414928c965e707e0246f7a90a747d">TreeNode&lt; T, N &gt;::get_data_reference()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a53120559ced904c076a4914af3e9423a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53120559ced904c076a4914af3e9423a">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildren() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fixed_rank_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_index_global_to_local_map_for_M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; types::global_dof_index, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_index_global_to_local_map_for_M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_build_index_set_global_to_local_map</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively construct the children of an \(\mathcal{H}\)-matrix with respect to a block cluster tree by starting from a tree node which is associated with the current \(\mathcal{H}\)-matrix.</p>
<p>The matrices in the leaf set are initialized with the data in the given full matrix <code>M</code>, which is created on the block cluster index set \(\tau \times \sigma\) associated with the current \(\mathcal{H}\)-matrix. Hence, this full matrix is just a block of the original global full matrix created on the block cluster index set \(I \times J\). The rank of the near field matrices are predefined fixed values.</p>
<p>During the recursive calling of this function, the source data matrix <code>M</code> is kept intact, which will not be restricted to small matrix blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td>Pointer to the current \(\mathcal{H}\)-matrix node, <b>which has already been created on the heap but with its internal data left empty.</b> </td></tr>
    <tr><td class="paramname">bc_node</td><td>Pointer to a <a class="el" href="classTreeNode.html" title="Class for general tree node. ">TreeNode</a> in a <a class="el" href="classBlockClusterTree.html" title="Class for block cluster tree. ">BlockClusterTree</a>, which is to be associated with <code>hmat</code>. </td></tr>
    <tr><td class="paramname">M</td><td>The full matrix, as a submatrix of the global full matrix, containing all the data required to initialize the \(\mathcal{H}\)-matrix. </td></tr>
    <tr><td class="paramname">row_index_global_to_local_map_for_M</td><td>The map from the global row indices to the local indices of the matrix associated the \(\mathcal{H}\)-matrix when first calling this recursive function. </td></tr>
    <tr><td class="paramname">col_index_global_to_local_map_for_M</td><td>The map from the global column indices to the local indices of the matrix associated the \(\mathcal{H}\)-matrix when first calling this recursive function. </td></tr>
  </table>
  </dd>
</dl>
<p>Link <code>hmat</code> with <code>bc_node</code>.</p>
<p>Link row and column indices.</p>
<p>Update the matrix dimension of <code>hmat</code>.</p>
<p>When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>. Then we will continue constructing hierarchical submatrices.</p>
<p>Create an empty <a class="el" href="classHMatrix.html">HMatrix</a> on the heap.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>Build the maps from global row and column indices respectively to local indices.</p>
<p>Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, <code>hmat</code> should be represented as a <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>. When the block cluster belongs to the far field, <code>hmat</code> should be represented as an <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the current \(\mathcal{H}\)-matrix.</p>
<p>Assign matrix values from <code>M</code> to the current <a class="el" href="classHMatrix.html">HMatrix</a>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="classTreeNode.html#a077cb5cc974f94ff431c69cc2ca5957f">TreeNode&lt; T, N &gt;::get_child_num()</a>, <a class="el" href="classTreeNode.html#ad3b1833452c787d2146a4beb3587c531">TreeNode&lt; T, N &gt;::get_child_pointer()</a>, <a class="el" href="classTreeNode.html#a7bf414928c965e707e0246f7a90a747d">TreeNode&lt; T, N &gt;::get_data_reference()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a9cf5008e3967b1029d5b766290c98139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf5008e3967b1029d5b766290c98139">&#9670;&nbsp;</a></span>InitAndCreateHMatrixChildren() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitAndCreateHMatrixChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively construct the children of an \(\mathcal{H}\)-matrix node with respect to a block cluster tree by starting from a tree node which is associated with the current \(\mathcal{H}\)-matrix node.</p>
<p>The matrices in the leaf set take the data migrated from the leaf set of the given \(\mathcal{H}\)-matrix <code>M</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Link <code>hmat</code> with <code>bc_node</code>.</p>
<p>Link row and column indices stored in the clusters \(\tau\) and \(\sigma\) respectively..</p>
<p>Update the matrix dimension of <code>hmat</code>.</p>
<p>When the block cluster node <code>bc_node</code> has children, set the current <code>hmat</code> type as <code>HierarchicalMatrixType</code>.</p>
<p>Then we will continue constructing its hierarchical submatrices.</p>
<p>Create an empty <a class="el" href="classHMatrix.html">HMatrix</a> on the heap.</p>
<p>Append the initialized child to the list of submatrices of <code>hmat</code>.</p>
<p>When the current \(\mathcal{H}\)-matrix node is a leaf, migrate the data from the leaf set of <code>H</code> to it.</p>
<p>Shallow copy the found \(\mathcal{H}\)-matrix node in the leaf set to the current \(\mathcal{H}\)-matrix node.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classTreeNode.html#a077cb5cc974f94ff431c69cc2ca5957f">TreeNode&lt; T, N &gt;::get_child_num()</a>, <a class="el" href="classTreeNode.html#ad3b1833452c787d2146a4beb3587c531">TreeNode&lt; T, N &gt;::get_child_pointer()</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="hmatrix_8h.html#a317e4841d6bb5b60883a7e21027a8893">InitAndCreateHMatrixChildren()</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a21892e360616f81dd5ad1c7089f9eaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21892e360616f81dd5ad1c7089f9eaab">&#9670;&nbsp;</a></span>InitHMatrixWrtBlockClusterNode() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitHMatrixWrtBlockClusterNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize an \(\mathcal{H}\)-matrix node with respect to a block cluster node. The list \(\Sigma_b^P\) is set to empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">bc_node</td><td></td></tr>
    <tr><td class="paramname">Sigma_P</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Link <code>hmat</code> with <code>bc_node</code>.</p>
<p>Link row and column indices stored in the clusters \(\tau\) and \(\sigma\) respectively.</p>
<p>Update the matrix dimension of <code>hmat</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, and <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>.</p>

</div>
</div>
<a id="ae5d510b10595b78a40764950441bcbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d510b10595b78a40764950441bcbaf">&#9670;&nbsp;</a></span>InitHMatrixWrtBlockClusterNode() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitHMatrixWrtBlockClusterNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma_P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize an \(\mathcal{H}\)-matrix node with respect to a block cluster node. Its member list \(\Sigma_b^P\) will be merged with the given <code>Sigma_P</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">bc_node</td><td></td></tr>
    <tr><td class="paramname">Sigma_P</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Link <code>hmat</code> with <code>bc_node</code>.</p>
<p>Link row and column indices stored in the clusters \(\tau\) and \(\sigma\) respectively.</p>
<p>Update the matrix dimension of <code>hmat</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, and <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>.</p>

</div>
</div>
<a id="a0f1d1afba43d1a66f46ee4799a9904a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1d1afba43d1a66f46ee4799a9904a2">&#9670;&nbsp;</a></span>InitHMatrixWrtBlockClusterNode() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void InitHMatrixWrtBlockClusterNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classBlockClusterTree.html">BlockClusterTree</a>&lt; spacedim, Number &gt;::node_const_pointer_type&#160;</td>
          <td class="paramname"><em>bc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *, <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>hmat_pair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize an \(\mathcal{H}\)-matrix node with respect to a block cluster node. The given <code>hmat_pair</code> will be appended to the list \(\Sigma_b^P\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hmat</td><td></td></tr>
    <tr><td class="paramname">bc_node</td><td></td></tr>
    <tr><td class="paramname">hmat_pair</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Link <code>hmat</code> with <code>bc_node</code>.</p>
<p>Link row and column indices stored in the clusters \(\tau\) and \(\sigma\) respectively.</p>
<p>Update the matrix dimension of <code>hmat</code>.</p>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, and <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>.</p>

</div>
</div>
<a id="a090df12c1646d637bc390fa6dae55f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090df12c1646d637bc390fa6dae55f24">&#9670;&nbsp;</a></span>RefineHMatrixWrtExtendedBlockClusterTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RefineHMatrixWrtExtendedBlockClusterTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>starting_hmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>current_hmat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refine an \(\mathcal{H}\)-matrix node with respect to its associated block cluster tree which has already been extended to be finer than the original tree. The \(\mathcal{H}\)-matrix node should be of either <code>FullMatrixType</code> or <code>RkMatrixType</code>, i.e. it belongs to the leaf set of the block cluster tree before extension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting_hmat</td><td>The pointer to the initial \(\mathcal{H}\)-matrix node from which this recursive function is called for the first time, i.e. the \(\mathcal{H}\)-matrix node from which the refinement begins. </td></tr>
    <tr><td class="paramname">current_hmat</td><td>The pointer to the current \(\mathcal{H}\)-matrix node being handled during the recursion. For the first time of calling this function, <code>current_hmat</code> is the same as <code>starting_hmat</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section">
<dt>Work flow </dt>
<dd><p class="startdd">Because the \(\mathcal{H}\)-matrix node from which the refinement begins belongs to the leaf set of the original block cluster tree, its \(\mathcal{H}\)-matrix type can only be <code>FullMatrixType</code> or <code>RkMatrixType</code>. Therefore, we make an assertion here.</p>
<p>Determine the total number of children of the current \(\mathcal{H}\)-matrix node by querying its associated block cluster node. We do it like this is because the block cluster tree has already been extended which contains a set of child node, while the hierarchy of H-matrices has still not been extended yet.</p>
<p>If the associated block cluster node of the current \(\mathcal{H}\)-matrix node has children, we firstly update the \(\mathcal{H}\)-matrix type for the current \(\mathcal{H}\)-matrix node as <code>HierarchicalMatrix</code> and this is only performed when the current \(\mathcal{H}\)-matrix node is not the starting \(\mathcal{H}\)-matrix node, because the original matrix type of the starting \(\mathcal{H}\)-matrix node will be used later during restriction operations to the current block cluster.</p>
<p>For each of the children, create an empty \(\mathcal{H}\)-matrix node on the heap and append it to the list of submatrices of the current \(\mathcal{H}\)-matrix.</p>
<p>Link the child \(\mathcal{H}\)-matrix node with the corresponding block cluster node.</p>
<p>Link row and column indices of the child \(\mathcal{H}\)-matrix node to those index sets stored in clusters.</p>
<p>Update the matrix dimension of the child \(\mathcal{H}\)-matrix node.</p>
<p>Recursively call the function.</p>
<p>When the current \(\mathcal{H}\)-matrix node has no children, i.e. it belongs to the leaf set of the extended block cluster tree.</p>
<p>If the current \(\mathcal{H}\)-matrix node is still the same as the starting \(\mathcal{H}\)-matrix node, there is no actual refinement work to be done.</p>
<pre class="fragment">                     If the current \form#17-matrix node is not the
</pre><p> starting \(\mathcal{H}\)-matrix node, we firstly build the maps from global row and column indices to their respective local indices. When there will be further refinement from those nodes, these maps will be used for matrix restriction.</p>
<dl class="section note">
<dt>Note </dt>
<dd>These two global to local maps are only needed for \(\mathcal{H}\)-matrix nodes in the leaf set, because only these \(\mathcal{H}\)-matrix nodes contain the actual full matrix data or rank-k matrix data. </dd>
</dl>
<p>Update the current \(\mathcal{H}\)-matrix node type according to the identity of the block cluster node: when the block cluster belongs to the near field, <code>current_hmat</code> should be represented as a full matrix <code><a class="el" href="classLAPACKFullMatrixExt.html">LAPACKFullMatrixExt</a></code>; when the block cluster belongs to the far field, <code>current_hmat</code> should be represented as a rank-k matrix <code><a class="el" href="classRkMatrix.html">RkMatrix</a></code>. Correspondingly, new matrices, either full matrix or rank-k matrix will be created on the heap and assigned to the corresponding field of the current \(\mathcal{H}\)-matrix.</p>
<p>Fill the current full matrix with the data extracted from the starting \(\mathcal{H}\)-matrix node. This is actually a restriction of the starting \(\mathcal{H}\)-matrix node to the current \(\mathcal{H}\)-matrix node.</p>
<p>Fill the current rank-k matrix with the data extracted from the starting \(\mathcal{H}\)-matrix node.</p>
<p class="enddd"></p>
</dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#a4a304494c970b5b267be1d8459d51586">HMatrix&lt; spacedim, Number &gt;::bc_node</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a328134c9e9cb2c4b05d5431c0ca8a533">HMatrix&lt; spacedim, Number &gt;::fullmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924">FullMatrixType</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d">HierarchicalMatrixType</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#a4bd1b9a32f2c7693e603a7c6ea916e4f">HMatrix&lt; spacedim, Number &gt;::submatrices</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
<a id="a5d344d3d2c8db0c93690bf7cbd4a4459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d344d3d2c8db0c93690bf7cbd4a4459">&#9670;&nbsp;</a></span>rk_h_mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rk_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRkMatrix.html">RkMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the first one <code>M1</code> has <code>RkMatrixType</code> and the result is also a rank-k matrix.</p>
<p>The arithmetic operation to be performed is </p><p class="formulaDsp">
\[ M = M_1 \cdot M_2 = (A B^T) M_2 = A (B^T M_2) = A B&#39;^T, \]
</p>
<p> where \(B&#39; = M_2^T B\) is calculated as a series of transposed \(\mathcal{H}\)-matrix-vector multiplications. For details, </p><p class="formulaDsp">
\[ M_2^T B = M_2^T \begin{bmatrix} b_{\sigma,1} &amp; \cdots &amp; b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_2^T b_{\sigma,1} &amp; \cdots &amp; M_2^T b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} b&#39;_{\rho,1} &amp; \cdots &amp; b&#39;_{\rho,r} \end{bmatrix}. \]
</p>
<p> It can be seen that the formal rank \(r\) of the result matrix <code>M</code> is the same as that of <code>M1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Create a temporary <code>Vector</code> storing a column \(b_{\sigma,j}\) in the <code>B</code> component of <code>M1</code> and another <code>Vector</code> \(b&#39;_{\rho,j}\) storing the matrix-vector product \(M_2^T \cdot b_{\sigma,j}\).</p>
<p>Initialize the result rank-k matrix <code>M</code> with the formal rank of <code>M1_rk</code>. Its <code>A</code> component matrix is the same as that of <code>M1_rk</code>.</p>
<p>Build the map from global DoF indices to local matrix indices if necessary.</p>
<p>Then we calculate the <code>B</code> component matrix of <code>M</code>, which is <code>M2^T*M1_rk</code>.B.</p>
<p>Fill the result vector into the <code>B</code> component matrix of <code>M</code>.</p>

<p class="reference">References <a class="el" href="generic__functors_8h.html#a45ed12a09686ebca5400b5161a186c09">build_index_set_global_to_local_map()</a>, <a class="el" href="classHMatrix.html#ab337c7b4f2f40699b9b7f3ab17a1e056">HMatrix&lt; spacedim, Number &gt;::col_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classRkMatrix.html#a7e4a8f0500daba627665c6a5ed8888d9">RkMatrix&lt; Number &gt;::formal_rank</a>, <a class="el" href="classRkMatrix.html#a8ca8898bcfedeee135437833f83b144c">RkMatrix&lt; Number &gt;::m</a>, <a class="el" href="classHMatrix.html#aa5523463043e4d542eae17d262bd22ad">HMatrix&lt; spacedim, Number &gt;::m</a>, <a class="el" href="classRkMatrix.html#a06d3b6636bb423c391c66e4ccc722687">RkMatrix&lt; Number &gt;::n</a>, <a class="el" href="classHMatrix.html#ab5ae2eb472f81f80653ed4411629c2d1">HMatrix&lt; spacedim, Number &gt;::n</a>, <a class="el" href="classRkMatrix.html#a5457372194e8009bffc7b88f11b95d03">RkMatrix&lt; Number &gt;::reinit()</a>, <a class="el" href="classHMatrix.html#a4d64145335fc0521603b206a22a67578">HMatrix&lt; spacedim, Number &gt;::row_index_global_to_local_map</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, and <a class="el" href="classHMatrix.html#a166893f3f371d4542cb57aaa33e533d1">HMatrix&lt; spacedim, Number &gt;::Tvmult_local_vector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="hmatrix_8h.html#a37b25e6262a25b27f374cab704407437">f_h_mmult()</a>, <a class="el" href="rkmatrix-hmatrix-mmult_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="hmatrix_8h.html#a43aef4fd52ce71103baa047f549293c6">rk_h_mmult_for_h_h_mmult()</a>.</p>

</div>
</div>
<a id="a43aef4fd52ce71103baa047f549293c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43aef4fd52ce71103baa047f549293c6">&#9670;&nbsp;</a></span>rk_h_mmult_for_h_h_mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rk_h_mmult_for_h_h_mmult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMatrix.html">HMatrix</a>&lt; spacedim, Number &gt; *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_M1M2_last_in_M_Sigma_P</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the product of two \(\mathcal{H}\)-matrix nodes, where the first one <code>M1</code> has <code>RkMatrixType</code> and the result will also be a rank-k matrix. This function is to be called by the matrix-matrix multiplication function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M1</td><td></td></tr>
    <tr><td class="paramname">M2</td><td></td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classHMatrix.html#ac30ae65e37ec5e4ccc7de2f6b9ea91e6">HMatrix&lt; spacedim, Number &gt;::col_indices</a>, <a class="el" href="classHMatrix.html#a9e023f39b1f8916117a63557895a91b4">HMatrix&lt; spacedim, Number &gt;::remove_hmat_pair_from_mm_product_list()</a>, <a class="el" href="hmatrix_8h.html#a5d344d3d2c8db0c93690bf7cbd4a4459">rk_h_mmult()</a>, <a class="el" href="classHMatrix.html#aa97a8f5e42aba0f1d5faf41f35a27819">HMatrix&lt; spacedim, Number &gt;::rkmatrix</a>, <a class="el" href="hmatrix_8h.html#ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c">RkMatrixType</a>, <a class="el" href="classHMatrix.html#a33b3a936f1b40e320e96d47471da07ae">HMatrix&lt; spacedim, Number &gt;::row_indices</a>, <a class="el" href="classHMatrix.html#aa659b6df63d533432ec1a24435cd9c40">HMatrix&lt; spacedim, Number &gt;::Sigma_F</a>, <a class="el" href="classHMatrix.html#a3d96d0252ef8c873ae06cf87874acaf3">HMatrix&lt; spacedim, Number &gt;::Sigma_P</a>, <a class="el" href="classHMatrix.html#a04d341b4e606d1be2d71b8ea636efe7b">HMatrix&lt; spacedim, Number &gt;::Sigma_R</a>, and <a class="el" href="classHMatrix.html#a89ef60f3ba737c04708195ca0bb13620">HMatrix&lt; spacedim, Number &gt;::type</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
