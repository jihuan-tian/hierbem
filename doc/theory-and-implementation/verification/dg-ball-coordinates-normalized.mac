kill(all);
batch("linalg.mac")$

/* Coordinate transformation between Cartesian and ball coordinate frames */
assume(theta >= 0, theta <= %pi)$
assume(r >= 0)$
assume(sin(theta) >= 0);

x : r*cos(phi)*sin(theta);
y : r*sin(phi)*sin(theta);
z : r*cos(theta);

/* Symbols adopted for the local coordinte chart $(u)=(r,phi,theta)$ */
u : [r, theta, phi];

/* Jacobian matrix for the transition map from ball coordinte chart to the
Cartesian coordinate chart */
Juv : matrix(
  [diff(x, r), diff(x,theta), diff(x,phi)],
  [diff(y, r), diff(y,theta), diff(y,phi)],
  [diff(z, r), diff(z,theta), diff(z,phi)]);

/* Metric tensor */
G : trigsimp(transpose(Juv) . Juv);
/* $\sqrt{g}$ appears in the pseudo volume 3-form */
g : determinant(G);

/* Compute the gradient of a 0-form */
depends(f, [u[1], u[2], u[3]]);
df : matrix(
  [diff(f, u[1])],
  [diff(f, u[2])],
  [diff(f, u[3])]
  );
nabla_f : G_inv . df;
scale_tangent_vector_to_normalized_basis(nabla_f, Juv);
expand(trigsimp(nabla_f));

/* Compute the curl of a tangent vector A */
A : matrix([a1], [a2], [a3]);
/* Transform the tangent vector to the non-normalized ball coordinates */
scale_tangent_vector_to_nonnormalized_basis(A, Juv);
/* Transform the tangent vector to 1-form $\alpha$ */
alpha : G . A;
depends([a1, a2, a3], [u[1], u[2], u[3]]);
/* Exterior differential of the 1-form $\alpha$ */
dalpha : matrix(
  [diff(alpha[3,1], u[2]) - diff(alpha[2,1], u[3])],
  [diff(alpha[1,1], u[3]) - diff(alpha[3,1], u[1])],
  [diff(alpha[2,1], u[1]) - diff(alpha[1,1], u[2])]);
curl_A : expand(trigsimp(1 / sqrt(g) * dalpha));
scale_tangent_vector_to_normalized_basis(curl_A, Juv);
expand(trigsimp(curl_A));

/* Compute the divergence of a tangent vector B */
B : matrix([b1], [b2], [b3]);
/* Transform the tangent vector to the non-normalized ball coordinates */
scale_tangent_vector_to_nonnormalized_basis(B, Juv);
depends([b1, b2, b3], [u[1], u[2], u[3]]);
div_B : expand(
  trigsimp(
    1 / sqrt(g) * (
      diff(sqrt(g) * B[1,1], u[1]) +
      diff(sqrt(g) * B[2,1], u[2]) +
      diff(sqrt(g) * B[3,1], u[3]))));

/* Compute the Laplacian */
G_inv : invert(G);
nabla_f : G_inv . df;
beta : nabla_f * sqrt(g);
laplacian_f : expand(
  trigsimp(
    1 / sqrt(g) * (diff(beta[1,1], u[1]) + diff(beta[2,1], u[2]) +
      diff(beta[3,1], u[3]))));
