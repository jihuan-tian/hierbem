#+TITLE: Figures in the documentation
#+AUTHOR: Jihuan Tian
#+OPTIONS: ':t toc:5 H:5
#+PROPERTY: header-args :eval never-export
#+LATEX_CLASS: article

* Introduction
  Some figures in the documentation are plotted using scripts, such as GNU Octave, [[https://asymptote.sourceforge.io/][Asymptote]], etc. The source code is organized within code blocks and categorized in this Emacs Org file. Using the functionality of [[https://orgmode.org/worg/org-contrib/babel/][Org Babel]] module, we can interactively run the code block and directly preview the generated figures in an Emacs buffer.
* Differential geometry
** Tangent vector
   #+BEGIN_SRC octave :session org-babel-octave :exports both :results file
     pkg load matgeom;

     N = 10;
     phi = linspace(0, 2*pi, N+1)';
     phi = phi(1:end-1);
     theta = pi/4;
     r = 1;

     ## Generate root points on the circle, in the format [x1 y1 z1; x2 y2 z2; ...]
     p = [r*cos(phi)*sin(theta), r*sin(phi)*sin(theta), r*cos(theta) * ones(N,1)];
     ## Generate vectors in the dphi direction.
     vect_length = 0.2;
     phi_dir = [-r*sin(phi)*sin(theta), r*cos(phi)*sin(theta), zeros(N,1)] * vect_length;
     theta_dir = [r*cos(phi)*cos(theta), r*sin(phi)*cos(theta), -r*sin(theta)*ones(N,1)] * vect_length;

     figure("visible", "on");
     hold on;
     ## Plot command goes here.
     sphere();
     drawVector3d(p, phi_dir, 'r');
     drawVector3d(p, theta_dir, 'g');

     colormap ocean;
     axis equal;
     grid on;
     view(-20, 30);
     xlabel("$x$");
     ylabel("$y$");
     zlabel("$z$");
     scale_fig(gcf, 2);

     PrintGCFLatex("./figures/basis-on-sphere.png");
     ans="./figures/basis-on-sphere.png";
   #+END_SRC

   #+CAPTION: caption
   #+NAME: fig:basis-on-sphere
   #+ATTR_HTML: :width 800px
   #+ATTR_LATEX: :width 0.5\textwidth
   #+RESULTS:
   [[file:./figures/basis-on-sphere.png]]
** Metric tensor of spherical coordinate chart
   #+begin_src maxima :exports both :results output
     /* Relationship between Cartesian and spherical coordinate frames */
     x:r*cos(phi)*sin(theta);
     y:r*sin(phi)*sin(theta);
     z:r*cos(theta);

     Juv:matrix([diff(x,phi), diff(x,theta)], [diff(y,phi), diff(y,theta)], [diff(z,phi), diff(z,theta)]);
     tex(Juv);

     G:trigsimp(transpose(Juv) . Juv);
     tex(G);
   #+end_src

   #+RESULTS:
   : $$\ifx\endpmatrix\undefined\pmatrix{\else\begin{pmatrix}\fi -\sin 
   :  \varphi\,r\,\sin \vartheta&\cos \varphi\,r\,\cos \vartheta\cr \cos 
   :  \varphi\,r\,\sin \vartheta&\sin \varphi\,r\,\cos \vartheta\cr 0&-r\,
   :  \sin \vartheta\cr \ifx\endpmatrix\undefined}\else\end{pmatrix}\fi $$
   : $$\ifx\endpmatrix\undefined\pmatrix{\else\begin{pmatrix}\fi r^2\,
   :  \sin ^2\vartheta&0\cr 0&r^2\cr 
   :  \ifx\endpmatrix\undefined}\else\end{pmatrix}\fi $$

   #+begin_src maxima :exports both :results output
     x:r*cos(phi)*sin(theta);
     y:r*sin(phi)*sin(theta);
     z:r*cos(theta);

     Juv:matrix([diff(x, r), diff(x,phi), diff(x,theta)], [diff(y, r), diff(y,phi), diff(y,theta)], [diff(z, r), diff(z,phi), diff(z,theta)]);
     tex(Juv);

     G:trigsimp(transpose(Juv) . Juv);
     tex(G);
   #+end_src

   #+RESULTS:
   : $$\ifx\endpmatrix\undefined\pmatrix{\else\begin{pmatrix}\fi \cos 
   :  \varphi\,\sin \vartheta&-\sin \varphi\,r\,\sin \vartheta&\cos 
   :  \varphi\,r\,\cos \vartheta\cr \sin \varphi\,\sin \vartheta&\cos 
   :  \varphi\,r\,\sin \vartheta&\sin \varphi\,r\,\cos \vartheta\cr \cos 
   :  \vartheta&0&-r\,\sin \vartheta\cr 
   :  \ifx\endpmatrix\undefined}\else\end{pmatrix}\fi $$
   : $$\ifx\endpmatrix\undefined\pmatrix{\else\begin{pmatrix}\fi 1&0&0\cr 
   :  0&r^2\,\sin ^2\vartheta&0\cr 0&0&r^2\cr 
   :  \ifx\endpmatrix\undefined}\else\end{pmatrix}\fi $$
* \(\mathcal{H}\)-matrix
** Hierarchical structure of \(\mathcal{H}\)-matrix
   :PROPERTIES:
   :CREATED:  <2023-11-09 Thu 16:15>
   :END:
*** Standard coarse partition
    Based on [[cite:&HackbuschHierarchical2015 page 42]].
    #+begin_src asymptote :exports both :results file :output-dir ./figures :file hmat-coarse-partition.png
      unitsize(1mm);
      int max_level = 5;
      real unit_cell_size = 5;

      path[] plot_rp(pair left_bottom_corner, real unit_cell_size, int current_level, int max_level)
      {
        real block_size = unit_cell_size * 2^(max_level - current_level);

        return box(left_bottom_corner, left_bottom_corner + (block_size, block_size));
      }

      path[] plot_hmat(pair left_bottom_corner, real unit_cell_size, int current_level, int max_level)
      {
        path [] hmat_hierarchy;
        real block_size = unit_cell_size * 2^(max_level - current_level);

        hmat_hierarchy = hmat_hierarchy^^box(left_bottom_corner, left_bottom_corner + (block_size, block_size));

        if (current_level != max_level)
          {
            hmat_hierarchy = hmat_hierarchy^^plot_hmat((left_bottom_corner.x, left_bottom_corner.y + block_size / 2.0), unit_cell_size, current_level + 1, max_level);
            hmat_hierarchy = hmat_hierarchy^^plot_rp((left_bottom_corner.x + block_size / 2.0, left_bottom_corner.y + block_size / 2.0), unit_cell_size, current_level + 1, max_level);
            hmat_hierarchy = hmat_hierarchy^^plot_rp((left_bottom_corner.x, left_bottom_corner.y), unit_cell_size, current_level + 1, max_level);
            hmat_hierarchy = hmat_hierarchy^^plot_hmat((left_bottom_corner.x + block_size / 2.0, left_bottom_corner.y), unit_cell_size, current_level + 1, max_level);
          }

        return hmat_hierarchy;
      }

      defaultpen(1);
      draw(plot_hmat((unit_cell_size, unit_cell_size), unit_cell_size, 0, max_level));
    #+end_src

    #+CAPTION: 
    #+NAME: fig:hmat-coarse-partition
    #+ATTR_HTML: :width 500px
    #+ATTR_LATEX: :width 0.5\textwidth
    #+RESULTS:
    [[file:./figures/hmat-coarse-partition.png]]
*** Standard fine partition
    Based on [[cite:&HackbuschHierarchical2015 page 90]].
    #+begin_src asymptote :exports both :results file :output-dir ./figures :file hmat-fine-partition.png
      unitsize(1mm);
      int max_level = 4;
      real unit_cell_size = 5;

      path[] plot_rp(pair left_bottom_corner, real unit_cell_size, int current_level, int max_level)
      {
        real block_size = unit_cell_size * 2^(max_level - current_level);

        return box(left_bottom_corner, left_bottom_corner + (block_size, block_size));
      }

      path[] plot_np(pair left_bottom_corner, real unit_cell_size, int current_level, int max_level)
      {
        path[] hmat_hierarchy;
        real block_size = unit_cell_size * 2^(max_level - current_level);

        hmat_hierarchy = hmat_hierarchy^^box(left_bottom_corner, left_bottom_corner + (block_size, block_size));

        if (current_level != max_level)
          {
            hmat_hierarchy = hmat_hierarchy^^plot_rp((left_bottom_corner.x, left_bottom_corner.y + block_size / 2), unit_cell_size, current_level + 1, max_level);
            hmat_hierarchy = hmat_hierarchy^^plot_rp((left_bottom_corner.x + block_size / 2, left_bottom_corner.y + block_size / 2), unit_cell_size, current_level + 1, max_level);
            hmat_hierarchy = hmat_hierarchy^^plot_np(left_bottom_corner, unit_cell_size, current_level + 1, max_level);
            hmat_hierarchy = hmat_hierarchy^^plot_rp((left_bottom_corner.x + block_size / 2, left_bottom_corner.y), unit_cell_size, current_level + 1, max_level);
          }

        return hmat_hierarchy;
      }

      path[] plot_np_star(pair left_bottom_corner, real unit_cell_size, int current_level, int max_level)
      {
        path[] hmat_hierarchy;
        real block_size = unit_cell_size * 2^(max_level - current_level);

        hmat_hierarchy = hmat_hierarchy^^box(left_bottom_corner, left_bottom_corner + (block_size, block_size));

        if (current_level != max_level)
          {
            hmat_hierarchy = hmat_hierarchy^^plot_rp((left_bottom_corner.x, left_bottom_corner.y + block_size / 2), unit_cell_size, current_level + 1, max_level);
            hmat_hierarchy = hmat_hierarchy^^plot_np_star((left_bottom_corner.x + block_size / 2, left_bottom_corner.y + block_size / 2), unit_cell_size, current_level + 1, max_level);
            hmat_hierarchy = hmat_hierarchy^^plot_rp(left_bottom_corner, unit_cell_size, current_level + 1, max_level);
            hmat_hierarchy = hmat_hierarchy^^plot_rp((left_bottom_corner.x + block_size / 2, left_bottom_corner.y), unit_cell_size, current_level + 1, max_level);
          }

        return hmat_hierarchy;
      }

      path[] plot_hmat(pair left_bottom_corner, real unit_cell_size, int current_level, int max_level)
      {
        path [] hmat_hierarchy;
        real block_size = unit_cell_size * 2^(max_level - current_level);

        hmat_hierarchy = hmat_hierarchy^^box(left_bottom_corner, left_bottom_corner + (block_size, block_size));

        if (current_level != max_level)
          {
            hmat_hierarchy = hmat_hierarchy^^plot_hmat((left_bottom_corner.x, left_bottom_corner.y + block_size / 2.0), unit_cell_size, current_level + 1, max_level);
            hmat_hierarchy = hmat_hierarchy^^plot_np((left_bottom_corner.x + block_size / 2.0, left_bottom_corner.y + block_size / 2.0), unit_cell_size, current_level + 1, max_level);
            hmat_hierarchy = hmat_hierarchy^^plot_np_star((left_bottom_corner.x, left_bottom_corner.y), unit_cell_size, current_level + 1, max_level);
            hmat_hierarchy = hmat_hierarchy^^plot_hmat((left_bottom_corner.x + block_size / 2.0, left_bottom_corner.y), unit_cell_size, current_level + 1, max_level);
          }

        return hmat_hierarchy;
      }

      defaultpen(1);
      draw(plot_hmat((unit_cell_size, unit_cell_size), unit_cell_size, 0, max_level));

    #+end_src

    #+CAPTION: 
    #+NAME: fig:hmat-fine-partition
    #+ATTR_HTML: :width 500px
    #+ATTR_LATEX: :width 0.5\textwidth
    #+RESULTS:
    [[file:./figures/hmat-fine-partition.png]]

<<bibliography link>>
bibliography:./hierbem.bib
