\hypertarget{classClusterTree}{}\section{Cluster\+Tree$<$ spacedim, Number $>$ Class Template Reference}
\label{classClusterTree}\index{Cluster\+Tree$<$ spacedim, Number $>$@{Cluster\+Tree$<$ spacedim, Number $>$}}


Class for cluster tree.  




{\ttfamily \#include $<$cluster\+\_\+tree.\+h$>$}



Collaboration diagram for Cluster\+Tree$<$ spacedim, Number $>$\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classClusterTree__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ \hyperlink{classCluster}{Cluster}$<$ spacedim, Number $>$ $>$ \hyperlink{classClusterTree_ab12442ec2508818e1663df6c5a137b05}{node\+\_\+value\+\_\+type}
\item 
typedef \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ \hyperlink{classCluster}{Cluster}$<$ spacedim, Number $>$ $>$ $\ast$ \hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type}
\item 
typedef const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ \hyperlink{classCluster}{Cluster}$<$ spacedim, Number $>$ $>$ $\ast$ \hyperlink{classClusterTree_acb805fbc20c01a71fa6a00adc959542c}{node\+\_\+const\+\_\+pointer\+\_\+type}
\item 
typedef \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ \hyperlink{classCluster}{Cluster}$<$ spacedim, Number $>$ $>$ \& \hyperlink{classClusterTree_a257ebe4c6eab6581a0b65ba62487ae2c}{node\+\_\+reference\+\_\+type}
\item 
typedef const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ \hyperlink{classCluster}{Cluster}$<$ spacedim, Number $>$ $>$ \& \hyperlink{classClusterTree_ac40955dbfdb9b0beec67a0ecf6810c8f}{node\+\_\+const\+\_\+reference\+\_\+type}
\item 
typedef \hyperlink{classCluster}{Cluster}$<$ spacedim, Number $>$ \hyperlink{classClusterTree_ab7875a0c5ba927d1d3c5f5212d1d524d}{data\+\_\+value\+\_\+type}
\item 
typedef \hyperlink{classCluster}{Cluster}$<$ spacedim, Number $>$ $\ast$ \hyperlink{classClusterTree_a87fee1708c95c5575fce3029b79d32a8}{data\+\_\+pointer\+\_\+type}
\item 
typedef const \hyperlink{classCluster}{Cluster}$<$ spacedim, Number $>$ $\ast$ \hyperlink{classClusterTree_ac425245d60967a91905245003e5d46b1}{data\+\_\+const\+\_\+pointer\+\_\+type}
\item 
typedef \hyperlink{classCluster}{Cluster}$<$ spacedim, Number $>$ \& \hyperlink{classClusterTree_ae47bb5a21c1468972b1c2ede0e8aa28c}{data\+\_\+reference\+\_\+type}
\item 
typedef const \hyperlink{classCluster}{Cluster}$<$ spacedim, Number $>$ \& \hyperlink{classClusterTree_a1d171cbb6b0a8367b4be0d2b87bc9ba8}{data\+\_\+const\+\_\+reference\+\_\+type}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classClusterTree_a28b31e2fbe58c74eff89a1a8e2124e10}{Cluster\+Tree} ()
\item 
\hyperlink{classClusterTree_ae21fda96c7d405825a853f8759c0cc4c}{Cluster\+Tree} (const std\+::vector$<$ types\+::global\+\_\+dof\+\_\+index $>$ \&index\+\_\+set, const unsigned int \hyperlink{classClusterTree_a2c1aa1755a2c06056b4d6b32ec35dba5}{n\+\_\+min})
\item 
\hyperlink{classClusterTree_a587c465f14f7fa0e0e6a82aa8733452f}{Cluster\+Tree} (const std\+::vector$<$ types\+::global\+\_\+dof\+\_\+index $>$ \&index\+\_\+set, const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&all\+\_\+support\+\_\+points, const unsigned int \hyperlink{classClusterTree_a2c1aa1755a2c06056b4d6b32ec35dba5}{n\+\_\+min})
\item 
\hyperlink{classClusterTree_a3fd518db632c62cfafb61e9ef56097c7}{Cluster\+Tree} (const std\+::vector$<$ types\+::global\+\_\+dof\+\_\+index $>$ \&index\+\_\+set, const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&all\+\_\+support\+\_\+points, const std\+::vector$<$ Number $>$ \&cell\+\_\+size\+\_\+at\+\_\+dofs, const unsigned int \hyperlink{classClusterTree_a2c1aa1755a2c06056b4d6b32ec35dba5}{n\+\_\+min})
\item 
\hyperlink{classClusterTree_a40d41a3a87bee15fe2d0b39a42f705d2}{Cluster\+Tree} (const \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$ \&cluster\+\_\+tree)
\item 
\hyperlink{classClusterTree_ad1b0ac0f6474de90d4fb528b6ed28db6}{$\sim$\+Cluster\+Tree} ()
\item 
void \hyperlink{classClusterTree_aa514c3b75864d5f7be72315a30079cfe}{partition} ()
\item 
void \hyperlink{classClusterTree_a5657415b4b0519f045f3139d1d63e85d}{partition} (const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&all\+\_\+support\+\_\+points)
\item 
void \hyperlink{classClusterTree_a4d2682986352bb1e44bc73ebfc5a9fdf}{partition} (const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&all\+\_\+support\+\_\+points, const std\+::vector$<$ Number $>$ \&cell\+\_\+size\+\_\+at\+\_\+dofs)
\item 
\hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type} \hyperlink{classClusterTree_a13132bfc3ca8b70af8c80066565b0adb}{get\+\_\+root} () const
\item 
std\+::vector$<$ \hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type} $>$ \& \hyperlink{classClusterTree_af17a96da7f2e5391d3e49028b2aba894}{get\+\_\+leaf\+\_\+set} ()
\item 
const std\+::vector$<$ \hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type} $>$ \& \hyperlink{classClusterTree_afbf8f03d5f34305d3c34ae4c360f50ae}{get\+\_\+leaf\+\_\+set} () const
\item 
void \hyperlink{classClusterTree_a1e7dc037d01b3e15f1d6b4eacac59cb1}{build\+\_\+leaf\+\_\+set} ()
\item 
unsigned int \hyperlink{classClusterTree_a403e59575a89a3e86e8d7092a8815aa5}{get\+\_\+n\+\_\+min} () const
\item 
unsigned int \hyperlink{classClusterTree_a2bd8dd175c4459338d76a8cb879afccf}{get\+\_\+depth} () const
\item 
unsigned int \hyperlink{classClusterTree_a3c1125039b1915ebad94247d6888df31}{get\+\_\+max\+\_\+level} () const
\item 
unsigned int \hyperlink{classClusterTree_af80051449b7324121fb0a27d5ce7c9a1}{get\+\_\+node\+\_\+num} () const
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const unsigned int \hyperlink{classClusterTree_aa9705d3fecd5b405b804331ea031570c}{child\+\_\+num} = 2
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classClusterTree_a8b650f0c7cc83adbde5aad9556a57ac3}{partition\+\_\+from\+\_\+cluster\+\_\+node} (\hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type} current\+\_\+cluster\+\_\+node, std\+::vector$<$ \hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type} $>$ \&leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node)
\item 
void \hyperlink{classClusterTree_a6d3636b1686d72909611a6d516f5ee47}{partition\+\_\+from\+\_\+cluster\+\_\+node} (\hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type} current\+\_\+cluster\+\_\+node, const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&all\+\_\+support\+\_\+points, std\+::vector$<$ \hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type} $>$ \&leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node)
\item 
void \hyperlink{classClusterTree_a8b853c36834044df5283fca9e03d39d2}{partition\+\_\+from\+\_\+cluster\+\_\+node} (\hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type} current\+\_\+cluster\+\_\+node, const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&all\+\_\+support\+\_\+points, const std\+::vector$<$ Number $>$ \&cell\+\_\+size\+\_\+at\+\_\+dofs, std\+::vector$<$ \hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type} $>$ \&leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classClusterTree_a47a5916039b17a75cda800520ac130b6}\label{classClusterTree_a47a5916039b17a75cda800520ac130b6}} 
\hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type} {\bfseries root\+\_\+node}
\item 
\mbox{\Hypertarget{classClusterTree_aa53275a95d4085912bde71f85ef39067}\label{classClusterTree_aa53275a95d4085912bde71f85ef39067}} 
std\+::vector$<$ \hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type} $>$ {\bfseries leaf\+\_\+set}
\item 
unsigned int \hyperlink{classClusterTree_a051df20340ed3f0e4bc0ee1fb1119f9f}{depth}
\item 
int \hyperlink{classClusterTree_a77800bb9f86c689821ba4d549ce97a58}{max\+\_\+level}
\item 
const unsigned int \hyperlink{classClusterTree_a2c1aa1755a2c06056b4d6b32ec35dba5}{n\+\_\+min}
\item 
unsigned int \hyperlink{classClusterTree_a6b352489be3ca9217d31966c24ee02a1}{node\+\_\+num}
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\std\+::ostream \& \hyperlink{classClusterTree_a67abb576193ee1ad87882a2b748df865}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim1, Number1 $>$ \&cluster\+\_\+tree)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$int spacedim, typename Number = double$>$\newline
class Cluster\+Tree$<$ spacedim, Number $>$}

Class for cluster tree. 

A cluster tree is a binary tree which holds a hierarchy of linked nodes with the type \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}. 

\subsection{Member Typedef Documentation}
\mbox{\Hypertarget{classClusterTree_ac425245d60967a91905245003e5d46b1}\label{classClusterTree_ac425245d60967a91905245003e5d46b1}} 
\index{Cluster\+Tree@{Cluster\+Tree}!data\+\_\+const\+\_\+pointer\+\_\+type@{data\+\_\+const\+\_\+pointer\+\_\+type}}
\index{data\+\_\+const\+\_\+pointer\+\_\+type@{data\+\_\+const\+\_\+pointer\+\_\+type}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{data\+\_\+const\+\_\+pointer\+\_\+type}{data\_const\_pointer\_type}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
typedef const \hyperlink{classCluster}{Cluster}$<$spacedim, Number$>$$\ast$ \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree_ac425245d60967a91905245003e5d46b1}{data\+\_\+const\+\_\+pointer\+\_\+type}}

Const pointer type for the content held by a node in the \hyperlink{classClusterTree}{Cluster\+Tree}. \mbox{\Hypertarget{classClusterTree_a1d171cbb6b0a8367b4be0d2b87bc9ba8}\label{classClusterTree_a1d171cbb6b0a8367b4be0d2b87bc9ba8}} 
\index{Cluster\+Tree@{Cluster\+Tree}!data\+\_\+const\+\_\+reference\+\_\+type@{data\+\_\+const\+\_\+reference\+\_\+type}}
\index{data\+\_\+const\+\_\+reference\+\_\+type@{data\+\_\+const\+\_\+reference\+\_\+type}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{data\+\_\+const\+\_\+reference\+\_\+type}{data\_const\_reference\_type}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
typedef const \hyperlink{classCluster}{Cluster}$<$spacedim, Number$>$\& \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree_a1d171cbb6b0a8367b4be0d2b87bc9ba8}{data\+\_\+const\+\_\+reference\+\_\+type}}

Const reference type for the content held by a node in the \hyperlink{classClusterTree}{Cluster\+Tree}. \mbox{\Hypertarget{classClusterTree_a87fee1708c95c5575fce3029b79d32a8}\label{classClusterTree_a87fee1708c95c5575fce3029b79d32a8}} 
\index{Cluster\+Tree@{Cluster\+Tree}!data\+\_\+pointer\+\_\+type@{data\+\_\+pointer\+\_\+type}}
\index{data\+\_\+pointer\+\_\+type@{data\+\_\+pointer\+\_\+type}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{data\+\_\+pointer\+\_\+type}{data\_pointer\_type}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
typedef \hyperlink{classCluster}{Cluster}$<$spacedim, Number$>$$\ast$ \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree_a87fee1708c95c5575fce3029b79d32a8}{data\+\_\+pointer\+\_\+type}}

Pointer type for the content held by a node in the \hyperlink{classClusterTree}{Cluster\+Tree}. \mbox{\Hypertarget{classClusterTree_ae47bb5a21c1468972b1c2ede0e8aa28c}\label{classClusterTree_ae47bb5a21c1468972b1c2ede0e8aa28c}} 
\index{Cluster\+Tree@{Cluster\+Tree}!data\+\_\+reference\+\_\+type@{data\+\_\+reference\+\_\+type}}
\index{data\+\_\+reference\+\_\+type@{data\+\_\+reference\+\_\+type}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{data\+\_\+reference\+\_\+type}{data\_reference\_type}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
typedef \hyperlink{classCluster}{Cluster}$<$spacedim, Number$>$\& \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree_ae47bb5a21c1468972b1c2ede0e8aa28c}{data\+\_\+reference\+\_\+type}}

Reference type for the content held by a node in the \hyperlink{classClusterTree}{Cluster\+Tree}. \mbox{\Hypertarget{classClusterTree_ab7875a0c5ba927d1d3c5f5212d1d524d}\label{classClusterTree_ab7875a0c5ba927d1d3c5f5212d1d524d}} 
\index{Cluster\+Tree@{Cluster\+Tree}!data\+\_\+value\+\_\+type@{data\+\_\+value\+\_\+type}}
\index{data\+\_\+value\+\_\+type@{data\+\_\+value\+\_\+type}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{data\+\_\+value\+\_\+type}{data\_value\_type}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
typedef \hyperlink{classCluster}{Cluster}$<$spacedim, Number$>$ \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree_ab7875a0c5ba927d1d3c5f5212d1d524d}{data\+\_\+value\+\_\+type}}

Data type for the content held by a node in the \hyperlink{classClusterTree}{Cluster\+Tree}. \mbox{\Hypertarget{classClusterTree_acb805fbc20c01a71fa6a00adc959542c}\label{classClusterTree_acb805fbc20c01a71fa6a00adc959542c}} 
\index{Cluster\+Tree@{Cluster\+Tree}!node\+\_\+const\+\_\+pointer\+\_\+type@{node\+\_\+const\+\_\+pointer\+\_\+type}}
\index{node\+\_\+const\+\_\+pointer\+\_\+type@{node\+\_\+const\+\_\+pointer\+\_\+type}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{node\+\_\+const\+\_\+pointer\+\_\+type}{node\_const\_pointer\_type}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
typedef const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$\hyperlink{classCluster}{Cluster}$<$spacedim, Number$>$ $>$$\ast$ \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree_acb805fbc20c01a71fa6a00adc959542c}{node\+\_\+const\+\_\+pointer\+\_\+type}}

Const pointer type for a node in the \hyperlink{classClusterTree}{Cluster\+Tree}. \mbox{\Hypertarget{classClusterTree_ac40955dbfdb9b0beec67a0ecf6810c8f}\label{classClusterTree_ac40955dbfdb9b0beec67a0ecf6810c8f}} 
\index{Cluster\+Tree@{Cluster\+Tree}!node\+\_\+const\+\_\+reference\+\_\+type@{node\+\_\+const\+\_\+reference\+\_\+type}}
\index{node\+\_\+const\+\_\+reference\+\_\+type@{node\+\_\+const\+\_\+reference\+\_\+type}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{node\+\_\+const\+\_\+reference\+\_\+type}{node\_const\_reference\_type}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
typedef const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$\hyperlink{classCluster}{Cluster}$<$spacedim, Number$>$ $>$\& \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree_ac40955dbfdb9b0beec67a0ecf6810c8f}{node\+\_\+const\+\_\+reference\+\_\+type}}

Const reference type for a node in the \hyperlink{classClusterTree}{Cluster\+Tree}. \mbox{\Hypertarget{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}\label{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}} 
\index{Cluster\+Tree@{Cluster\+Tree}!node\+\_\+pointer\+\_\+type@{node\+\_\+pointer\+\_\+type}}
\index{node\+\_\+pointer\+\_\+type@{node\+\_\+pointer\+\_\+type}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{node\+\_\+pointer\+\_\+type}{node\_pointer\_type}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
typedef \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$\hyperlink{classCluster}{Cluster}$<$spacedim, Number$>$ $>$$\ast$ \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type}}

Pointer type for a node in the \hyperlink{classClusterTree}{Cluster\+Tree}. \mbox{\Hypertarget{classClusterTree_a257ebe4c6eab6581a0b65ba62487ae2c}\label{classClusterTree_a257ebe4c6eab6581a0b65ba62487ae2c}} 
\index{Cluster\+Tree@{Cluster\+Tree}!node\+\_\+reference\+\_\+type@{node\+\_\+reference\+\_\+type}}
\index{node\+\_\+reference\+\_\+type@{node\+\_\+reference\+\_\+type}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{node\+\_\+reference\+\_\+type}{node\_reference\_type}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
typedef \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$\hyperlink{classCluster}{Cluster}$<$spacedim, Number$>$ $>$\& \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree_a257ebe4c6eab6581a0b65ba62487ae2c}{node\+\_\+reference\+\_\+type}}

Reference type for a node in the \hyperlink{classClusterTree}{Cluster\+Tree}. \mbox{\Hypertarget{classClusterTree_ab12442ec2508818e1663df6c5a137b05}\label{classClusterTree_ab12442ec2508818e1663df6c5a137b05}} 
\index{Cluster\+Tree@{Cluster\+Tree}!node\+\_\+value\+\_\+type@{node\+\_\+value\+\_\+type}}
\index{node\+\_\+value\+\_\+type@{node\+\_\+value\+\_\+type}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{node\+\_\+value\+\_\+type}{node\_value\_type}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
typedef \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$\hyperlink{classCluster}{Cluster}$<$spacedim, Number$>$ $>$ \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree_ab12442ec2508818e1663df6c5a137b05}{node\+\_\+value\+\_\+type}}

Data type for a node in the \hyperlink{classClusterTree}{Cluster\+Tree}. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classClusterTree_a28b31e2fbe58c74eff89a1a8e2124e10}\label{classClusterTree_a28b31e2fbe58c74eff89a1a8e2124e10}} 
\index{Cluster\+Tree@{Cluster\+Tree}!Cluster\+Tree@{Cluster\+Tree}}
\index{Cluster\+Tree@{Cluster\+Tree}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{Cluster\+Tree()}{ClusterTree()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree}{Cluster\+Tree} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Default constructor, which initializes an empty binary tree. \mbox{\Hypertarget{classClusterTree_ae21fda96c7d405825a853f8759c0cc4c}\label{classClusterTree_ae21fda96c7d405825a853f8759c0cc4c}} 
\index{Cluster\+Tree@{Cluster\+Tree}!Cluster\+Tree@{Cluster\+Tree}}
\index{Cluster\+Tree@{Cluster\+Tree}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{Cluster\+Tree()}{ClusterTree()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree}{Cluster\+Tree} (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ types\+::global\+\_\+dof\+\_\+index $>$ \&}]{index\+\_\+set,  }\item[{const unsigned int}]{n\+\_\+min }\end{DoxyParamCaption})}

Construct from only an index set without support point and the partition will be only based on the cardinality of the index set. 
\begin{DoxyParams}{Parameters}
{\em index\+\_\+set} & \\
\hline
{\em n\+\_\+min} & \\
\hline
\end{DoxyParams}


References Cluster\+Tree$<$ spacedim, Number $>$\+::depth, Cluster\+Tree$<$ spacedim, Number $>$\+::max\+\_\+level, and Cluster\+Tree$<$ spacedim, Number $>$\+::node\+\_\+num.

\mbox{\Hypertarget{classClusterTree_a587c465f14f7fa0e0e6a82aa8733452f}\label{classClusterTree_a587c465f14f7fa0e0e6a82aa8733452f}} 
\index{Cluster\+Tree@{Cluster\+Tree}!Cluster\+Tree@{Cluster\+Tree}}
\index{Cluster\+Tree@{Cluster\+Tree}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{Cluster\+Tree()}{ClusterTree()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree}{Cluster\+Tree} (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ types\+::global\+\_\+dof\+\_\+index $>$ \&}]{index\+\_\+set,  }\item[{const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&}]{all\+\_\+support\+\_\+points,  }\item[{const unsigned int}]{n\+\_\+min }\end{DoxyParamCaption})}

Constructor from a full index set and associated support point coordinates.

This constructor will create the root node of the cluster tree based on the given data. There is no mesh cell size correction for the cluster diameter. 
\begin{DoxyParams}{Parameters}
{\em index\+\_\+set} & The full DoF index set, which will be assigned to the root node. \\
\hline
{\em all\+\_\+support\+\_\+points} & All the support points. \\
\hline
\end{DoxyParams}


References Cluster\+Tree$<$ spacedim, Number $>$\+::depth, Cluster\+Tree$<$ spacedim, Number $>$\+::max\+\_\+level, and Cluster\+Tree$<$ spacedim, Number $>$\+::node\+\_\+num.

\mbox{\Hypertarget{classClusterTree_a3fd518db632c62cfafb61e9ef56097c7}\label{classClusterTree_a3fd518db632c62cfafb61e9ef56097c7}} 
\index{Cluster\+Tree@{Cluster\+Tree}!Cluster\+Tree@{Cluster\+Tree}}
\index{Cluster\+Tree@{Cluster\+Tree}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{Cluster\+Tree()}{ClusterTree()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree}{Cluster\+Tree} (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ types\+::global\+\_\+dof\+\_\+index $>$ \&}]{index\+\_\+set,  }\item[{const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&}]{all\+\_\+support\+\_\+points,  }\item[{const std\+::vector$<$ Number $>$ \&}]{cell\+\_\+size\+\_\+at\+\_\+dofs,  }\item[{const unsigned int}]{n\+\_\+min }\end{DoxyParamCaption})}

Constructor from a full index set and associated support point coordinates.

This constructor will create the root node of the cluster tree based on the given data. There is mesh cell size correction for the cluster diameter. 
\begin{DoxyParams}{Parameters}
{\em index\+\_\+set} & The full DoF index set, which will be assigned to the root node. \\
\hline
{\em all\+\_\+support\+\_\+points} & All the support points. \\
\hline
\end{DoxyParams}


References Cluster\+Tree$<$ spacedim, Number $>$\+::depth, Cluster\+Tree$<$ spacedim, Number $>$\+::max\+\_\+level, and Cluster\+Tree$<$ spacedim, Number $>$\+::node\+\_\+num.

\mbox{\Hypertarget{classClusterTree_a40d41a3a87bee15fe2d0b39a42f705d2}\label{classClusterTree_a40d41a3a87bee15fe2d0b39a42f705d2}} 
\index{Cluster\+Tree@{Cluster\+Tree}!Cluster\+Tree@{Cluster\+Tree}}
\index{Cluster\+Tree@{Cluster\+Tree}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{Cluster\+Tree()}{ClusterTree()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree}{Cluster\+Tree} (\begin{DoxyParamCaption}\item[{const \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{cluster\+\_\+tree }\end{DoxyParamCaption})}

Copy constructor. 
\begin{DoxyParams}{Parameters}
{\em cluster\+\_\+tree} & \\
\hline
\end{DoxyParams}


References Cluster\+Tree$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), Copy\+Tree(), and Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+root().

\mbox{\Hypertarget{classClusterTree_ad1b0ac0f6474de90d4fb528b6ed28db6}\label{classClusterTree_ad1b0ac0f6474de90d4fb528b6ed28db6}} 
\index{Cluster\+Tree@{Cluster\+Tree}!````~Cluster\+Tree@{$\sim$\+Cluster\+Tree}}
\index{````~Cluster\+Tree@{$\sim$\+Cluster\+Tree}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{$\sim$\+Cluster\+Tree()}{~ClusterTree()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::$\sim$\hyperlink{classClusterTree}{Cluster\+Tree} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Destructor which recursively destroys every node in the cluster tree. 

References Delete\+Tree().



\subsection{Member Function Documentation}
\mbox{\Hypertarget{classClusterTree_a1e7dc037d01b3e15f1d6b4eacac59cb1}\label{classClusterTree_a1e7dc037d01b3e15f1d6b4eacac59cb1}} 
\index{Cluster\+Tree@{Cluster\+Tree}!build\+\_\+leaf\+\_\+set@{build\+\_\+leaf\+\_\+set}}
\index{build\+\_\+leaf\+\_\+set@{build\+\_\+leaf\+\_\+set}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{build\+\_\+leaf\+\_\+set()}{build\_leaf\_set()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Build the leaf set by tree recursion. 

References Get\+Tree\+Leaves().



Referenced by Cluster\+Tree$<$ spacedim, Number $>$\+::\+Cluster\+Tree().

\mbox{\Hypertarget{classClusterTree_a2bd8dd175c4459338d76a8cb879afccf}\label{classClusterTree_a2bd8dd175c4459338d76a8cb879afccf}} 
\index{Cluster\+Tree@{Cluster\+Tree}!get\+\_\+depth@{get\+\_\+depth}}
\index{get\+\_\+depth@{get\+\_\+depth}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+depth()}{get\_depth()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
unsigned int \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+depth (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the tree depth. 

References Cluster\+Tree$<$ spacedim, Number $>$\+::depth.

\mbox{\Hypertarget{classClusterTree_af17a96da7f2e5391d3e49028b2aba894}\label{classClusterTree_af17a96da7f2e5391d3e49028b2aba894}} 
\index{Cluster\+Tree@{Cluster\+Tree}!get\+\_\+leaf\+\_\+set@{get\+\_\+leaf\+\_\+set}}
\index{get\+\_\+leaf\+\_\+set@{get\+\_\+leaf\+\_\+set}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+leaf\+\_\+set()}{get\_leaf\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
std\+::vector$<$ typename \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type} $>$ \& \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+leaf\+\_\+set (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Get the reference to the block cluster list. 

Referenced by main().

\mbox{\Hypertarget{classClusterTree_afbf8f03d5f34305d3c34ae4c360f50ae}\label{classClusterTree_afbf8f03d5f34305d3c34ae4c360f50ae}} 
\index{Cluster\+Tree@{Cluster\+Tree}!get\+\_\+leaf\+\_\+set@{get\+\_\+leaf\+\_\+set}}
\index{get\+\_\+leaf\+\_\+set@{get\+\_\+leaf\+\_\+set}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+leaf\+\_\+set()}{get\_leaf\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
const std\+::vector$<$ typename \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type} $>$ \& \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+leaf\+\_\+set (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the reference to the block cluster list (const version). \mbox{\Hypertarget{classClusterTree_a3c1125039b1915ebad94247d6888df31}\label{classClusterTree_a3c1125039b1915ebad94247d6888df31}} 
\index{Cluster\+Tree@{Cluster\+Tree}!get\+\_\+max\+\_\+level@{get\+\_\+max\+\_\+level}}
\index{get\+\_\+max\+\_\+level@{get\+\_\+max\+\_\+level}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+max\+\_\+level()}{get\_max\_level()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
unsigned int \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+max\+\_\+level (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the maximum tree level. 

References Cluster\+Tree$<$ spacedim, Number $>$\+::max\+\_\+level.

\mbox{\Hypertarget{classClusterTree_a403e59575a89a3e86e8d7092a8815aa5}\label{classClusterTree_a403e59575a89a3e86e8d7092a8815aa5}} 
\index{Cluster\+Tree@{Cluster\+Tree}!get\+\_\+n\+\_\+min@{get\+\_\+n\+\_\+min}}
\index{get\+\_\+n\+\_\+min@{get\+\_\+n\+\_\+min}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+n\+\_\+min()}{get\_n\_min()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
unsigned int \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+n\+\_\+min (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the minimum cluster size. 

References Cluster\+Tree$<$ spacedim, Number $>$\+::n\+\_\+min.



Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::\+Block\+Cluster\+Tree().

\mbox{\Hypertarget{classClusterTree_af80051449b7324121fb0a27d5ce7c9a1}\label{classClusterTree_af80051449b7324121fb0a27d5ce7c9a1}} 
\index{Cluster\+Tree@{Cluster\+Tree}!get\+\_\+node\+\_\+num@{get\+\_\+node\+\_\+num}}
\index{get\+\_\+node\+\_\+num@{get\+\_\+node\+\_\+num}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+node\+\_\+num()}{get\_node\_num()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
unsigned int \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+node\+\_\+num (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the total number of clusters in the tree. 

References Cluster\+Tree$<$ spacedim, Number $>$\+::node\+\_\+num.

\mbox{\Hypertarget{classClusterTree_a13132bfc3ca8b70af8c80066565b0adb}\label{classClusterTree_a13132bfc3ca8b70af8c80066565b0adb}} 
\index{Cluster\+Tree@{Cluster\+Tree}!get\+\_\+root@{get\+\_\+root}}
\index{get\+\_\+root@{get\+\_\+root}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+root()}{get\_root()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type} \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+root (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the pointer to the root node of the cluster tree. 

Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::\+Block\+Cluster\+Tree(), and Cluster\+Tree$<$ spacedim, Number $>$\+::\+Cluster\+Tree().

\mbox{\Hypertarget{classClusterTree_aa514c3b75864d5f7be72315a30079cfe}\label{classClusterTree_aa514c3b75864d5f7be72315a30079cfe}} 
\index{Cluster\+Tree@{Cluster\+Tree}!partition@{partition}}
\index{partition@{partition}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition()}{partition()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::partition (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Perform a pure cardinality based recursive partition, which will ultimately be used in constructing an $\mathcal{H}^p$ matrix for example.


\begin{DoxyDescription}
\item[Note ]
\begin{DoxyEnumerate}
\item If the initial complete cluster index set $I$ is sorted, which is usually $[0, 1, \cdots, N]$, the cardinality based cluster partition produces cluster index sets following the same order, i.\+e. the cardinality based partition is order preserving.
\item If the initial complete cluster index set $I$ is also continuous, i.\+e. it is a continuous integer array, the cardinality based cluster partition also produces continuous cluster index sets. Hence, the cardinality based partition is continuity preserving.  
\end{DoxyEnumerate}
\end{DoxyDescription}

References calc\+\_\+depth(), Cluster\+Tree$<$ spacedim, Number $>$\+::depth, Cluster\+Tree$<$ spacedim, Number $>$\+::max\+\_\+level, and Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+from\+\_\+cluster\+\_\+node().



Referenced by main().

\mbox{\Hypertarget{classClusterTree_a5657415b4b0519f045f3139d1d63e85d}\label{classClusterTree_a5657415b4b0519f045f3139d1d63e85d}} 
\index{Cluster\+Tree@{Cluster\+Tree}!partition@{partition}}
\index{partition@{partition}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition()}{partition()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::partition (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&}]{all\+\_\+support\+\_\+points }\end{DoxyParamCaption})}

Perform a recursive partition dependent on the coordinates of DoF support points by starting from the root node.

In this version, there is no mesh cell size correction to the cluster diameter and cluster pair distance.


\begin{DoxyDescription}
\item[Note ]
\begin{DoxyEnumerate}
\item If the initial complete cluster index set $I$ is sorted, which is usually $[0, 1, \cdots, N]$, the support point coordinates based partition is also order preserving. This is because the two child clusters of the current cluster are built by scanning the index set of the current cluster from beginning to end.
\item The support point coordinates based partition is not continuity preserving.  
\end{DoxyEnumerate}
\end{DoxyDescription}

References calc\+\_\+depth(), Cluster\+Tree$<$ spacedim, Number $>$\+::depth, Cluster\+Tree$<$ spacedim, Number $>$\+::max\+\_\+level, and Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+from\+\_\+cluster\+\_\+node().

\mbox{\Hypertarget{classClusterTree_a4d2682986352bb1e44bc73ebfc5a9fdf}\label{classClusterTree_a4d2682986352bb1e44bc73ebfc5a9fdf}} 
\index{Cluster\+Tree@{Cluster\+Tree}!partition@{partition}}
\index{partition@{partition}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition()}{partition()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::partition (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&}]{all\+\_\+support\+\_\+points,  }\item[{const std\+::vector$<$ Number $>$ \&}]{cell\+\_\+size\+\_\+at\+\_\+dofs }\end{DoxyParamCaption})}

Perform a recursive partition dependent on the coordinates of DoF support points by starting from the root node.

In this version, there is mesh cell size correction to the cluster diameter and cluster pair distance.


\begin{DoxyDescription}
\item[Note ]
\begin{DoxyEnumerate}
\item If the initial complete cluster index set $I$ is sorted, which is usually $[0, 1, \cdots, N]$, the support point coordinates based partition is also order preserving. This is because the two child clusters of the current cluster are built by scanning the index set of the current cluster from beginning to end.
\item The support point coordinates based partition is not continuity preserving.  
\end{DoxyEnumerate}
\end{DoxyDescription}

References calc\+\_\+depth(), Cluster\+Tree$<$ spacedim, Number $>$\+::depth, Cluster\+Tree$<$ spacedim, Number $>$\+::max\+\_\+level, and Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+from\+\_\+cluster\+\_\+node().

\mbox{\Hypertarget{classClusterTree_a8b650f0c7cc83adbde5aad9556a57ac3}\label{classClusterTree_a8b650f0c7cc83adbde5aad9556a57ac3}} 
\index{Cluster\+Tree@{Cluster\+Tree}!partition\+\_\+from\+\_\+cluster\+\_\+node@{partition\+\_\+from\+\_\+cluster\+\_\+node}}
\index{partition\+\_\+from\+\_\+cluster\+\_\+node@{partition\+\_\+from\+\_\+cluster\+\_\+node}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition\+\_\+from\+\_\+cluster\+\_\+node()}{partition\_from\_cluster\_node()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::partition\+\_\+from\+\_\+cluster\+\_\+node (\begin{DoxyParamCaption}\item[{\hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type}}]{current\+\_\+cluster\+\_\+node,  }\item[{std\+::vector$<$ \hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type} $>$ \&}]{leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Perform a pure cardinality based recursive partition by starting from a cluster node.


\begin{DoxyDescription}
\item[Note ]
\begin{DoxyEnumerate}
\item If the initial complete cluster index set $I$ is sorted, which is usually $[0, 1, \cdots, N]$, the cardinality based cluster partition produces cluster index sets following the same order, i.\+e. the cardinality based partition is order preserving.
\item If the initial complete cluster index set $I$ is also continuous, i.\+e. it is a continuous integer array, the cardinality based cluster partition also produces continuous cluster index sets. Hence, the cardinality based partition is continuity preserving.  
\end{DoxyEnumerate}
\end{DoxyDescription}


\begin{DoxyParams}{Parameters}
{\em current\+\_\+cluster\+\_\+node} & \\
\hline
{\em leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node} & \\
\hline
\end{DoxyParams}
When the cardinality of the current cluster is large enough, continue the partition.

Declare the two child index sets.

Split the index set of the current node into halves.

Calculate the splitting index in the middle of the index set, which is to be used for constructing half-\/closed and half-\/open subintervals.

Construct the left child index set.

Construct the right child index set.

Append this new node as the left child of the current cluster node.

Continue the recursive partition by starting from this child node.

Merge the leaf set wrt. the child cluster node into the leaf set of the current cluster node.

Append this new node as the right child of the current cluster node.

Continue the recursive partition by starting from this child node.

Merge the leaf set wrt. the child cluster node into the leaf set of the current cluster node.

References Binary\+Tree\+Node$<$ T $>$\+::get\+\_\+data\+\_\+pointer(), Binary\+Tree\+Node$<$ T $>$\+::get\+\_\+level(), Binary\+Tree\+Node$<$ T $>$\+::\+Left(), Cluster\+Tree$<$ spacedim, Number $>$\+::n\+\_\+min, Cluster\+Tree$<$ spacedim, Number $>$\+::node\+\_\+num, and Binary\+Tree\+Node$<$ T $>$\+::\+Right().



Referenced by Cluster\+Tree$<$ spacedim, Number $>$\+::partition(), and Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+from\+\_\+cluster\+\_\+node().

\mbox{\Hypertarget{classClusterTree_a6d3636b1686d72909611a6d516f5ee47}\label{classClusterTree_a6d3636b1686d72909611a6d516f5ee47}} 
\index{Cluster\+Tree@{Cluster\+Tree}!partition\+\_\+from\+\_\+cluster\+\_\+node@{partition\+\_\+from\+\_\+cluster\+\_\+node}}
\index{partition\+\_\+from\+\_\+cluster\+\_\+node@{partition\+\_\+from\+\_\+cluster\+\_\+node}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition\+\_\+from\+\_\+cluster\+\_\+node()}{partition\_from\_cluster\_node()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::partition\+\_\+from\+\_\+cluster\+\_\+node (\begin{DoxyParamCaption}\item[{\hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type}}]{current\+\_\+cluster\+\_\+node,  }\item[{const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&}]{all\+\_\+support\+\_\+points,  }\item[{std\+::vector$<$ \hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type} $>$ \&}]{leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Perform a recursive partition dependent on the coordinates of DoF support points by starting from a cluster node.

In this version, there is no mesh cell size correction to the cluster diameter and cluster pair distance.


\begin{DoxyDescription}
\item[Note ]
\begin{DoxyEnumerate}
\item If the initial complete cluster index set $I$ is sorted, which is usually $[0, 1, \cdots, N]$, the support point coordinates based partition is also order preserving. This is because the two child clusters of the current cluster are built by scanning the index set of the current cluster from beginning to end.
\item The support point coordinates based partition is not continuity preserving.  
\end{DoxyEnumerate}
\end{DoxyDescription}


\begin{DoxyParams}{Parameters}
{\em all\+\_\+support\+\_\+points} & All the support points. \\
\hline
\end{DoxyParams}
When the size/cardinality of the current cluster is large enough, continue the partition.

Divide the bounding box of the current cluster into halves.

Declare the two child index sets.

Determine to which child index set each support point in the original bounding box belongs to.

If the support point associated with the current DoF index belongs to the left child box, add this DoF index to the left child index set.

Otherwise, add this DoF index to the right child index set.

N.\+B. During the creation of the new child cluster, its bounding box will be recalculated, which may be smaller than the child bounding box obtained from the previous bounding box geometric bisection.

Append this new node as the left child of the current cluster node.

Continue the recursive partition by starting from this child node.

Merge the leaf set wrt. the child cluster node into the leaf set of the current cluster node.

N.\+B. During the creation of the new child cluster, its bounding box will be recalculated, which may be smaller than the child bounding box obtained from the previous bounding box geometric bisection.

Append this new node as the right child of the current cluster node.

Continue the recursive partition by starting from this child node.

Merge the leaf set wrt. the child cluster node into the leaf set of the current cluster node.

References Binary\+Tree\+Node$<$ T $>$\+::get\+\_\+data\+\_\+pointer(), Binary\+Tree\+Node$<$ T $>$\+::get\+\_\+level(), Binary\+Tree\+Node$<$ T $>$\+::\+Left(), Cluster\+Tree$<$ spacedim, Number $>$\+::n\+\_\+min, Cluster\+Tree$<$ spacedim, Number $>$\+::node\+\_\+num, Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+from\+\_\+cluster\+\_\+node(), and Binary\+Tree\+Node$<$ T $>$\+::\+Right().

\mbox{\Hypertarget{classClusterTree_a8b853c36834044df5283fca9e03d39d2}\label{classClusterTree_a8b853c36834044df5283fca9e03d39d2}} 
\index{Cluster\+Tree@{Cluster\+Tree}!partition\+\_\+from\+\_\+cluster\+\_\+node@{partition\+\_\+from\+\_\+cluster\+\_\+node}}
\index{partition\+\_\+from\+\_\+cluster\+\_\+node@{partition\+\_\+from\+\_\+cluster\+\_\+node}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition\+\_\+from\+\_\+cluster\+\_\+node()}{partition\_from\_cluster\_node()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::partition\+\_\+from\+\_\+cluster\+\_\+node (\begin{DoxyParamCaption}\item[{\hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type}}]{current\+\_\+cluster\+\_\+node,  }\item[{const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&}]{all\+\_\+support\+\_\+points,  }\item[{const std\+::vector$<$ Number $>$ \&}]{cell\+\_\+size\+\_\+at\+\_\+dofs,  }\item[{std\+::vector$<$ \hyperlink{classClusterTree_ae4bb0fdc7ac559d7844d04a00ab3e9de}{node\+\_\+pointer\+\_\+type} $>$ \&}]{leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Perform a recursive partition dependent on the coordinates of DoF support points by starting from a cluster node.

In this version, there is mesh cell size correction to the cluster diameter and cluster pair distance.


\begin{DoxyDescription}
\item[Note ]
\begin{DoxyEnumerate}
\item If the initial complete cluster index set $I$ is sorted, which is usually $[0, 1, \cdots, N]$, the support point coordinates based partition is also order preserving. This is because the two child clusters of the current cluster are built by scanning the index set of the current cluster from beginning to end.
\item The support point coordinates based partition is not continuity preserving.  
\end{DoxyEnumerate}
\end{DoxyDescription}


\begin{DoxyParams}{Parameters}
{\em all\+\_\+support\+\_\+points} & All the support points. \\
\hline
\end{DoxyParams}
When the size/cardinality of the current cluster is large enough, continue the partition.

Divide the bounding box of the current cluster into halves.

Declare the two child index sets.

Determine to which child index set each support point in the original bounding box belongs to.

If the support point associated with the current DoF index belongs to the left child box, add this DoF index to the left child index set.

Otherwise, add this DoF index to the right child index set.

N.\+B. During the creation of the new child cluster, its bounding box will be recalculated, which may be smaller than the child bounding box obtained from the previous bounding box geometric bisection.

Append this new node as the left child of the current cluster node.

Continue the recursive partition by starting from this child node.

Merge the leaf set wrt. the child cluster node into the leaf set of the current cluster node.

N.\+B. During the creation of the new child cluster, its bounding box will be recalculated, which may be smaller than the child bounding box obtained from the previous bounding box geometric bisection.

Append this new node as the right child of the current cluster node.

Continue the recursive partition by starting from this child node.

Merge the leaf set wrt. the child cluster node into the leaf set of the current cluster node.

References Binary\+Tree\+Node$<$ T $>$\+::get\+\_\+data\+\_\+pointer(), Binary\+Tree\+Node$<$ T $>$\+::get\+\_\+level(), Binary\+Tree\+Node$<$ T $>$\+::\+Left(), Cluster\+Tree$<$ spacedim, Number $>$\+::n\+\_\+min, Cluster\+Tree$<$ spacedim, Number $>$\+::node\+\_\+num, Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+from\+\_\+cluster\+\_\+node(), and Binary\+Tree\+Node$<$ T $>$\+::\+Right().



\subsection{Friends And Related Function Documentation}
\mbox{\Hypertarget{classClusterTree_a67abb576193ee1ad87882a2b748df865}\label{classClusterTree_a67abb576193ee1ad87882a2b748df865}} 
\index{Cluster\+Tree@{Cluster\+Tree}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{operator$<$$<$}{operator<<}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
template$<$int spacedim1, typename Number1 $>$ \\
std\+::ostream\& operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out,  }\item[{const \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim1, Number1 $>$ \&}]{cluster\+\_\+tree }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}

Print a whole cluster tree using recursion. 
\begin{DoxyParams}{Parameters}
{\em out} & \\
\hline
{\em cluster\+\_\+tree} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classClusterTree_aa9705d3fecd5b405b804331ea031570c}\label{classClusterTree_aa9705d3fecd5b405b804331ea031570c}} 
\index{Cluster\+Tree@{Cluster\+Tree}!child\+\_\+num@{child\+\_\+num}}
\index{child\+\_\+num@{child\+\_\+num}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{child\+\_\+num}{child\_num}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
const unsigned int \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::child\+\_\+num = 2\hspace{0.3cm}{\ttfamily [static]}}

Number of children in a cluster tree.

At present, only binary tree is allowed. \mbox{\Hypertarget{classClusterTree_a051df20340ed3f0e4bc0ee1fb1119f9f}\label{classClusterTree_a051df20340ed3f0e4bc0ee1fb1119f9f}} 
\index{Cluster\+Tree@{Cluster\+Tree}!depth@{depth}}
\index{depth@{depth}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{depth}{depth}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
unsigned int \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::depth\hspace{0.3cm}{\ttfamily [private]}}

Depth of the tree, which is the maximum level plus one. 

Referenced by Cluster\+Tree$<$ spacedim, Number $>$\+::\+Cluster\+Tree(), Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+depth(), and Cluster\+Tree$<$ spacedim, Number $>$\+::partition().

\mbox{\Hypertarget{classClusterTree_a77800bb9f86c689821ba4d549ce97a58}\label{classClusterTree_a77800bb9f86c689821ba4d549ce97a58}} 
\index{Cluster\+Tree@{Cluster\+Tree}!max\+\_\+level@{max\+\_\+level}}
\index{max\+\_\+level@{max\+\_\+level}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{max\+\_\+level}{max\_level}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
int \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::max\+\_\+level\hspace{0.3cm}{\ttfamily [private]}}

Maximum level of the cluster tree, which is {\ttfamily depth} -\/ 1. 

Referenced by Cluster\+Tree$<$ spacedim, Number $>$\+::\+Cluster\+Tree(), Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+max\+\_\+level(), and Cluster\+Tree$<$ spacedim, Number $>$\+::partition().

\mbox{\Hypertarget{classClusterTree_a2c1aa1755a2c06056b4d6b32ec35dba5}\label{classClusterTree_a2c1aa1755a2c06056b4d6b32ec35dba5}} 
\index{Cluster\+Tree@{Cluster\+Tree}!n\+\_\+min@{n\+\_\+min}}
\index{n\+\_\+min@{n\+\_\+min}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{n\+\_\+min}{n\_min}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
const unsigned int \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::n\+\_\+min\hspace{0.3cm}{\ttfamily [private]}}

Minimum cluster size, which is used as the condition for stopping box division. 

Referenced by Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+n\+\_\+min(), and Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+from\+\_\+cluster\+\_\+node().

\mbox{\Hypertarget{classClusterTree_a6b352489be3ca9217d31966c24ee02a1}\label{classClusterTree_a6b352489be3ca9217d31966c24ee02a1}} 
\index{Cluster\+Tree@{Cluster\+Tree}!node\+\_\+num@{node\+\_\+num}}
\index{node\+\_\+num@{node\+\_\+num}!Cluster\+Tree@{Cluster\+Tree}}
\subsubsection{\texorpdfstring{node\+\_\+num}{node\_num}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
unsigned int \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+num\hspace{0.3cm}{\ttfamily [private]}}

Total number of clusters in the tree. 

Referenced by Cluster\+Tree$<$ spacedim, Number $>$\+::\+Cluster\+Tree(), Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+node\+\_\+num(), and Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+from\+\_\+cluster\+\_\+node().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/jihuan/\+Projects/deal.\+ii/program/dealii-\/9.\+1.\+1/examples/laplace-\/bem/include/cluster\+\_\+tree.\+h\end{DoxyCompactItemize}
