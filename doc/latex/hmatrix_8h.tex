\hypertarget{hmatrix_8h}{}\section{/home/jihuan/\+Projects/deal.ii/program/dealii-\/9.1.1/examples/laplace-\/bem/include/hmatrix.h File Reference}
\label{hmatrix_8h}\index{/home/jihuan/\+Projects/deal.\+ii/program/dealii-\/9.\+1.\+1/examples/laplace-\/bem/include/hmatrix.\+h@{/home/jihuan/\+Projects/deal.\+ii/program/dealii-\/9.\+1.\+1/examples/laplace-\/bem/include/hmatrix.\+h}}


Definition of hierarchical matrix.  


{\ttfamily \#include $<$deal.\+I\+I/base/logstream.\+h$>$}\newline
{\ttfamily \#include $<$deal.\+I\+I/lac/full\+\_\+matrix.\+h$>$}\newline
{\ttfamily \#include $<$algorithm$>$}\newline
{\ttfamily \#include $<$fstream$>$}\newline
{\ttfamily \#include $<$iostream$>$}\newline
{\ttfamily \#include $<$map$>$}\newline
{\ttfamily \#include $<$sstream$>$}\newline
{\ttfamily \#include $<$string$>$}\newline
{\ttfamily \#include $<$utility$>$}\newline
{\ttfamily \#include $<$vector$>$}\newline
{\ttfamily \#include \char`\"{}block\+\_\+cluster.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}block\+\_\+cluster\+\_\+tree.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}generic\+\_\+functors.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}lapack\+\_\+full\+\_\+matrix\+\_\+ext.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}rkmatrix.\+h\char`\"{}}\newline
Include dependency graph for hmatrix.\+h\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{hmatrix_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{hmatrix_8h__dep__incl}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classHMatrix}{H\+Matrix$<$ spacedim, Number $>$}
\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494}{H\+Matrix\+Type} \{ \hyperlink{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924}{Full\+Matrix\+Type}, 
\hyperlink{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c}{Rk\+Matrix\+Type}, 
\hyperlink{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d}{Hierarchical\+Matrix\+Type}, 
\hyperlink{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7}{Undefined\+Matrix\+Type}
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{hmatrix_8h_a42e2d29cc860fddf6697fc294d76460a}\label{hmatrix_8h_a42e2d29cc860fddf6697fc294d76460a}} 
{\bfseries Decl\+Exception1} (Exc\+Invalid\+H\+Matrix\+Type, \hyperlink{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494}{H\+Matrix\+Type},$<$$<$ \char`\"{}Invalid \hyperlink{classHMatrix}{H\+Matrix} type \char`\"{}$<$$<$ arg1)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a21892e360616f81dd5ad1c7089f9eaab}{Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type bc\+\_\+node)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_ae5d510b10595b78a40764950441bcbaf}{Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type bc\+\_\+node, const std\+::vector$<$ std\+::pair$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$$>$$>$ \&Sigma\+\_\+P)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a0f1d1afba43d1a66f46ee4799a9904a2}{Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type bc\+\_\+node, const std\+::pair$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$$>$ \&hmat\+\_\+pair)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a65e47eb35744c93b8955b6d564e5bf9a}{Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type bc\+\_\+node, const bool is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map=true)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a317e4841d6bb5b60883a7e21027a8893}{Init\+And\+Create\+H\+Matrix\+Children} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type bc\+\_\+node, const unsigned int fixed\+\_\+rank\+\_\+k, bool is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map=true)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a2b56a9e943f5632f50d08f4e892b1787}{Init\+And\+Create\+H\+Matrix\+Children} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type bc\+\_\+node, const unsigned int fixed\+\_\+rank\+\_\+k, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M, bool is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map=true)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a6b547084e856ac11a021c104331400cf}{Init\+And\+Create\+H\+Matrix\+Children} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type bc\+\_\+node, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M, bool is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map=true)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a53120559ced904c076a4914af3e9423a}{Init\+And\+Create\+H\+Matrix\+Children} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type bc\+\_\+node, const unsigned int fixed\+\_\+rank\+\_\+k, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+M, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+M, bool is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map=true)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a427e26a795634442821a7baf5f34a8ed}{Init\+And\+Create\+H\+Matrix\+Children} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type bc\+\_\+node, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+M, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+M, bool is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map=true)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a9cf5008e3967b1029d5b766290c98139}{Init\+And\+Create\+H\+Matrix\+Children} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type bc\+\_\+node, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&\&H)
\item 
{\footnotesize template$<$int spacedim, typename Number $>$ }\\void \hyperlink{hmatrix_8h_a090df12c1646d637bc390fa6dae55f24}{Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$starting\+\_\+hmat, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$current\+\_\+hmat)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a13b0f4d71b52952d99ee7ecb0eb033cb}{convert\+H\+Mat\+Block\+To\+Rk\+Matrix} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$hmat\+\_\+block, const unsigned int fixed\+\_\+rank\+\_\+k, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$hmat\+\_\+root\+\_\+block=nullptr, size\+\_\+t $\ast$calling\+\_\+counter=nullptr, const std\+::string \&output\+\_\+file\+\_\+base\+\_\+name=std\+::string(\char`\"{}hmat-\/bct\char`\"{}))
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_afee9050ba0b224929bcbf99484385a59}{h\+\_\+rk\+\_\+mmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a9b93b5c19ef281408c6ed1e6460462e5}{h\+\_\+rk\+\_\+mmult} (const Number alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a4d0d61778a104b7e1452c3b9be60b5e4}{h\+\_\+rk\+\_\+m\+Tmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_acfbe51ba1fe5ea83d5910d1f893d589f}{h\+\_\+rk\+\_\+m\+Tmult} (const Number alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a84df06910d958d84ac8c544f9a8423a8}{h\+\_\+rk\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$M1, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$M2, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$M, bool is\+\_\+\+M1\+M2\+\_\+last\+\_\+in\+\_\+\+M\+\_\+\+Sigma\+\_\+P=true)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a5d344d3d2c8db0c93690bf7cbd4a4459}{rk\+\_\+h\+\_\+mmult} (const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_af5e90e9592ce3d05bdea99a9b93d7606}{rk\+\_\+h\+\_\+mmult} (const Number alpha, const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_aca19ab9519b7b1aa1b9660dbfa8fe604}{rk\+\_\+h\+\_\+m\+Tmult} (const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_ab2eac81199c6e3cdf57242dfae682841}{rk\+\_\+h\+\_\+m\+Tmult} (const Number alpha, const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a43aef4fd52ce71103baa047f549293c6}{rk\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult} (const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$M2, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$M, bool is\+\_\+\+M1\+M2\+\_\+last\+\_\+in\+\_\+\+M\+\_\+\+Sigma\+\_\+P=true)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_ae495fd6b480f203cf797e7e86e996313}{h\+\_\+f\+\_\+mmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M2, \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_aceb4579cb7d6a65805c548aa9c3f97b9}{h\+\_\+f\+\_\+mmult} (const Number alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M2, \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a8c5bc5080b3c7e065e70fdba10faae55}{h\+\_\+f\+\_\+m\+Tmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M2, \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a3a2ffe1ccde0ac2a90b63cfdd92a5235}{h\+\_\+f\+\_\+m\+Tmult} (const Number alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M2, \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a723281b6cf62859890ec5ee49555c908}{h\+\_\+f\+\_\+mmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a398869486c36312aefc9c22f395fc494}{h\+\_\+f\+\_\+mmult} (const Number alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_ac9f0b303f7933e220bb976db96536ef9}{h\+\_\+f\+\_\+m\+Tmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_ab4df594f8278dbd00a4d098f6e591f68}{h\+\_\+f\+\_\+m\+Tmult} (const Number alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a374070dba133f2152e9c44ce10947f20}{h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$M1, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$M2, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$M, bool is\+\_\+\+M1\+M2\+\_\+last\+\_\+in\+\_\+\+M\+\_\+\+Sigma\+\_\+P=true)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a37b25e6262a25b27f374cab704407437}{f\+\_\+h\+\_\+mmult} (const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a34a2ebfa11a73c83d768089617e308d8}{f\+\_\+h\+\_\+mmult} (const Number alpha, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_acf140473681cc5ea3ab57fafdc986357}{f\+\_\+h\+\_\+m\+Tmult} (const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a8d9fbb4b9a0e5e87096e8d8f833cbb76}{f\+\_\+h\+\_\+m\+Tmult} (const Number alpha, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a2138cf7f25917862b5353a6ceee9ea11}{f\+\_\+h\+\_\+mmult} (const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a951849a7b68e93f385c9e1fa0c4c251d}{f\+\_\+h\+\_\+mmult} (const Number alpha, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a942dd3cabbf54bd4e6bc5a922746b257}{f\+\_\+h\+\_\+m\+Tmult} (const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_ae7e6b54a178a7a0149f5ad6336e4e49c}{f\+\_\+h\+\_\+m\+Tmult} (const Number alpha, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&M)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a242e7e3da010e972783e20326ae15a36}{f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult} (const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$M2, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$M, bool is\+\_\+\+M1\+M2\+\_\+last\+\_\+in\+\_\+\+M\+\_\+\+Sigma\+\_\+P=true)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_aad08ee9bd389abe7b7b76fd0f2cb292e}{h\+\_\+h\+\_\+mmult\+\_\+phase1\+\_\+recursion} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$M, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&Tind)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a199fb48349b9486624a3c55c5aece3f4}{h\+\_\+h\+\_\+mmult\+\_\+phase2} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&target\+\_\+bc\+\_\+tree, const unsigned int fixed\+\_\+rank)
\item 
{\footnotesize template$<$int spacedim, typename Number $>$ }\\void \hyperlink{hmatrix_8h_a2b842125056627d38c5aee3a077e596c}{h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M0, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, const unsigned int fixed\+\_\+rank)
\item 
{\footnotesize template$<$int spacedim, typename Number $>$ }\\void \hyperlink{hmatrix_8h_a7cb1a4bfe1f72bde6920f716eb9314a0}{h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M0, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M, const Number alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, const unsigned int fixed\+\_\+rank)
\item 
{\footnotesize template$<$int spacedim, typename Number $>$ }\\void \hyperlink{hmatrix_8h_ab9d49e86d3c8b5596b1b603793818276}{h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M0, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, const unsigned int fixed\+\_\+rank)
\item 
{\footnotesize template$<$int spacedim, typename Number $>$ }\\void \hyperlink{hmatrix_8h_a9b8abc06deedda9951406d65af89e42f}{h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M0, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M, const Number alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, const unsigned int fixed\+\_\+rank)
\item 
{\footnotesize template$<$int spacedim, typename Number $>$ }\\void \hyperlink{hmatrix_8h_a6534ff122b0835d0313d94264794b601}{h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M0, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, const unsigned int fixed\+\_\+rank)
\item 
{\footnotesize template$<$int spacedim, typename Number $>$ }\\void \hyperlink{hmatrix_8h_a0ed620dee37feefb517062f960c9810e}{h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M0, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M, const Number alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, const unsigned int fixed\+\_\+rank)
\item 
{\footnotesize template$<$int spacedim, typename Number $>$ }\\void \hyperlink{hmatrix_8h_a8855023aa4832e4119c6ead1115d4beb}{h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M0, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, const unsigned int fixed\+\_\+rank)
\item 
{\footnotesize template$<$int spacedim, typename Number $>$ }\\void \hyperlink{hmatrix_8h_a6025a164b80c84f13121a5b6af3fab7b}{h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M0, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M, const Number alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2, const unsigned int fixed\+\_\+rank)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a1eeb0a11d6f43231a21267b2b45fefb2}{copy\+\_\+hmatrix\+\_\+node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&hmat\+\_\+dst, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&hmat\+\_\+src)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_a3e61ba5438c4cf0337664ec4b8562873}{copy\+\_\+hmatrix\+\_\+node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&hmat\+\_\+dst, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&\&hmat\+\_\+src)
\item 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void \hyperlink{hmatrix_8h_af4b3e4f5b78b4b6a9885325225eba0a1}{copy\+\_\+hmatrix} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&hmat\+\_\+dst, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&hmat\+\_\+src)
\item 
\mbox{\Hypertarget{hmatrix_8h_abb67e27b0623d39d9b974fe43b56c349}\label{hmatrix_8h_abb67e27b0623d39d9b974fe43b56c349}} 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void {\bfseries print\+\_\+h\+\_\+submatrix\+\_\+accessor} (std\+::ostream \&out, const std\+::string \&name, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M)
\item 
\mbox{\Hypertarget{hmatrix_8h_a78a2429426558ca0d6982f97b3669bf3}\label{hmatrix_8h_a78a2429426558ca0d6982f97b3669bf3}} 
{\footnotesize template$<$int spacedim, typename Number  = double$>$ }\\void {\bfseries print\+\_\+h\+\_\+h\+\_\+submatrix\+\_\+mmult\+\_\+accessor} (std\+::ostream \&out, const std\+::string \&name1, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M1, const std\+::string \&name2, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M2)
\item 
\mbox{\Hypertarget{hmatrix_8h_a88b34ad37e3ad46b0fc514ad4a428e18}\label{hmatrix_8h_a88b34ad37e3ad46b0fc514ad4a428e18}} 
{\footnotesize template$<$int spacedim, typename Number $>$ }\\void {\bfseries hmatrix\+\_\+solve\+\_\+lu} (const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&L, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&U, Vector$<$ Number $>$ \&x, const Vector$<$ Number $>$ \&b)
\item 
\mbox{\Hypertarget{hmatrix_8h_aa4d08a58ab3946a4c2912f3b0af531f7}\label{hmatrix_8h_aa4d08a58ab3946a4c2912f3b0af531f7}} 
{\footnotesize template$<$int spacedim, typename Number $>$ }\\void {\bfseries hmatrix\+\_\+solve\+\_\+cholesky} (const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&L, Vector$<$ Number $>$ \&x, const Vector$<$ Number $>$ \&b)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Definition of hierarchical matrix. 

\begin{DoxyDate}{Date}
2021-\/06-\/06 
\end{DoxyDate}
\begin{DoxyAuthor}{Author}
Jihuan Tian 
\end{DoxyAuthor}


\subsection{Enumeration Type Documentation}
\mbox{\Hypertarget{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494}\label{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494}} 
\index{hmatrix.\+h@{hmatrix.\+h}!H\+Matrix\+Type@{H\+Matrix\+Type}}
\index{H\+Matrix\+Type@{H\+Matrix\+Type}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{H\+Matrix\+Type}{HMatrixType}}
{\footnotesize\ttfamily enum \hyperlink{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494}{H\+Matrix\+Type}}

Matrix type of an H\+Maxtrix, which can be full matrix in the near field, rank-\/k matrix in the far field and hierarchical matrix which does not belong to the leaf set of a block cluster tree. \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{Full\+Matrix\+Type@{Full\+Matrix\+Type}!hmatrix.\+h@{hmatrix.\+h}}\index{hmatrix.\+h@{hmatrix.\+h}!Full\+Matrix\+Type@{Full\+Matrix\+Type}}}\mbox{\Hypertarget{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924}\label{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494a51de26f7a73c478c006090ae907e7924}} 
Full\+Matrix\+Type&Full\+Matrix\+Type. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Rk\+Matrix\+Type@{Rk\+Matrix\+Type}!hmatrix.\+h@{hmatrix.\+h}}\index{hmatrix.\+h@{hmatrix.\+h}!Rk\+Matrix\+Type@{Rk\+Matrix\+Type}}}\mbox{\Hypertarget{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c}\label{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494a2cf6ea273987e941519349b7c4b0b88c}} 
Rk\+Matrix\+Type&Rk\+Matrix\+Type. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Hierarchical\+Matrix\+Type@{Hierarchical\+Matrix\+Type}!hmatrix.\+h@{hmatrix.\+h}}\index{hmatrix.\+h@{hmatrix.\+h}!Hierarchical\+Matrix\+Type@{Hierarchical\+Matrix\+Type}}}\mbox{\Hypertarget{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d}\label{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494a8721e6353d7dcebee5c58f4990a0241d}} 
Hierarchical\+Matrix\+Type&Hierarchical\+Type. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Undefined\+Matrix\+Type@{Undefined\+Matrix\+Type}!hmatrix.\+h@{hmatrix.\+h}}\index{hmatrix.\+h@{hmatrix.\+h}!Undefined\+Matrix\+Type@{Undefined\+Matrix\+Type}}}\mbox{\Hypertarget{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7}\label{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494aba1ff44c7102f5c03299dffd067b74b7}} 
Undefined\+Matrix\+Type&Undefined\+Matrix\+Type. \\
\hline

\end{DoxyEnumFields}


\subsection{Function Documentation}
\mbox{\Hypertarget{hmatrix_8h_a13b0f4d71b52952d99ee7ecb0eb033cb}\label{hmatrix_8h_a13b0f4d71b52952d99ee7ecb0eb033cb}} 
\index{hmatrix.\+h@{hmatrix.\+h}!convert\+H\+Mat\+Block\+To\+Rk\+Matrix@{convert\+H\+Mat\+Block\+To\+Rk\+Matrix}}
\index{convert\+H\+Mat\+Block\+To\+Rk\+Matrix@{convert\+H\+Mat\+Block\+To\+Rk\+Matrix}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{convert\+H\+Mat\+Block\+To\+Rk\+Matrix()}{convertHMatBlockToRkMatrix()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void convert\+H\+Mat\+Block\+To\+Rk\+Matrix (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{hmat\+\_\+block,  }\item[{const unsigned int}]{fixed\+\_\+rank\+\_\+k,  }\item[{const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{hmat\+\_\+root\+\_\+block = {\ttfamily nullptr},  }\item[{size\+\_\+t $\ast$}]{calling\+\_\+counter = {\ttfamily nullptr},  }\item[{const std\+::string \&}]{output\+\_\+file\+\_\+base\+\_\+name = {\ttfamily std\+:\+:string(\char`\"{}hmat-\/bct\char`\"{})} }\end{DoxyParamCaption})}

Convert an $\mathcal{H}$-\/matrix block {\ttfamily hmat\+\_\+block} recursively into a rank-\/k matrix or a full matrix, which depends on whether the block cluster associated with {\ttfamily hmat\+\_\+block} is large or not.

Generally speaking, this method can be considered as the agglomeration of all descendants of {\ttfamily hmat\+\_\+block}.


\begin{DoxyDescription}
\item[Note ]This method implements the operator $\mathcal{T}_r^{\mathcal{R} \leftarrow \mathcal{H}}$, i.\+e. the algorithm $Convert\_H$ in (7.\+8) in Hackbusch\textquotesingle{}s $\mathcal{H}$-\/matrix book. 
\end{DoxyDescription}

This $\mathcal{H}$-\/matrix block is implemented as a node in a whole $\mathcal{H}$-\/matrix hierarchy. This conversion algorithm will recursively descend in the hierarchical matrices for processing\+:


\begin{DoxyEnumerate}
\item when the current matrix block belongs to the near field set $P^-$, it is represented as a full matrix and no operations will be applied to it;
\item when it belongs to the far field set $P^+$, it is already a rank-\/k matrix, which will then be truncated to the given {\ttfamily fixed\+\_\+rank\+\_\+k};
\item when it is not a leaf, i.\+e. it is a hierarchical matrix, this function will be called recursively for each of its children. After that,

a. if the block cluster related to the current matrix is large, pairwise agglomeration for rank-\/k matrices will be performed and a rank-\/k matrix will be obtained with the given rank {\ttfamily fixed\+\_\+rank\+\_\+k};

b. if the block cluster related to the current matrix is small, agglomeration of full matrices will be performed and a full matrix will be obtained.
\end{DoxyEnumerate}


\begin{DoxyParams}{Parameters}
{\em hmat\+\_\+block} & the pointer to the current matrix block from which the recursion will start. \\
\hline
{\em fixed\+\_\+rank\+\_\+k} & the fixed rank to which the rank-\/k matrices in the far field set will be truncated. \\
\hline
{\em hmat\+\_\+root\+\_\+block} & the pointer to the root $\mathcal{H}$-\/matrix block, which is only used for exporting matrix partition structure for further visualization. \\
\hline
{\em calling\+\_\+counter} & the pointer to the counter which records the current total number of calling times of this function. Its value will be used to construct the name of the output file, which stores the matrix partition structure. \\
\hline
{\em output\+\_\+file\+\_\+base\+\_\+name} & the based name of the output file which stores the matrix partition structure. \\
\hline
\end{DoxyParams}

\begin{DoxyDescription}
\item[Work flow ]

When the current $\mathcal{H}$-\/matrix block belongs to the leaf set.

When the current $\mathcal{H}$-\/matrix belongs to the near field set, it should be of a full matrix type. Therefore, we make an assertion here. After that we do nothing, since a near field node should always be represented as a full matrix, thus the rank truncation should not be applied.

When the current $\mathcal{H}$-\/matrix belongs to the far field set, it should be of a rank-\/k matrix type. Therefore, we make an assertion here. After that the rank-\/k matrix block is truncated to the specified rank.

When the current $\mathcal{H}$-\/matrix block does not belong to the leaf set, recursively convert each child of it to rank-\/k matrix if possible.

When the current $\mathcal{H}$-\/matrix block belongs to the near field set, we perform the operation of full matrix agglomeration.


\begin{DoxyDescription}
\item[Note ]Normally, this case cannot happen because when an $\mathcal{H}$-\/matrix block belongs to the near field, it is represented as a full matrix and belongs to the leaf set. However, this contradicts the precondition that the current $\mathcal{H}$-\/matrix block does not belong to the leaf set.

But still this situation may happen during the conversion of an $\mathcal{H}$-\/matrix to a different block cluster tree. 
\end{DoxyDescription}

{\bfseries The general work flow for the agglomeration of a set of full matrix blocks is as below.}


\begin{DoxyEnumerate}
\item Create a large full matrix on the heap and assemble all submatrices into it which depends on the split mode of the block cluster.

a. When it is {\ttfamily Cross\+Split\+Mode}, apply agglomeration of four full submatrices.

b. When the split mode is {\ttfamily Horizontal\+Split\+Mode}, apply agglomeration of two full submatrices via vertical stacking.

c. When the split mode is {\ttfamily Vertical\+Split\+Mode}, apply agglomeration of two full submatrices via horizontal stacking.
\item Delete all submatrices associated with the current $\mathcal{H}$-\/matrix and clear the {\ttfamily std\+::vector} storing submatrix pointers.
\item Associate the new large full matrix with the current $\mathcal{H}$-\/matrix.
\item Update the $\mathcal{H}$-\/matrix type as {\ttfamily Full\+Matrix}.
\end{DoxyEnumerate}

{\bfseries About matrix assembly for {\ttfamily Cross\+Split\+Mode}} 

Let the block cluster associated with the current $\mathcal{H}$-\/matrix is $\tau \times \sigma$. Assume the clusters are partitioned as $\tau = [\tau_1, \tau_2]$ and $\sigma = [\sigma_1, \sigma_2]$. Then the ordering of the child block clusters are $\tau_1 \times \sigma_1, \tau_1 \times \sigma_2, \tau_2 \times \sigma_1, \tau_2 \times \sigma_2$.

Build the map from the global DoF indices to the local row indices of the current $\mathcal{H}$-\/matrix node, if necessary.

Build the map from the global DoF indices to the local column indices of the current $\mathcal{H}$-\/matrix node, if necessary.

When the current $\mathcal{H}$-\/matrix block belongs to the far field set, perform the pairwise matrix agglomeration of rank-\/k submatrices or full submatrices, which has been implemented into the constructor of {\ttfamily \hyperlink{classRkMatrix}{Rk\+Matrix}}.

Build the map from the global DoF indices to the local row indices of the current $\mathcal{H}$-\/matrix node, if necessary.

Build the map from the global DoF indices to the local column indices of the current $\mathcal{H}$-\/matrix node, if necessary.

If the children of the current $\mathcal{H}$-\/matrix block are rank-\/k matrices, perform the pairwise rank-\/k matrix agglomeration directly.

If the children of the current $\mathcal{H}$-\/matrix block are full matrices, firstly convert all of them into rank-\/k matrices, then perform the pairwise rank-\/k matrix agglomeration.

Other cases are invalid.

If the children of the current $\mathcal{H}$-\/matrix block are rank-\/k matrices, perform the pairwise rank-\/k matrix agglomeration directly.

If the children of the current $\mathcal{H}$-\/matrix block are full matrices, firstly convert all of them into rank-\/k matrices, then perform the pairwise rank-\/k matrix agglomeration.

Other cases are invalid.

If the children of the current $\mathcal{H}$-\/matrix block are rank-\/k matrices, perform the pairwise rank-\/k matrix agglomeration directly.

If the children of the current $\mathcal{H}$-\/matrix block are full matrices, firstly convert all of them into rank-\/k matrices, then perform the pairwise rank-\/k matrix agglomeration.

Other cases are invalid.

Visualize the partition structure if a not-\/null pointer to the root $\mathcal{H}$-\/matrix node and a a not-\/null pointer to a {\ttfamily calling\+\_\+counter} are provided.


\end{DoxyDescription}

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, Full\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.



Referenced by main().

\mbox{\Hypertarget{hmatrix_8h_af4b3e4f5b78b4b6a9885325225eba0a1}\label{hmatrix_8h_af4b3e4f5b78b4b6a9885325225eba0a1}} 
\index{hmatrix.\+h@{hmatrix.\+h}!copy\+\_\+hmatrix@{copy\+\_\+hmatrix}}
\index{copy\+\_\+hmatrix@{copy\+\_\+hmatrix}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{copy\+\_\+hmatrix()}{copy\_hmatrix()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void copy\+\_\+hmatrix (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{hmat\+\_\+dst,  }\item[{const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{hmat\+\_\+src }\end{DoxyParamCaption})}

Recursively copy an $\mathcal{H}$-\/matrix into the target matrix. 
\begin{DoxyParams}{Parameters}
{\em M\+\_\+dst} & \\
\hline
{\em M\+\_\+src} & \\
\hline
\end{DoxyParams}
Copy the current $\mathcal{H}$-\/matrix node.

Recursively copy child $\mathcal{H}$-\/matrix nodes.

Create a corresponding child $\mathcal{H}$-\/matrix node on the heap and push it back into the {\ttfamily submatrices} list of the current $\mathcal{H}$-\/matrix node.

References copy\+\_\+hmatrix\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::parent, and H\+Matrix$<$ spacedim, Number $>$\+::submatrices.

\mbox{\Hypertarget{hmatrix_8h_a1eeb0a11d6f43231a21267b2b45fefb2}\label{hmatrix_8h_a1eeb0a11d6f43231a21267b2b45fefb2}} 
\index{hmatrix.\+h@{hmatrix.\+h}!copy\+\_\+hmatrix\+\_\+node@{copy\+\_\+hmatrix\+\_\+node}}
\index{copy\+\_\+hmatrix\+\_\+node@{copy\+\_\+hmatrix\+\_\+node}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{copy\+\_\+hmatrix\+\_\+node()}{copy\_hmatrix\_node()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void copy\+\_\+hmatrix\+\_\+node (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{hmat\+\_\+dst,  }\item[{const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{hmat\+\_\+src }\end{DoxyParamCaption})}

Deep copy an $\mathcal{H}$-\/matrix node into the target node, i.\+e. the copy is limited within the current node without recursion into its descendants. This function will be called by {\ttfamily copy\+\_\+hmatrix}.

N.\+B. Do not copy the list {\ttfamily submatrices} from the source submatrix, because newly created child matrices will be pushed back into this list.

Do not copy the list {\ttfamily leaf\+\_\+set}. After the whole $\mathcal{H}$-\/matrix hierarchy has been constructed, the leaf set will be built in the constructor.

Do not copy the working data\+: {\ttfamily Sigma\+\_\+P}, {\ttfamily Sigma\+\_\+F}, {\ttfamily Sigma\+\_\+R} and {\ttfamily Tind}.


\begin{DoxyParams}{Parameters}
{\em hmat\+\_\+dst} & \\
\hline
{\em hmat\+\_\+src} & \\
\hline
\end{DoxyParams}
Copy the rank-\/k matrix in the source submatrix if it is not {\ttfamily N\+U\+LL}.

Copy the full matrix in the source submatrix if it is not {\ttfamily N\+U\+LL}.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrix\+\_\+index, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by copy\+\_\+hmatrix().

\mbox{\Hypertarget{hmatrix_8h_a3e61ba5438c4cf0337664ec4b8562873}\label{hmatrix_8h_a3e61ba5438c4cf0337664ec4b8562873}} 
\index{hmatrix.\+h@{hmatrix.\+h}!copy\+\_\+hmatrix\+\_\+node@{copy\+\_\+hmatrix\+\_\+node}}
\index{copy\+\_\+hmatrix\+\_\+node@{copy\+\_\+hmatrix\+\_\+node}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{copy\+\_\+hmatrix\+\_\+node()}{copy\_hmatrix\_node()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void copy\+\_\+hmatrix\+\_\+node (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{hmat\+\_\+dst,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&\&}]{hmat\+\_\+src }\end{DoxyParamCaption})}

Shallow copy an $\mathcal{H}$-\/matrix node into the target node, i.\+e. the copy is limited within the current node without recursion into its descendants. 
\begin{DoxyParams}{Parameters}
{\em hmat\+\_\+dst} & \\
\hline
{\em hmat\+\_\+src} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, H\+Matrix$<$ spacedim, Number $>$\+::leaf\+\_\+set, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::parent, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+F, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+P, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+R, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::submatrix\+\_\+index, H\+Matrix$<$ spacedim, Number $>$\+::\+Tind, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{hmatrix_8h_a37b25e6262a25b27f374cab704407437}\label{hmatrix_8h_a37b25e6262a25b27f374cab704407437}} 
\index{hmatrix.\+h@{hmatrix.\+h}!f\+\_\+h\+\_\+mmult@{f\+\_\+h\+\_\+mmult}}
\index{f\+\_\+h\+\_\+mmult@{f\+\_\+h\+\_\+mmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{f\+\_\+h\+\_\+mmult()}{f\_h\_mmult()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void f\+\_\+h\+\_\+mmult (\begin{DoxyParamCaption}\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{\hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Multiplication of a full matrix and a $\mathcal{H}$-\/matrix. A full matrix is returned in {\ttfamily M}. 
\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Build the map from global DoF indices to local matrix indices if necessary.

References build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext$<$ Number $>$\+::fill\+\_\+row(), L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext$<$ Number $>$\+::get\+\_\+row(), H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, and H\+Matrix$<$ spacedim, Number $>$\+::\+Tvmult().



Referenced by f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving(), and main().

\mbox{\Hypertarget{hmatrix_8h_a34a2ebfa11a73c83d768089617e308d8}\label{hmatrix_8h_a34a2ebfa11a73c83d768089617e308d8}} 
\index{hmatrix.\+h@{hmatrix.\+h}!f\+\_\+h\+\_\+mmult@{f\+\_\+h\+\_\+mmult}}
\index{f\+\_\+h\+\_\+mmult@{f\+\_\+h\+\_\+mmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{f\+\_\+h\+\_\+mmult()}{f\_h\_mmult()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void f\+\_\+h\+\_\+mmult (\begin{DoxyParamCaption}\item[{const Number}]{alpha,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{\hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Multiplication of a full matrix and a $\mathcal{H}$-\/matrix and the result is scaled by a factor. A full matrix is returned in {\ttfamily M}.


\begin{DoxyParams}{Parameters}
{\em alpha} & \\
\hline
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Build the map from global DoF indices to local matrix indices if necessary.

{\bfseries Since the following {\ttfamily Tvmult} will compute $y = y + M^T x$, {\ttfamily result\+\_\+vect} should be reset to zero beforehand.}

References build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext$<$ Number $>$\+::fill\+\_\+row(), L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext$<$ Number $>$\+::get\+\_\+row(), H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, and H\+Matrix$<$ spacedim, Number $>$\+::\+Tvmult().

\mbox{\Hypertarget{hmatrix_8h_a2138cf7f25917862b5353a6ceee9ea11}\label{hmatrix_8h_a2138cf7f25917862b5353a6ceee9ea11}} 
\index{hmatrix.\+h@{hmatrix.\+h}!f\+\_\+h\+\_\+mmult@{f\+\_\+h\+\_\+mmult}}
\index{f\+\_\+h\+\_\+mmult@{f\+\_\+h\+\_\+mmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{f\+\_\+h\+\_\+mmult()}{f\_h\_mmult()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void f\+\_\+h\+\_\+mmult (\begin{DoxyParamCaption}\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Multiplication of a full matrix and a $\mathcal{H}$-\/matrix. A rank-\/k matrix is returned in {\ttfamily M}.


\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
{\bfseries The creation of the rank-\/k matrix {\ttfamily M1\+\_\+rk} from {\ttfamily M1} will modify {\ttfamily M1} internally. Hence, we make a copy of {\ttfamily M1} here.}

References H\+Matrix$<$ spacedim, Number $>$\+::m, and rk\+\_\+h\+\_\+mmult().

\mbox{\Hypertarget{hmatrix_8h_a951849a7b68e93f385c9e1fa0c4c251d}\label{hmatrix_8h_a951849a7b68e93f385c9e1fa0c4c251d}} 
\index{hmatrix.\+h@{hmatrix.\+h}!f\+\_\+h\+\_\+mmult@{f\+\_\+h\+\_\+mmult}}
\index{f\+\_\+h\+\_\+mmult@{f\+\_\+h\+\_\+mmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{f\+\_\+h\+\_\+mmult()}{f\_h\_mmult()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void f\+\_\+h\+\_\+mmult (\begin{DoxyParamCaption}\item[{const Number}]{alpha,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Multiplication of a full matrix and a $\mathcal{H}$-\/matrix and the result is scaled by a factor. A rank-\/k matrix is returned in {\ttfamily M}.


\begin{DoxyParams}{Parameters}
{\em alpha} & \\
\hline
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
{\bfseries The creation of the rank-\/k matrix {\ttfamily M1\+\_\+rk} from {\ttfamily M1} will modify {\ttfamily M1} internally. Hence, we make a copy of {\ttfamily M1} here.}

References H\+Matrix$<$ spacedim, Number $>$\+::m, and rk\+\_\+h\+\_\+mmult().

\mbox{\Hypertarget{hmatrix_8h_a242e7e3da010e972783e20326ae15a36}\label{hmatrix_8h_a242e7e3da010e972783e20326ae15a36}} 
\index{hmatrix.\+h@{hmatrix.\+h}!f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult@{f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult}}
\index{f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult@{f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult()}{f\_h\_mmult\_for\_h\_h\_mmult()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult (\begin{DoxyParamCaption}\item[{const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{M2,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{M,  }\item[{bool}]{is\+\_\+\+M1\+M2\+\_\+last\+\_\+in\+\_\+\+M\+\_\+\+Sigma\+\_\+P = {\ttfamily true} }\end{DoxyParamCaption})}

Multiplication of two $\mathcal{H}$-\/matrices, where the first one is of {\ttfamily Full\+Matrix\+Type}. An $\mathcal{H}$-\/matrix is returned in {\ttfamily M}, which is either of {\ttfamily Full\+Matrix\+Type} or {\ttfamily Rk\+Matrix\+Type}. 
\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
{\em is\+\_\+\+M1\+M2\+\_\+last\+\_\+in\+\_\+\+M\+\_\+\+Sigma\+\_\+P} & \\
\hline
\end{DoxyParams}
Full matrix is returned.

Rank-\/k matrix is returned.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, f\+\_\+h\+\_\+mmult(), H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list(), Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+F, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+P, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+R, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{hmatrix_8h_acf140473681cc5ea3ab57fafdc986357}\label{hmatrix_8h_acf140473681cc5ea3ab57fafdc986357}} 
\index{hmatrix.\+h@{hmatrix.\+h}!f\+\_\+h\+\_\+m\+Tmult@{f\+\_\+h\+\_\+m\+Tmult}}
\index{f\+\_\+h\+\_\+m\+Tmult@{f\+\_\+h\+\_\+m\+Tmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{f\+\_\+h\+\_\+m\+Tmult()}{f\_h\_mTmult()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void f\+\_\+h\+\_\+m\+Tmult (\begin{DoxyParamCaption}\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{\hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Multiplication of a full matrix and a $\mathcal{H}$-\/matrix with the second operand being transposed. A full matrix is returned in {\ttfamily M}.


\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Build the map from global DoF indices to local matrix indices if necessary.

References build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext$<$ Number $>$\+::fill\+\_\+row(), L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext$<$ Number $>$\+::get\+\_\+row(), H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, and H\+Matrix$<$ spacedim, Number $>$\+::vmult().



Referenced by h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving().

\mbox{\Hypertarget{hmatrix_8h_a8d9fbb4b9a0e5e87096e8d8f833cbb76}\label{hmatrix_8h_a8d9fbb4b9a0e5e87096e8d8f833cbb76}} 
\index{hmatrix.\+h@{hmatrix.\+h}!f\+\_\+h\+\_\+m\+Tmult@{f\+\_\+h\+\_\+m\+Tmult}}
\index{f\+\_\+h\+\_\+m\+Tmult@{f\+\_\+h\+\_\+m\+Tmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{f\+\_\+h\+\_\+m\+Tmult()}{f\_h\_mTmult()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void f\+\_\+h\+\_\+m\+Tmult (\begin{DoxyParamCaption}\item[{const Number}]{alpha,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{\hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Multiplication of a full matrix and a $\mathcal{H}$-\/matrix with the second operand being transposed, the result of which will be scaled by a factor. A full matrix is returned in {\ttfamily M}.


\begin{DoxyParams}{Parameters}
{\em alpha} & \\
\hline
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Build the map from global DoF indices to local matrix indices if necessary.

References build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext$<$ Number $>$\+::fill\+\_\+row(), L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext$<$ Number $>$\+::get\+\_\+row(), H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, and H\+Matrix$<$ spacedim, Number $>$\+::vmult().

\mbox{\Hypertarget{hmatrix_8h_a942dd3cabbf54bd4e6bc5a922746b257}\label{hmatrix_8h_a942dd3cabbf54bd4e6bc5a922746b257}} 
\index{hmatrix.\+h@{hmatrix.\+h}!f\+\_\+h\+\_\+m\+Tmult@{f\+\_\+h\+\_\+m\+Tmult}}
\index{f\+\_\+h\+\_\+m\+Tmult@{f\+\_\+h\+\_\+m\+Tmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{f\+\_\+h\+\_\+m\+Tmult()}{f\_h\_mTmult()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void f\+\_\+h\+\_\+m\+Tmult (\begin{DoxyParamCaption}\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Multiplication of a full matrix and a $\mathcal{H}$-\/matrix with the second operand being transposed. A rank-\/k matrix is returned in {\ttfamily M}.


\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
{\bfseries The creation of the rank-\/k matrix {\ttfamily M1\+\_\+rk} from {\ttfamily M1} will modify {\ttfamily M1} internally. Hence, we make a copy of {\ttfamily M1} here.}

References H\+Matrix$<$ spacedim, Number $>$\+::n, and rk\+\_\+h\+\_\+m\+Tmult().

\mbox{\Hypertarget{hmatrix_8h_ae7e6b54a178a7a0149f5ad6336e4e49c}\label{hmatrix_8h_ae7e6b54a178a7a0149f5ad6336e4e49c}} 
\index{hmatrix.\+h@{hmatrix.\+h}!f\+\_\+h\+\_\+m\+Tmult@{f\+\_\+h\+\_\+m\+Tmult}}
\index{f\+\_\+h\+\_\+m\+Tmult@{f\+\_\+h\+\_\+m\+Tmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{f\+\_\+h\+\_\+m\+Tmult()}{f\_h\_mTmult()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void f\+\_\+h\+\_\+m\+Tmult (\begin{DoxyParamCaption}\item[{const Number}]{alpha,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Multiplication of a full matrix and a $\mathcal{H}$-\/matrix with the second operand being transposed. The result will be scaled by a factor. A rank-\/k matrix is returned in {\ttfamily M}.


\begin{DoxyParams}{Parameters}
{\em alpha} & \\
\hline
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
{\bfseries The creation of the rank-\/k matrix {\ttfamily M1\+\_\+rk} from {\ttfamily M1} will modify {\ttfamily M1} internally. Hence, we make a copy of {\ttfamily M1} here.}

References H\+Matrix$<$ spacedim, Number $>$\+::n, and rk\+\_\+h\+\_\+m\+Tmult().

\mbox{\Hypertarget{hmatrix_8h_ae495fd6b480f203cf797e7e86e996313}\label{hmatrix_8h_ae495fd6b480f203cf797e7e86e996313}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+f\+\_\+mmult@{h\+\_\+f\+\_\+mmult}}
\index{h\+\_\+f\+\_\+mmult@{h\+\_\+f\+\_\+mmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+f\+\_\+mmult()}{h\_f\_mmult()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void h\+\_\+f\+\_\+mmult (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M2,  }\item[{\hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes, where the second one is a full matrix and the result is also represented as a full matrix because the associated block cluster node $\tau\times\rho$ is small.


\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Build the map from global DoF indices to local matrix indices if necessary.

References build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext$<$ Number $>$\+::fill\+\_\+col(), L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext$<$ Number $>$\+::get\+\_\+column(), H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, and H\+Matrix$<$ spacedim, Number $>$\+::vmult().



Referenced by h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving(), and main().

\mbox{\Hypertarget{hmatrix_8h_aceb4579cb7d6a65805c548aa9c3f97b9}\label{hmatrix_8h_aceb4579cb7d6a65805c548aa9c3f97b9}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+f\+\_\+mmult@{h\+\_\+f\+\_\+mmult}}
\index{h\+\_\+f\+\_\+mmult@{h\+\_\+f\+\_\+mmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+f\+\_\+mmult()}{h\_f\_mmult()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void h\+\_\+f\+\_\+mmult (\begin{DoxyParamCaption}\item[{const Number}]{alpha,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M2,  }\item[{\hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes with the result scaled by a factor. The second operand is a full matrix and the result is also represented as a full matrix because the associated block cluster node $\tau\times\rho$ is small.


\begin{DoxyParams}{Parameters}
{\em alpha} & \\
\hline
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Build the map from global DoF indices to local matrix indices if necessary.

References build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext$<$ Number $>$\+::fill\+\_\+col(), L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext$<$ Number $>$\+::get\+\_\+column(), H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, and H\+Matrix$<$ spacedim, Number $>$\+::vmult().

\mbox{\Hypertarget{hmatrix_8h_a723281b6cf62859890ec5ee49555c908}\label{hmatrix_8h_a723281b6cf62859890ec5ee49555c908}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+f\+\_\+mmult@{h\+\_\+f\+\_\+mmult}}
\index{h\+\_\+f\+\_\+mmult@{h\+\_\+f\+\_\+mmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+f\+\_\+mmult()}{h\_f\_mmult()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void h\+\_\+f\+\_\+mmult (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M2,  }\item[{\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes, where the second one is a full matrix and the result is represented as a rank-\/k matrix because the associated block cluster is large.

The second matrix {\ttfamily M2} will be firstly converted to a rank-\/k matrix. Then its multiplication with {\ttfamily M1} will be carried by calling {\ttfamily h\+\_\+rk\+\_\+mmult}. Since the conversion from a full matrix to a rank-\/k matrix will modify the original data, a copy of {\ttfamily M2} will be created. 
\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Create a local copy of the full matrix {\ttfamily M2}.

Convert the full matrix {\ttfamily M2} to a rank-\/k matrix.

References h\+\_\+rk\+\_\+mmult(), and H\+Matrix$<$ spacedim, Number $>$\+::n.

\mbox{\Hypertarget{hmatrix_8h_a398869486c36312aefc9c22f395fc494}\label{hmatrix_8h_a398869486c36312aefc9c22f395fc494}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+f\+\_\+mmult@{h\+\_\+f\+\_\+mmult}}
\index{h\+\_\+f\+\_\+mmult@{h\+\_\+f\+\_\+mmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+f\+\_\+mmult()}{h\_f\_mmult()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void h\+\_\+f\+\_\+mmult (\begin{DoxyParamCaption}\item[{const Number}]{alpha,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M2,  }\item[{\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes with the result scaled by a factor. The second operand is a full matrix and the result is represented as a rank-\/k matrix because the associated block cluster is large.

The second matrix {\ttfamily M2} will be firstly converted to a rank-\/k matrix. Then its multiplication with {\ttfamily M1} will be carried by calling {\ttfamily h\+\_\+rk\+\_\+mmult}. Since the conversion from a full matrix to a rank-\/k matrix will modify the original data, a copy of {\ttfamily M2} will be created.


\begin{DoxyParams}{Parameters}
{\em alpha} & \\
\hline
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Create a local copy of the full matrix {\ttfamily M2}.

Convert the full matrix {\ttfamily M2} to a rank-\/k matrix.

References h\+\_\+rk\+\_\+mmult(), and H\+Matrix$<$ spacedim, Number $>$\+::n.

\mbox{\Hypertarget{hmatrix_8h_a374070dba133f2152e9c44ce10947f20}\label{hmatrix_8h_a374070dba133f2152e9c44ce10947f20}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult@{h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult}}
\index{h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult@{h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult()}{h\_f\_mmult\_for\_h\_h\_mmult()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{M1,  }\item[{const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{M2,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{M,  }\item[{bool}]{is\+\_\+\+M1\+M2\+\_\+last\+\_\+in\+\_\+\+M\+\_\+\+Sigma\+\_\+P = {\ttfamily true} }\end{DoxyParamCaption})}

Multiplication of two $\mathcal{H}$-\/matrices, where the second one is of {\ttfamily Full\+Matrix\+Type}. An $\mathcal{H}$-\/matrix is returned in {\ttfamily M}, which is either of {\ttfamily Full\+Matrix\+Type} or {\ttfamily Rk\+Matrix\+Type}. 
\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
{\em is\+\_\+\+M1\+M2\+\_\+last\+\_\+in\+\_\+\+M\+\_\+\+Sigma\+\_\+P} & \\
\hline
\end{DoxyParams}
Full matrix is returned.

Rank-\/k matrix is returned.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, h\+\_\+f\+\_\+mmult(), H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list(), Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+F, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+P, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+R, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{hmatrix_8h_a8c5bc5080b3c7e065e70fdba10faae55}\label{hmatrix_8h_a8c5bc5080b3c7e065e70fdba10faae55}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+f\+\_\+m\+Tmult@{h\+\_\+f\+\_\+m\+Tmult}}
\index{h\+\_\+f\+\_\+m\+Tmult@{h\+\_\+f\+\_\+m\+Tmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+f\+\_\+m\+Tmult()}{h\_f\_mTmult()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void h\+\_\+f\+\_\+m\+Tmult (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M2,  }\item[{\hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes with the second operand being transposed, where the second one is a full matrix and the result is also represented as a full matrix because the associated block cluster node $\tau\times\rho$ is small.


\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Build the map from global DoF indices to local matrix indices if necessary.

References build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext$<$ Number $>$\+::fill\+\_\+col(), L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext$<$ Number $>$\+::get\+\_\+row(), H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, and H\+Matrix$<$ spacedim, Number $>$\+::vmult().



Referenced by h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving().

\mbox{\Hypertarget{hmatrix_8h_a3a2ffe1ccde0ac2a90b63cfdd92a5235}\label{hmatrix_8h_a3a2ffe1ccde0ac2a90b63cfdd92a5235}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+f\+\_\+m\+Tmult@{h\+\_\+f\+\_\+m\+Tmult}}
\index{h\+\_\+f\+\_\+m\+Tmult@{h\+\_\+f\+\_\+m\+Tmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+f\+\_\+m\+Tmult()}{h\_f\_mTmult()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void h\+\_\+f\+\_\+m\+Tmult (\begin{DoxyParamCaption}\item[{const Number}]{alpha,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M2,  }\item[{\hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes with the second operand being transposed, where the second one is a full matrix and the result is also represented as a full matrix because the associated block cluster node $\tau\times\rho$ is small. The result will be scaled by a factor.


\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Build the map from global DoF indices to local matrix indices if necessary.

References build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext$<$ Number $>$\+::fill\+\_\+col(), L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext$<$ Number $>$\+::get\+\_\+row(), H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, and H\+Matrix$<$ spacedim, Number $>$\+::vmult().

\mbox{\Hypertarget{hmatrix_8h_ac9f0b303f7933e220bb976db96536ef9}\label{hmatrix_8h_ac9f0b303f7933e220bb976db96536ef9}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+f\+\_\+m\+Tmult@{h\+\_\+f\+\_\+m\+Tmult}}
\index{h\+\_\+f\+\_\+m\+Tmult@{h\+\_\+f\+\_\+m\+Tmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+f\+\_\+m\+Tmult()}{h\_f\_mTmult()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void h\+\_\+f\+\_\+m\+Tmult (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M2,  }\item[{\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes with the second operand being transposed, where the second one is a full matrix and the result is represented as a rank-\/k matrix because the associated block cluster is large.

The second matrix {\ttfamily M2} will be firstly converted to a rank-\/k matrix. Then its multiplication with {\ttfamily M1} will be carried by calling {\ttfamily h\+\_\+rk\+\_\+m\+Tmult}. Since the conversion from a full matrix to a rank-\/k matrix will modify the original data, a copy of {\ttfamily M2} will be created.


\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Create a local copy of the full matrix {\ttfamily M2}.

Convert the full matrix {\ttfamily M2} to a rank-\/k matrix.

References h\+\_\+rk\+\_\+m\+Tmult(), and H\+Matrix$<$ spacedim, Number $>$\+::n.

\mbox{\Hypertarget{hmatrix_8h_ab4df594f8278dbd00a4d098f6e591f68}\label{hmatrix_8h_ab4df594f8278dbd00a4d098f6e591f68}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+f\+\_\+m\+Tmult@{h\+\_\+f\+\_\+m\+Tmult}}
\index{h\+\_\+f\+\_\+m\+Tmult@{h\+\_\+f\+\_\+m\+Tmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+f\+\_\+m\+Tmult()}{h\_f\_mTmult()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void h\+\_\+f\+\_\+m\+Tmult (\begin{DoxyParamCaption}\item[{const Number}]{alpha,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M2,  }\item[{\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes with the second operand being transposed, where the second one is a full matrix and the result is represented as a rank-\/k matrix because the associated block cluster is large. The result will be scaled by a factor.

The second matrix {\ttfamily M2} will be firstly converted to a rank-\/k matrix. Then its multiplication with {\ttfamily M1} will be carried by calling {\ttfamily h\+\_\+rk\+\_\+m\+Tmult}. Since the conversion from a full matrix to a rank-\/k matrix will modify the original data, a copy of {\ttfamily M2} will be created.


\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Create a local copy of the full matrix {\ttfamily M2}.

Convert the full matrix {\ttfamily M2} to a rank-\/k matrix.

References h\+\_\+rk\+\_\+m\+Tmult(), and H\+Matrix$<$ spacedim, Number $>$\+::n.

\mbox{\Hypertarget{hmatrix_8h_a2b842125056627d38c5aee3a077e596c}\label{hmatrix_8h_a2b842125056627d38c5aee3a077e596c}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node@{h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node}}
\index{h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node@{h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node()}{h\_h\_mmult\_from\_leaf\_node()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M0,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

$\mathcal{H}$-\/matrix-\/ $\mathcal{H}$-\/matrix multiplication when the product matrix belongs to the leaf set of the target block cluster tree.

This function implements the recursive {\ttfamily M\+MR} algorithm in (7.\+26) in Hackbusch\textquotesingle{}s $\mathcal{H}$-\/matrix book.


\begin{DoxyParams}{Parameters}
{\em M0} & The initial product matrix on the block cluster node $\tau_0\times\rho_0$.\\
\hline
{\em M} & The current product matrix $M$ on the block cluster node $\tau\times\rho$, which will assembles the contribution from $M_1 \cdot M_2$. For the first call of this function, {\ttfamily M} is the same as {\ttfamily M0}. \\
\hline
{\em M1} & The first operand of the multiplication, which is built upon the block cluster node $\tau\times\sigma$. \\
\hline
{\em M2} & The second operand of the multiplication, which is built upon the block cluster node $\sigma\times\rho$. \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}
Create a block cluster node $\tau\times\rho$ for the current local product matrix {\ttfamily Z}. Since this block cluster node will not be connected with other block cluster nodes in a block cluster tree, it has neither parent nor children and its level is set to zero.

Set the {\ttfamily is\+\_\+near\+\_\+field} flag of the block cluster node for the current local product matrix {\ttfamily Z} according to the matrix type of the initial leaf node matrix {\ttfamily M0}, i.\+e. it inherits the {\ttfamily is\+\_\+near\+\_\+field} flag of the block cluster node for {\ttfamily M0}.

Create the local $\mathcal{H}$-\/matrix {\ttfamily Z} associated with the current block cluster node. During its initialization, memory will be allocated for {\ttfamily Z} depending on its matrix type.

When either operand {\ttfamily M1} or {\ttfamily M2} is a leaf node, directly evaluation of their multiplication can be performed.

{\bfseries When we perform submatrix multiplication, we use a higher specified rank, since the results will be assembled into the larger matrix {\ttfamily Z} via pairwise formatted addition, during which the actual matrix rank may increase.}

Assemble the local matrix {\ttfamily Z} to the product matrix {\ttfamily M}.

When the original matrix {\ttfamily M0} belongs to the near field, assemble the full matrix stored in {\ttfamily Z} directly into {\ttfamily M}.

When the original matrix {\ttfamily M0} does not belong to the near field, assemble the rank-\/k matrix stored in {\ttfamily Z} into {\ttfamily M} by first embedding then formatted addition, which has been implemented in the member function {\ttfamily assemble\+\_\+from\+\_\+rkmatrix}.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node.



Referenced by h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving().

\mbox{\Hypertarget{hmatrix_8h_a7cb1a4bfe1f72bde6920f716eb9314a0}\label{hmatrix_8h_a7cb1a4bfe1f72bde6920f716eb9314a0}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node@{h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node}}
\index{h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node@{h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node()}{h\_h\_mmult\_from\_leaf\_node()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M0,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M,  }\item[{const Number}]{alpha,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

$\mathcal{H}$-\/matrix-\/ $\mathcal{H}$-\/matrix multiplication with the result scaled by a factor, when the product matrix belongs to the leaf set of the target block cluster tree.

This function implements the recursive {\ttfamily M\+MR} algorithm in (7.\+26) in Hackbusch\textquotesingle{}s $\mathcal{H}$-\/matrix book.


\begin{DoxyParams}{Parameters}
{\em M0} & The initial product matrix on the block cluster node $\tau_0\times\rho_0$.\\
\hline
{\em M} & The current product matrix $M$ on the block cluster node $\tau\times\rho$, which will assembles the contribution from $M_1 \cdot M_2$. For the first call of this function, {\ttfamily M} is the same as {\ttfamily M0}. \\
\hline
{\em M1} & The first operand of the multiplication, which is built upon the block cluster node $\tau\times\sigma$. \\
\hline
{\em M2} & The second operand of the multiplication, which is built upon the block cluster node $\sigma\times\rho$. \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}
Create a block cluster node $\tau\times\rho$ for the current local product matrix {\ttfamily Z}. Since this block cluster node will not be connected with other block cluster nodes in a block cluster tree, it has neither parent nor children and its level is set to zero.

Set the {\ttfamily is\+\_\+near\+\_\+field} flag of the block cluster node for the current local product matrix {\ttfamily Z} according to the matrix type of the initial leaf node matrix {\ttfamily M0}, i.\+e. it inherits the {\ttfamily is\+\_\+near\+\_\+field} flag of the block cluster node for {\ttfamily M0}.

Create the local $\mathcal{H}$-\/matrix {\ttfamily Z} associated with the current block cluster node. During its initialization, memory will be allocated for {\ttfamily Z} depending on its matrix type.

When either operand {\ttfamily M1} or {\ttfamily M2} is a leaf node, directly evaluation of their multiplication can be performed.

{\bfseries When we perform submatrix multiplication, we use a higher specified rank, since the results will be assembled into the larger matrix {\ttfamily Z} via pairwise formatted addition, during which the actual matrix rank may increase.}

Assemble the local matrix {\ttfamily Z} to the product matrix {\ttfamily M}.

When the original matrix {\ttfamily M0} belongs to the near field, assemble the full matrix stored in {\ttfamily Z} directly into {\ttfamily M}.

When the original matrix {\ttfamily M0} does not belong to the near field, assemble the rank-\/k matrix stored in {\ttfamily Z} into {\ttfamily M} by first embedding then formatted addition, which has been implemented in the member function {\ttfamily assemble\+\_\+from\+\_\+rkmatrix}.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node.

\mbox{\Hypertarget{hmatrix_8h_a6534ff122b0835d0313d94264794b601}\label{hmatrix_8h_a6534ff122b0835d0313d94264794b601}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving@{h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving}}
\index{h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving@{h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving()}{h\_h\_mmult\_level\_conserving()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M0,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

Multiplication of two level-\/conserving $\mathcal{H}$-\/matrices and the result will be added to the target matrix {\ttfamily M}, i.\+e. $M = M + M_1 M_2$.


\begin{DoxyDescription}
\item[Note ]It is required that an empty result matrix {\ttfamily M} should be created first with respect to a block cluster tree. 
\end{DoxyDescription}


\begin{DoxyParams}{Parameters}
{\em M0} & \\
\hline
{\em M} & \\
\hline
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::add(), H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, f\+\_\+h\+\_\+mmult(), H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, h\+\_\+f\+\_\+mmult(), h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node(), h\+\_\+rk\+\_\+mmult(), rk\+\_\+h\+\_\+mmult(), H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving(), and main().

\mbox{\Hypertarget{hmatrix_8h_a0ed620dee37feefb517062f960c9810e}\label{hmatrix_8h_a0ed620dee37feefb517062f960c9810e}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving@{h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving}}
\index{h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving@{h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving()}{h\_h\_mmult\_level\_conserving()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M0,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M,  }\item[{const Number}]{alpha,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

Multiplication of two level-\/conserving $\mathcal{H}$-\/matrices with a factor multiplied to the matrix product and the result will be added to the target matrix {\ttfamily M}, i.\+e. $M = M + \alpha \cdot M_1 M_2$.


\begin{DoxyDescription}
\item[Note ]It is required that an empty result matrix {\ttfamily M} should be created first with respect to a block cluster tree. 
\end{DoxyDescription}


\begin{DoxyParams}{Parameters}
{\em M0} & \\
\hline
{\em M} & \\
\hline
{\em alpha} & \\
\hline
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::add(), H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, f\+\_\+h\+\_\+mmult(), H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, h\+\_\+f\+\_\+mmult(), h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node(), h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving(), h\+\_\+rk\+\_\+mmult(), rk\+\_\+h\+\_\+mmult(), H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{hmatrix_8h_aad08ee9bd389abe7b7b76fd0f2cb292e}\label{hmatrix_8h_aad08ee9bd389abe7b7b76fd0f2cb292e}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+h\+\_\+mmult\+\_\+phase1\+\_\+recursion@{h\+\_\+h\+\_\+mmult\+\_\+phase1\+\_\+recursion}}
\index{h\+\_\+h\+\_\+mmult\+\_\+phase1\+\_\+recursion@{h\+\_\+h\+\_\+mmult\+\_\+phase1\+\_\+recursion}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+h\+\_\+mmult\+\_\+phase1\+\_\+recursion()}{h\_h\_mmult\_phase1\_recursion()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void h\+\_\+h\+\_\+mmult\+\_\+phase1\+\_\+recursion (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{M,  }\item[{\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{Tind }\end{DoxyParamCaption})}

There are still multiplication subtasks stored in {\ttfamily Sigma\+\_\+P} to be handled recursively.

After previous reduction and splitting, the matrix multiplication for the current $\mathcal{H}$-\/matrix node should be replaced by the multiplication subtasks for submatrices. These subtasks are recorded as $\mathcal{H}$-\/matrix node pairs which are stored in $\Sigma_b^P$ of the submatrices.

References H\+Matrix$<$ spacedim, Number $>$\+::determine\+\_\+mm\+\_\+split\+\_\+mode\+\_\+from\+\_\+\+Sigma\+\_\+\+P(), H\+Matrix$<$ spacedim, Number $>$\+::h\+\_\+h\+\_\+mmult\+\_\+reduction(), and H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+P.

\mbox{\Hypertarget{hmatrix_8h_a199fb48349b9486624a3c55c5aece3f4}\label{hmatrix_8h_a199fb48349b9486624a3c55c5aece3f4}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+h\+\_\+mmult\+\_\+phase2@{h\+\_\+h\+\_\+mmult\+\_\+phase2}}
\index{h\+\_\+h\+\_\+mmult\+\_\+phase2@{h\+\_\+h\+\_\+mmult\+\_\+phase2}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+h\+\_\+mmult\+\_\+phase2()}{h\_h\_mmult\_phase2()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void h\+\_\+h\+\_\+mmult\+\_\+phase2 (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M,  }\item[{\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{target\+\_\+bc\+\_\+tree,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

Collect terms in {\ttfamily Sigma\+\_\+R} and {\ttfamily Sigma\+\_\+F} for the leaf nodes.

Here we make sure that $\mathcal{H}$-\/matrix pairs in the list $\Sigma_b^P$ have all been processed and erased, hence the list should be empty.

Perform pairwise formatted addition for the list of rank-\/k matrices stored in the list $\Sigma_b^R$, the result of which will be assigned to the {\ttfamily rkmatrix} field of the current $\mathcal{H}$-\/matrix leaf node.

Clear the list $\Sigma_b^R$ after adding all of its rank-\/k matrices.

Clear the list $\Sigma_b^F$ after adding all of its full matrices.

{\bfseries Important}\+: Distribute matrices stored in $\Sigma_b^R$ and $\Sigma_b^F$ of each {\bfseries non-\/leaf node} to the leaf nodes which are its descendants.

Convert the calculated product matrix to the specified matrix structure.

References H\+Matrix$<$ spacedim, Number $>$\+::convert\+\_\+between\+\_\+different\+\_\+block\+\_\+cluster\+\_\+trees(), H\+Matrix$<$ spacedim, Number $>$\+::distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::leaf\+\_\+set, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+F, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+P, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+R, H\+Matrix$<$ spacedim, Number $>$\+::\+Tind, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{hmatrix_8h_ab9d49e86d3c8b5596b1b603793818276}\label{hmatrix_8h_ab9d49e86d3c8b5596b1b603793818276}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node@{h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node}}
\index{h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node@{h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node()}{h\_h\_mTmult\_from\_leaf\_node()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M0,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

$\mathcal{H}$-\/matrix-\/ $\mathcal{H}$-\/matrix multiplication with the second operand transposed, when the product matrix belongs to the leaf set of the target block cluster tree.

This function implements the recursive {\ttfamily M\+MR} algorithm in (7.\+26) in Hackbusch\textquotesingle{}s $\mathcal{H}$-\/matrix book.


\begin{DoxyParams}{Parameters}
{\em M0} & The initial product matrix on the block cluster node $\tau_0\times\rho_0$. \\
\hline
{\em M} & The current product matrix $M$ on the block cluster node $\tau\times\rho$, which will assembles the contribution from $M_1 \cdot M_2$. For the first call of this function, {\ttfamily M} is the same as {\ttfamily M0}. \\
\hline
{\em M1} & The first operand of the multiplication, which is built upon the block cluster node $\tau\times\sigma$. \\
\hline
{\em M2} & The second operand of the multiplication, which is built upon the block cluster node $\rho\times\sigma$. \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}
Create a block cluster node $\tau\times\rho$ for the current local product matrix {\ttfamily Z}. Since this block cluster node will not be connected with other block cluster nodes in a block cluster tree, it has neither parent nor children and its level is set to zero.

Set the {\ttfamily is\+\_\+near\+\_\+field} flag of the block cluster node for the current local product matrix {\ttfamily Z} according to the matrix type of the initial leaf node matrix {\ttfamily M0}, i.\+e. it inherits the {\ttfamily is\+\_\+near\+\_\+field} flag of the block cluster node for {\ttfamily M0}.

Create the local $\mathcal{H}$-\/matrix {\ttfamily Z} associated with the current block cluster node. During its initialization, memory will be allocated for {\ttfamily Z} depending on its matrix type.

When either operand {\ttfamily M1} or {\ttfamily M2} is a leaf node, directly evaluation of their multiplication can be performed.

{\bfseries When we perform submatrix multiplication, we use a higher specified rank, since the results will be assembled into the larger matrix {\ttfamily Z} via pairwise formatted addition, during which the actual matrix rank may increase.}

Assemble the local matrix {\ttfamily Z} to the product matrix {\ttfamily M}.

When the original matrix {\ttfamily M0} belongs to the near field, assemble the full matrix stored in {\ttfamily Z} directly into {\ttfamily M}.

When the original matrix {\ttfamily M0} does not belong to the near field, assemble the rank-\/k matrix stored in {\ttfamily Z} into {\ttfamily M} by first embedding then formatted addition, which has been implemented in the member function {\ttfamily assemble\+\_\+from\+\_\+rkmatrix}.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node.



Referenced by h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving().

\mbox{\Hypertarget{hmatrix_8h_a9b8abc06deedda9951406d65af89e42f}\label{hmatrix_8h_a9b8abc06deedda9951406d65af89e42f}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node@{h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node}}
\index{h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node@{h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node()}{h\_h\_mTmult\_from\_leaf\_node()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M0,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M,  }\item[{const Number}]{alpha,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

$\mathcal{H}$-\/matrix-\/ $\mathcal{H}$-\/matrix multiplication with the second operand transposed, when the product matrix belongs to the leaf set of the target block cluster tree.

This function implements the recursive {\ttfamily M\+MR} algorithm in (7.\+26) in Hackbusch\textquotesingle{}s $\mathcal{H}$-\/matrix book.


\begin{DoxyParams}{Parameters}
{\em M0} & The initial product matrix on the block cluster node $\tau_0\times\rho_0$. \\
\hline
{\em M} & The current product matrix $M$ on the block cluster node $\tau\times\rho$, which will assembles the contribution from $M_1 \cdot M_2$. For the first call of this function, {\ttfamily M} is the same as {\ttfamily M0}. \\
\hline
{\em M1} & The first operand of the multiplication, which is built upon the block cluster node $\tau\times\sigma$. \\
\hline
{\em M2} & The second operand of the multiplication, which is built upon the block cluster node $\rho\times\sigma$. \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}
Create a block cluster node $\tau\times\rho$ for the current local product matrix {\ttfamily Z}. Since this block cluster node will not be connected with other block cluster nodes in a block cluster tree, it has neither parent nor children and its level is set to zero.

Set the {\ttfamily is\+\_\+near\+\_\+field} flag of the block cluster node for the current local product matrix {\ttfamily Z} according to the matrix type of the initial leaf node matrix {\ttfamily M0}, i.\+e. it inherits the {\ttfamily is\+\_\+near\+\_\+field} flag of the block cluster node for {\ttfamily M0}.

Create the local $\mathcal{H}$-\/matrix {\ttfamily Z} associated with the current block cluster node. During its initialization, memory will be allocated for {\ttfamily Z} depending on its matrix type.

When either operand {\ttfamily M1} or {\ttfamily M2} is a leaf node, directly evaluation of their multiplication can be performed.

{\bfseries When we perform submatrix multiplication, we use a higher specified rank, since the results will be assembled into the larger matrix {\ttfamily Z} via pairwise formatted addition, during which the actual matrix rank may increase.}

Assemble the local matrix {\ttfamily Z} to the product matrix {\ttfamily M}.

When the original matrix {\ttfamily M0} belongs to the near field, assemble the full matrix stored in {\ttfamily Z} directly into {\ttfamily M}.

When the original matrix {\ttfamily M0} does not belong to the near field, assemble the rank-\/k matrix stored in {\ttfamily Z} into {\ttfamily M} by first embedding then formatted addition, which has been implemented in the member function {\ttfamily assemble\+\_\+from\+\_\+rkmatrix}.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node.

\mbox{\Hypertarget{hmatrix_8h_a8855023aa4832e4119c6ead1115d4beb}\label{hmatrix_8h_a8855023aa4832e4119c6ead1115d4beb}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving@{h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving}}
\index{h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving@{h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving()}{h\_h\_mTmult\_level\_conserving()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M0,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

Multiplication of two level-\/conserving $\mathcal{H}$-\/matrices with the second operand transposed. The result will be added to the target matrix {\ttfamily M}, i.\+e. $M = M + M_1 M_2^T$.


\begin{DoxyDescription}
\item[Note ]It is required that an empty result matrix {\ttfamily M} should be created first with respect to a block cluster tree. 
\end{DoxyDescription}


\begin{DoxyParams}{Parameters}
{\em M0} & \\
\hline
{\em M} & \\
\hline
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::add(), H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, f\+\_\+h\+\_\+m\+Tmult(), H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, h\+\_\+f\+\_\+m\+Tmult(), h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node(), h\+\_\+rk\+\_\+m\+Tmult(), rk\+\_\+h\+\_\+m\+Tmult(), H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving(), and main().

\mbox{\Hypertarget{hmatrix_8h_a6025a164b80c84f13121a5b6af3fab7b}\label{hmatrix_8h_a6025a164b80c84f13121a5b6af3fab7b}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving@{h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving}}
\index{h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving@{h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving()}{h\_h\_mTmult\_level\_conserving()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M0,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M,  }\item[{const Number}]{alpha,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

Multiplication of two level-\/conserving $\mathcal{H}$-\/matrices with the second operand transposed. The result will multiplied by a factor and then added to the target matrix {\ttfamily M}, i.\+e. $M = M + \alpha \cdot M_1 M_2^T$.


\begin{DoxyDescription}
\item[Note ]It is required that an empty result matrix {\ttfamily M} should be created first with respect to a block cluster tree. 
\end{DoxyDescription}


\begin{DoxyParams}{Parameters}
{\em M0} & \\
\hline
{\em M} & \\
\hline
{\em alpha} & \\
\hline
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::add(), H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, f\+\_\+h\+\_\+m\+Tmult(), H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, h\+\_\+f\+\_\+m\+Tmult(), h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node(), h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving(), h\+\_\+rk\+\_\+m\+Tmult(), rk\+\_\+h\+\_\+m\+Tmult(), H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{hmatrix_8h_afee9050ba0b224929bcbf99484385a59}\label{hmatrix_8h_afee9050ba0b224929bcbf99484385a59}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+rk\+\_\+mmult@{h\+\_\+rk\+\_\+mmult}}
\index{h\+\_\+rk\+\_\+mmult@{h\+\_\+rk\+\_\+mmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+rk\+\_\+mmult()}{h\_rk\_mmult()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void h\+\_\+rk\+\_\+mmult (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M2,  }\item[{\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes, where the second one {\ttfamily M2} has {\ttfamily Rk\+Matrix\+Type} and the result will also be a rank-\/k matrix.

The arithmetic operation to be performed is \[ M = M_1 \cdot M_2 = M_1 (A B^T) = (M_1 A) B^T = A' B^T, \] where $A' = M_1 A$ is calculated as a series of $\mathcal{H}$-\/matrix-\/vector multiplications. For details, \[ M_1 A = M_1 \begin{bmatrix} a_{\sigma,1} & \cdots & a_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_1 a_{\sigma,1} & \cdots & M_1 a_{\sigma,r} \end{bmatrix} = \begin{bmatrix} a'_{\tau,1} & \cdots & a'_{\tau,r} \end{bmatrix}. \] It can be seen that the formal rank $r$ of the result matrix {\ttfamily M} is the same as that of {\ttfamily M2}.


\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Create a temporary {\ttfamily Vector} storing a column $a_{\sigma,j}$ in the {\ttfamily A} component of {\ttfamily M2} and another {\ttfamily Vector} $a'_{\tau,j}$ storing the matrix-\/vector product $M_1 \cdot a_{\sigma,j}$.

Initialize the result rank-\/k matrix {\ttfamily M} with the formal rank of {\ttfamily M2}. Its {\ttfamily B} component matrix is the same as that of {\ttfamily M2}.

Build the map from global DoF indices to local matrix indices if necessary.

Then we calculate the {\ttfamily A} component matrix of {\ttfamily M}, which is {\ttfamily M1$\ast$\+M2}.A.

Fill the result vector into the {\ttfamily A} component matrix of {\ttfamily M}.

References build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, Rk\+Matrix$<$ Number $>$\+::formal\+\_\+rank, Rk\+Matrix$<$ Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::m, Rk\+Matrix$<$ Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::n, Rk\+Matrix$<$ Number $>$\+::reinit(), H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, and H\+Matrix$<$ spacedim, Number $>$\+::vmult().



Referenced by h\+\_\+f\+\_\+mmult(), h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving(), h\+\_\+rk\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), and main().

\mbox{\Hypertarget{hmatrix_8h_a9b93b5c19ef281408c6ed1e6460462e5}\label{hmatrix_8h_a9b93b5c19ef281408c6ed1e6460462e5}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+rk\+\_\+mmult@{h\+\_\+rk\+\_\+mmult}}
\index{h\+\_\+rk\+\_\+mmult@{h\+\_\+rk\+\_\+mmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+rk\+\_\+mmult()}{h\_rk\_mmult()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void h\+\_\+rk\+\_\+mmult (\begin{DoxyParamCaption}\item[{const Number}]{alpha,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M2,  }\item[{\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes and the result is scaled by a factor, where the second one {\ttfamily M2} has {\ttfamily Rk\+Matrix\+Type} and the result will also be a rank-\/k matrix.

The arithmetic operation to be performed is \[ M = \alpha \cdot M_1 \cdot M_2 = \alpha \cdot M_1 (A B^T) = \alpha \cdot (M_1 A) B^T = \alpha \cdot A' B^T, \] where $A' = M_1 A$ is calculated as a series of $\mathcal{H}$-\/matrix-\/vector multiplications. For details, \[ M_1 A = M_1 \begin{bmatrix} a_{\sigma,1} & \cdots & a_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_1 a_{\sigma,1} & \cdots & M_1 a_{\sigma,r} \end{bmatrix} = \begin{bmatrix} a'_{\tau,1} & \cdots & a'_{\tau,r} \end{bmatrix}. \] It can be seen that the formal rank $r$ of the result matrix {\ttfamily M} is the same as that of {\ttfamily M2}.


\begin{DoxyParams}{Parameters}
{\em alpha} & \\
\hline
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Create a temporary {\ttfamily Vector} storing a column $a_{\sigma,j}$ in the {\ttfamily A} component of {\ttfamily M2} and another {\ttfamily Vector} $a'_{\tau,j}$ storing the matrix-\/vector product $M_1 \cdot a_{\sigma,j}$.

Initialize the result rank-\/k matrix {\ttfamily M} with the formal rank of {\ttfamily M2}. Its {\ttfamily B} component matrix is the same as that of {\ttfamily M2}.

Build the map from global DoF indices to local matrix indices if necessary.

Then we calculate the {\ttfamily A} component matrix of {\ttfamily M}, which is {\ttfamily M1$\ast$\+M2}.A.

{\bfseries Since the following {\ttfamily vmult} will compute $y = y + M x$, {\ttfamily result\+\_\+vect} should be reset to zero beforehand.}

Fill the result vector into the {\ttfamily A} component matrix of {\ttfamily M}.

References build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, Rk\+Matrix$<$ Number $>$\+::formal\+\_\+rank, Rk\+Matrix$<$ Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::m, Rk\+Matrix$<$ Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::n, Rk\+Matrix$<$ Number $>$\+::reinit(), H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, and H\+Matrix$<$ spacedim, Number $>$\+::vmult().

\mbox{\Hypertarget{hmatrix_8h_a84df06910d958d84ac8c544f9a8423a8}\label{hmatrix_8h_a84df06910d958d84ac8c544f9a8423a8}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+rk\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult@{h\+\_\+rk\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult}}
\index{h\+\_\+rk\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult@{h\+\_\+rk\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+rk\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult()}{h\_rk\_mmult\_for\_h\_h\_mmult()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void h\+\_\+rk\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{M1,  }\item[{const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{M2,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{M,  }\item[{bool}]{is\+\_\+\+M1\+M2\+\_\+last\+\_\+in\+\_\+\+M\+\_\+\+Sigma\+\_\+P = {\ttfamily true} }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes, where the second one {\ttfamily M2} has {\ttfamily Rk\+Matrix\+Type} and the result will also be a rank-\/k matrix. This function is to be called by the matrix-\/matrix multiplication function. 
\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}


References h\+\_\+rk\+\_\+mmult(), H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list(), H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+F, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+P, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+R, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{hmatrix_8h_a4d0d61778a104b7e1452c3b9be60b5e4}\label{hmatrix_8h_a4d0d61778a104b7e1452c3b9be60b5e4}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+rk\+\_\+m\+Tmult@{h\+\_\+rk\+\_\+m\+Tmult}}
\index{h\+\_\+rk\+\_\+m\+Tmult@{h\+\_\+rk\+\_\+m\+Tmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+rk\+\_\+m\+Tmult()}{h\_rk\_mTmult()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void h\+\_\+rk\+\_\+m\+Tmult (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M2,  }\item[{\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes with the second operand being transposed, where the second operand {\ttfamily M2} has {\ttfamily Rk\+Matrix\+Type} and the result will also be a rank-\/k matrix.

The arithmetic operation to be performed is \[ M = M_1 \cdot M_2^T = M_1 (A B^T)^T = (M_1 B) A^T = A' B'^T, \] where $A' = M_1 B$ is calculated as a series of $\mathcal{H}$-\/matrix-\/vector multiplications, and $B' = A$. For details, \[ M_1 B = M_1 \begin{bmatrix} b_{\sigma,1} & \cdots & b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_1 b_{\sigma,1} & \cdots & M_1 b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} b'_{\tau,1} & \cdots & b'_{\tau,r} \end{bmatrix}. \] It can be seen that the formal rank $r$ of the result matrix {\ttfamily M} is the same as that of {\ttfamily M2}.


\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Create a temporary {\ttfamily Vector} storing a column $b_{\sigma,j}$ in the {\ttfamily B} component of {\ttfamily M2} and another {\ttfamily Vector} $b'_{\tau,j}$ storing the matrix-\/vector product $M_1 \cdot b_{\sigma,j}$.

Initialize the result rank-\/k matrix {\ttfamily M} with the formal rank of {\ttfamily M2}. Its {\ttfamily B} component matrix is the same as that of {\ttfamily M2}.

Build the map from global DoF indices to local matrix indices if necessary.

Then we calculate the {\ttfamily A} component matrix of {\ttfamily M}, which is {\ttfamily M1$\ast$\+M2}.B.

Fill the result vector into the {\ttfamily A} component matrix of {\ttfamily M}.

References build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, Rk\+Matrix$<$ Number $>$\+::formal\+\_\+rank, Rk\+Matrix$<$ Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::m, Rk\+Matrix$<$ Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::n, Rk\+Matrix$<$ Number $>$\+::reinit(), H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, and H\+Matrix$<$ spacedim, Number $>$\+::vmult().



Referenced by h\+\_\+f\+\_\+m\+Tmult(), and h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving().

\mbox{\Hypertarget{hmatrix_8h_acfbe51ba1fe5ea83d5910d1f893d589f}\label{hmatrix_8h_acfbe51ba1fe5ea83d5910d1f893d589f}} 
\index{hmatrix.\+h@{hmatrix.\+h}!h\+\_\+rk\+\_\+m\+Tmult@{h\+\_\+rk\+\_\+m\+Tmult}}
\index{h\+\_\+rk\+\_\+m\+Tmult@{h\+\_\+rk\+\_\+m\+Tmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{h\+\_\+rk\+\_\+m\+Tmult()}{h\_rk\_mTmult()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void h\+\_\+rk\+\_\+m\+Tmult (\begin{DoxyParamCaption}\item[{const Number}]{alpha,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M1,  }\item[{const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M2,  }\item[{\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes with the second operand being transposed, where the second operand {\ttfamily M2} has {\ttfamily Rk\+Matrix\+Type} and the result will also be a rank-\/k matrix. The result will be scaled by a factor.

The arithmetic operation to be performed is \[ M = \alpha \cdot M_1 \cdot M_2^T = \alpha \cdot M_1 (A B^T)^T = \alpha \cdot (M_1 B) A^T = \alpha \cdot A' B'^T, \] where $A' = M_1 B$ is calculated as a series of $\mathcal{H}$-\/matrix-\/vector multiplications, and $B' = A$. For details, \[ M_1 B = M_1 \begin{bmatrix} b_{\sigma,1} & \cdots & b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_1 b_{\sigma,1} & \cdots & M_1 b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} b'_{\tau,1} & \cdots & b'_{\tau,r} \end{bmatrix}. \] It can be seen that the formal rank $r$ of the result matrix {\ttfamily M} is the same as that of {\ttfamily M2}.


\begin{DoxyParams}{Parameters}
{\em alpha} & \\
\hline
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Create a temporary {\ttfamily Vector} storing a column $b_{\sigma,j}$ in the {\ttfamily B} component of {\ttfamily M2} and another {\ttfamily Vector} $b'_{\tau,j}$ storing the matrix-\/vector product $M_1 \cdot b_{\sigma,j}$.

Initialize the result rank-\/k matrix {\ttfamily M} with the formal rank of {\ttfamily M2}. Its {\ttfamily B} component matrix is the same as that of {\ttfamily M2}.

Build the map from global DoF indices to local matrix indices if necessary.

Then we calculate the {\ttfamily A} component matrix of {\ttfamily M}, which is {\ttfamily M1$\ast$\+M2}.B.

Fill the result vector into the {\ttfamily A} component matrix of {\ttfamily M}.

References build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, Rk\+Matrix$<$ Number $>$\+::formal\+\_\+rank, Rk\+Matrix$<$ Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::m, Rk\+Matrix$<$ Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::n, Rk\+Matrix$<$ Number $>$\+::reinit(), H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, and H\+Matrix$<$ spacedim, Number $>$\+::vmult().

\mbox{\Hypertarget{hmatrix_8h_a317e4841d6bb5b60883a7e21027a8893}\label{hmatrix_8h_a317e4841d6bb5b60883a7e21027a8893}} 
\index{hmatrix.\+h@{hmatrix.\+h}!Init\+And\+Create\+H\+Matrix\+Children@{Init\+And\+Create\+H\+Matrix\+Children}}
\index{Init\+And\+Create\+H\+Matrix\+Children@{Init\+And\+Create\+H\+Matrix\+Children}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{Init\+And\+Create\+H\+Matrix\+Children()}{InitAndCreateHMatrixChildren()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void Init\+And\+Create\+H\+Matrix\+Children (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{hmat,  }\item[{typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type}]{bc\+\_\+node,  }\item[{const unsigned int}]{fixed\+\_\+rank\+\_\+k,  }\item[{bool}]{is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map = {\ttfamily true} }\end{DoxyParamCaption})}

Recursively construct the children of an $\mathcal{H}$-\/matrix with respect to a block cluster tree by starting from a tree node which is associated with the current $\mathcal{H}$-\/matrix.

The matrices in the leaf set are initialized with zero values. The rank of the near field matrices are predefined fixed values.


\begin{DoxyParams}{Parameters}
{\em hmat} & Pointer to the current $\mathcal{H}$-\/matrix node, {\bfseries which has already been created on the heap but with its internal data left empty.} \\
\hline
{\em bc\+\_\+node} & Pointer to a \hyperlink{classTreeNode}{Tree\+Node} in a \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}, which is to be associated with {\ttfamily hmat}. \\
\hline
\end{DoxyParams}
Link {\ttfamily hmat} with {\ttfamily bc\+\_\+node}.

Link row and column indices stored in the clusters $\tau$ and $\sigma$ respectively.

Update the matrix dimension of {\ttfamily hmat}.

When the block cluster node {\ttfamily bc\+\_\+node} has children, set the current {\ttfamily hmat} type as {\ttfamily Hierarchical\+Matrix\+Type}.

Then we will continue constructing its hierarchical submatrices.

Create an empty \hyperlink{classHMatrix}{H\+Matrix} on the heap.

Append the initialized child to the list of submatrices of {\ttfamily hmat}.

Set the pointer to the parent $\mathcal{H}$-\/matrix node of the current child $\mathcal{H}$-\/matrix node.

Build the maps from global row and column indices respectively to local indices.

Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, {\ttfamily hmat} should be represented as a {\ttfamily \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}}. When the block cluster belongs to the far field, {\ttfamily hmat} should be represented as an {\ttfamily \hyperlink{classRkMatrix}{Rk\+Matrix}}. Correspondingly, new matrices, either full matrix or rank-\/k matrix will be created on the heap and assigned to the current $\mathcal{H}$-\/matrix.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+num(), Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+pointer(), Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+reference(), Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::parent, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::submatrix\+\_\+index, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by Init\+And\+Create\+H\+Matrix\+Children().

\mbox{\Hypertarget{hmatrix_8h_a2b56a9e943f5632f50d08f4e892b1787}\label{hmatrix_8h_a2b56a9e943f5632f50d08f4e892b1787}} 
\index{hmatrix.\+h@{hmatrix.\+h}!Init\+And\+Create\+H\+Matrix\+Children@{Init\+And\+Create\+H\+Matrix\+Children}}
\index{Init\+And\+Create\+H\+Matrix\+Children@{Init\+And\+Create\+H\+Matrix\+Children}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{Init\+And\+Create\+H\+Matrix\+Children()}{InitAndCreateHMatrixChildren()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void Init\+And\+Create\+H\+Matrix\+Children (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{hmat,  }\item[{typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type}]{bc\+\_\+node,  }\item[{const unsigned int}]{fixed\+\_\+rank\+\_\+k,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M,  }\item[{bool}]{is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map = {\ttfamily true} }\end{DoxyParamCaption})}

Recursively construct the children of an $\mathcal{H}$-\/matrix with respect to a block cluster tree by starting from a tree node which is associated with the current $\mathcal{H}$-\/matrix.

The matrices in the leaf set are initialized with the data in the given global full matrix {\ttfamily M}, which is created on the complete block cluster index set $I \times J$ and whose elements should be accessed via indices stored in the block cluster. The rank of the far field matrices are predefined fixed values.

During the recursive calling of this function, the source data matrix {\ttfamily M} is kept intact, which will not be restricted to small matrix blocks.


\begin{DoxyParams}{Parameters}
{\em hmat} & Pointer to the current $\mathcal{H}$-\/matrix node, {\bfseries which has already been created on the heap but with its internal data left empty.} \\
\hline
{\em bc\+\_\+node} & Pointer to a \hyperlink{classTreeNode}{Tree\+Node} in a \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}, which is to be associated with {\ttfamily hmat}. \\
\hline
{\em M} & The global full matrix containing all the data required to initialize the $\mathcal{H}$-\/matrix. \\
\hline
\end{DoxyParams}
Link {\ttfamily hmat} with {\ttfamily bc\+\_\+node}.

Link row and column indices.

Update the matrix dimension of {\ttfamily hmat}.

When the block cluster node {\ttfamily bc\+\_\+node} has children, set the current {\ttfamily hmat} type as {\ttfamily Hierarchical\+Matrix\+Type}. Then we will continue constructing hierarchical submatrices.

Create an empty \hyperlink{classHMatrix}{H\+Matrix} on the heap.

Append the initialized child to the list of submatrices of {\ttfamily hmat}.

Set the pointer to the parent $\mathcal{H}$-\/matrix node of the current child $\mathcal{H}$-\/matrix node.

Build the maps from global row and column indices respectively to local indices.

Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, {\ttfamily hmat} should be represented as a {\ttfamily \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}}. When the block cluster belongs to the far field, {\ttfamily hmat} should be represented as an {\ttfamily \hyperlink{classRkMatrix}{Rk\+Matrix}}. Correspondingly, new matrices, either full matrix or rank-\/k matrix will be created on the heap and assigned to the current $\mathcal{H}$-\/matrix.

Assign matrix values from {\ttfamily M} to the current \hyperlink{classHMatrix}{H\+Matrix}.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+num(), Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+pointer(), Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+reference(), Hierarchical\+Matrix\+Type, Init\+And\+Create\+H\+Matrix\+Children(), H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::parent, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::submatrix\+\_\+index, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{hmatrix_8h_a6b547084e856ac11a021c104331400cf}\label{hmatrix_8h_a6b547084e856ac11a021c104331400cf}} 
\index{hmatrix.\+h@{hmatrix.\+h}!Init\+And\+Create\+H\+Matrix\+Children@{Init\+And\+Create\+H\+Matrix\+Children}}
\index{Init\+And\+Create\+H\+Matrix\+Children@{Init\+And\+Create\+H\+Matrix\+Children}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{Init\+And\+Create\+H\+Matrix\+Children()}{InitAndCreateHMatrixChildren()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void Init\+And\+Create\+H\+Matrix\+Children (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{hmat,  }\item[{typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type}]{bc\+\_\+node,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M,  }\item[{bool}]{is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map = {\ttfamily true} }\end{DoxyParamCaption})}

Recursively construct the children of an $\mathcal{H}$-\/matrix with respect to a block cluster tree by starting from a tree node which is associated with the current $\mathcal{H}$-\/matrix. There is no rank truncation to the rank-\/k matrices.

The matrices in the leaf set are initialized with the data in the given global full matrix {\ttfamily M}, which is created on the complete block cluster index set $I \times J$ and whose elements should be accessed via indices stored in the block cluster.

During the recursive calling of this function, the source data matrix {\ttfamily M} is kept intact, which will not be restricted to small matrix blocks.


\begin{DoxyParams}{Parameters}
{\em hmat} & Pointer to the current $\mathcal{H}$-\/matrix node, {\bfseries which has already been created on the heap but with its internal data left empty.} \\
\hline
{\em bc\+\_\+node} & Pointer to a \hyperlink{classTreeNode}{Tree\+Node} in a \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}, which is to be associated with {\ttfamily hmat}. \\
\hline
{\em M} & The global full matrix containing all the data required to initialize the $\mathcal{H}$-\/matrix. \\
\hline
\end{DoxyParams}
Link {\ttfamily hmat} with {\ttfamily bc\+\_\+node}.

Link row and column indices.

Update the matrix dimension of {\ttfamily hmat}.

When the block cluster node {\ttfamily bc\+\_\+node} has children, set the current {\ttfamily hmat} type as {\ttfamily Hierarchical\+Matrix\+Type}. Then we will continue constructing hierarchical submatrices.

Create an empty \hyperlink{classHMatrix}{H\+Matrix} on the heap.

Append the initialized child to the list of submatrices of {\ttfamily hmat}.

Set the pointer to the parent $\mathcal{H}$-\/matrix node of the current child $\mathcal{H}$-\/matrix node.

Build the maps from global row and column indices respectively to local indices.

Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, {\ttfamily hmat} should be represented as a {\ttfamily \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}}. When the block cluster belongs to the far field, {\ttfamily hmat} should be represented as an {\ttfamily \hyperlink{classRkMatrix}{Rk\+Matrix}}. Correspondingly, new matrices, either full matrix or rank-\/k matrix will be created on the heap and assigned to the current $\mathcal{H}$-\/matrix.

Assign matrix values from {\ttfamily M} to the current \hyperlink{classHMatrix}{H\+Matrix}.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+num(), Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+pointer(), Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+reference(), Hierarchical\+Matrix\+Type, Init\+And\+Create\+H\+Matrix\+Children(), H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::parent, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::submatrix\+\_\+index, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{hmatrix_8h_a53120559ced904c076a4914af3e9423a}\label{hmatrix_8h_a53120559ced904c076a4914af3e9423a}} 
\index{hmatrix.\+h@{hmatrix.\+h}!Init\+And\+Create\+H\+Matrix\+Children@{Init\+And\+Create\+H\+Matrix\+Children}}
\index{Init\+And\+Create\+H\+Matrix\+Children@{Init\+And\+Create\+H\+Matrix\+Children}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{Init\+And\+Create\+H\+Matrix\+Children()}{InitAndCreateHMatrixChildren()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void Init\+And\+Create\+H\+Matrix\+Children (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{hmat,  }\item[{typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type}]{bc\+\_\+node,  }\item[{const unsigned int}]{fixed\+\_\+rank\+\_\+k,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+M,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+M,  }\item[{bool}]{is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map = {\ttfamily true} }\end{DoxyParamCaption})}

Recursively construct the children of an $\mathcal{H}$-\/matrix with respect to a block cluster tree by starting from a tree node which is associated with the current $\mathcal{H}$-\/matrix.

The matrices in the leaf set are initialized with the data in the given full matrix {\ttfamily M}, which is created on the block cluster index set $\tau \times \sigma$ associated with the current $\mathcal{H}$-\/matrix. Hence, this full matrix is just a block of the original global full matrix created on the block cluster index set $I \times J$. The rank of the far field matrices are predefined fixed values.

During the recursive calling of this function, the source data matrix {\ttfamily M} is kept intact, which will not be restricted to small matrix blocks.


\begin{DoxyParams}{Parameters}
{\em hmat} & Pointer to the current $\mathcal{H}$-\/matrix node, {\bfseries which has already been created on the heap but with its internal data left empty.} \\
\hline
{\em bc\+\_\+node} & Pointer to a \hyperlink{classTreeNode}{Tree\+Node} in a \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}, which is to be associated with {\ttfamily hmat}. \\
\hline
{\em M} & The full matrix, as a submatrix of the global full matrix, containing all the data required to initialize the $\mathcal{H}$-\/matrix. \\
\hline
{\em row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+M} & The map from the global row indices to the local indices of the matrix associated the $\mathcal{H}$-\/matrix when first calling this recursive function. \\
\hline
{\em col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+M} & The map from the global column indices to the local indices of the matrix associated the $\mathcal{H}$-\/matrix when first calling this recursive function. \\
\hline
\end{DoxyParams}
Link {\ttfamily hmat} with {\ttfamily bc\+\_\+node}.

Link row and column indices.

Update the matrix dimension of {\ttfamily hmat}.

When the block cluster node {\ttfamily bc\+\_\+node} has children, set the current {\ttfamily hmat} type as {\ttfamily Hierarchical\+Matrix\+Type}. Then we will continue constructing hierarchical submatrices.

Create an empty \hyperlink{classHMatrix}{H\+Matrix} on the heap.

Append the initialized child to the list of submatrices of {\ttfamily hmat}.

Set the pointer to the parent $\mathcal{H}$-\/matrix node of the current child $\mathcal{H}$-\/matrix node.

Build the maps from global row and column indices respectively to local indices.

Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, {\ttfamily hmat} should be represented as a {\ttfamily \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}}. When the block cluster belongs to the far field, {\ttfamily hmat} should be represented as an {\ttfamily \hyperlink{classRkMatrix}{Rk\+Matrix}}. Correspondingly, new matrices, either full matrix or rank-\/k matrix will be created on the heap and assigned to the current $\mathcal{H}$-\/matrix.

Assign matrix values from {\ttfamily M} to the current \hyperlink{classHMatrix}{H\+Matrix}.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+num(), Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+pointer(), Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+reference(), Hierarchical\+Matrix\+Type, Init\+And\+Create\+H\+Matrix\+Children(), H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::parent, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::submatrix\+\_\+index, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{hmatrix_8h_a427e26a795634442821a7baf5f34a8ed}\label{hmatrix_8h_a427e26a795634442821a7baf5f34a8ed}} 
\index{hmatrix.\+h@{hmatrix.\+h}!Init\+And\+Create\+H\+Matrix\+Children@{Init\+And\+Create\+H\+Matrix\+Children}}
\index{Init\+And\+Create\+H\+Matrix\+Children@{Init\+And\+Create\+H\+Matrix\+Children}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{Init\+And\+Create\+H\+Matrix\+Children()}{InitAndCreateHMatrixChildren()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void Init\+And\+Create\+H\+Matrix\+Children (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{hmat,  }\item[{typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type}]{bc\+\_\+node,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+M,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+M,  }\item[{bool}]{is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map = {\ttfamily true} }\end{DoxyParamCaption})}

Recursively construct the children of an $\mathcal{H}$-\/matrix with respect to a block cluster tree by starting from a tree node which is associated with the current $\mathcal{H}$-\/matrix. There is no rank truncation to the rank-\/k matrices.

The matrices in the leaf set are initialized with the data in the given full matrix {\ttfamily M}, which is created on the block cluster index set $\tau \times \sigma$ associated with the current $\mathcal{H}$-\/matrix. Hence, this full matrix is just a block of the original global full matrix created on the block cluster index set $I \times J$.

During the recursive calling of this function, the source data matrix {\ttfamily M} is kept intact, which will not be restricted to small matrix blocks.


\begin{DoxyParams}{Parameters}
{\em hmat} & Pointer to the current $\mathcal{H}$-\/matrix node, {\bfseries which has already been created on the heap but with its internal data left empty.} \\
\hline
{\em bc\+\_\+node} & Pointer to a \hyperlink{classTreeNode}{Tree\+Node} in a \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}, which is to be associated with {\ttfamily hmat}. \\
\hline
{\em M} & The full matrix, as a submatrix of the global full matrix, containing all the data required to initialize the $\mathcal{H}$-\/matrix. \\
\hline
{\em row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+M} & The map from the global row indices to the local indices of the matrix associated the $\mathcal{H}$-\/matrix when first calling this recursive function. \\
\hline
{\em col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+M} & The map from the global column indices to the local indices of the matrix associated the $\mathcal{H}$-\/matrix when first calling this recursive function. \\
\hline
\end{DoxyParams}
Link {\ttfamily hmat} with {\ttfamily bc\+\_\+node}.

Link row and column indices.

Update the matrix dimension of {\ttfamily hmat}.

When the block cluster node {\ttfamily bc\+\_\+node} has children, set the current {\ttfamily hmat} type as {\ttfamily Hierarchical\+Matrix\+Type}. Then we will continue constructing hierarchical submatrices.

Create an empty \hyperlink{classHMatrix}{H\+Matrix} on the heap.

Append the initialized child to the list of submatrices of {\ttfamily hmat}.

Set the pointer to the parent $\mathcal{H}$-\/matrix node of the current child $\mathcal{H}$-\/matrix node.

Build the maps from global row and column indices respectively to local indices.

Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, {\ttfamily hmat} should be represented as a {\ttfamily \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}}. When the block cluster belongs to the far field, {\ttfamily hmat} should be represented as an {\ttfamily \hyperlink{classRkMatrix}{Rk\+Matrix}}. Correspondingly, new matrices, either full matrix or rank-\/k matrix will be created on the heap and assigned to the current $\mathcal{H}$-\/matrix.

Assign matrix values from {\ttfamily M} to the current \hyperlink{classHMatrix}{H\+Matrix}.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+num(), Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+pointer(), Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+reference(), Hierarchical\+Matrix\+Type, Init\+And\+Create\+H\+Matrix\+Children(), H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::parent, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::submatrix\+\_\+index, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{hmatrix_8h_a9cf5008e3967b1029d5b766290c98139}\label{hmatrix_8h_a9cf5008e3967b1029d5b766290c98139}} 
\index{hmatrix.\+h@{hmatrix.\+h}!Init\+And\+Create\+H\+Matrix\+Children@{Init\+And\+Create\+H\+Matrix\+Children}}
\index{Init\+And\+Create\+H\+Matrix\+Children@{Init\+And\+Create\+H\+Matrix\+Children}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{Init\+And\+Create\+H\+Matrix\+Children()}{InitAndCreateHMatrixChildren()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void Init\+And\+Create\+H\+Matrix\+Children (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{hmat,  }\item[{typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type}]{bc\+\_\+node,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&\&}]{H }\end{DoxyParamCaption})}

Recursively construct the children of an $\mathcal{H}$-\/matrix node with respect to a block cluster tree by starting from a tree node which is associated with the current $\mathcal{H}$-\/matrix node.

The matrices in the leaf set take the data migrated from the leaf set of the given $\mathcal{H}$-\/matrix {\ttfamily H}.


\begin{DoxyParams}{Parameters}
{\em hmat} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Link {\ttfamily hmat} with {\ttfamily bc\+\_\+node}.

Link row and column indices stored in the clusters $\tau$ and $\sigma$ respectively..

Update the matrix dimension of {\ttfamily hmat}.

When the block cluster node {\ttfamily bc\+\_\+node} has children, set the current {\ttfamily hmat} type as {\ttfamily Hierarchical\+Matrix\+Type}.

Then we will continue constructing its hierarchical submatrices.

Create an empty \hyperlink{classHMatrix}{H\+Matrix} on the heap.

Append the initialized child to the list of submatrices of {\ttfamily hmat}.

Set the pointer to the parent $\mathcal{H}$-\/matrix node of the current child $\mathcal{H}$-\/matrix node.

When the current $\mathcal{H}$-\/matrix node is a leaf, migrate the data from the leaf set of {\ttfamily H} to it.

Shallow copy the found $\mathcal{H}$-\/matrix node in the leaf set to the current $\mathcal{H}$-\/matrix node.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+num(), Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+pointer(), Hierarchical\+Matrix\+Type, Init\+And\+Create\+H\+Matrix\+Children(), H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::parent, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::submatrix\+\_\+index, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{hmatrix_8h_a65e47eb35744c93b8955b6d564e5bf9a}\label{hmatrix_8h_a65e47eb35744c93b8955b6d564e5bf9a}} 
\index{hmatrix.\+h@{hmatrix.\+h}!Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc@{Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc}}
\index{Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc@{Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc()}{InitAndCreateHMatrixChildrenWithoutAlloc()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{hmat,  }\item[{typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type}]{bc\+\_\+node,  }\item[{const bool}]{is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map = {\ttfamily true} }\end{DoxyParamCaption})}

Recursively construct the children of an $\mathcal{H}$-\/matrix with respect to a block cluster tree by starting from a tree node which is to be associated with the current $\mathcal{H}$-\/matrix.


\begin{DoxyParams}{Parameters}
{\em hmat} & Pointer to the current $\mathcal{H}$-\/matrix node, {\bfseries which has already been created on the heap but with its internal data left empty.} \\
\hline
{\em bc\+\_\+node} & Pointer to a \hyperlink{classTreeNode}{Tree\+Node} in a \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}, which is to be associated with {\ttfamily hmat}. \\
\hline
\end{DoxyParams}
Link {\ttfamily hmat} with {\ttfamily bc\+\_\+node}.

Link row and column indices stored in the clusters $\tau$ and $\sigma$ respectively.

Update the matrix dimension of {\ttfamily hmat}.

When the block cluster node {\ttfamily bc\+\_\+node} has children, set the current {\ttfamily hmat} type as {\ttfamily Hierarchical\+Matrix\+Type}.

Then we will continue constructing its hierarchical submatrices.

Create an empty \hyperlink{classHMatrix}{H\+Matrix} on the heap.

Append the initialized child to the list of submatrices of {\ttfamily hmat}.

Set the pointer to the parent $\mathcal{H}$-\/matrix node of the current child $\mathcal{H}$-\/matrix node.

Build the maps from global row and column indices respectively to local indices.

Update the current matrix type according to the identity of the block cluster node. When the block cluster belongs to the near field, {\ttfamily hmat} should be represented as a {\ttfamily \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}}. When the block cluster belongs to the far field, {\ttfamily hmat} should be represented as an {\ttfamily \hyperlink{classRkMatrix}{Rk\+Matrix}}. Correspondingly, new matrices, either full matrix or rank-\/k matrix will be created on the heap and assigned to the current $\mathcal{H}$-\/matrix.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+num(), Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+pointer(), Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+reference(), Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::parent, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::submatrix\+\_\+index, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{hmatrix_8h_a21892e360616f81dd5ad1c7089f9eaab}\label{hmatrix_8h_a21892e360616f81dd5ad1c7089f9eaab}} 
\index{hmatrix.\+h@{hmatrix.\+h}!Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node@{Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node}}
\index{Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node@{Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node()}{InitHMatrixWrtBlockClusterNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{hmat,  }\item[{typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type}]{bc\+\_\+node }\end{DoxyParamCaption})}

Initialize an $\mathcal{H}$-\/matrix node with respect to a block cluster node. The list $\Sigma_b^P$ is set to empty.


\begin{DoxyParams}{Parameters}
{\em hmat} & \\
\hline
{\em bc\+\_\+node} & \\
\hline
{\em Sigma\+\_\+P} & \\
\hline
\end{DoxyParams}
Link {\ttfamily hmat} with {\ttfamily bc\+\_\+node}.

Link row and column indices stored in the clusters $\tau$ and $\sigma$ respectively.

Update the matrix dimension of {\ttfamily hmat}.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+F, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+P, and H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+R.

\mbox{\Hypertarget{hmatrix_8h_ae5d510b10595b78a40764950441bcbaf}\label{hmatrix_8h_ae5d510b10595b78a40764950441bcbaf}} 
\index{hmatrix.\+h@{hmatrix.\+h}!Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node@{Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node}}
\index{Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node@{Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node()}{InitHMatrixWrtBlockClusterNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{hmat,  }\item[{typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type}]{bc\+\_\+node,  }\item[{const std\+::vector$<$ std\+::pair$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$$>$$>$ \&}]{Sigma\+\_\+P }\end{DoxyParamCaption})}

Initialize an $\mathcal{H}$-\/matrix node with respect to a block cluster node. Its member list $\Sigma_b^P$ will be merged with the given {\ttfamily Sigma\+\_\+P}.


\begin{DoxyParams}{Parameters}
{\em hmat} & \\
\hline
{\em bc\+\_\+node} & \\
\hline
{\em Sigma\+\_\+P} & \\
\hline
\end{DoxyParams}
Link {\ttfamily hmat} with {\ttfamily bc\+\_\+node}.

Link row and column indices stored in the clusters $\tau$ and $\sigma$ respectively.

Update the matrix dimension of {\ttfamily hmat}.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+F, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+P, and H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+R.

\mbox{\Hypertarget{hmatrix_8h_a0f1d1afba43d1a66f46ee4799a9904a2}\label{hmatrix_8h_a0f1d1afba43d1a66f46ee4799a9904a2}} 
\index{hmatrix.\+h@{hmatrix.\+h}!Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node@{Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node}}
\index{Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node@{Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node()}{InitHMatrixWrtBlockClusterNode()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{hmat,  }\item[{typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type}]{bc\+\_\+node,  }\item[{const std\+::pair$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$$>$ \&}]{hmat\+\_\+pair }\end{DoxyParamCaption})}

Initialize an $\mathcal{H}$-\/matrix node with respect to a block cluster node. The given {\ttfamily hmat\+\_\+pair} will be appended to the list $\Sigma_b^P$.


\begin{DoxyParams}{Parameters}
{\em hmat} & \\
\hline
{\em bc\+\_\+node} & \\
\hline
{\em hmat\+\_\+pair} & \\
\hline
\end{DoxyParams}
Link {\ttfamily hmat} with {\ttfamily bc\+\_\+node}.

Link row and column indices stored in the clusters $\tau$ and $\sigma$ respectively.

Update the matrix dimension of {\ttfamily hmat}.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+F, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+P, and H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+R.

\mbox{\Hypertarget{hmatrix_8h_a090df12c1646d637bc390fa6dae55f24}\label{hmatrix_8h_a090df12c1646d637bc390fa6dae55f24}} 
\index{hmatrix.\+h@{hmatrix.\+h}!Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree@{Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree}}
\index{Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree@{Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree()}{RefineHMatrixWrtExtendedBlockClusterTree()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{starting\+\_\+hmat,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{current\+\_\+hmat }\end{DoxyParamCaption})}

Refine an $\mathcal{H}$-\/matrix node with respect to its associated block cluster tree which has already been extended to be finer than the original tree. The $\mathcal{H}$-\/matrix node should be of either {\ttfamily Full\+Matrix\+Type} or {\ttfamily Rk\+Matrix\+Type}, i.\+e. it belongs to the leaf set of the block cluster tree before extension.


\begin{DoxyParams}{Parameters}
{\em starting\+\_\+hmat} & The pointer to the initial $\mathcal{H}$-\/matrix node from which this recursive function is called for the first time, i.\+e. the $\mathcal{H}$-\/matrix node from which the refinement begins. \\
\hline
{\em current\+\_\+hmat} & The pointer to the current $\mathcal{H}$-\/matrix node being handled during the recursion. For the first time of calling this function, {\ttfamily current\+\_\+hmat} is the same as {\ttfamily starting\+\_\+hmat}. \\
\hline
\end{DoxyParams}

\begin{DoxyDescription}
\item[Work flow ]Because the $\mathcal{H}$-\/matrix node from which the refinement begins belongs to the leaf set of the original block cluster tree, its $\mathcal{H}$-\/matrix type can only be {\ttfamily Full\+Matrix\+Type} or {\ttfamily Rk\+Matrix\+Type}. Therefore, we make an assertion here.

Determine the total number of children of the current $\mathcal{H}$-\/matrix node by querying its associated block cluster node. We do it like this is because the block cluster tree has already been extended which contains a set of child node, while the hierarchy of H-\/matrices has still not been extended yet.

If the associated block cluster node of the current $\mathcal{H}$-\/matrix node has children, we firstly update the $\mathcal{H}$-\/matrix type for the current $\mathcal{H}$-\/matrix node as {\ttfamily Hierarchical\+Matrix} and this is only performed when the current $\mathcal{H}$-\/matrix node is not the starting $\mathcal{H}$-\/matrix node, because the original matrix type of the starting $\mathcal{H}$-\/matrix node will be used later during restriction operations to the current block cluster.

For each of the children, create an empty $\mathcal{H}$-\/matrix node on the heap and append it to the list of submatrices of the current $\mathcal{H}$-\/matrix.

Link the child $\mathcal{H}$-\/matrix node with the corresponding block cluster node.

Link row and column indices of the child $\mathcal{H}$-\/matrix node to those index sets stored in clusters.

Update the matrix dimension of the child $\mathcal{H}$-\/matrix node.

Set the pointer to the parent $\mathcal{H}$-\/matrix node of the current child $\mathcal{H}$-\/matrix node.

Recursively call the function.

When the current $\mathcal{H}$-\/matrix node has no children, i.\+e. it belongs to the leaf set of the extended block cluster tree.

If the current $\mathcal{H}$-\/matrix node is still the same as the starting $\mathcal{H}$-\/matrix node, there is no actual refinement work to be done.

Update the current $\mathcal{H}$-\/matrix node type according to the identity of the block cluster node\+: when the block cluster belongs to the near field, {\ttfamily current\+\_\+hmat} should be represented as a full matrix {\ttfamily \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}}; when the block cluster belongs to the far field, {\ttfamily current\+\_\+hmat} should be represented as a rank-\/k matrix {\ttfamily \hyperlink{classRkMatrix}{Rk\+Matrix}}. Correspondingly, new matrices, either full matrix or rank-\/k matrix will be created on the heap and assigned to the corresponding field of the current $\mathcal{H}$-\/matrix.

Fill the current full matrix with the data extracted from the starting $\mathcal{H}$-\/matrix node. This is actually a restriction of the starting $\mathcal{H}$-\/matrix node to the current $\mathcal{H}$-\/matrix node.

Fill the current rank-\/k matrix with the data extracted from the starting $\mathcal{H}$-\/matrix node.


\end{DoxyDescription}

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::parent, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::submatrix\+\_\+index, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{hmatrix_8h_a5d344d3d2c8db0c93690bf7cbd4a4459}\label{hmatrix_8h_a5d344d3d2c8db0c93690bf7cbd4a4459}} 
\index{hmatrix.\+h@{hmatrix.\+h}!rk\+\_\+h\+\_\+mmult@{rk\+\_\+h\+\_\+mmult}}
\index{rk\+\_\+h\+\_\+mmult@{rk\+\_\+h\+\_\+mmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{rk\+\_\+h\+\_\+mmult()}{rk\_h\_mmult()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void rk\+\_\+h\+\_\+mmult (\begin{DoxyParamCaption}\item[{const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes, where the first one {\ttfamily M1} has {\ttfamily Rk\+Matrix\+Type} and the result is also a rank-\/k matrix.

The arithmetic operation to be performed is \[ M = M_1 \cdot M_2 = (A B^T) M_2 = A (B^T M_2) = A B'^T, \] where $B' = M_2^T B$ is calculated as a series of transposed $\mathcal{H}$-\/matrix-\/vector multiplications. For details, \[ M_2^T B = M_2^T \begin{bmatrix} b_{\sigma,1} & \cdots & b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_2^T b_{\sigma,1} & \cdots & M_2^T b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} b'_{\rho,1} & \cdots & b'_{\rho,r} \end{bmatrix}. \] It can be seen that the formal rank $r$ of the result matrix {\ttfamily M} is the same as that of {\ttfamily M1}.


\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Create a temporary {\ttfamily Vector} storing a column $b_{\sigma,j}$ in the {\ttfamily B} component of {\ttfamily M1} and another {\ttfamily Vector} $b'_{\rho,j}$ storing the matrix-\/vector product $M_2^T \cdot b_{\sigma,j}$.

Initialize the result rank-\/k matrix {\ttfamily M} with the formal rank of {\ttfamily M1\+\_\+rk}. Its {\ttfamily A} component matrix is the same as that of {\ttfamily M1\+\_\+rk}.

Build the map from global DoF indices to local matrix indices if necessary.

Then we calculate the {\ttfamily B} component matrix of {\ttfamily M}, which is {\ttfamily M2$^\wedge$\+T$\ast$\+M1\+\_\+rk}.B.

Fill the result vector into the {\ttfamily B} component matrix of {\ttfamily M}.

References build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, Rk\+Matrix$<$ Number $>$\+::formal\+\_\+rank, Rk\+Matrix$<$ Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::m, Rk\+Matrix$<$ Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::n, Rk\+Matrix$<$ Number $>$\+::reinit(), H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, and H\+Matrix$<$ spacedim, Number $>$\+::\+Tvmult().



Referenced by f\+\_\+h\+\_\+mmult(), h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving(), main(), and rk\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult().

\mbox{\Hypertarget{hmatrix_8h_af5e90e9592ce3d05bdea99a9b93d7606}\label{hmatrix_8h_af5e90e9592ce3d05bdea99a9b93d7606}} 
\index{hmatrix.\+h@{hmatrix.\+h}!rk\+\_\+h\+\_\+mmult@{rk\+\_\+h\+\_\+mmult}}
\index{rk\+\_\+h\+\_\+mmult@{rk\+\_\+h\+\_\+mmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{rk\+\_\+h\+\_\+mmult()}{rk\_h\_mmult()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void rk\+\_\+h\+\_\+mmult (\begin{DoxyParamCaption}\item[{const Number}]{alpha,  }\item[{const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes and the result is scaled by a factor, where the first one {\ttfamily M1} has {\ttfamily Rk\+Matrix\+Type} and the result is also a rank-\/k matrix.

The arithmetic operation to be performed is \[ M = \alpha \cdot M_1 \cdot M_2 = \alpha \cdot (A B^T) M_2 = \alpha \cdot A (B^T M_2) = \alpha \cdot A B'^T, \] where $B' = M_2^T B$ is calculated as a series of transposed $\mathcal{H}$-\/matrix-\/vector multiplications. For details, \[ M_2^T B = M_2^T \begin{bmatrix} b_{\sigma,1} & \cdots & b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_2^T b_{\sigma,1} & \cdots & M_2^T b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} b'_{\rho,1} & \cdots & b'_{\rho,r} \end{bmatrix}. \] It can be seen that the formal rank $r$ of the result matrix {\ttfamily M} is the same as that of {\ttfamily M1}.


\begin{DoxyParams}{Parameters}
{\em alpha} & \\
\hline
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Create a temporary {\ttfamily Vector} storing a column $b_{\sigma,j}$ in the {\ttfamily B} component of {\ttfamily M1} and another {\ttfamily Vector} $b'_{\rho,j}$ storing the matrix-\/vector product $M_2^T \cdot b_{\sigma,j}$.

Initialize the result rank-\/k matrix {\ttfamily M} with the formal rank of {\ttfamily M1\+\_\+rk}. Its {\ttfamily A} component matrix is the same as that of {\ttfamily M1\+\_\+rk}.

Build the map from global DoF indices to local matrix indices if necessary.

Then we calculate the {\ttfamily B} component matrix of {\ttfamily M}, which is {\ttfamily M2$^\wedge$\+T$\ast$\+M1\+\_\+rk}.B.

{\bfseries Since the following {\ttfamily Tvmult} will compute $y = y + M^T x$, {\ttfamily result\+\_\+vect} should be reset to zero beforehand.}

Fill the result vector into the {\ttfamily B} component matrix of {\ttfamily M}.

References build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, Rk\+Matrix$<$ Number $>$\+::formal\+\_\+rank, Rk\+Matrix$<$ Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::m, Rk\+Matrix$<$ Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::n, Rk\+Matrix$<$ Number $>$\+::reinit(), H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, and H\+Matrix$<$ spacedim, Number $>$\+::\+Tvmult().

\mbox{\Hypertarget{hmatrix_8h_a43aef4fd52ce71103baa047f549293c6}\label{hmatrix_8h_a43aef4fd52ce71103baa047f549293c6}} 
\index{hmatrix.\+h@{hmatrix.\+h}!rk\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult@{rk\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult}}
\index{rk\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult@{rk\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{rk\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult()}{rk\_h\_mmult\_for\_h\_h\_mmult()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void rk\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult (\begin{DoxyParamCaption}\item[{const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{M2,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{M,  }\item[{bool}]{is\+\_\+\+M1\+M2\+\_\+last\+\_\+in\+\_\+\+M\+\_\+\+Sigma\+\_\+P = {\ttfamily true} }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes, where the first one {\ttfamily M1} has {\ttfamily Rk\+Matrix\+Type} and the result will also be a rank-\/k matrix. This function is to be called by the matrix-\/matrix multiplication function. 
\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list(), rk\+\_\+h\+\_\+mmult(), H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+F, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+P, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+R, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{hmatrix_8h_aca19ab9519b7b1aa1b9660dbfa8fe604}\label{hmatrix_8h_aca19ab9519b7b1aa1b9660dbfa8fe604}} 
\index{hmatrix.\+h@{hmatrix.\+h}!rk\+\_\+h\+\_\+m\+Tmult@{rk\+\_\+h\+\_\+m\+Tmult}}
\index{rk\+\_\+h\+\_\+m\+Tmult@{rk\+\_\+h\+\_\+m\+Tmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{rk\+\_\+h\+\_\+m\+Tmult()}{rk\_h\_mTmult()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void rk\+\_\+h\+\_\+m\+Tmult (\begin{DoxyParamCaption}\item[{const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes with the second operand being transposed, where the first operand {\ttfamily M1} has {\ttfamily Rk\+Matrix\+Type} and the result is also a rank-\/k matrix.

The arithmetic operation to be performed is \[ M = M_1 \cdot M_2^T = (A B^T) M_2^T = A (B^T M_2^T) = A B'^T, \] where $B' = M_2 B$ is calculated as a series of $\mathcal{H}$-\/matrix-\/vector multiplications. For details, \[ M_2 B = M_2 \begin{bmatrix} b_{\sigma,1} & \cdots & b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_2 b_{\sigma,1} & \cdots & M_2 b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} b'_{\rho,1} & \cdots & b'_{\rho,r} \end{bmatrix}. \] It can be seen that the formal rank $r$ of the result matrix {\ttfamily M} is the same as that of {\ttfamily M1}.


\begin{DoxyParams}{Parameters}
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Create a temporary {\ttfamily Vector} storing a column $b_{\sigma,j}$ in the {\ttfamily B} component of {\ttfamily M1} and another {\ttfamily Vector} $b'_{\rho,j}$ storing the matrix-\/vector product $M_2 \cdot b_{\sigma,j}$.

Initialize the result rank-\/k matrix {\ttfamily M} with the formal rank of {\ttfamily M1\+\_\+rk}. Its {\ttfamily A} component matrix is the same as that of {\ttfamily M1\+\_\+rk}.

Build the map from global DoF indices to local matrix indices if necessary.

Then we calculate the {\ttfamily B} component matrix of {\ttfamily M}, which is {\ttfamily M2$\ast$\+M1\+\_\+rk}.B.

Fill the result vector into the {\ttfamily B} component matrix of {\ttfamily M}.

References build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, Rk\+Matrix$<$ Number $>$\+::formal\+\_\+rank, Rk\+Matrix$<$ Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::m, Rk\+Matrix$<$ Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::n, Rk\+Matrix$<$ Number $>$\+::reinit(), H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, and H\+Matrix$<$ spacedim, Number $>$\+::vmult().



Referenced by f\+\_\+h\+\_\+m\+Tmult(), and h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving().

\mbox{\Hypertarget{hmatrix_8h_ab2eac81199c6e3cdf57242dfae682841}\label{hmatrix_8h_ab2eac81199c6e3cdf57242dfae682841}} 
\index{hmatrix.\+h@{hmatrix.\+h}!rk\+\_\+h\+\_\+m\+Tmult@{rk\+\_\+h\+\_\+m\+Tmult}}
\index{rk\+\_\+h\+\_\+m\+Tmult@{rk\+\_\+h\+\_\+m\+Tmult}!hmatrix.\+h@{hmatrix.\+h}}
\subsubsection{\texorpdfstring{rk\+\_\+h\+\_\+m\+Tmult()}{rk\_h\_mTmult()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number  = double$>$ \\
void rk\+\_\+h\+\_\+m\+Tmult (\begin{DoxyParamCaption}\item[{const Number}]{alpha,  }\item[{const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M1,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M2,  }\item[{\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{M }\end{DoxyParamCaption})}

Calculate the product of two $\mathcal{H}$-\/matrix nodes with the second operand being transposed, where the first operand {\ttfamily M1} has {\ttfamily Rk\+Matrix\+Type} and the result is also a rank-\/k matrix. The result will be scaled by a factor.

The arithmetic operation to be performed is \[ M = \alpha \cdot M_1 \cdot M_2^T = \alpha \cdot (A B^T) M_2^T = \alpha \cdot A (B^T M_2^T) = \alpha \cdot A B'^T, \] where $B' = M_2 B$ is calculated as a series of $\mathcal{H}$-\/matrix-\/vector multiplications. For details, \[ M_2 B = M_2 \begin{bmatrix} b_{\sigma,1} & \cdots & b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_2 b_{\sigma,1} & \cdots & M_2 b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} b'_{\rho,1} & \cdots & b'_{\rho,r} \end{bmatrix}. \] It can be seen that the formal rank $r$ of the result matrix {\ttfamily M} is the same as that of {\ttfamily M1}.


\begin{DoxyParams}{Parameters}
{\em alpha} & \\
\hline
{\em M1} & \\
\hline
{\em M2} & \\
\hline
{\em M} & \\
\hline
\end{DoxyParams}
Create a temporary {\ttfamily Vector} storing a column $b_{\sigma,j}$ in the {\ttfamily B} component of {\ttfamily M1} and another {\ttfamily Vector} $b'_{\rho,j}$ storing the matrix-\/vector product $M_2 \cdot b_{\sigma,j}$.

Initialize the result rank-\/k matrix {\ttfamily M} with the formal rank of {\ttfamily M1\+\_\+rk}. Its {\ttfamily A} component matrix is the same as that of {\ttfamily M1\+\_\+rk}.

Build the map from global DoF indices to local matrix indices if necessary.

Then we calculate the {\ttfamily B} component matrix of {\ttfamily M}, which is {\ttfamily M2$\ast$\+M1\+\_\+rk}.B.

Fill the result vector into the {\ttfamily B} component matrix of {\ttfamily M}.

References build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, Rk\+Matrix$<$ Number $>$\+::formal\+\_\+rank, Rk\+Matrix$<$ Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::m, Rk\+Matrix$<$ Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::n, Rk\+Matrix$<$ Number $>$\+::reinit(), H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, and H\+Matrix$<$ spacedim, Number $>$\+::vmult().

