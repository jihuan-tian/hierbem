\hypertarget{tree_8h}{}\section{/home/jihuan/\+Projects/deal.ii/program/dealii-\/9.1.1/examples/laplace-\/bem/include/tree.h File Reference}
\label{tree_8h}\index{/home/jihuan/\+Projects/deal.\+ii/program/dealii-\/9.\+1.\+1/examples/laplace-\/bem/include/tree.\+h@{/home/jihuan/\+Projects/deal.\+ii/program/dealii-\/9.\+1.\+1/examples/laplace-\/bem/include/tree.\+h}}


Implementation of the classes for binary tree node, general tree node and functions for manipulating the trees constructed from these nodes.  


{\ttfamily \#include $<$deal.\+I\+I/base/exceptions.\+h$>$}\newline
{\ttfamily \#include $<$algorithm$>$}\newline
{\ttfamily \#include $<$array$>$}\newline
{\ttfamily \#include $<$exception$>$}\newline
{\ttfamily \#include $<$functional$>$}\newline
{\ttfamily \#include $<$iostream$>$}\newline
{\ttfamily \#include $<$new$>$}\newline
{\ttfamily \#include $<$vector$>$}\newline
Include dependency graph for tree.\+h\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{tree_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{tree_8h__dep__incl}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node$<$ T $>$}
\begin{DoxyCompactList}\small\item\em Class for binary tree node. \end{DoxyCompactList}\item 
class \hyperlink{classTreeNode}{Tree\+Node$<$ T, N $>$}
\begin{DoxyCompactList}\small\item\em Class for general tree node. \end{DoxyCompactList}\end{DoxyCompactItemize}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{tree_8h_a922ca07db9633957939f697a65aff11d}{Tree\+Node\+Split\+Mode} \{ {\bfseries Horizontal\+Split\+Mode}, 
{\bfseries Vertical\+Split\+Mode}, 
{\bfseries Cross\+Split\+Mode}, 
{\bfseries Unsplit\+Mode}
 \}
\item 
{\footnotesize template$<$typename T $>$ }\\\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$ \hyperlink{tree_8h_a330672af8616e2ac4eb794536a8dab29}{Create\+Tree\+Node} (const T \&data, unsigned int level=0, \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$left=nullptr, \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$right=nullptr, \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$parent=nullptr)
\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\\hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$ \hyperlink{tree_8h_adc1e8ab25d385a563b0db275eda3341e}{Create\+Tree\+Node} (const T \&data, unsigned int level, const std\+::array$<$ \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$, N $>$ \&children, \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$parent=nullptr, \hyperlink{tree_8h_a922ca07db9633957939f697a65aff11d}{Tree\+Node\+Split\+Mode} split\+\_\+mode=Unsplit\+Mode)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{tree_8h_aac8275ded0edcb76d9bdc1b28b236c55}{Delete\+Tree\+Node} (const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$p)
\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\void \hyperlink{tree_8h_a0d1ea365ebbf17fc54675bd2119c7806}{Delete\+Tree\+Node} (const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$p)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{tree_8h_ac1ff54ed810ce602e31c7014d433a32a}{Print\+Tree\+Node} (std\+::ostream \&out, const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$p)
\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\void \hyperlink{tree_8h_ac79780d9ce7a15217bb16825ac5dd667}{Print\+Tree\+Node} (std\+::ostream \&out, const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$p)
\item 
{\footnotesize template$<$typename T $>$ }\\unsigned int \hyperlink{tree_8h_a9880a9179821bf75db4aa7b241d6306c}{calc\+\_\+depth} (const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$p)
\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\unsigned int \hyperlink{tree_8h_ad3a6aa99a2fcecf4e175267c47e34496}{calc\+\_\+depth} (\hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$p)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{tree_8h_a061ad9bc5f1538bf17f8edff53f93692}{Preorder} (\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$p, std\+::function$<$ void(\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$)$>$ operate)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{tree_8h_aadc45736974d58f073fd1c55cfacf0af}{Preorder} (const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$p, std\+::function$<$ void(const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$)$>$ operate)
\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\void \hyperlink{tree_8h_a84858a26871e87d4a60b8276da29fa7a}{Preorder} (\hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$p, std\+::function$<$ void(\hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$)$>$ operate)
\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\void \hyperlink{tree_8h_a351fa2fd9df6902a69c6fdf62bc2e8a3}{Preorder} (const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$p, std\+::function$<$ void(const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$)$>$ operate)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{tree_8h_a5722c24f5711b194e17f1276f73238aa}{Inorder} (\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$p, std\+::function$<$ void(\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$)$>$ operate)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{tree_8h_a9bbb5d6dc0c310f52b61917bef354a65}{Inorder} (const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$p, std\+::function$<$ void(const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$)$>$ operate)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{tree_8h_a795a488977c9d18c51d7ecb4cbbf6b4e}{Postorder} (\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$p, std\+::function$<$ void(\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$)$>$ operate)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{tree_8h_a2052355959626f8e868e94213f9f2e27}{Postorder} (const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$p, std\+::function$<$ void(const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$)$>$ operate)
\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\void \hyperlink{tree_8h_a303afb5f20bab76a42a9b9131a8ba198}{Postorder} (\hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$p, std\+::function$<$ void(\hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$)$>$ operate)
\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\void \hyperlink{tree_8h_a504c448dd213be47792112f59d3b40e2}{Postorder} (const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$p, std\+::function$<$ void(const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$)$>$ operate)
\item 
{\footnotesize template$<$typename T $>$ }\\\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$ \hyperlink{tree_8h_a19010552004cddb2c5629712435b79c2}{Copy\+Tree} (const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$p)
\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\\hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$ \hyperlink{tree_8h_a9d481b23edef52959501ec228c739f5a}{Copy\+Tree} (const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$p)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{tree_8h_ade4e0de136e8a9c2ad63dc993f179f73}{Get\+Tree\+Leaves} (const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$p, std\+::vector$<$ \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$$>$ \&leaf\+\_\+set)
\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\void \hyperlink{tree_8h_a6afdf668f762a15b07ff923f4a176473}{Get\+Tree\+Leaves} (const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$p, std\+::vector$<$ \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$$>$ \&leaf\+\_\+set)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{tree_8h_ab16ac39ab42152858920f34e85430e0d}{Print\+Tree} (std\+::ostream \&out, const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$p)
\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\void \hyperlink{tree_8h_a1a8f56da4fe89fcb7c8963a6a17b2eaa}{Print\+Tree} (std\+::ostream \&out, const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$p)
\item 
{\footnotesize template$<$typename T $>$ }\\unsigned int \hyperlink{tree_8h_a0242ff1112ca2bb585990416bd04a666}{Count\+Tree\+Nodes} (const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$p)
\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\unsigned int \hyperlink{tree_8h_af40388adab3384b5f89dc42fed14b8ab}{Count\+Tree\+Nodes} (const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$p)
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{tree_8h_a95dd5928a5634c270b46685504798903}{Delete\+Tree} (const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$p)
\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\void \hyperlink{tree_8h_a70857c1127906fef58479f4d1bc79a39}{Delete\+Tree} (const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$p)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Implementation of the classes for binary tree node, general tree node and functions for manipulating the trees constructed from these nodes. 

\begin{DoxyDate}{Date}
2021-\/04-\/18 
\end{DoxyDate}
\begin{DoxyAuthor}{Author}
Jihuan Tian 
\end{DoxyAuthor}


\subsection{Enumeration Type Documentation}
\mbox{\Hypertarget{tree_8h_a922ca07db9633957939f697a65aff11d}\label{tree_8h_a922ca07db9633957939f697a65aff11d}} 
\index{tree.\+h@{tree.\+h}!Tree\+Node\+Split\+Mode@{Tree\+Node\+Split\+Mode}}
\index{Tree\+Node\+Split\+Mode@{Tree\+Node\+Split\+Mode}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Tree\+Node\+Split\+Mode}{TreeNodeSplitMode}}
{\footnotesize\ttfamily enum \hyperlink{tree_8h_a922ca07db9633957939f697a65aff11d}{Tree\+Node\+Split\+Mode}}

The splitting mode for a tree node, which can be cross split ({\ttfamily Cross\+Split\+Mode}), horizontal split ({\ttfamily Horizontal\+Split\+Mode}), vertical split ({\ttfamily Vertical\+Split\+Mode}) and unsplit ({\ttfamily Unsplit\+Mode}).


\begin{DoxyDescription}
\item[Note ]
\begin{DoxyEnumerate}
\item When a tree node has four children, which are constructed via a tensor product of the children of the $\tau$ cluster and the children of the $\sigma$ cluster, it must be cross split.
\item When a tree node has two children, which are constructed via a tensor product of the children of the $\tau$ cluster and the $\sigma$ cluster, i.\+e. only the rows of the associated $\mathcal{H}$-\/matrix node will be split, then it should be horizontal split.
\item When a tree node has two children, which are constructed via a tensor product of the $\tau$ cluster and the children of the $\sigma$ cluster, i.\+e. only the columns of the associated $\mathcal{H}$-\/matrix node will be split, then it should be vertical split.  
\end{DoxyEnumerate}
\end{DoxyDescription}

\subsection{Function Documentation}
\mbox{\Hypertarget{tree_8h_a9880a9179821bf75db4aa7b241d6306c}\label{tree_8h_a9880a9179821bf75db4aa7b241d6306c}} 
\index{tree.\+h@{tree.\+h}!calc\+\_\+depth@{calc\+\_\+depth}}
\index{calc\+\_\+depth@{calc\+\_\+depth}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{calc\+\_\+depth()}{calc\_depth()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
unsigned int calc\+\_\+depth (\begin{DoxyParamCaption}\item[{const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$}]{p }\end{DoxyParamCaption})}

Calculate the depth of a Binary\+Tree using recursion. 

References Binary\+Tree\+Node$<$ T $>$\+::\+Left(), and Binary\+Tree\+Node$<$ T $>$\+::\+Right().



Referenced by calc\+\_\+depth(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level(), and Cluster\+Tree$<$ spacedim, Number $>$\+::partition().

\mbox{\Hypertarget{tree_8h_ad3a6aa99a2fcecf4e175267c47e34496}\label{tree_8h_ad3a6aa99a2fcecf4e175267c47e34496}} 
\index{tree.\+h@{tree.\+h}!calc\+\_\+depth@{calc\+\_\+depth}}
\index{calc\+\_\+depth@{calc\+\_\+depth}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{calc\+\_\+depth()}{calc\_depth()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
unsigned int calc\+\_\+depth (\begin{DoxyParamCaption}\item[{\hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$}]{p }\end{DoxyParamCaption})}

Calculate the depth of a \hyperlink{classTreeNode}{Tree\+Node} using recursion. 

References calc\+\_\+depth(), and Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+pointer().

\mbox{\Hypertarget{tree_8h_a19010552004cddb2c5629712435b79c2}\label{tree_8h_a19010552004cddb2c5629712435b79c2}} 
\index{tree.\+h@{tree.\+h}!Copy\+Tree@{Copy\+Tree}}
\index{Copy\+Tree@{Copy\+Tree}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Copy\+Tree()}{CopyTree()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$T$>$$\ast$ Copy\+Tree (\begin{DoxyParamCaption}\item[{const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$}]{p }\end{DoxyParamCaption})}

Copy the current node to a new node without setting children, parent and child\+\_\+num at the moment.

Associate the newly created left child node with the current node.

Associate the newly created right child node with the current node.

References Create\+Tree\+Node(), Binary\+Tree\+Node$<$ T $>$\+::get\+\_\+data\+\_\+reference(), Binary\+Tree\+Node$<$ T $>$\+::get\+\_\+level(), Binary\+Tree\+Node$<$ T $>$\+::increase\+\_\+child\+\_\+num(), Binary\+Tree\+Node$<$ T $>$\+::\+Left(), and Binary\+Tree\+Node$<$ T $>$\+::\+Right().



Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::\+Block\+Cluster\+Tree(), Cluster\+Tree$<$ spacedim, Number $>$\+::\+Cluster\+Tree(), Copy\+Tree(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::operator=().

\mbox{\Hypertarget{tree_8h_a9d481b23edef52959501ec228c739f5a}\label{tree_8h_a9d481b23edef52959501ec228c739f5a}} 
\index{tree.\+h@{tree.\+h}!Copy\+Tree@{Copy\+Tree}}
\index{Copy\+Tree@{Copy\+Tree}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Copy\+Tree()}{CopyTree()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
\hyperlink{classTreeNode}{Tree\+Node}$<$T, N$>$$\ast$ Copy\+Tree (\begin{DoxyParamCaption}\item[{const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$}]{p }\end{DoxyParamCaption})}

Perform deep copy of a tree. 
\begin{DoxyParams}{Parameters}
{\em p} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
Create and copy the current node.

References Copy\+Tree(), Create\+Tree\+Node(), Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+num(), Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+pointer(), Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+reference(), Tree\+Node$<$ T, N $>$\+::get\+\_\+level(), Tree\+Node$<$ T, N $>$\+::get\+\_\+split\+\_\+mode(), Tree\+Node$<$ T, N $>$\+::increase\+\_\+child\+\_\+num(), Tree\+Node$<$ T, N $>$\+::\+Parent(), and Tree\+Node$<$ T, N $>$\+::set\+\_\+child\+\_\+pointer().

\mbox{\Hypertarget{tree_8h_a0242ff1112ca2bb585990416bd04a666}\label{tree_8h_a0242ff1112ca2bb585990416bd04a666}} 
\index{tree.\+h@{tree.\+h}!Count\+Tree\+Nodes@{Count\+Tree\+Nodes}}
\index{Count\+Tree\+Nodes@{Count\+Tree\+Nodes}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Count\+Tree\+Nodes()}{CountTreeNodes()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
unsigned int Count\+Tree\+Nodes (\begin{DoxyParamCaption}\item[{const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$}]{p }\end{DoxyParamCaption})}

Count the total number of the binary tree nodes by recursion. 

References Binary\+Tree\+Node$<$ T $>$\+::\+Left(), and Binary\+Tree\+Node$<$ T $>$\+::\+Right().



Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::\+Block\+Cluster\+Tree(), Count\+Tree\+Nodes(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::prune\+\_\+descendants\+\_\+from\+\_\+node().

\mbox{\Hypertarget{tree_8h_af40388adab3384b5f89dc42fed14b8ab}\label{tree_8h_af40388adab3384b5f89dc42fed14b8ab}} 
\index{tree.\+h@{tree.\+h}!Count\+Tree\+Nodes@{Count\+Tree\+Nodes}}
\index{Count\+Tree\+Nodes@{Count\+Tree\+Nodes}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Count\+Tree\+Nodes()}{CountTreeNodes()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
unsigned int Count\+Tree\+Nodes (\begin{DoxyParamCaption}\item[{const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$}]{p }\end{DoxyParamCaption})}

Count the total number of the tree nodes by recursion. 

References Count\+Tree\+Nodes(), and Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+pointer().

\mbox{\Hypertarget{tree_8h_a330672af8616e2ac4eb794536a8dab29}\label{tree_8h_a330672af8616e2ac4eb794536a8dab29}} 
\index{tree.\+h@{tree.\+h}!Create\+Tree\+Node@{Create\+Tree\+Node}}
\index{Create\+Tree\+Node@{Create\+Tree\+Node}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Create\+Tree\+Node()}{CreateTreeNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$T$>$$\ast$ Create\+Tree\+Node (\begin{DoxyParamCaption}\item[{const T \&}]{data,  }\item[{unsigned int}]{level = {\ttfamily 0},  }\item[{\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$}]{left = {\ttfamily nullptr},  }\item[{\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$}]{right = {\ttfamily nullptr},  }\item[{\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$}]{parent = {\ttfamily nullptr} }\end{DoxyParamCaption})}

Create a new binary tree node from the provided data. 

Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::\+Block\+Cluster\+Tree(), and Copy\+Tree().

\mbox{\Hypertarget{tree_8h_adc1e8ab25d385a563b0db275eda3341e}\label{tree_8h_adc1e8ab25d385a563b0db275eda3341e}} 
\index{tree.\+h@{tree.\+h}!Create\+Tree\+Node@{Create\+Tree\+Node}}
\index{Create\+Tree\+Node@{Create\+Tree\+Node}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Create\+Tree\+Node()}{CreateTreeNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
\hyperlink{classTreeNode}{Tree\+Node}$<$T, N$>$$\ast$ Create\+Tree\+Node (\begin{DoxyParamCaption}\item[{const T \&}]{data,  }\item[{unsigned int}]{level,  }\item[{const std\+::array$<$ \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$, N $>$ \&}]{children,  }\item[{\hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$}]{parent = {\ttfamily nullptr},  }\item[{\hyperlink{tree_8h_a922ca07db9633957939f697a65aff11d}{Tree\+Node\+Split\+Mode}}]{split\+\_\+mode = {\ttfamily UnsplitMode} }\end{DoxyParamCaption})}

Create a new tree node from the provided data. \mbox{\Hypertarget{tree_8h_a95dd5928a5634c270b46685504798903}\label{tree_8h_a95dd5928a5634c270b46685504798903}} 
\index{tree.\+h@{tree.\+h}!Delete\+Tree@{Delete\+Tree}}
\index{Delete\+Tree@{Delete\+Tree}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Delete\+Tree()}{DeleteTree()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Delete\+Tree (\begin{DoxyParamCaption}\item[{const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$}]{p }\end{DoxyParamCaption})}

Use the Delete a whole binary tree using post-\/order traversal. 

Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::prune\+\_\+descendants\+\_\+from\+\_\+node(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::release(), and Cluster\+Tree$<$ spacedim, Number $>$\+::$\sim$\+Cluster\+Tree().

\mbox{\Hypertarget{tree_8h_a70857c1127906fef58479f4d1bc79a39}\label{tree_8h_a70857c1127906fef58479f4d1bc79a39}} 
\index{tree.\+h@{tree.\+h}!Delete\+Tree@{Delete\+Tree}}
\index{Delete\+Tree@{Delete\+Tree}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Delete\+Tree()}{DeleteTree()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
void Delete\+Tree (\begin{DoxyParamCaption}\item[{const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$}]{p }\end{DoxyParamCaption})}

Use the Delete a whole tree using post-\/order traversal. \mbox{\Hypertarget{tree_8h_aac8275ded0edcb76d9bdc1b28b236c55}\label{tree_8h_aac8275ded0edcb76d9bdc1b28b236c55}} 
\index{tree.\+h@{tree.\+h}!Delete\+Tree\+Node@{Delete\+Tree\+Node}}
\index{Delete\+Tree\+Node@{Delete\+Tree\+Node}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Delete\+Tree\+Node()}{DeleteTreeNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Delete\+Tree\+Node (\begin{DoxyParamCaption}\item[{const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$}]{p }\end{DoxyParamCaption})}

Destroy a binary tree node. \mbox{\Hypertarget{tree_8h_a0d1ea365ebbf17fc54675bd2119c7806}\label{tree_8h_a0d1ea365ebbf17fc54675bd2119c7806}} 
\index{tree.\+h@{tree.\+h}!Delete\+Tree\+Node@{Delete\+Tree\+Node}}
\index{Delete\+Tree\+Node@{Delete\+Tree\+Node}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Delete\+Tree\+Node()}{DeleteTreeNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
void Delete\+Tree\+Node (\begin{DoxyParamCaption}\item[{const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$}]{p }\end{DoxyParamCaption})}

Destroy a tree node. \mbox{\Hypertarget{tree_8h_ade4e0de136e8a9c2ad63dc993f179f73}\label{tree_8h_ade4e0de136e8a9c2ad63dc993f179f73}} 
\index{tree.\+h@{tree.\+h}!Get\+Tree\+Leaves@{Get\+Tree\+Leaves}}
\index{Get\+Tree\+Leaves@{Get\+Tree\+Leaves}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Get\+Tree\+Leaves()}{GetTreeLeaves()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Get\+Tree\+Leaves (\begin{DoxyParamCaption}\item[{const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$}]{p,  }\item[{std\+::vector$<$ \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$$>$ \&}]{leaf\+\_\+set }\end{DoxyParamCaption})}

Construct the leaf set of a binary tree.


\begin{DoxyDescription}
\item[Note ]The leaf set should be cleared before calling this function. 
\end{DoxyDescription}


\begin{DoxyParams}{Parameters}
{\em p} & \\
\hline
{\em leaf\+\_\+set} & \\
\hline
\end{DoxyParams}
If the current node has no children, append it to the leaf set.

If the current node has children, recursively collect leaves from its left and right children.

References Binary\+Tree\+Node$<$ T $>$\+::get\+\_\+child\+\_\+num(), Binary\+Tree\+Node$<$ T $>$\+::\+Left(), and Binary\+Tree\+Node$<$ T $>$\+::\+Right().



Referenced by Cluster\+Tree$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), and Get\+Tree\+Leaves().

\mbox{\Hypertarget{tree_8h_a6afdf668f762a15b07ff923f4a176473}\label{tree_8h_a6afdf668f762a15b07ff923f4a176473}} 
\index{tree.\+h@{tree.\+h}!Get\+Tree\+Leaves@{Get\+Tree\+Leaves}}
\index{Get\+Tree\+Leaves@{Get\+Tree\+Leaves}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Get\+Tree\+Leaves()}{GetTreeLeaves()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
void Get\+Tree\+Leaves (\begin{DoxyParamCaption}\item[{const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$}]{p,  }\item[{std\+::vector$<$ \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$$>$ \&}]{leaf\+\_\+set }\end{DoxyParamCaption})}

Construct the leaf set of a general tree.


\begin{DoxyDescription}
\item[Note ]The leaf set should be cleared before calling this function. 
\end{DoxyDescription}


\begin{DoxyParams}{Parameters}
{\em p} & \\
\hline
{\em leaf\+\_\+set} & \\
\hline
\end{DoxyParams}
If the current node has no children, append it to the leaf set.

If the current node has children, recursively collect leaves from each of its children.

References Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+num(), Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+pointer(), and Get\+Tree\+Leaves().

\mbox{\Hypertarget{tree_8h_a5722c24f5711b194e17f1276f73238aa}\label{tree_8h_a5722c24f5711b194e17f1276f73238aa}} 
\index{tree.\+h@{tree.\+h}!Inorder@{Inorder}}
\index{Inorder@{Inorder}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Inorder()}{Inorder()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Inorder (\begin{DoxyParamCaption}\item[{\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$}]{p,  }\item[{std\+::function$<$ void(\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$)$>$}]{operate }\end{DoxyParamCaption})}

In-\/order traverse of a binary tree. 

References Binary\+Tree\+Node$<$ T $>$\+::\+Left(), and Binary\+Tree\+Node$<$ T $>$\+::\+Right().



Referenced by Inorder().

\mbox{\Hypertarget{tree_8h_a9bbb5d6dc0c310f52b61917bef354a65}\label{tree_8h_a9bbb5d6dc0c310f52b61917bef354a65}} 
\index{tree.\+h@{tree.\+h}!Inorder@{Inorder}}
\index{Inorder@{Inorder}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Inorder()}{Inorder()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Inorder (\begin{DoxyParamCaption}\item[{const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$}]{p,  }\item[{std\+::function$<$ void(const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$)$>$}]{operate }\end{DoxyParamCaption})}

In-\/order traverse of a binary tree (const version). 

References Inorder(), Binary\+Tree\+Node$<$ T $>$\+::\+Left(), and Binary\+Tree\+Node$<$ T $>$\+::\+Right().

\mbox{\Hypertarget{tree_8h_a795a488977c9d18c51d7ecb4cbbf6b4e}\label{tree_8h_a795a488977c9d18c51d7ecb4cbbf6b4e}} 
\index{tree.\+h@{tree.\+h}!Postorder@{Postorder}}
\index{Postorder@{Postorder}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Postorder()}{Postorder()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Postorder (\begin{DoxyParamCaption}\item[{\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$}]{p,  }\item[{std\+::function$<$ void(\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$)$>$}]{operate }\end{DoxyParamCaption})}

Post-\/order traverse of a binary tree. 

References Binary\+Tree\+Node$<$ T $>$\+::\+Left(), and Binary\+Tree\+Node$<$ T $>$\+::\+Right().



Referenced by Postorder().

\mbox{\Hypertarget{tree_8h_a2052355959626f8e868e94213f9f2e27}\label{tree_8h_a2052355959626f8e868e94213f9f2e27}} 
\index{tree.\+h@{tree.\+h}!Postorder@{Postorder}}
\index{Postorder@{Postorder}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Postorder()}{Postorder()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Postorder (\begin{DoxyParamCaption}\item[{const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$}]{p,  }\item[{std\+::function$<$ void(const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$)$>$}]{operate }\end{DoxyParamCaption})}

Post-\/order traverse of a binary tree (const version). 

References Binary\+Tree\+Node$<$ T $>$\+::\+Left(), Postorder(), and Binary\+Tree\+Node$<$ T $>$\+::\+Right().

\mbox{\Hypertarget{tree_8h_a303afb5f20bab76a42a9b9131a8ba198}\label{tree_8h_a303afb5f20bab76a42a9b9131a8ba198}} 
\index{tree.\+h@{tree.\+h}!Postorder@{Postorder}}
\index{Postorder@{Postorder}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Postorder()}{Postorder()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
void Postorder (\begin{DoxyParamCaption}\item[{\hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$}]{p,  }\item[{std\+::function$<$ void(\hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$)$>$}]{operate }\end{DoxyParamCaption})}

Post-\/order traverse of a tree. Recursively call the operate function on each child.

References Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+pointer(), and Postorder().

\mbox{\Hypertarget{tree_8h_a504c448dd213be47792112f59d3b40e2}\label{tree_8h_a504c448dd213be47792112f59d3b40e2}} 
\index{tree.\+h@{tree.\+h}!Postorder@{Postorder}}
\index{Postorder@{Postorder}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Postorder()}{Postorder()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
void Postorder (\begin{DoxyParamCaption}\item[{const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$}]{p,  }\item[{std\+::function$<$ void(const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$)$>$}]{operate }\end{DoxyParamCaption})}

Post-\/order traverse of a tree (const version). Recursively call the operate function on each child.

References Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+pointer(), and Postorder().

\mbox{\Hypertarget{tree_8h_a061ad9bc5f1538bf17f8edff53f93692}\label{tree_8h_a061ad9bc5f1538bf17f8edff53f93692}} 
\index{tree.\+h@{tree.\+h}!Preorder@{Preorder}}
\index{Preorder@{Preorder}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Preorder()}{Preorder()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Preorder (\begin{DoxyParamCaption}\item[{\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$}]{p,  }\item[{std\+::function$<$ void(\hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$)$>$}]{operate }\end{DoxyParamCaption})}

Pre-\/order traverse of a binary tree. 

References Binary\+Tree\+Node$<$ T $>$\+::\+Left(), and Binary\+Tree\+Node$<$ T $>$\+::\+Right().



Referenced by Preorder().

\mbox{\Hypertarget{tree_8h_aadc45736974d58f073fd1c55cfacf0af}\label{tree_8h_aadc45736974d58f073fd1c55cfacf0af}} 
\index{tree.\+h@{tree.\+h}!Preorder@{Preorder}}
\index{Preorder@{Preorder}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Preorder()}{Preorder()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Preorder (\begin{DoxyParamCaption}\item[{const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$}]{p,  }\item[{std\+::function$<$ void(const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$)$>$}]{operate }\end{DoxyParamCaption})}

Pre-\/order traverse of a binary tree (const version). 

References Binary\+Tree\+Node$<$ T $>$\+::\+Left(), Preorder(), and Binary\+Tree\+Node$<$ T $>$\+::\+Right().

\mbox{\Hypertarget{tree_8h_a84858a26871e87d4a60b8276da29fa7a}\label{tree_8h_a84858a26871e87d4a60b8276da29fa7a}} 
\index{tree.\+h@{tree.\+h}!Preorder@{Preorder}}
\index{Preorder@{Preorder}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Preorder()}{Preorder()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
void Preorder (\begin{DoxyParamCaption}\item[{\hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$}]{p,  }\item[{std\+::function$<$ void(\hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$)$>$}]{operate }\end{DoxyParamCaption})}

Pre-\/order traverse of a tree. Recursively call the function itself on each child.

References Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+pointer(), and Preorder().

\mbox{\Hypertarget{tree_8h_a351fa2fd9df6902a69c6fdf62bc2e8a3}\label{tree_8h_a351fa2fd9df6902a69c6fdf62bc2e8a3}} 
\index{tree.\+h@{tree.\+h}!Preorder@{Preorder}}
\index{Preorder@{Preorder}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Preorder()}{Preorder()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
void Preorder (\begin{DoxyParamCaption}\item[{const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$}]{p,  }\item[{std\+::function$<$ void(const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$)$>$}]{operate }\end{DoxyParamCaption})}

Pre-\/order traverse of a tree (const version). Recursively call the operate function on each child.

References Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+pointer(), and Preorder().

\mbox{\Hypertarget{tree_8h_ab16ac39ab42152858920f34e85430e0d}\label{tree_8h_ab16ac39ab42152858920f34e85430e0d}} 
\index{tree.\+h@{tree.\+h}!Print\+Tree@{Print\+Tree}}
\index{Print\+Tree@{Print\+Tree}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Print\+Tree()}{PrintTree()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Print\+Tree (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out,  }\item[{const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$}]{p }\end{DoxyParamCaption})}

Print a binary tree recursively by starting from a node. \mbox{\Hypertarget{tree_8h_a1a8f56da4fe89fcb7c8963a6a17b2eaa}\label{tree_8h_a1a8f56da4fe89fcb7c8963a6a17b2eaa}} 
\index{tree.\+h@{tree.\+h}!Print\+Tree@{Print\+Tree}}
\index{Print\+Tree@{Print\+Tree}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Print\+Tree()}{PrintTree()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
void Print\+Tree (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out,  }\item[{const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$}]{p }\end{DoxyParamCaption})}

Print a tree recursively by starting from a node. \mbox{\Hypertarget{tree_8h_ac1ff54ed810ce602e31c7014d433a32a}\label{tree_8h_ac1ff54ed810ce602e31c7014d433a32a}} 
\index{tree.\+h@{tree.\+h}!Print\+Tree\+Node@{Print\+Tree\+Node}}
\index{Print\+Tree\+Node@{Print\+Tree\+Node}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Print\+Tree\+Node()}{PrintTreeNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Print\+Tree\+Node (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out,  }\item[{const \hyperlink{classBinaryTreeNode}{Binary\+Tree\+Node}$<$ T $>$ $\ast$}]{p }\end{DoxyParamCaption})}

Print the data contained in a binary tree node. 

References Binary\+Tree\+Node$<$ T $>$\+::get\+\_\+child\+\_\+num(), Binary\+Tree\+Node$<$ T $>$\+::get\+\_\+data\+\_\+reference(), Binary\+Tree\+Node$<$ T $>$\+::get\+\_\+level(), and Binary\+Tree\+Node$<$ T $>$\+::\+Parent().

\mbox{\Hypertarget{tree_8h_ac79780d9ce7a15217bb16825ac5dd667}\label{tree_8h_ac79780d9ce7a15217bb16825ac5dd667}} 
\index{tree.\+h@{tree.\+h}!Print\+Tree\+Node@{Print\+Tree\+Node}}
\index{Print\+Tree\+Node@{Print\+Tree\+Node}!tree.\+h@{tree.\+h}}
\subsubsection{\texorpdfstring{Print\+Tree\+Node()}{PrintTreeNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
void Print\+Tree\+Node (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out,  }\item[{const \hyperlink{classTreeNode}{Tree\+Node}$<$ T, N $>$ $\ast$}]{p }\end{DoxyParamCaption})}

Print the data contained in a tree node. 

References Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+num(), Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+reference(), Tree\+Node$<$ T, N $>$\+::get\+\_\+level(), Tree\+Node$<$ T, N $>$\+::get\+\_\+split\+\_\+mode(), and Tree\+Node$<$ T, N $>$\+::\+Parent().

