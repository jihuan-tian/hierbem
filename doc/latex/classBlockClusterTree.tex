\hypertarget{classBlockClusterTree}{}\section{Block\+Cluster\+Tree$<$ spacedim, Number $>$ Class Template Reference}
\label{classBlockClusterTree}\index{Block\+Cluster\+Tree$<$ spacedim, Number $>$@{Block\+Cluster\+Tree$<$ spacedim, Number $>$}}


Class for block cluster tree.  




{\ttfamily \#include $<$block\+\_\+cluster\+\_\+tree.\+h$>$}



Collaboration diagram for Block\+Cluster\+Tree$<$ spacedim, Number $>$\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classBlockClusterTree__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classTreeNode}{Tree\+Node}$<$ \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim, Number $>$, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}{child\+\_\+num} $>$ \hyperlink{classBlockClusterTree_a960c20eac27464dedd804261f185c61f}{node\+\_\+value\+\_\+type}
\item 
\mbox{\Hypertarget{classBlockClusterTree_a0fe6521e231371ee47687fc4ada1734a}\label{classBlockClusterTree_a0fe6521e231371ee47687fc4ada1734a}} 
typedef \hyperlink{classTreeNode}{Tree\+Node}$<$ \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim, Number $>$, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}{child\+\_\+num} $>$ $\ast$ {\bfseries node\+\_\+pointer\+\_\+type}
\item 
\mbox{\Hypertarget{classBlockClusterTree_ae009f8c6e64ac756770678366cf5e924}\label{classBlockClusterTree_ae009f8c6e64ac756770678366cf5e924}} 
typedef const \hyperlink{classTreeNode}{Tree\+Node}$<$ \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim, Number $>$, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}{child\+\_\+num} $>$ $\ast$ {\bfseries node\+\_\+const\+\_\+pointer\+\_\+type}
\item 
\mbox{\Hypertarget{classBlockClusterTree_acff2ef08707f864bce5da02be6f9f8a9}\label{classBlockClusterTree_acff2ef08707f864bce5da02be6f9f8a9}} 
typedef \hyperlink{classTreeNode}{Tree\+Node}$<$ \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim, Number $>$, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}{child\+\_\+num} $>$ \& {\bfseries node\+\_\+reference\+\_\+type}
\item 
\mbox{\Hypertarget{classBlockClusterTree_ac5dc9f60e63b4024045d1c0c41f92f5a}\label{classBlockClusterTree_ac5dc9f60e63b4024045d1c0c41f92f5a}} 
typedef const \hyperlink{classTreeNode}{Tree\+Node}$<$ \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim, Number $>$, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}{child\+\_\+num} $>$ \& {\bfseries node\+\_\+const\+\_\+reference\+\_\+type}
\item 
typedef \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim, Number $>$ \hyperlink{classBlockClusterTree_a4d03fe184a7f7838111b27cdae056a62}{data\+\_\+value\+\_\+type}
\item 
\mbox{\Hypertarget{classBlockClusterTree_a0480a48aa335fd1adeec9ffdc8086193}\label{classBlockClusterTree_a0480a48aa335fd1adeec9ffdc8086193}} 
typedef \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim, Number $>$ $\ast$ {\bfseries data\+\_\+pointer\+\_\+type}
\item 
\mbox{\Hypertarget{classBlockClusterTree_a179b726b207148de1b866d5c36915809}\label{classBlockClusterTree_a179b726b207148de1b866d5c36915809}} 
typedef const \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim, Number $>$ $\ast$ {\bfseries data\+\_\+const\+\_\+pointer\+\_\+type}
\item 
\mbox{\Hypertarget{classBlockClusterTree_a62869615d2fd6ec6bf58163e3b36bca1}\label{classBlockClusterTree_a62869615d2fd6ec6bf58163e3b36bca1}} 
typedef \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim, Number $>$ \& {\bfseries data\+\_\+reference\+\_\+type}
\item 
\mbox{\Hypertarget{classBlockClusterTree_a3ae82489506a1d2a0ff3cf0a4039b9f9}\label{classBlockClusterTree_a3ae82489506a1d2a0ff3cf0a4039b9f9}} 
typedef const \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim, Number $>$ \& {\bfseries data\+\_\+const\+\_\+reference\+\_\+type}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classBlockClusterTree_a967049a8deecb49c36492ffdf64349cd}\label{classBlockClusterTree_a967049a8deecb49c36492ffdf64349cd}} 
{\bfseries Decl\+Exception2} (Exc\+Cluster\+Level\+Mismatch, unsigned int, unsigned int,$<$$<$ \char`\"{}The level of cluster tau \char`\"{}$<$$<$ arg1$<$$<$ \char`\"{} is different from that of cluster sigma\char`\"{}$<$$<$ arg2$<$$<$ \char`\"{} which is not allowed in a level preserving construction of a block cluster tree.\char`\"{})
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const unsigned int \hyperlink{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}{child\+\_\+num} = 4
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classBlockClusterTree_ac1111e02e99c25545857e6ce85c73fa0}\label{classBlockClusterTree_ac1111e02e99c25545857e6ce85c73fa0}} 
\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} {\bfseries root\+\_\+node}
\item 
\mbox{\Hypertarget{classBlockClusterTree_a4a070c8bebf3afb8eac8348be3cae226}\label{classBlockClusterTree_a4a070c8bebf3afb8eac8348be3cae226}} 
std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ {\bfseries leaf\+\_\+set}
\item 
\mbox{\Hypertarget{classBlockClusterTree_a91ff2520dacea664e08437b3bc54034a}\label{classBlockClusterTree_a91ff2520dacea664e08437b3bc54034a}} 
std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ {\bfseries near\+\_\+field\+\_\+set}
\item 
\mbox{\Hypertarget{classBlockClusterTree_afb80508e2eceac6545cdbac7310fcaa3}\label{classBlockClusterTree_afb80508e2eceac6545cdbac7310fcaa3}} 
std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ {\bfseries far\+\_\+field\+\_\+set}
\item 
\mbox{\Hypertarget{classBlockClusterTree_ab47a6ccabcf386897ea3fa4341827c25}\label{classBlockClusterTree_ab47a6ccabcf386897ea3fa4341827c25}} 
unsigned int {\bfseries n\+\_\+min}
\item 
\mbox{\Hypertarget{classBlockClusterTree_affa858180dc35e877eb64ab2afd1baef}\label{classBlockClusterTree_affa858180dc35e877eb64ab2afd1baef}} 
Number {\bfseries eta}
\item 
unsigned int \hyperlink{classBlockClusterTree_a77349ec9ccb36d45af3f176a93516897}{depth}
\item 
int \hyperlink{classBlockClusterTree_a9151f138713d01c53ac17f004c7e6b62}{max\+\_\+level}
\item 
unsigned int \hyperlink{classBlockClusterTree_a75757146cea0aa0e9271b760b1d76307}{node\+\_\+num}
\item 
bool \hyperlink{classBlockClusterTree_a8dc01af98989bb71246fa2cd4d7307da}{is\+\_\+subtree}
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\std\+::ostream \& \hyperlink{classBlockClusterTree_a6ead7d49add78a2462eb039f00bf7f6a}{operator$<$$<$} (std\+::ostream \&out, const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$ \&block\+\_\+cluster\+\_\+tree)
\item 
\mbox{\Hypertarget{classBlockClusterTree_a3f70501fa33bdb6761b998978b59f1b0}\label{classBlockClusterTree_a3f70501fa33bdb6761b998978b59f1b0}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries split\+\_\+block\+\_\+cluster\+\_\+node} (\hyperlink{classTreeNode}{Tree\+Node}$<$ \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim1, Number1 $>$, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::\hyperlink{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}{child\+\_\+num} $>$ $\ast$bc\+\_\+node, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$ \&bc\+\_\+tree, const \hyperlink{tree_8h_a922ca07db9633957939f697a65aff11d}{Tree\+Node\+Split\+Mode} split\+\_\+mode, const bool if\+\_\+add\+\_\+child\+\_\+nodes\+\_\+to\+\_\+leaf\+\_\+set)
\item 
\mbox{\Hypertarget{classBlockClusterTree_a75196d39c6db593dfdaa17f0f0cd8042}\label{classBlockClusterTree_a75196d39c6db593dfdaa17f0f0cd8042}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\bool {\bfseries prune\+\_\+to\+\_\+partition\+\_\+recursion} (\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$ \&bct, const std\+::vector$<$ \hyperlink{classTreeNode}{Tree\+Node}$<$ \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim1, Number1 $>$, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::\hyperlink{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}{child\+\_\+num} $>$ $\ast$$>$ \&\hyperlink{classBlockClusterTree_a3ca42421f732c20fc07bdf5d5ab94319}{partition}, \hyperlink{classTreeNode}{Tree\+Node}$<$ \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim1, Number1 $>$, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::\hyperlink{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}{child\+\_\+num} $>$ $\ast$bc\+\_\+node)
\item 
\mbox{\Hypertarget{classBlockClusterTree_a4be1a37fb4e8389d1035c532102aa20b}\label{classBlockClusterTree_a4be1a37fb4e8389d1035c532102aa20b}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\\hyperlink{classTreeNode}{Tree\+Node}$<$ \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim1, Number1 $>$, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::\hyperlink{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}{child\+\_\+num} $>$ $\ast$ {\bfseries find\+\_\+bc\+\_\+node\+\_\+in\+\_\+partition\+\_\+intersect\+\_\+current\+\_\+bc\+\_\+node} (\hyperlink{classTreeNode}{Tree\+Node}$<$ \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim1, Number1 $>$, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::\hyperlink{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}{child\+\_\+num} $>$ $\ast$current\+\_\+bc\+\_\+node, const std\+::vector$<$ \hyperlink{classTreeNode}{Tree\+Node}$<$ \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim1, Number1 $>$, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::\hyperlink{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}{child\+\_\+num} $>$ $\ast$$>$ \&\hyperlink{classBlockClusterTree_a3ca42421f732c20fc07bdf5d5ab94319}{partition})
\item 
\mbox{\Hypertarget{classBlockClusterTree_a1b5de5c860d62a2e28791afdbb2e2d72}\label{classBlockClusterTree_a1b5de5c860d62a2e28791afdbb2e2d72}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\\hyperlink{classTreeNode}{Tree\+Node}$<$ \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim1, Number1 $>$, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::\hyperlink{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}{child\+\_\+num} $>$ $\ast$ {\bfseries find\+\_\+bc\+\_\+node\+\_\+in\+\_\+partition\+\_\+proper\+\_\+subset\+\_\+of\+\_\+current\+\_\+bc\+\_\+node} (\hyperlink{classTreeNode}{Tree\+Node}$<$ \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim1, Number1 $>$, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::\hyperlink{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}{child\+\_\+num} $>$ $\ast$current\+\_\+bc\+\_\+node, const std\+::vector$<$ \hyperlink{classTreeNode}{Tree\+Node}$<$ \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim1, Number1 $>$, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::\hyperlink{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}{child\+\_\+num} $>$ $\ast$$>$ \&\hyperlink{classBlockClusterTree_a3ca42421f732c20fc07bdf5d5ab94319}{partition})
\end{DoxyCompactItemize}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classBlockClusterTree_a20b1ec6a9e81c252b1994c5a99c44af4}{Block\+Cluster\+Tree} ()
\item 
\hyperlink{classBlockClusterTree_a61d415eda9bfffa9e0aa5492b461edab}{Block\+Cluster\+Tree} (const \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$ \&TI, const \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$ \&TJ, const unsigned int n\+\_\+min=0)
\item 
\hyperlink{classBlockClusterTree_a3073c9b5669e356c9c37ccd0a13ed8b3}{Block\+Cluster\+Tree} (typename \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} tau\+\_\+root\+\_\+node, typename \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} sigma\+\_\+root\+\_\+node, const unsigned int n\+\_\+min=1)
\item 
\hyperlink{classBlockClusterTree_ace6087e8fe7dc3d737ff6b4cd97070fc}{Block\+Cluster\+Tree} (\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} bc\+\_\+node, const unsigned int n\+\_\+min)
\item 
\hyperlink{classBlockClusterTree_a522ad51298f5b58b948e435a9e2d2a40}{Block\+Cluster\+Tree} (\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} bc\+\_\+node, const Number eta, const unsigned int n\+\_\+min)
\item 
\hyperlink{classBlockClusterTree_aefb93288ece0e153eb5843d1df21a2a6}{Block\+Cluster\+Tree} (const \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$ \&TI, const \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$ \&TJ, const Number eta, const unsigned int n\+\_\+min)
\item 
\hyperlink{classBlockClusterTree_a1c31aecfd91383f8b96601fd2b63dd62}{Block\+Cluster\+Tree} (const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&bct)
\item 
\hyperlink{classBlockClusterTree_ae3bb67cdcb7868237063c8003d4079ab}{Block\+Cluster\+Tree} (\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&\&bct)
\item 
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \& \hyperlink{classBlockClusterTree_a85553cc442e419b8d707720312118328}{operator=} (const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&bct)
\item 
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \& \hyperlink{classBlockClusterTree_aa635be81dfabed3ba455a17de3b65c2e}{operator=} (\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&\&bct)
\item 
\hyperlink{classBlockClusterTree_a43b969867200b06f3416647c3e4f9f61}{$\sim$\+Block\+Cluster\+Tree} ()
\item 
void \hyperlink{classBlockClusterTree_a0415fe94fd480bbb985a45dc691e2bed}{release} ()
\item 
void \hyperlink{classBlockClusterTree_ab4227d666cd2872fbbfb4eec69e66313}{clear} ()
\item 
void \hyperlink{classBlockClusterTree_ab10f54639969bc4aacd6aa27cf315610}{partition\+\_\+tensor\+\_\+product} ()
\item 
void \hyperlink{classBlockClusterTree_a0e40b3884535eae57d00c078ec782459}{partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product} ()
\item 
void \hyperlink{classBlockClusterTree_ac6d23af20c52c7b32eb080bd54556206}{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product} ()
\item 
void \hyperlink{classBlockClusterTree_a3ca42421f732c20fc07bdf5d5ab94319}{partition} (const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&all\+\_\+support\+\_\+points)
\item 
void \hyperlink{classBlockClusterTree_a075983197c805c6451aa00502dc30e76}{partition} (const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&all\+\_\+support\+\_\+points, const std\+::vector$<$ Number $>$ \&cell\+\_\+size\+\_\+at\+\_\+dofs)
\item 
bool \hyperlink{classBlockClusterTree_a3c4a4da89b964559cc02ecbf13ad4a4b}{extend\+\_\+finer\+\_\+than\+\_\+partition} (const std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&\hyperlink{classBlockClusterTree_a3ca42421f732c20fc07bdf5d5ab94319}{partition})
\item 
bool \hyperlink{classBlockClusterTree_adfe18d32a3c05a9209a5cdc9270b47d7}{extend\+\_\+to\+\_\+finer\+\_\+partition} (const std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&\hyperlink{classBlockClusterTree_a3ca42421f732c20fc07bdf5d5ab94319}{partition})
\item 
bool \hyperlink{classBlockClusterTree_a6fd771b68a4c7195151f6dc02e8ec7e9}{prune\+\_\+descendants\+\_\+from\+\_\+node} (\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} bc\+\_\+node)
\item 
bool \hyperlink{classBlockClusterTree_af1663a109b6fd5c67c85e9bb88a54a13}{prune\+\_\+to\+\_\+partition} (const std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&\hyperlink{classBlockClusterTree_a3ca42421f732c20fc07bdf5d5ab94319}{partition}, const bool is\+\_\+partition\+\_\+in\+\_\+bct)
\item 
\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} \hyperlink{classBlockClusterTree_a4a4f3b893380d1d7f53b772589a847d2}{get\+\_\+root} () const
\item 
std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \& \hyperlink{classBlockClusterTree_a162b396d814b420f96289425529852e9}{get\+\_\+leaf\+\_\+set} ()
\item 
const std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \& \hyperlink{classBlockClusterTree_a38c3d1ad3aa983ea1d0b711914664b4c}{get\+\_\+leaf\+\_\+set} () const
\item 
void \hyperlink{classBlockClusterTree_a1b3396fbedf6ec07cce9c23a62b2c30b}{build\+\_\+leaf\+\_\+set} ()
\item 
void \hyperlink{classBlockClusterTree_aef01b51b0530536bc5481492d4719375}{write\+\_\+leaf\+\_\+set} (std\+::ostream \&out) const
\item 
{\footnotesize template$<$typename Number1  = double$>$ }\\void \hyperlink{classBlockClusterTree_a652b1c53dff2794e2f18343bf3988e19}{write\+\_\+leaf\+\_\+set} (std\+::ostream \&out, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&matrix, const Number1 singular\+\_\+value\+\_\+threshold=0.) const
\item 
std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \& \hyperlink{classBlockClusterTree_a82f61b31f1e9cf869831fa4c8232df81}{get\+\_\+near\+\_\+field\+\_\+set} ()
\item 
const std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \& \hyperlink{classBlockClusterTree_a6ac71437177d14012c12f7b4f354cdd1}{get\+\_\+near\+\_\+field\+\_\+set} () const
\item 
std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \& \hyperlink{classBlockClusterTree_a2980726dc3789773b5cd3c04df5e69a3}{get\+\_\+far\+\_\+field\+\_\+set} ()
\item 
const std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \& \hyperlink{classBlockClusterTree_a93763855c84100e1a9da3080737295f4}{get\+\_\+far\+\_\+field\+\_\+set} () const
\item 
unsigned int \hyperlink{classBlockClusterTree_ab00acda5e8fd4c3e381637d8d9322923}{get\+\_\+n\+\_\+min} () const
\item 
Number \hyperlink{classBlockClusterTree_a312d01ddb6cf5560d84abf7d254fa2c3}{get\+\_\+eta} () const
\item 
unsigned int \hyperlink{classBlockClusterTree_ab6c57acfcc5dfbbef04f028e6b9c749d}{get\+\_\+depth} () const
\item 
void \hyperlink{classBlockClusterTree_a7f9dbea25751771830c72d09efacacb2}{calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level} ()
\item 
int \hyperlink{classBlockClusterTree_a404693ef7dfdbc383705c38105c75e14}{get\+\_\+max\+\_\+level} () const
\item 
unsigned int \hyperlink{classBlockClusterTree_a042e040d2f6dfcbbfd70b43b8967c6f6}{get\+\_\+node\+\_\+num} () const
\item 
void \hyperlink{classBlockClusterTree_a02be4a882acca918386ad024769925bc}{set\+\_\+node\+\_\+num} (unsigned int \hyperlink{classBlockClusterTree_a75757146cea0aa0e9271b760b1d76307}{node\+\_\+num})
\item 
unsigned int \hyperlink{classBlockClusterTree_aec9920e5b215fbfe2aa9f54980d3b30a}{increase\+\_\+node\+\_\+num} (unsigned int increased\+\_\+node\+\_\+num=1)
\item 
unsigned int \hyperlink{classBlockClusterTree_ae0e55e3ac56bffa31f251d4f07ae7e51}{decrease\+\_\+node\+\_\+num} (unsigned int decreased\+\_\+node\+\_\+num=1)
\item 
void \hyperlink{classBlockClusterTree_a286bd48cc863cbba7c9ad53b6bdb12ca}{categorize\+\_\+near\+\_\+and\+\_\+far\+\_\+field\+\_\+sets} ()
\item 
void \hyperlink{classBlockClusterTree_ae77f8167ce49871f5751b8dcf8c93153}{partition\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node} (\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} current\+\_\+block\+\_\+cluster\+\_\+node, std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node)
\item 
void \hyperlink{classBlockClusterTree_a61b6c204f3f1d5ff7c71a07b26ca9d09}{partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node} (\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} current\+\_\+block\+\_\+cluster\+\_\+node, std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node)
\item 
void \hyperlink{classBlockClusterTree_aa6354696477c8cae61d362b5ec707034}{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node} (\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} current\+\_\+block\+\_\+cluster\+\_\+node, std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node)
\item 
void \hyperlink{classBlockClusterTree_aafad0fae48bf7c462e8e943b76893fc0}{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node\+\_\+N} (\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} current\+\_\+block\+\_\+cluster\+\_\+node, std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node)
\item 
void \hyperlink{classBlockClusterTree_afdeb6723e01b5eaf11281e2c1c1cf566}{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node\+\_\+\+Nstar} (\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} current\+\_\+block\+\_\+cluster\+\_\+node, std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node)
\item 
void \hyperlink{classBlockClusterTree_ad11fb277e43c33f2a399dc6b1c14b998}{partition\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node} (\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} current\+\_\+block\+\_\+cluster\+\_\+node, const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&all\+\_\+support\+\_\+points, std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node)
\item 
void \hyperlink{classBlockClusterTree_a425583a70d63ddbf9341a31b736bd0fe}{partition\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node} (\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} current\+\_\+block\+\_\+cluster\+\_\+node, const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&all\+\_\+support\+\_\+points, const std\+::vector$<$ Number $>$ \&cell\+\_\+size\+\_\+at\+\_\+dofs, std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node)
\item 
\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} \hyperlink{classBlockClusterTree_a97a99684ebd9ed470a79e56b73374068}{find\+\_\+leaf\+\_\+bc\+\_\+node\+\_\+not\+\_\+subset\+\_\+of\+\_\+bc\+\_\+nodes\+\_\+in\+\_\+partition} (const std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&\hyperlink{classBlockClusterTree_a3ca42421f732c20fc07bdf5d5ab94319}{partition}, typename std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$\+::const\+\_\+iterator \&it\+\_\+for\+\_\+desired\+\_\+bc\+\_\+node) const
\item 
\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} \hyperlink{classBlockClusterTree_a4782e1e817b6e6265bff43baf2b1dbaa}{find\+\_\+leaf\+\_\+bc\+\_\+node\+\_\+not\+\_\+in\+\_\+partition} (const std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&\hyperlink{classBlockClusterTree_a3ca42421f732c20fc07bdf5d5ab94319}{partition}, typename std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$\+::const\+\_\+iterator \&it\+\_\+for\+\_\+desired\+\_\+bc\+\_\+node) const
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$int spacedim, typename Number = double$>$\newline
class Block\+Cluster\+Tree$<$ spacedim, Number $>$}

Class for block cluster tree. 

A block cluster tree is a quad-\/tree which holds a hierarchy of doubly linked nodes with the type \hyperlink{classTreeNode}{Tree\+Node}. Because a node in the block cluster tree has four children, the template argument {\ttfamily T} required by {\ttfamily \hyperlink{classTreeNode}{Tree\+Node}} should be 4. 

\subsection{Member Typedef Documentation}
\mbox{\Hypertarget{classBlockClusterTree_a4d03fe184a7f7838111b27cdae056a62}\label{classBlockClusterTree_a4d03fe184a7f7838111b27cdae056a62}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!data\+\_\+value\+\_\+type@{data\+\_\+value\+\_\+type}}
\index{data\+\_\+value\+\_\+type@{data\+\_\+value\+\_\+type}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{data\+\_\+value\+\_\+type}{data\_value\_type}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
typedef \hyperlink{classBlockCluster}{Block\+Cluster}$<$spacedim, Number$>$ \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classBlockClusterTree_a4d03fe184a7f7838111b27cdae056a62}{data\+\_\+value\+\_\+type}}

Data type of the data held by a tree node. \mbox{\Hypertarget{classBlockClusterTree_a960c20eac27464dedd804261f185c61f}\label{classBlockClusterTree_a960c20eac27464dedd804261f185c61f}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!node\+\_\+value\+\_\+type@{node\+\_\+value\+\_\+type}}
\index{node\+\_\+value\+\_\+type@{node\+\_\+value\+\_\+type}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{node\+\_\+value\+\_\+type}{node\_value\_type}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
typedef \hyperlink{classTreeNode}{Tree\+Node}$<$\hyperlink{classBlockCluster}{Block\+Cluster}$<$spacedim, Number$>$, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$spacedim, Number$>$\+::\hyperlink{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}{child\+\_\+num}$>$ \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classBlockClusterTree_a960c20eac27464dedd804261f185c61f}{node\+\_\+value\+\_\+type}}

Data type of the tree node. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classBlockClusterTree_a20b1ec6a9e81c252b1994c5a99c44af4}\label{classBlockClusterTree_a20b1ec6a9e81c252b1994c5a99c44af4}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{Block\+Cluster\+Tree()}{BlockClusterTree()}\hspace{0.1cm}{\footnotesize\ttfamily [1/8]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Default constructor, which initializes an empty quad-\/tree. \mbox{\Hypertarget{classBlockClusterTree_a61d415eda9bfffa9e0aa5492b461edab}\label{classBlockClusterTree_a61d415eda9bfffa9e0aa5492b461edab}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{Block\+Cluster\+Tree()}{BlockClusterTree()}\hspace{0.1cm}{\footnotesize\ttfamily [2/8]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree} (\begin{DoxyParamCaption}\item[{const \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{TI,  }\item[{const \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{TJ,  }\item[{const unsigned int}]{n\+\_\+min = {\ttfamily 0} }\end{DoxyParamCaption})}

Construct from two cluster trees built from pure cardinality based partition, which has no admissibility condition.

After construction, there is only one node in the block cluster tree, i.\+e. tree hierarchy is not built.


\begin{DoxyParams}{Parameters}
{\em TI} & \\
\hline
{\em TJ} & \\
\hline
{\em n\+\_\+min} & \\
\hline
\end{DoxyParams}


References Create\+Tree\+Node(), Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+n\+\_\+min(), and Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+root().

\mbox{\Hypertarget{classBlockClusterTree_a3073c9b5669e356c9c37ccd0a13ed8b3}\label{classBlockClusterTree_a3073c9b5669e356c9c37ccd0a13ed8b3}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{Block\+Cluster\+Tree()}{BlockClusterTree()}\hspace{0.1cm}{\footnotesize\ttfamily [3/8]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree} (\begin{DoxyParamCaption}\item[{typename \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type}}]{tau\+\_\+root\+\_\+node,  }\item[{typename \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type}}]{sigma\+\_\+root\+\_\+node,  }\item[{const unsigned int}]{n\+\_\+min = {\ttfamily 1} }\end{DoxyParamCaption})}

Construct from two cluster nodes, whose Cartesian product is the root node of the block cluster tree.

After construction, there is only one node in the block cluster tree, i.\+e. tree hierarchy is not built.


\begin{DoxyParams}{Parameters}
{\em tau\+\_\+root\+\_\+node} & \\
\hline
{\em sigma\+\_\+root\+\_\+node} & \\
\hline
\end{DoxyParams}


References Create\+Tree\+Node().

\mbox{\Hypertarget{classBlockClusterTree_ace6087e8fe7dc3d737ff6b4cd97070fc}\label{classBlockClusterTree_ace6087e8fe7dc3d737ff6b4cd97070fc}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{Block\+Cluster\+Tree()}{BlockClusterTree()}\hspace{0.1cm}{\footnotesize\ttfamily [4/8]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree} (\begin{DoxyParamCaption}\item[{\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type}}]{bc\+\_\+node,  }\item[{const unsigned int}]{n\+\_\+min }\end{DoxyParamCaption})}

Construct a block cluster subtree by initializing from a block cluster node.

The constructed block cluster subtree simply takes over an existing block cluster node in a block cluster tree which has been built before.


\begin{DoxyParams}{Parameters}
{\em bc\+\_\+node} & \\
\hline
{\em n\+\_\+min} & \\
\hline
\end{DoxyParams}


References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::categorize\+\_\+near\+\_\+and\+\_\+far\+\_\+field\+\_\+sets(), Count\+Tree\+Nodes(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::node\+\_\+num.

\mbox{\Hypertarget{classBlockClusterTree_a522ad51298f5b58b948e435a9e2d2a40}\label{classBlockClusterTree_a522ad51298f5b58b948e435a9e2d2a40}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{Block\+Cluster\+Tree()}{BlockClusterTree()}\hspace{0.1cm}{\footnotesize\ttfamily [5/8]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree} (\begin{DoxyParamCaption}\item[{\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type}}]{bc\+\_\+node,  }\item[{const Number}]{eta,  }\item[{const unsigned int}]{n\+\_\+min }\end{DoxyParamCaption})}

Construct a block cluster subtree by initializing from a block cluster node. This version has the admissibility condition.

The constructed block cluster subtree simply takes over an existing block cluster node in a block cluster tree which has been built before.


\begin{DoxyParams}{Parameters}
{\em bc\+\_\+node} & \\
\hline
\end{DoxyParams}


References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::categorize\+\_\+near\+\_\+and\+\_\+far\+\_\+field\+\_\+sets(), Count\+Tree\+Nodes(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::node\+\_\+num.

\mbox{\Hypertarget{classBlockClusterTree_aefb93288ece0e153eb5843d1df21a2a6}\label{classBlockClusterTree_aefb93288ece0e153eb5843d1df21a2a6}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{Block\+Cluster\+Tree()}{BlockClusterTree()}\hspace{0.1cm}{\footnotesize\ttfamily [6/8]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree} (\begin{DoxyParamCaption}\item[{const \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{TI,  }\item[{const \hyperlink{classClusterTree}{Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{TJ,  }\item[{const Number}]{eta,  }\item[{const unsigned int}]{n\+\_\+min }\end{DoxyParamCaption})}

Construct from two cluster trees and admissibility condition.

The Cartesian product of the two clusters in the root nodes of $T(I)$ and $T(J)$ becomes the data in the root node of the block cluster tree.

After construction, there is only one node in the block cluster tree, i.\+e. tree hierarchy is not built. 

References Create\+Tree\+Node(), Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+n\+\_\+min(), and Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+root().

\mbox{\Hypertarget{classBlockClusterTree_a1c31aecfd91383f8b96601fd2b63dd62}\label{classBlockClusterTree_a1c31aecfd91383f8b96601fd2b63dd62}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{Block\+Cluster\+Tree()}{BlockClusterTree()}\hspace{0.1cm}{\footnotesize\ttfamily [7/8]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree} (\begin{DoxyParamCaption}\item[{const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{bct }\end{DoxyParamCaption})}

Copy constructor for {\ttfamily \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}}, which realizes deep copy internally.


\begin{DoxyDescription}
\item[Note ]Because this is deep copy, the constructed block cluster tree is a new tree but never a subtree of an existing block cluster tree. Hence, the data field {\ttfamily is\+\_\+subtree} is set to {\ttfamily false}. 
\end{DoxyDescription}


\begin{DoxyParams}{Parameters}
{\em bct} & \\
\hline
\end{DoxyParams}


References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::categorize\+\_\+near\+\_\+and\+\_\+far\+\_\+field\+\_\+sets(), Copy\+Tree(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+root().

\mbox{\Hypertarget{classBlockClusterTree_ae3bb67cdcb7868237063c8003d4079ab}\label{classBlockClusterTree_ae3bb67cdcb7868237063c8003d4079ab}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{Block\+Cluster\+Tree()}{BlockClusterTree()}\hspace{0.1cm}{\footnotesize\ttfamily [8/8]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree} (\begin{DoxyParamCaption}\item[{\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&\&}]{bct }\end{DoxyParamCaption})}

Copy constructor via shallow copy.


\begin{DoxyDescription}
\item[Note ]The data members of the input {\ttfamily bct} must be cleared before exiting this constructor. Otherwise, when {\ttfamily bct} is out of its range, the data associated with the current block cluster tree will also be destroyed, which is undesired. 
\end{DoxyDescription}


\begin{DoxyParams}{Parameters}
{\em bct} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::operator=().

\mbox{\Hypertarget{classBlockClusterTree_a43b969867200b06f3416647c3e4f9f61}\label{classBlockClusterTree_a43b969867200b06f3416647c3e4f9f61}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!````~Block\+Cluster\+Tree@{$\sim$\+Block\+Cluster\+Tree}}
\index{````~Block\+Cluster\+Tree@{$\sim$\+Block\+Cluster\+Tree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{$\sim$\+Block\+Cluster\+Tree()}{~BlockClusterTree()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::$\sim$\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Destructor which recursively destroys every node in the block cluster tree. 

References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::clear(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::is\+\_\+subtree, and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::release().



\subsection{Member Function Documentation}
\mbox{\Hypertarget{classBlockClusterTree_a1b3396fbedf6ec07cce9c23a62b2c30b}\label{classBlockClusterTree_a1b3396fbedf6ec07cce9c23a62b2c30b}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!build\+\_\+leaf\+\_\+set@{build\+\_\+leaf\+\_\+set}}
\index{build\+\_\+leaf\+\_\+set@{build\+\_\+leaf\+\_\+set}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{build\+\_\+leaf\+\_\+set()}{build\_leaf\_set()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Build the leaf set by tree recursion. 

References Get\+Tree\+Leaves().



Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::\+Block\+Cluster\+Tree(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::operator=(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::prune\+\_\+to\+\_\+partition().

\mbox{\Hypertarget{classBlockClusterTree_a7f9dbea25751771830c72d09efacacb2}\label{classBlockClusterTree_a7f9dbea25751771830c72d09efacacb2}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level@{calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level}}
\index{calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level@{calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level()}{calc\_depth\_and\_max\_level()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Calculate the depth. 

References calc\+\_\+depth(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::depth, and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::max\+\_\+level.



Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::\+Block\+Cluster\+Tree(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+tensor\+\_\+product(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::prune\+\_\+to\+\_\+partition().

\mbox{\Hypertarget{classBlockClusterTree_a286bd48cc863cbba7c9ad53b6bdb12ca}\label{classBlockClusterTree_a286bd48cc863cbba7c9ad53b6bdb12ca}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!categorize\+\_\+near\+\_\+and\+\_\+far\+\_\+field\+\_\+sets@{categorize\+\_\+near\+\_\+and\+\_\+far\+\_\+field\+\_\+sets}}
\index{categorize\+\_\+near\+\_\+and\+\_\+far\+\_\+field\+\_\+sets@{categorize\+\_\+near\+\_\+and\+\_\+far\+\_\+field\+\_\+sets}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{categorize\+\_\+near\+\_\+and\+\_\+far\+\_\+field\+\_\+sets()}{categorize\_near\_and\_far\_field\_sets()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::categorize\+\_\+near\+\_\+and\+\_\+far\+\_\+field\+\_\+sets (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Categorize the leaf set into near field set and far field set. 

Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::\+Block\+Cluster\+Tree(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::operator=(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+tensor\+\_\+product(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::prune\+\_\+to\+\_\+partition().

\mbox{\Hypertarget{classBlockClusterTree_ab4227d666cd2872fbbfb4eec69e66313}\label{classBlockClusterTree_ab4227d666cd2872fbbfb4eec69e66313}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!clear@{clear}}
\index{clear@{clear}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Clear the data field of the block cluster tree because its memory has been migrated to another object via shallow copy. 

References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::depth, Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::is\+\_\+subtree, Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::max\+\_\+level, and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::node\+\_\+num.



Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::operator=(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::release(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::$\sim$\+Block\+Cluster\+Tree().

\mbox{\Hypertarget{classBlockClusterTree_ae0e55e3ac56bffa31f251d4f07ae7e51}\label{classBlockClusterTree_ae0e55e3ac56bffa31f251d4f07ae7e51}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!decrease\+\_\+node\+\_\+num@{decrease\+\_\+node\+\_\+num}}
\index{decrease\+\_\+node\+\_\+num@{decrease\+\_\+node\+\_\+num}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{decrease\+\_\+node\+\_\+num()}{decrease\_node\_num()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
unsigned int \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::decrease\+\_\+node\+\_\+num (\begin{DoxyParamCaption}\item[{unsigned int}]{decreased\+\_\+node\+\_\+num = {\ttfamily 1} }\end{DoxyParamCaption})}

Decrease the total number of nodes in the tree. 

References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::node\+\_\+num.



Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::prune\+\_\+descendants\+\_\+from\+\_\+node().

\mbox{\Hypertarget{classBlockClusterTree_a3c4a4da89b964559cc02ecbf13ad4a4b}\label{classBlockClusterTree_a3c4a4da89b964559cc02ecbf13ad4a4b}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!extend\+\_\+finer\+\_\+than\+\_\+partition@{extend\+\_\+finer\+\_\+than\+\_\+partition}}
\index{extend\+\_\+finer\+\_\+than\+\_\+partition@{extend\+\_\+finer\+\_\+than\+\_\+partition}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{extend\+\_\+finer\+\_\+than\+\_\+partition()}{extend\_finer\_than\_partition()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
bool \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::extend\+\_\+finer\+\_\+than\+\_\+partition (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&}]{partition }\end{DoxyParamCaption})}

Extend the current block cluster tree to be finer than the given partition.

This member functions implements (7.\+10a) in Hackbusch\textquotesingle{}s $\mathcal{H}$-\/matrix book.


\begin{DoxyDescription}
\item[Note ]{\bfseries This algorithm iterates over each element in the leaf set of the block cluster tree to be extended. During the iteration, because leaf nodes may be further split into smaller ones, the leaf set is not a constant. Hence, the leaf set should be updated immediately whenever a block cluster node is split. This behavior is different from other functions such as {\ttfamily \hyperlink{classHMatrix_ad2b353962226c78910d6ddb6b5b8e460}{H\+Matrix$<$spacedim, Number$>$\+::refine\+\_\+to\+\_\+supertree}}, the leaf set of of which will be built after the whole tree hierarchy has been constructed.}  
\end{DoxyDescription}
\begin{DoxyParams}{Parameters}
{\em P} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether the block cluster tree has really been extended. 
\end{DoxyReturn}
Iterate over the leaf set of the current block cluster tree and look for a block cluster which is not contained by any block cluster in the given partition.

Flag variable indicating whether the current block cluster tree has actually been extended. If true, the leaf set of the current block cluster tree has been modified during the extension, which needs a further re-\/categorization into the near field set and the far field set.

Enter the loop by selecting a block cluster node from the leaf set which is not contained in any block cluster nodes in the given partition.

Because the selected block cluster node in the leaf set is about to be split, we delete the current block cluster node from the leaf set here and add its children to the leaf set later on during calling {\ttfamily split\+\_\+block\+\_\+cluster\+\_\+node}.

Select a block cluster node in the given partition, whose index set has a nonempty intersection with the index set of the current block cluster node.

Because the given partition is a covering of the complete block cluster index set $I \times J$, such block cluster node must exist. Hence we make an assertion here.

Extend the current block cluster node by splitting its $\tau$ node, which is horizontal split, then make Cartesian product with its $\sigma$ node. The newly created block cluster nodes are appended to the leaf set.

Extend the current block cluster node by splitting its $\sigma$ node, which is vertical split, then make Cartesian product with its $\tau$ node. The newly created block cluster nodes are appended to the leaf set.

Extend the current block cluster node by splitting its $\tau$ node, which is horizontal split, then make Cartesian product with its $\sigma$ node. The newly created block cluster nodes are appended to the leaf set.

Extend the current block cluster node by splitting its $\sigma$ node, which is vertical split, then make Cartesian product with its $\tau$ node. The newly created block cluster nodes are appended to the leaf set.

Update the maximum level and depth of the current tree if necessary.

After block cluster tree extension, re-\/categorize the near field set and far field set based on the new leaf set. N.\+B. The value of {\ttfamily n\+\_\+min} and {\ttfamily eta} does not change. Meanwhile, {\ttfamily depth} and {\ttfamily max\+\_\+level} have been updated during previous procedures.

References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::find\+\_\+leaf\+\_\+bc\+\_\+node\+\_\+not\+\_\+subset\+\_\+of\+\_\+bc\+\_\+nodes\+\_\+in\+\_\+partition(), and Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+reference().



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::convert\+\_\+between\+\_\+different\+\_\+block\+\_\+cluster\+\_\+trees(), and main().

\mbox{\Hypertarget{classBlockClusterTree_adfe18d32a3c05a9209a5cdc9270b47d7}\label{classBlockClusterTree_adfe18d32a3c05a9209a5cdc9270b47d7}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!extend\+\_\+to\+\_\+finer\+\_\+partition@{extend\+\_\+to\+\_\+finer\+\_\+partition}}
\index{extend\+\_\+to\+\_\+finer\+\_\+partition@{extend\+\_\+to\+\_\+finer\+\_\+partition}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{extend\+\_\+to\+\_\+finer\+\_\+partition()}{extend\_to\_finer\_partition()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
bool \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::extend\+\_\+to\+\_\+finer\+\_\+partition (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&}]{partition }\end{DoxyParamCaption})}

Extend the current block cluster tree to the given finer partition.

This member functions implements (7.\+10b) in Hackbusch\textquotesingle{}s $\mathcal{H}$-\/matrix book.


\begin{DoxyDescription}
\item[Note ]{\bfseries This algorithm iterates over each element in the leaf set of the block cluster tree to be extended. During the iteration, because leaf nodes may be further split into smaller ones, the leaf set is not a constant. Hence, the leaf set should be updated immediately whenever a block cluster node is split. This behavior is different from other functions such as {\ttfamily \hyperlink{classHMatrix_ad2b353962226c78910d6ddb6b5b8e460}{H\+Matrix$<$spacedim, Number$>$\+::refine\+\_\+to\+\_\+supertree}}, the leaf set of of which will be built after the whole tree hierarchy has been constructed.}  
\end{DoxyDescription}Iterate over the leaf set of the current block cluster tree and look for a block cluster which does not belong to the partition.

Enter the loop by selecting a block cluster node from the leaf set, which does not belong to the given partition.

Because the selected block cluster node in the leaf set is about to be split, we delete the current block cluster node from the leaf set here and add its children to the leaf set later on during calling {\ttfamily split\+\_\+block\+\_\+cluster\+\_\+node}.

Select a block cluster node in the given partition, whose index set is a proper subset of the index set of the current block cluster node.

Because the partition is a covering of the complete block cluster index set $I \times J$ and it is finer than the leaf set of the current block cluster tree, such block cluster node must exist. Hence we make an assertion here.

Here we ensure that the level difference between $\tau$ and $\sigma$ clusters is at most 1.

Extend the current block cluster node by splitting its $\tau$ node, which is horizontal split, then make Cartesian product with its $\sigma$ node. The newly created block cluster nodes are appended to the leaf set.

Extend the current block cluster node by splitting its $\sigma$ node, which is vertical split, then make Cartesian product with its $\tau$ node. The newly created block cluster nodes are appended to the leaf set.

Extend the current block cluster node by splitting its $\tau$ node, which is horizontal split, then make Cartesian product with its $\sigma$ node. The newly created block cluster nodes are appended to the leaf set.

Extend the current block cluster node by splitting its $\sigma$ node, which is vertical split, then make Cartesian product with its $\tau$ node. The newly created block cluster nodes are appended to the leaf set.

Update the maximum level and depth of the current tree if necessary.

After block cluster tree extension, re-\/categorize the near field set and far field set based on the new leaf set. N.\+B. The value of {\ttfamily n\+\_\+min} and {\ttfamily eta} does not change. Meanwhile, {\ttfamily depth} and {\ttfamily max\+\_\+level} have been updated during previous procedures.

References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::find\+\_\+leaf\+\_\+bc\+\_\+node\+\_\+not\+\_\+in\+\_\+partition(), and Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+reference().



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::convert\+\_\+between\+\_\+different\+\_\+block\+\_\+cluster\+\_\+trees(), and main().

\mbox{\Hypertarget{classBlockClusterTree_a4782e1e817b6e6265bff43baf2b1dbaa}\label{classBlockClusterTree_a4782e1e817b6e6265bff43baf2b1dbaa}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!find\+\_\+leaf\+\_\+bc\+\_\+node\+\_\+not\+\_\+in\+\_\+partition@{find\+\_\+leaf\+\_\+bc\+\_\+node\+\_\+not\+\_\+in\+\_\+partition}}
\index{find\+\_\+leaf\+\_\+bc\+\_\+node\+\_\+not\+\_\+in\+\_\+partition@{find\+\_\+leaf\+\_\+bc\+\_\+node\+\_\+not\+\_\+in\+\_\+partition}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{find\+\_\+leaf\+\_\+bc\+\_\+node\+\_\+not\+\_\+in\+\_\+partition()}{find\_leaf\_bc\_node\_not\_in\_partition()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::find\+\_\+leaf\+\_\+bc\+\_\+node\+\_\+not\+\_\+in\+\_\+partition (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&}]{partition,  }\item[{typename std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$\+::const\+\_\+iterator \&}]{it\+\_\+for\+\_\+desired\+\_\+bc\+\_\+node }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [private]}}

Find a block cluster node in the leaf set of the current block cluster tree, which does not belong to the partition. 
\begin{DoxyParams}{Parameters}
{\em partition} & the given partition. \\
\hline
{\em it\+\_\+for\+\_\+desired\+\_\+bc\+\_\+node} & the returned iterator which points to the selected block cluster node in the leaf set of the current block cluster tree. N.\+B. Only when the returned pointer is not {\ttfamily nullptr}, this iterator is meaningful. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to the selected block cluster node. 
\end{DoxyReturn}

\begin{DoxyDescription}
\item[Work flow ]

Iterate over each block cluster node in the leaf set of the current block cluster tree.

Iterate over each block cluster node in the given partition.

When the index set of the current block cluster node is equal to the index set of some block cluster node in the given partition, terminate the inner loop and jump to the next leaf node for checking.

Here the desired block cluster node in the leaf set is found. Then exist the outer loop and the iterator {\ttfamily it\+\_\+for\+\_\+desired\+\_\+bc\+\_\+node} now pointing to this node will also be returned.


\end{DoxyDescription}

References Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+reference(), and is\+\_\+equal().



Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::extend\+\_\+to\+\_\+finer\+\_\+partition().

\mbox{\Hypertarget{classBlockClusterTree_a97a99684ebd9ed470a79e56b73374068}\label{classBlockClusterTree_a97a99684ebd9ed470a79e56b73374068}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!find\+\_\+leaf\+\_\+bc\+\_\+node\+\_\+not\+\_\+subset\+\_\+of\+\_\+bc\+\_\+nodes\+\_\+in\+\_\+partition@{find\+\_\+leaf\+\_\+bc\+\_\+node\+\_\+not\+\_\+subset\+\_\+of\+\_\+bc\+\_\+nodes\+\_\+in\+\_\+partition}}
\index{find\+\_\+leaf\+\_\+bc\+\_\+node\+\_\+not\+\_\+subset\+\_\+of\+\_\+bc\+\_\+nodes\+\_\+in\+\_\+partition@{find\+\_\+leaf\+\_\+bc\+\_\+node\+\_\+not\+\_\+subset\+\_\+of\+\_\+bc\+\_\+nodes\+\_\+in\+\_\+partition}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{find\+\_\+leaf\+\_\+bc\+\_\+node\+\_\+not\+\_\+subset\+\_\+of\+\_\+bc\+\_\+nodes\+\_\+in\+\_\+partition()}{find\_leaf\_bc\_node\_not\_subset\_of\_bc\_nodes\_in\_partition()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::find\+\_\+leaf\+\_\+bc\+\_\+node\+\_\+not\+\_\+subset\+\_\+of\+\_\+bc\+\_\+nodes\+\_\+in\+\_\+partition (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&}]{partition,  }\item[{typename std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$\+::const\+\_\+iterator \&}]{it\+\_\+for\+\_\+desired\+\_\+bc\+\_\+node }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [private]}}

Find a block cluster node in the leaf set of the current block cluster tree, which is not a subset of any block cluster in the given partition. 
\begin{DoxyParams}{Parameters}
{\em partition} & the given partition. \\
\hline
{\em it\+\_\+for\+\_\+desired\+\_\+bc\+\_\+node} & the returned iterator which points to the selected block cluster node in the leaf set of the current block cluster tree. N.\+B. Only when the returned pointer is not {\ttfamily nullptr}, this iterator is meaningful. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to the selected block cluster node. 
\end{DoxyReturn}

\begin{DoxyDescription}
\item[Work flow ]

Iterate over each block cluster node in the leaf set of the current block cluster tree.

Iterate over each block cluster node in the given partition.

When the index set of the current block cluster node in the leaf set is a subset of the index set of some block cluster node in the given partition, terminate the inner loop and jump to the next leaf node for checking.

Here the desired block cluster node in the leaf set is found. Then exist the outer loop and the iterator {\ttfamily it\+\_\+for\+\_\+desired\+\_\+bc\+\_\+node} now pointing to this node will also be returned.


\end{DoxyDescription}

References Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+reference().



Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::extend\+\_\+finer\+\_\+than\+\_\+partition().

\mbox{\Hypertarget{classBlockClusterTree_ab6c57acfcc5dfbbef04f028e6b9c749d}\label{classBlockClusterTree_ab6c57acfcc5dfbbef04f028e6b9c749d}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!get\+\_\+depth@{get\+\_\+depth}}
\index{get\+\_\+depth@{get\+\_\+depth}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+depth()}{get\_depth()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
unsigned int \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+depth (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the tree depth. 

References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::depth.

\mbox{\Hypertarget{classBlockClusterTree_a312d01ddb6cf5560d84abf7d254fa2c3}\label{classBlockClusterTree_a312d01ddb6cf5560d84abf7d254fa2c3}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!get\+\_\+eta@{get\+\_\+eta}}
\index{get\+\_\+eta@{get\+\_\+eta}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+eta()}{get\_eta()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
Number \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+eta (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the admissibility parameter. \begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{classBlockClusterTree_a2980726dc3789773b5cd3c04df5e69a3}\label{classBlockClusterTree_a2980726dc3789773b5cd3c04df5e69a3}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!get\+\_\+far\+\_\+field\+\_\+set@{get\+\_\+far\+\_\+field\+\_\+set}}
\index{get\+\_\+far\+\_\+field\+\_\+set@{get\+\_\+far\+\_\+field\+\_\+set}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+far\+\_\+field\+\_\+set()}{get\_far\_field\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
std\+::vector$<$ typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \& \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+far\+\_\+field\+\_\+set (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Get the reference to the block cluster list which belongs to the far field. \mbox{\Hypertarget{classBlockClusterTree_a93763855c84100e1a9da3080737295f4}\label{classBlockClusterTree_a93763855c84100e1a9da3080737295f4}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!get\+\_\+far\+\_\+field\+\_\+set@{get\+\_\+far\+\_\+field\+\_\+set}}
\index{get\+\_\+far\+\_\+field\+\_\+set@{get\+\_\+far\+\_\+field\+\_\+set}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+far\+\_\+field\+\_\+set()}{get\_far\_field\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
const std\+::vector$<$ typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \& \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+far\+\_\+field\+\_\+set (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the reference to the block cluster list which belongs to the far field (const version). \mbox{\Hypertarget{classBlockClusterTree_a162b396d814b420f96289425529852e9}\label{classBlockClusterTree_a162b396d814b420f96289425529852e9}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!get\+\_\+leaf\+\_\+set@{get\+\_\+leaf\+\_\+set}}
\index{get\+\_\+leaf\+\_\+set@{get\+\_\+leaf\+\_\+set}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+leaf\+\_\+set()}{get\_leaf\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
std\+::vector$<$ typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \& \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+leaf\+\_\+set (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Get the reference to the block cluster list. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::coarsen\+\_\+to\+\_\+subtree(), H\+Matrix$<$ spacedim, Number $>$\+::convert\+\_\+between\+\_\+different\+\_\+block\+\_\+cluster\+\_\+trees(), and main().

\mbox{\Hypertarget{classBlockClusterTree_a38c3d1ad3aa983ea1d0b711914664b4c}\label{classBlockClusterTree_a38c3d1ad3aa983ea1d0b711914664b4c}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!get\+\_\+leaf\+\_\+set@{get\+\_\+leaf\+\_\+set}}
\index{get\+\_\+leaf\+\_\+set@{get\+\_\+leaf\+\_\+set}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+leaf\+\_\+set()}{get\_leaf\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
const std\+::vector$<$ typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \& \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+leaf\+\_\+set (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the reference to the block cluster list (const version). \mbox{\Hypertarget{classBlockClusterTree_a404693ef7dfdbc383705c38105c75e14}\label{classBlockClusterTree_a404693ef7dfdbc383705c38105c75e14}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!get\+\_\+max\+\_\+level@{get\+\_\+max\+\_\+level}}
\index{get\+\_\+max\+\_\+level@{get\+\_\+max\+\_\+level}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+max\+\_\+level()}{get\_max\_level()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
int \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+max\+\_\+level (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the maximum level of the tree. 

References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::max\+\_\+level.

\mbox{\Hypertarget{classBlockClusterTree_ab00acda5e8fd4c3e381637d8d9322923}\label{classBlockClusterTree_ab00acda5e8fd4c3e381637d8d9322923}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!get\+\_\+n\+\_\+min@{get\+\_\+n\+\_\+min}}
\index{get\+\_\+n\+\_\+min@{get\+\_\+n\+\_\+min}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+n\+\_\+min()}{get\_n\_min()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
unsigned int \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+n\+\_\+min (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the minimum cluster size. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::mmult().

\mbox{\Hypertarget{classBlockClusterTree_a82f61b31f1e9cf869831fa4c8232df81}\label{classBlockClusterTree_a82f61b31f1e9cf869831fa4c8232df81}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!get\+\_\+near\+\_\+field\+\_\+set@{get\+\_\+near\+\_\+field\+\_\+set}}
\index{get\+\_\+near\+\_\+field\+\_\+set@{get\+\_\+near\+\_\+field\+\_\+set}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+near\+\_\+field\+\_\+set()}{get\_near\_field\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
std\+::vector$<$ typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \& \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+near\+\_\+field\+\_\+set (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Get the reference to the block cluster list which belongs to the near field. \mbox{\Hypertarget{classBlockClusterTree_a6ac71437177d14012c12f7b4f354cdd1}\label{classBlockClusterTree_a6ac71437177d14012c12f7b4f354cdd1}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!get\+\_\+near\+\_\+field\+\_\+set@{get\+\_\+near\+\_\+field\+\_\+set}}
\index{get\+\_\+near\+\_\+field\+\_\+set@{get\+\_\+near\+\_\+field\+\_\+set}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+near\+\_\+field\+\_\+set()}{get\_near\_field\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
const std\+::vector$<$ typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \& \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+near\+\_\+field\+\_\+set (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the reference to the block cluster list which belongs to the near field (const version). \mbox{\Hypertarget{classBlockClusterTree_a042e040d2f6dfcbbfd70b43b8967c6f6}\label{classBlockClusterTree_a042e040d2f6dfcbbfd70b43b8967c6f6}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!get\+\_\+node\+\_\+num@{get\+\_\+node\+\_\+num}}
\index{get\+\_\+node\+\_\+num@{get\+\_\+node\+\_\+num}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+node\+\_\+num()}{get\_node\_num()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
unsigned int \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+node\+\_\+num (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the total number of clusters in the tree. 

References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::node\+\_\+num.

\mbox{\Hypertarget{classBlockClusterTree_a4a4f3b893380d1d7f53b772589a847d2}\label{classBlockClusterTree_a4a4f3b893380d1d7f53b772589a847d2}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!get\+\_\+root@{get\+\_\+root}}
\index{get\+\_\+root@{get\+\_\+root}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{get\+\_\+root()}{get\_root()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::get\+\_\+root (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the pointer to the root node of the block cluster tree. \begin{DoxyReturn}{Returns}

\end{DoxyReturn}


References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node().



Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::\+Block\+Cluster\+Tree(), H\+Matrix$<$ spacedim, Number $>$\+::\+H\+Matrix(), main(), H\+Matrix$<$ spacedim, Number $>$\+::mmult(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::operator=(), and H\+Matrix$<$ spacedim, Number $>$\+::reinit().

\mbox{\Hypertarget{classBlockClusterTree_aec9920e5b215fbfe2aa9f54980d3b30a}\label{classBlockClusterTree_aec9920e5b215fbfe2aa9f54980d3b30a}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!increase\+\_\+node\+\_\+num@{increase\+\_\+node\+\_\+num}}
\index{increase\+\_\+node\+\_\+num@{increase\+\_\+node\+\_\+num}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{increase\+\_\+node\+\_\+num()}{increase\_node\_num()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
unsigned int \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::increase\+\_\+node\+\_\+num (\begin{DoxyParamCaption}\item[{unsigned int}]{increased\+\_\+node\+\_\+num = {\ttfamily 1} }\end{DoxyParamCaption})}

Increase the total number of nodes in the tree. 

References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::node\+\_\+num.

\mbox{\Hypertarget{classBlockClusterTree_a85553cc442e419b8d707720312118328}\label{classBlockClusterTree_a85553cc442e419b8d707720312118328}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!operator=@{operator=}}
\index{operator=@{operator=}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \& \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::operator= (\begin{DoxyParamCaption}\item[{const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{bct }\end{DoxyParamCaption})}

Overloaded assignment operator with deep copy. 
\begin{DoxyParams}{Parameters}
{\em bct} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
If the current block cluster tree is a subtree of an existing block cluster tree, clear its data members instead of releasing their memory.

References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::categorize\+\_\+near\+\_\+and\+\_\+far\+\_\+field\+\_\+sets(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::clear(), Copy\+Tree(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::depth, Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+root(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::is\+\_\+subtree, Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::max\+\_\+level, Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::node\+\_\+num, and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::release().



Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::\+Block\+Cluster\+Tree().

\mbox{\Hypertarget{classBlockClusterTree_aa635be81dfabed3ba455a17de3b65c2e}\label{classBlockClusterTree_aa635be81dfabed3ba455a17de3b65c2e}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!operator=@{operator=}}
\index{operator=@{operator=}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \& \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::operator= (\begin{DoxyParamCaption}\item[{\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&\&}]{bct }\end{DoxyParamCaption})}

Overloaded assignment operator with shallow copy. 
\begin{DoxyParams}{Parameters}
{\em bct} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::clear(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::depth, Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::is\+\_\+subtree, Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::max\+\_\+level, Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::node\+\_\+num, and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::release().

\mbox{\Hypertarget{classBlockClusterTree_a3ca42421f732c20fc07bdf5d5ab94319}\label{classBlockClusterTree_a3ca42421f732c20fc07bdf5d5ab94319}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!partition@{partition}}
\index{partition@{partition}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition()}{partition()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::partition (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&}]{all\+\_\+support\+\_\+points }\end{DoxyParamCaption})}

Perform a recursive partition by starting from the root node. The evaluation of the admissibility condition has no mesh cell size correction.


\begin{DoxyParams}{Parameters}
{\em all\+\_\+support\+\_\+points} & All the support points. \\
\hline
\end{DoxyParams}


References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::categorize\+\_\+near\+\_\+and\+\_\+far\+\_\+field\+\_\+sets(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node().



Referenced by find\+\_\+bc\+\_\+node\+\_\+in\+\_\+partition\+\_\+intersect\+\_\+current\+\_\+bc\+\_\+node(), main(), and prune\+\_\+to\+\_\+partition\+\_\+recursion().

\mbox{\Hypertarget{classBlockClusterTree_a075983197c805c6451aa00502dc30e76}\label{classBlockClusterTree_a075983197c805c6451aa00502dc30e76}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!partition@{partition}}
\index{partition@{partition}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition()}{partition()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::partition (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&}]{all\+\_\+support\+\_\+points,  }\item[{const std\+::vector$<$ Number $>$ \&}]{cell\+\_\+size\+\_\+at\+\_\+dofs }\end{DoxyParamCaption})}

Perform a recursive partition by starting from the root node. The evaluation of the admissibility condition has mesh cell size correction.


\begin{DoxyParams}{Parameters}
{\em all\+\_\+support\+\_\+points} & All the support points. \\
\hline
\end{DoxyParams}


References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::categorize\+\_\+near\+\_\+and\+\_\+far\+\_\+field\+\_\+sets(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node().

\mbox{\Hypertarget{classBlockClusterTree_a0e40b3884535eae57d00c078ec782459}\label{classBlockClusterTree_a0e40b3884535eae57d00c078ec782459}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product@{partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product}}
\index{partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product@{partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product()}{partition\_coarse\_non\_tensor\_product()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Perform a recursive partition in coarse non-\/tensor product form without the admissibility condition because the two comprising cluster trees are built from pure cardinality based partition. 

References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::categorize\+\_\+near\+\_\+and\+\_\+far\+\_\+field\+\_\+sets(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node().



Referenced by main().

\mbox{\Hypertarget{classBlockClusterTree_a61b6c204f3f1d5ff7c71a07b26ca9d09}\label{classBlockClusterTree_a61b6c204f3f1d5ff7c71a07b26ca9d09}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node@{partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node}}
\index{partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node@{partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node()}{partition\_coarse\_non\_tensor\_product\_from\_block\_cluster\_node()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node (\begin{DoxyParamCaption}\item[{\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type}}]{current\+\_\+block\+\_\+cluster\+\_\+node,  }\item[{std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&}]{leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Perform a recursive non-\/tensor product type coarse partition by starting from a block cluster node in the tree.

No admissibility condition is enabled in this situation, because the two comprising cluster trees are built from pure cardinality based partition.

Reference\+: Section 2.\+2.\+2 in Hackbusch, W. 1999. “A Sparse Matrix Arithmetic Based on H-\/\+Matrices. Part I\+: Introduction to H-\/\+Matrices.” Computing 62 (2)\+: 89–108. 
\begin{DoxyParams}{Parameters}
{\em current\+\_\+block\+\_\+cluster\+\_\+node} & \\
\hline
{\em leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node} & \\
\hline
\end{DoxyParams}
Push back the current cluster node, which is small, to the leaf set and set its split mode as {\ttfamily Unsplit\+Mode}.

Make sure that the two clusters $\tau$ and $\sigma$ have the same level in their respective cluster trees, i.\+e. level preserving property should be satisfied.

Create a new block cluster node as child. Then append this new node as one of the children of the current block cluster node. Finally, recursively partition from this node if the two component clusters have the same indices, i.\+e. $I_1 \times I_1$ and $I_2 \times I_2$; otherwise, for $I_1 \times I_2$ and $I_2 \times I_1$, stop the recursion and directly add them to the leaf set.

Append this new node as one of the children of the current block cluster node.

Handle the case for $I_1 \times I_1$ and $I_2 \times I_2$.

Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.

Handle the case for $I_1 \times I_2$ and $I_2 \times I_1$. Because the recursion stops here, we need to check and update its near field property.

Make sure the current block cluster have four children, which is ensured by the non-\/tensor product construction.


\begin{DoxyDescription}
\item[Note ]The second argument {\ttfamily \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$spacedim}, Number$>$\+::child\+\_\+num should be wrapped between the brackets, otherwise, the program cannot be compiled. 
\end{DoxyDescription}

Set the split mode of the current block cluster node as cross.

References Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+pointer(), and Tree\+Node$<$ T, N $>$\+::set\+\_\+split\+\_\+mode().



Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+coarse\+\_\+non\+\_\+tensor\+\_\+product().

\mbox{\Hypertarget{classBlockClusterTree_ac6d23af20c52c7b32eb080bd54556206}\label{classBlockClusterTree_ac6d23af20c52c7b32eb080bd54556206}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product@{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product}}
\index{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product@{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product()}{partition\_fine\_non\_tensor\_product()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Perform a recursive partition in fine non-\/tensor product form without the admissibility condition because the two comprising cluster trees are built from pure cardinality based partition. 

References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::categorize\+\_\+near\+\_\+and\+\_\+far\+\_\+field\+\_\+sets(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node().



Referenced by main().

\mbox{\Hypertarget{classBlockClusterTree_aa6354696477c8cae61d362b5ec707034}\label{classBlockClusterTree_aa6354696477c8cae61d362b5ec707034}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node@{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node}}
\index{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node@{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node()}{partition\_fine\_non\_tensor\_product\_from\_block\_cluster\_node()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node (\begin{DoxyParamCaption}\item[{\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type}}]{current\+\_\+block\+\_\+cluster\+\_\+node,  }\item[{std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&}]{leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Perform a recursive non-\/tensor product type fine partition of $\mathcal{M}_{\mathcal{H},k}$ type by starting from a block cluster node in the tree.

No admissibility condition is enabled in this situation, because the two comprising cluster trees are built from pure cardinality based partition.

Reference\+: Section 5 in Hackbusch, W. 1999. “A Sparse Matrix Arithmetic Based on H-\/\+Matrices. Part I\+: Introduction to H-\/\+Matrices.” Computing 62 (2)\+: 89–108. 
\begin{DoxyParams}{Parameters}
{\em current\+\_\+block\+\_\+cluster\+\_\+node} & \\
\hline
{\em leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node} & \\
\hline
\end{DoxyParams}
Push back the current cluster node, which is small, to the leaf set and set its split mode as {\ttfamily Unsplit\+Mode}.

Set the split mode of the current block cluster node as cross.

Make sure that the two clusters $\tau$ and $\sigma$ have the same level in their respective cluster trees, i.\+e. level preserving property should be satisfied.

Create a new block cluster node as child. Then append this new node as one of the children of the current block cluster node. Finally, recursively partition from this node using the fine non-\/tensor product method if the two component clusters have the same indices, i.\+e. $I_1 \times I_1$ and $I_2 \times I_2$; for $I_1 \times I_2$, recursively partition from it using the $\mathcal{N}$-\/type partition method; for $I_2 \times I_1$, recursively partition from it using the $\mathcal{N}^*$-\/type partition method.

Append this new node as one of the children of the current block cluster node.

Handle the case for $I_1 \times I_1$ and $I_2 \times I_2$ by recursively applying the fine non-\/tensor product partition method itself.

Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.

Handle the case for $I_1 \times I_2$ and perform the $\mathcal{N}$-\/type recursive partition.

Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.

Handle the case for $I_2 \times I_1$ and perform the $\mathcal{N}^*$-\/type recursive partition.

Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.

This case can never happen.

Make sure the current block cluster have four children, which is ensured by the fine non-\/tensor product construction.


\begin{DoxyDescription}
\item[Note ]{\bfseries The second argument {\ttfamily \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$spacedim}, Number$>$\+::child\+\_\+num should be wrapped between the brackets, otherwise, the program cannot be compiled.} 
\end{DoxyDescription}

References Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+pointer(), and Tree\+Node$<$ T, N $>$\+::set\+\_\+split\+\_\+mode().



Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product().

\mbox{\Hypertarget{classBlockClusterTree_aafad0fae48bf7c462e8e943b76893fc0}\label{classBlockClusterTree_aafad0fae48bf7c462e8e943b76893fc0}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node\+\_\+N@{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node\+\_\+N}}
\index{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node\+\_\+N@{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node\+\_\+N}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node\+\_\+\+N()}{partition\_fine\_non\_tensor\_product\_from\_block\_cluster\_node\_N()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node\+\_\+N (\begin{DoxyParamCaption}\item[{\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type}}]{current\+\_\+block\+\_\+cluster\+\_\+node,  }\item[{std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&}]{leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Perform a recursive non-\/tensor product type fine partition of $\mathcal{M}_{\mathcal{N},k}$ type by starting from a block cluster node in the tree.

No admissibility condition is enabled in this situation, because the two comprising cluster trees are built from pure cardinality based partition.

Reference\+: Section 5 in Hackbusch, W. 1999. “A Sparse Matrix Arithmetic Based on H-\/\+Matrices. Part I\+: Introduction to H-\/\+Matrices.” Computing 62 (2)\+: 89–108. 
\begin{DoxyParams}{Parameters}
{\em current\+\_\+block\+\_\+cluster\+\_\+node} & \\
\hline
{\em leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node} & \\
\hline
\end{DoxyParams}
Push back the current cluster node, which is small, to the leaf set and set its split mode as {\ttfamily Unsplit\+Mode}.

Make sure that the two clusters $\tau$ and $\sigma$ have the same level in their respective cluster trees, i.\+e. level preserving property should be satisfied.

Create a new block cluster node as child. Then append this new node as one of the children of the current block cluster node. Finally, recursively partition from this node if it is on the bottom left corner, i.\+e. it is the $I_2 \times I_1$ block cluster; otherwise, for $I_1 \times I_1$, $I_1 \times I_2$ and $I_2 \times I_2$, stop the recursion and directly add them to the leaf set.

Append this new node as one of the children of the current block cluster node.

Handle the case for $I_2 \times I_1$ and perform the $\mathcal{N}$-\/type recursive partition.

Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.

Handle the case for $I_1 \times I_1$, $I_1 \times I_2$ and $I_2 \times I_2$. Because the recursion stops here, we need to check and update its near field property.

Make sure the current block cluster have four children, which is ensured by the fine non-\/tensor product $\mathcal{N}$-\/type construction.


\begin{DoxyDescription}
\item[Note ]The second argument {\ttfamily \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$spacedim}, Number$>$\+::child\+\_\+num should be wrapped between the brackets, otherwise, the program cannot be compiled. 
\end{DoxyDescription}

Set the split mode of the current block cluster node as cross.

References Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+pointer(), and Tree\+Node$<$ T, N $>$\+::set\+\_\+split\+\_\+mode().

\mbox{\Hypertarget{classBlockClusterTree_afdeb6723e01b5eaf11281e2c1c1cf566}\label{classBlockClusterTree_afdeb6723e01b5eaf11281e2c1c1cf566}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node\+\_\+\+Nstar@{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node\+\_\+\+Nstar}}
\index{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node\+\_\+\+Nstar@{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node\+\_\+\+Nstar}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node\+\_\+\+Nstar()}{partition\_fine\_non\_tensor\_product\_from\_block\_cluster\_node\_Nstar()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::partition\+\_\+fine\+\_\+non\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node\+\_\+\+Nstar (\begin{DoxyParamCaption}\item[{\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type}}]{current\+\_\+block\+\_\+cluster\+\_\+node,  }\item[{std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&}]{leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Perform a recursive non-\/tensor product type fine partition of $\mathcal{M}_{\mathcal{N}^*,k}$ type by starting from a block cluster node in the tree.

No admissibility condition is enabled in this situation, because the two comprising cluster trees are built from pure cardinality based partition.

Reference\+: Section 5 in Hackbusch, W. 1999. “A Sparse Matrix Arithmetic Based on H-\/\+Matrices. Part I\+: Introduction to H-\/\+Matrices.” Computing 62 (2)\+: 89–108. 
\begin{DoxyParams}{Parameters}
{\em current\+\_\+block\+\_\+cluster\+\_\+node} & \\
\hline
{\em leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node} & \\
\hline
\end{DoxyParams}
Push back the current cluster node, which is small, to the leaf set and set its split mode as {\ttfamily Unsplit\+Mode}.

Make sure that the two clusters $\tau$ and $\sigma$ have the same level in their respective cluster trees, i.\+e. level preserving property should be satisfied.

Create a new block cluster node as child. Then append this new node as one of the children of the current block cluster node. Finally, recursively partition from this node if it is on the top right corner, i.\+e. it is the $I_1 \times I_2$ block cluster; otherwise, for $I_1 \times I_1$, $I_2 \times I_1$ and $I_2 \times I_2$, stop the recursion and directly add them to the leaf set.

Append this new node as one of the children of the current block cluster node.

Handle the case for $I_1 \times I_2$ and perform the $\mathcal{N}^*$-\/type recursive partition.

Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.

Handle the case for $I_1 \times I_1$, $I_2 \times I_1$ and $I_2 \times I_2$. Because the recursion stops here, we need to check and update its near field property.

Make sure the current block cluster have four children, which is ensured by the fine non-\/tensor product $\mathcal{N}^*$-\/type construction.


\begin{DoxyDescription}
\item[Note ]The second argument {\ttfamily \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$spacedim}, Number$>$\+::child\+\_\+num should be wrapped between the brackets, otherwise, the program cannot be compiled. 
\end{DoxyDescription}

Set the split mode of the current block cluster node as cross.

References Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+pointer(), and Tree\+Node$<$ T, N $>$\+::set\+\_\+split\+\_\+mode().

\mbox{\Hypertarget{classBlockClusterTree_ad11fb277e43c33f2a399dc6b1c14b998}\label{classBlockClusterTree_ad11fb277e43c33f2a399dc6b1c14b998}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!partition\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node@{partition\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node}}
\index{partition\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node@{partition\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node()}{partition\_from\_block\_cluster\_node()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::partition\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node (\begin{DoxyParamCaption}\item[{\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type}}]{current\+\_\+block\+\_\+cluster\+\_\+node,  }\item[{const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&}]{all\+\_\+support\+\_\+points,  }\item[{std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&}]{leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Perform a recursive partition by starting from a block cluster node in the tree.

N.\+B. The evaluation of the admissibility condition has no mesh cell size correction.

The algorithm performs an iteration over all the children of the current block cluster $b = \tau \times \sigma$. Because the map $S$ for generating the children of $b$ is realized from a tensor product of the children of $\tau$ and $\sigma$, the algorithm contains nested double loops.


\begin{DoxyParams}{Parameters}
{\em current\+\_\+block\+\_\+cluster\+\_\+node} & The pointer to the block cluster node in the tree, from which the admissible partition will be performed. \\
\hline
{\em all\+\_\+support\+\_\+points} & Spatial coordinates for all the support points. \\
\hline
{\em leaf\+\_\+set} & A list of block cluster node pointers which comprise the leaf set with respect to {\ttfamily current\+\_\+block\+\_\+cluster\+\_\+node}. \\
\hline
\end{DoxyParams}
Push back the current cluster node, which is small, to the leaf set and set its split mode as {\ttfamily Unsplit\+Mode}.

Make sure that the two clusters $\tau$ and $\sigma$ have the same level in their respective cluster trees, i.\+e. level preserving property should be satisfied.

Create a new block cluster node as child and recursively partition from it.

Append this new node as one of the children of the current block cluster node.

Update the total number of nodes in the tree.

Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.

Make sure the current block cluster have four children, which is ensured by the tensor product construction.


\begin{DoxyDescription}
\item[Note ]The second argument {\ttfamily \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$spacedim}, Number$>$\+::child\+\_\+num should be wrapped between the brackets, otherwise, the program cannot be compiled. 
\end{DoxyDescription}

Set the split mode of the current block cluster node as cross.

References Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+pointer(), and Tree\+Node$<$ T, N $>$\+::set\+\_\+split\+\_\+mode().



Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition().

\mbox{\Hypertarget{classBlockClusterTree_a425583a70d63ddbf9341a31b736bd0fe}\label{classBlockClusterTree_a425583a70d63ddbf9341a31b736bd0fe}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!partition\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node@{partition\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node}}
\index{partition\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node@{partition\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node()}{partition\_from\_block\_cluster\_node()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::partition\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node (\begin{DoxyParamCaption}\item[{\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type}}]{current\+\_\+block\+\_\+cluster\+\_\+node,  }\item[{const std\+::vector$<$ Point$<$ spacedim $>$$>$ \&}]{all\+\_\+support\+\_\+points,  }\item[{const std\+::vector$<$ Number $>$ \&}]{cell\+\_\+size\+\_\+at\+\_\+dofs,  }\item[{std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&}]{leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Same as above but the evaluation of the admissibility condition has mesh cell size correction. Push back the current cluster node, which is small, to the leaf set and set its split mode as {\ttfamily Unsplit\+Mode}.

Make sure that the two clusters $\tau$ and $\sigma$ have the same level in their respective cluster trees, i.\+e. level preserving property should be satisfied.

Create a new block cluster node as child and recursively partition from it.

Append this new node as one of the children of the current block cluster node.

Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.

Make sure the current block cluster have four children, which is ensured by the tensor product construction.


\begin{DoxyDescription}
\item[Note ]The second argument {\ttfamily \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$spacedim}, Number$>$\+::child\+\_\+num should be wrapped between the brackets, otherwise, the program cannot be compiled. 
\end{DoxyDescription}

Set the split mode of the current block cluster node as cross.

References Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+pointer(), and Tree\+Node$<$ T, N $>$\+::set\+\_\+split\+\_\+mode().

\mbox{\Hypertarget{classBlockClusterTree_ab10f54639969bc4aacd6aa27cf315610}\label{classBlockClusterTree_ab10f54639969bc4aacd6aa27cf315610}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!partition\+\_\+tensor\+\_\+product@{partition\+\_\+tensor\+\_\+product}}
\index{partition\+\_\+tensor\+\_\+product@{partition\+\_\+tensor\+\_\+product}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition\+\_\+tensor\+\_\+product()}{partition\_tensor\_product()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::partition\+\_\+tensor\+\_\+product (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Perform a recursive partition in tensor product form without the admissibility condition because the two comprising cluster trees are built from pure cardinality based partition. 

References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::categorize\+\_\+near\+\_\+and\+\_\+far\+\_\+field\+\_\+sets(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node().



Referenced by main().

\mbox{\Hypertarget{classBlockClusterTree_ae77f8167ce49871f5751b8dcf8c93153}\label{classBlockClusterTree_ae77f8167ce49871f5751b8dcf8c93153}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!partition\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node@{partition\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node}}
\index{partition\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node@{partition\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{partition\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node()}{partition\_tensor\_product\_from\_block\_cluster\_node()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::partition\+\_\+tensor\+\_\+product\+\_\+from\+\_\+block\+\_\+cluster\+\_\+node (\begin{DoxyParamCaption}\item[{\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type}}]{current\+\_\+block\+\_\+cluster\+\_\+node,  }\item[{std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&}]{leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Perform a recursive tensor product type partition by starting from a block cluster node in the tree.

No admissibility condition is enabled in this situation, because the two comprising cluster trees are built from pure cardinality based partition. 
\begin{DoxyParams}{Parameters}
{\em current\+\_\+block\+\_\+cluster\+\_\+node} & \\
\hline
{\em leaf\+\_\+set\+\_\+wrt\+\_\+current\+\_\+node} & \\
\hline
\end{DoxyParams}
Push back the current cluster node, which is small, to the leaf set and set its split mode as {\ttfamily Unsplit\+Mode}.

Make sure that the two clusters $\tau$ and $\sigma$ have the same level in their respective cluster trees, i.\+e. level preserving property should be satisfied.

Create a new block cluster node as child and recursively partition from it.

Append this new node as one of the children of the current block cluster node.

Merge the leaf set wrt. the child block cluster node into the leaf set of the current block cluster node.

Make sure the current block cluster have four children, which is ensured by the tensor product construction.


\begin{DoxyDescription}
\item[Note ]The second argument {\ttfamily \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$spacedim}, Number$>$\+::child\+\_\+num should be wrapped between the brackets, otherwise, the program cannot be compiled. 
\end{DoxyDescription}

Set the split mode of the current block cluster node as cross.

References Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+pointer(), and Tree\+Node$<$ T, N $>$\+::set\+\_\+split\+\_\+mode().



Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+root(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::partition\+\_\+tensor\+\_\+product().

\mbox{\Hypertarget{classBlockClusterTree_a6fd771b68a4c7195151f6dc02e8ec7e9}\label{classBlockClusterTree_a6fd771b68a4c7195151f6dc02e8ec7e9}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!prune\+\_\+descendants\+\_\+from\+\_\+node@{prune\+\_\+descendants\+\_\+from\+\_\+node}}
\index{prune\+\_\+descendants\+\_\+from\+\_\+node@{prune\+\_\+descendants\+\_\+from\+\_\+node}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{prune\+\_\+descendants\+\_\+from\+\_\+node()}{prune\_descendants\_from\_node()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
bool \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::prune\+\_\+descendants\+\_\+from\+\_\+node (\begin{DoxyParamCaption}\item[{\hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type}}]{bc\+\_\+node }\end{DoxyParamCaption})}

Prune the descendants of the given block cluster node. 
\begin{DoxyParams}{Parameters}
{\em bc\+\_\+node} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether the block cluster tree is really pruned. 
\end{DoxyReturn}
Delete the subtree emanating from each child node of the current block cluster node in the partition.

Update the block cluster node status including number of children and split mode.

References Count\+Tree\+Nodes(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::decrease\+\_\+node\+\_\+num(), Delete\+Tree(), Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+num(), Tree\+Node$<$ T, N $>$\+::get\+\_\+child\+\_\+pointer(), Tree\+Node$<$ T, N $>$\+::set\+\_\+child\+\_\+num(), Tree\+Node$<$ T, N $>$\+::set\+\_\+child\+\_\+pointer(), and Tree\+Node$<$ T, N $>$\+::set\+\_\+split\+\_\+mode().



Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::prune\+\_\+to\+\_\+partition(), and prune\+\_\+to\+\_\+partition\+\_\+recursion().

\mbox{\Hypertarget{classBlockClusterTree_af1663a109b6fd5c67c85e9bb88a54a13}\label{classBlockClusterTree_af1663a109b6fd5c67c85e9bb88a54a13}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!prune\+\_\+to\+\_\+partition@{prune\+\_\+to\+\_\+partition}}
\index{prune\+\_\+to\+\_\+partition@{prune\+\_\+to\+\_\+partition}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{prune\+\_\+to\+\_\+partition()}{prune\_to\_partition()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
bool \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::prune\+\_\+to\+\_\+partition (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \hyperlink{classTreeNode}{node\+\_\+pointer\+\_\+type} $>$ \&}]{partition,  }\item[{const bool}]{is\+\_\+partition\+\_\+in\+\_\+bct }\end{DoxyParamCaption})}

Prune all those block cluster nodes which are descendants of the block cluster nodes in the given partition.


\begin{DoxyParams}{Parameters}
{\em partition} & \\
\hline
{\em is\+\_\+partition\+\_\+in\+\_\+bct} & Whether the block cluster nodes in the given {\ttfamily partition} are contained in this block cluster tree. \\
\hline
\end{DoxyParams}
If the block cluster nodes in the given {\ttfamily partition} are contained in this block cluster tree, we directly prune their descendants.

References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::categorize\+\_\+near\+\_\+and\+\_\+far\+\_\+field\+\_\+sets(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::prune\+\_\+descendants\+\_\+from\+\_\+node().



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::convert\+\_\+between\+\_\+different\+\_\+block\+\_\+cluster\+\_\+trees().

\mbox{\Hypertarget{classBlockClusterTree_a0415fe94fd480bbb985a45dc691e2bed}\label{classBlockClusterTree_a0415fe94fd480bbb985a45dc691e2bed}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!release@{release}}
\index{release@{release}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{release()}{release()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::release (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Release the memory of the block cluster tree. 

References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::clear(), and Delete\+Tree().



Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::operator=(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::$\sim$\+Block\+Cluster\+Tree().

\mbox{\Hypertarget{classBlockClusterTree_a02be4a882acca918386ad024769925bc}\label{classBlockClusterTree_a02be4a882acca918386ad024769925bc}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!set\+\_\+node\+\_\+num@{set\+\_\+node\+\_\+num}}
\index{set\+\_\+node\+\_\+num@{set\+\_\+node\+\_\+num}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{set\+\_\+node\+\_\+num()}{set\_node\_num()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::set\+\_\+node\+\_\+num (\begin{DoxyParamCaption}\item[{unsigned int}]{node\+\_\+num }\end{DoxyParamCaption})}

Set the total number of nodes in the tree. 

References Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::node\+\_\+num.

\mbox{\Hypertarget{classBlockClusterTree_aef01b51b0530536bc5481492d4719375}\label{classBlockClusterTree_aef01b51b0530536bc5481492d4719375}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!write\+\_\+leaf\+\_\+set@{write\+\_\+leaf\+\_\+set}}
\index{write\+\_\+leaf\+\_\+set@{write\+\_\+leaf\+\_\+set}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{write\+\_\+leaf\+\_\+set()}{write\_leaf\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::write\+\_\+leaf\+\_\+set (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out }\end{DoxyParamCaption}) const}

Write formatted leaf set to the output stream.

Each leaf node is written in the following format\+:

\begin{quote}


\end{quote}
\mbox{[}list-\/of-\/indices-\/in-\/cluster-\/tau\mbox{]},\mbox{[}list-\/of-\/indices-\/in-\/cluster-\/sigma\mbox{]},is\+\_\+near\+\_\+field

For example,

\begin{quote}
\mbox{[}1 2 3 ...\mbox{]},\mbox{[}7 8 9 ...\mbox{]},1 \end{quote}

\begin{DoxyParams}{Parameters}
{\em out} & \\
\hline
\end{DoxyParams}
Print index set of cluster $\tau$.

Print index set of cluster $\sigma$.

Print the {\ttfamily is\+\_\+near\+\_\+field} flag.

Referenced by main().

\mbox{\Hypertarget{classBlockClusterTree_a652b1c53dff2794e2f18343bf3988e19}\label{classBlockClusterTree_a652b1c53dff2794e2f18343bf3988e19}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!write\+\_\+leaf\+\_\+set@{write\+\_\+leaf\+\_\+set}}
\index{write\+\_\+leaf\+\_\+set@{write\+\_\+leaf\+\_\+set}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{write\+\_\+leaf\+\_\+set()}{write\_leaf\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
template$<$typename Number1 $>$ \\
void \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::write\+\_\+leaf\+\_\+set (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&}]{matrix,  }\item[{const Number1}]{singular\+\_\+value\+\_\+threshold = {\ttfamily 0.} }\end{DoxyParamCaption}) const}

Write formatted leaf set to the output stream as well as the rank of each matrix block.

Each leaf node is written in the following format\+:

\begin{quote}


\end{quote}
\mbox{[}list-\/of-\/indices-\/in-\/cluster-\/tau\mbox{]},\mbox{[}list-\/of-\/indices-\/in-\/cluster-\/sigma\mbox{]},is\+\_\+near\+\_\+field,rank

For example,

\begin{quote}
\mbox{[}1 2 3 ...\mbox{]},\mbox{[}7 8 9 ...\mbox{]},1,1 \end{quote}

\begin{DoxyParams}{Parameters}
{\em out} & \\
\hline
\end{DoxyParams}
Print index set of cluster $\tau$.

Print index set of cluster $\sigma$.

Print the {\ttfamily is\+\_\+near\+\_\+field} flag.

Make a local copy of the matrix block and calculate its rank using S\+VD.

Print the {\ttfamily rank} flag.

\subsection{Friends And Related Function Documentation}
\mbox{\Hypertarget{classBlockClusterTree_a6ead7d49add78a2462eb039f00bf7f6a}\label{classBlockClusterTree_a6ead7d49add78a2462eb039f00bf7f6a}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{operator$<$$<$}{operator<<}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
template$<$int spacedim1, typename Number1 $>$ \\
std\+::ostream\& operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out,  }\item[{const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$ \&}]{block\+\_\+cluster\+\_\+tree }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}

Print a whole block cluster tree using recursion. 
\begin{DoxyParams}{Parameters}
{\em out} & \\
\hline
{\em block\+\_\+cluster\+\_\+tree} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}\label{classBlockClusterTree_a000c439b578bcf4fa28b7f3edd6079e9}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!child\+\_\+num@{child\+\_\+num}}
\index{child\+\_\+num@{child\+\_\+num}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{child\+\_\+num}{child\_num}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
const unsigned int \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::child\+\_\+num = 4\hspace{0.3cm}{\ttfamily [static]}}

Number of children in a block cluster tree.

At present, only quad-\/tree is allowed. \mbox{\Hypertarget{classBlockClusterTree_a77349ec9ccb36d45af3f176a93516897}\label{classBlockClusterTree_a77349ec9ccb36d45af3f176a93516897}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!depth@{depth}}
\index{depth@{depth}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{depth}{depth}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
unsigned int \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::depth\hspace{0.3cm}{\ttfamily [private]}}

Depth of the tree, which is the maximum level plus one. 

Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::clear(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+depth(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::operator=().

\mbox{\Hypertarget{classBlockClusterTree_a8dc01af98989bb71246fa2cd4d7307da}\label{classBlockClusterTree_a8dc01af98989bb71246fa2cd4d7307da}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!is\+\_\+subtree@{is\+\_\+subtree}}
\index{is\+\_\+subtree@{is\+\_\+subtree}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{is\+\_\+subtree}{is\_subtree}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
bool \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::is\+\_\+subtree\hspace{0.3cm}{\ttfamily [private]}}

Whether the current block cluster tree is a subtree of an existing tree. 

Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::clear(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::operator=(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::$\sim$\+Block\+Cluster\+Tree().

\mbox{\Hypertarget{classBlockClusterTree_a9151f138713d01c53ac17f004c7e6b62}\label{classBlockClusterTree_a9151f138713d01c53ac17f004c7e6b62}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!max\+\_\+level@{max\+\_\+level}}
\index{max\+\_\+level@{max\+\_\+level}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{max\+\_\+level}{max\_level}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
int \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::max\+\_\+level\hspace{0.3cm}{\ttfamily [private]}}

Maximum node level in the tree, which is {\ttfamily depth} -\/ 1. 

Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::calc\+\_\+depth\+\_\+and\+\_\+max\+\_\+level(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::clear(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+max\+\_\+level(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::operator=().

\mbox{\Hypertarget{classBlockClusterTree_a75757146cea0aa0e9271b760b1d76307}\label{classBlockClusterTree_a75757146cea0aa0e9271b760b1d76307}} 
\index{Block\+Cluster\+Tree@{Block\+Cluster\+Tree}!node\+\_\+num@{node\+\_\+num}}
\index{node\+\_\+num@{node\+\_\+num}!Block\+Cluster\+Tree@{Block\+Cluster\+Tree}}
\subsubsection{\texorpdfstring{node\+\_\+num}{node\_num}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
unsigned int \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+num\hspace{0.3cm}{\ttfamily [private]}}

Total number of block clusters in the tree. 

Referenced by Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::\+Block\+Cluster\+Tree(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::clear(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::decrease\+\_\+node\+\_\+num(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+node\+\_\+num(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::increase\+\_\+node\+\_\+num(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::operator=(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::set\+\_\+node\+\_\+num().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/jihuan/\+Projects/deal.\+ii/program/dealii-\/9.\+1.\+1/examples/laplace-\/bem/include/\hyperlink{block__cluster__tree_8h}{block\+\_\+cluster\+\_\+tree.\+h}\end{DoxyCompactItemize}
