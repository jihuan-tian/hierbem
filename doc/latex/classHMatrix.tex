\hypertarget{classHMatrix}{}\section{H\+Matrix$<$ spacedim, Number $>$ Class Template Reference}
\label{classHMatrix}\index{H\+Matrix$<$ spacedim, Number $>$@{H\+Matrix$<$ spacedim, Number $>$}}


Collaboration diagram for H\+Matrix$<$ spacedim, Number $>$\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classHMatrix__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} = std\+::make\+\_\+unsigned$<$ types\+::blas\+\_\+int $>$\+::\hyperlink{classHMatrix_a89ef60f3ba737c04708195ca0bb13620}{type}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classHMatrix_ae3dc35e1aefee2580d27ad2d65c906de}{H\+Matrix} ()
\item 
\hyperlink{classHMatrix_a6a4dead0321e8df38865bf6fbd0f6e81}{H\+Matrix} (const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&bct, const unsigned int fixed\+\_\+rank\+\_\+k=1)
\item 
\hyperlink{classHMatrix_a4fe44a3aa2b813f593b787f24be56a1c}{H\+Matrix} (typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type \hyperlink{classHMatrix_a4a304494c970b5b267be1d8459d51586}{bc\+\_\+node}, const unsigned int fixed\+\_\+rank\+\_\+k=1)
\item 
\hyperlink{classHMatrix_a8e7d103ec4f093870f9e792e26d6b915}{H\+Matrix} (const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&bct, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M, const unsigned int fixed\+\_\+rank\+\_\+k=1)
\item 
\hyperlink{classHMatrix_abb59b3981e9f32f319479088d786989d}{H\+Matrix} (typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type \hyperlink{classHMatrix_a4a304494c970b5b267be1d8459d51586}{bc\+\_\+node}, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&M, const unsigned int fixed\+\_\+rank\+\_\+k=1)
\item 
\hyperlink{classHMatrix_abeb8d0add9bffecafc12f4c6b1dcab8e}{H\+Matrix} (typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type \hyperlink{classHMatrix_a4a304494c970b5b267be1d8459d51586}{bc\+\_\+node}, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&\&H)
\item 
\hyperlink{classHMatrix_a78aa967d7a99e27cc172f0db3791306b}{H\+Matrix} (const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&bct, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&\&H)
\item 
\hyperlink{classHMatrix_a0b5227e35290f6c9fba1e8948e9a29c3}{H\+Matrix} (const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&H)
\item 
\hyperlink{classHMatrix_a556325d4cdaee699f17aa1be63bb58ee}{H\+Matrix} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&\&H)
\item 
void \hyperlink{classHMatrix_a83f804163e1695cfb952ddb6b0df2503}{reinit} (const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&bct, const unsigned int fixed\+\_\+rank\+\_\+k=1)
\item 
void \hyperlink{classHMatrix_a41d20c1839f3d7a756107b8e4defea0b}{reinit} (typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type \hyperlink{classHMatrix_a4a304494c970b5b267be1d8459d51586}{bc\+\_\+node}, const unsigned int fixed\+\_\+rank\+\_\+k=1)
\item 
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \& \hyperlink{classHMatrix_a2c72ede65323af5b57a6b16f5774de50}{operator=} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&\&H)
\item 
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \& \hyperlink{classHMatrix_a83958971f40409b3b2a192b71eae1513}{operator=} (const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&H)
\item 
{\footnotesize template$<$typename Matrix\+Type $>$ }\\void \hyperlink{classHMatrix_a00bdd40f7fcf5c912c34c427df518300}{convert\+To\+Full\+Matrix} (Matrix\+Type \&M) const
\item 
void \hyperlink{classHMatrix_a812e8276888b2ad866edf7ce9b286839}{release} ()
\item 
void \hyperlink{classHMatrix_ae55bd45587b895bfdb977e7cbea46519}{clear} ()
\item 
void \hyperlink{classHMatrix_aec0815bc9c3654391bb2b3095383e6cb}{clear\+\_\+hmat\+\_\+node} ()
\item 
\hyperlink{classHMatrix_ae16c956c1b22eb307e9f360a83f4fa75}{$\sim$\+H\+Matrix} ()
\item 
\hyperlink{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494}{H\+Matrix\+Type} \hyperlink{classHMatrix_aadea9fa59f420d22b3b1c939f6b573cc}{get\+\_\+type} () const
\item 
\hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} \hyperlink{classHMatrix_aabe735f7712a10ba5325ff116f8ca1c7}{get\+\_\+m} () const
\item 
\hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} \hyperlink{classHMatrix_abff89130116d62ea4159bc69ca11f8d5}{get\+\_\+n} () const
\item 
\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ $\ast$ \hyperlink{classHMatrix_a0189de6e276fbd3425c4a7ef132f5e16}{get\+\_\+rkmatrix} ()
\item 
const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ $\ast$ \hyperlink{classHMatrix_a64c81db6357d0e00b82fd523af001ae5}{get\+\_\+rkmatrix} () const
\item 
void \hyperlink{classHMatrix_a72191c447afaa0fd84505022cf1d174e}{calc\+\_\+rank\+\_\+upper\+\_\+bound\+\_\+for\+\_\+rkmatrices} () const
\item 
\hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ $\ast$ \hyperlink{classHMatrix_a9d914c27d4e990d476a4529b2daa64cd}{get\+\_\+fullmatrix} ()
\item 
const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ $\ast$ \hyperlink{classHMatrix_aed550b5b41a64c6f1bbcde4f8f7eca91}{get\+\_\+fullmatrix} () const
\item 
std\+::vector$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ $>$ \& \hyperlink{classHMatrix_a0572b2c0484ce618db0034e3bc7988ed}{get\+\_\+submatrices} ()
\item 
const std\+::vector$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ $>$ \& \hyperlink{classHMatrix_a8f8e9bc437ab86296d78950081ea34cd}{get\+\_\+submatrices} () const
\item 
void \hyperlink{classHMatrix_a7e849f7e8f35e3ebdfcb2dbb7ad4ad01}{print\+\_\+formatted} (std\+::ostream \&out, const unsigned int precision=3, const bool scientific=true, const unsigned int width=0, const char $\ast$zero\+\_\+string=\char`\"{} \char`\"{}, const double denominator=1., const double threshold=0.) const
\item 
void \hyperlink{classHMatrix_ad8f87883cf49080706233441c0e09171}{print\+\_\+matrix\+\_\+info} (std\+::ostream \&out) const
\item 
void \hyperlink{classHMatrix_aab0c393acf1c416ebc7ab05ca85d9e49}{print\+\_\+current\+\_\+matrix\+\_\+info} (std\+::ostream \&out) const
\item 
void \hyperlink{classHMatrix_ae904288a7e0ac82d9fd2364b1c150bc2}{print\+\_\+matrix\+\_\+info\+\_\+as\+\_\+dot} (std\+::ostream \&out) const
\item 
void \hyperlink{classHMatrix_a42f958a13c56d64564d59487e67bc8a2}{write\+\_\+fullmatrix\+\_\+leaf\+\_\+node} (std\+::ostream \&out, const Number singular\+\_\+value\+\_\+threshold=0.) const
\item 
void \hyperlink{classHMatrix_ac2c8ccd5763d3952505741c657b6468c}{write\+\_\+rkmatrix\+\_\+leaf\+\_\+node} (std\+::ostream \&out) const
\item 
void \hyperlink{classHMatrix_aaf0ae0960a40ad78a941aee823e80315}{write\+\_\+leaf\+\_\+set} (std\+::ostream \&out, const Number singular\+\_\+value\+\_\+threshold=0.) const
\item 
void \hyperlink{classHMatrix_aac1e1ddbfeb133520dcd50c0174aab8d}{write\+\_\+leaf\+\_\+set\+\_\+by\+\_\+iteration} (std\+::ostream \&out, const Number singular\+\_\+value\+\_\+threshold=0.) const
\item 
\hyperlink{classHMatrix}{H\+Matrix} $\ast$ \hyperlink{classHMatrix_a1da518d5ca7e685e3e787f58dcad4e61}{find\+\_\+row\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block} ()
\item 
\hyperlink{classHMatrix}{H\+Matrix} $\ast$ \hyperlink{classHMatrix_a1ab763860706b9cbef8f5e73d995f29a}{find\+\_\+col\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block} ()
\item 
void \hyperlink{classHMatrix_a64be687cacd167efc12b892aa154dcd3}{truncate\+\_\+to\+\_\+rank} (\hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} new\+\_\+rank)
\item 
void \hyperlink{classHMatrix_a15191d30e94d5f54d30c5f612f606ce1}{truncate\+\_\+to\+\_\+rank\+\_\+preserve\+\_\+positive\+\_\+definite} (\hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} new\+\_\+rank)
\item 
void \hyperlink{classHMatrix_a93834ac1b8a659dc2b81cd3af1dea997}{truncate\+\_\+to\+\_\+rank\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite} (\hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} new\+\_\+rank)
\item 
void \hyperlink{classHMatrix_a58c40b6db50fe3dbbf230f951d346b9c}{truncate\+\_\+to\+\_\+rank\+\_\+off\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite} (\hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} new\+\_\+rank)
\item 
void \hyperlink{classHMatrix_aa11b5761aba86606effd14b4bdf31912}{vmult} (Vector$<$ Number $>$ \&y, const Vector$<$ Number $>$ \&x) const
\item 
void \hyperlink{classHMatrix_a21ca2a043c8a02a531d5d08437356310}{vmult} (Vector$<$ Number $>$ \&y, const Number alpha, const Vector$<$ Number $>$ \&x) const
\item 
void \hyperlink{classHMatrix_a690927f0810d85d08f0ab2239e405ffe}{vmult} (Vector$<$ Number $>$ \&y, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&y\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, const Vector$<$ Number $>$ \&x, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&x\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map) const
\item 
void \hyperlink{classHMatrix_ab0a61c4d55a5d132b25589240be5c015}{vmult} (Vector$<$ Number $>$ \&y, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&y\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, const Number alpha, const Vector$<$ Number $>$ \&x, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&x\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map) const
\item 
void \hyperlink{classHMatrix_a72e5255eb5ce46136d0e2b195c82f016}{Tvmult} (Vector$<$ Number $>$ \&y, const Vector$<$ Number $>$ \&x) const
\item 
void \hyperlink{classHMatrix_a46298efb74444db494068cc3fab73431}{Tvmult} (Vector$<$ Number $>$ \&y, const Number alpha, const Vector$<$ Number $>$ \&x) const
\item 
void \hyperlink{classHMatrix_a52a9fb807eab3f9f0903c03dd637382c}{Tvmult} (Vector$<$ Number $>$ \&y, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&y\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, const Vector$<$ Number $>$ \&x, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&x\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map) const
\item 
void \hyperlink{classHMatrix_a9ce6e0dd7cfa3dc0fff165d6ed819017}{Tvmult} (Vector$<$ Number $>$ \&y, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&y\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, const Number alpha, const Vector$<$ Number $>$ \&x, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&x\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map) const
\item 
void \hyperlink{classHMatrix_a168b6eea2e5b27528497850bf5ee2bbe}{h\+\_\+h\+\_\+mmult\+\_\+reduction} ()
\item 
void \hyperlink{classHMatrix_a38c88893c6ca784d4e56653d8b0e3e67}{h\+\_\+h\+\_\+mmult\+\_\+horizontal\+\_\+split} (\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&bc\+\_\+tree)
\item 
void \hyperlink{classHMatrix_a253c23d09e89a9a37a7d808374b5ae4e}{h\+\_\+h\+\_\+mmult\+\_\+vertical\+\_\+split} (\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&bc\+\_\+tree)
\item 
void \hyperlink{classHMatrix_ab315324e3ece178943f406823f792746}{h\+\_\+h\+\_\+mmult\+\_\+cross\+\_\+split} (\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&bc\+\_\+tree)
\item 
void \hyperlink{classHMatrix_af40d53aabc8bec86fa543638d48ba64e}{mmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&C, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&B, const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&bct\+\_\+a, const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&bct\+\_\+b, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&bct\+\_\+c, const unsigned int fixed\+\_\+rank=1)
\item 
void \hyperlink{classHMatrix_a4139e9069e3b18d4719c527ce2e0414c}{mmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&C, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&B, const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&bct\+\_\+a, const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&bct\+\_\+b, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&bct\+\_\+c, const unsigned int fixed\+\_\+rank, const bool adding)
\item 
void \hyperlink{classHMatrix_a4ea0317bff2670e3ed7e48416f908873}{mmult\+\_\+level\+\_\+conserving} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&C, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&B, const unsigned int fixed\+\_\+rank)
\item 
void \hyperlink{classHMatrix_aefdb7dbcff58654f53a149b94e545bf7}{mmult\+\_\+level\+\_\+conserving} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&C, const Number alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&B, const unsigned int fixed\+\_\+rank)
\item 
void \hyperlink{classHMatrix_a0b7fe2940b614a130d154a29b28b39d4}{m\+Tmult\+\_\+level\+\_\+conserving} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&C, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&B, const unsigned int fixed\+\_\+rank)
\item 
void \hyperlink{classHMatrix_aae163c33fc8d51f96df712ca192e0b6f}{m\+Tmult\+\_\+level\+\_\+conserving} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&C, const Number alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&B, const unsigned int fixed\+\_\+rank)
\item 
void \hyperlink{classHMatrix_a8f96186426cd3147d5af32ca84ad25ea}{add} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&C, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&B, const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} fixed\+\_\+rank\+\_\+k) const
\item 
void \hyperlink{classHMatrix_aea42f5112b88270fef73342853fa386d}{add} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&C, const Number b, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&B, const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} fixed\+\_\+rank\+\_\+k) const
\item 
void \hyperlink{classHMatrix_a9bd48ada567962ab0dc75c31986bd1a6}{add} (const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&B, const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} fixed\+\_\+rank\+\_\+k) const
\item 
void \hyperlink{classHMatrix_af42aaa86b9f47c5c1514e4f06e343db6}{add} (const Number b, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&B, const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} fixed\+\_\+rank\+\_\+k) const
\item 
void \hyperlink{classHMatrix_a1793dff400aeae649f909d7f45db8b8a}{add} (const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&B, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+rk, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+rk, const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} fixed\+\_\+rank\+\_\+k) const
\item 
void \hyperlink{classHMatrix_ad3800d6fded523d5c8eeb8fd0c106a34}{add} (const Number b, const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&B, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+rk, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+rk, const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} fixed\+\_\+rank\+\_\+k) const
\item 
void \hyperlink{classHMatrix_ab9000d7604e2045cf7cad7458daca340}{add} (const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&B, const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} fixed\+\_\+rank\+\_\+k)
\item 
void \hyperlink{classHMatrix_a94981e45b7d9aa0f2afae77d414f1c1a}{add} (const Number b, const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&B, const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} fixed\+\_\+rank\+\_\+k)
\item 
void \hyperlink{classHMatrix_a403d72a5eea3912d67fd0807ddd0baf8}{add} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&C, const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&B, const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} fixed\+\_\+rank\+\_\+k)
\item 
void \hyperlink{classHMatrix_af66071b53145fe007ac040fa0c4b47c6}{add} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&C, const Number b, const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&B, const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} fixed\+\_\+rank\+\_\+k)
\item 
void \hyperlink{classHMatrix_af972cb62d436b8dca5d95a5b6e2ed964}{invert\+\_\+by\+\_\+gauss\+\_\+elim} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M\+\_\+inv, const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} fixed\+\_\+rank\+\_\+k)
\item 
void \hyperlink{classHMatrix_aeee2443c3f85cd6a961e77e5287e43f9}{solve\+\_\+by\+\_\+forward\+\_\+substitution} (Vector$<$ Number $>$ \&b, const bool is\+\_\+unit\+\_\+diagonal=true) const
\item 
void \hyperlink{classHMatrix_a4c226aaa96ad7b1a7f0c1507d43bba89}{solve\+\_\+by\+\_\+forward\+\_\+substitution} (Vector$<$ Number $>$ \&x, const Vector$<$ Number $>$ \&b, const bool is\+\_\+unit\+\_\+diagonal=true) const
\item 
void \hyperlink{classHMatrix_a898ed2cdcb0351a6a9b57251320b5d1d}{solve\+\_\+by\+\_\+forward\+\_\+substitution} (Vector$<$ Number $>$ \&b, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, const bool is\+\_\+unit\+\_\+diagonal=true) const
\item 
void \hyperlink{classHMatrix_a5ddd48bc33e45d0b4221416cbb039cc3}{solve\+\_\+by\+\_\+forward\+\_\+substitution} (Vector$<$ Number $>$ \&x, const Vector$<$ Number $>$ \&b, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, const bool is\+\_\+unit\+\_\+diagonal=true) const
\item 
void \hyperlink{classHMatrix_a20fa0ad9c55bb5225440ccab58608cf8}{solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&X, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&Z, const unsigned int fixed\+\_\+rank, const bool is\+\_\+unit\+\_\+diagonal=true)
\item 
void \hyperlink{classHMatrix_a948b0b53490cc7614ee82fec80fa245a}{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&X, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&Z, const unsigned int fixed\+\_\+rank)
\item 
void \hyperlink{classHMatrix_a624fc153099a20572a655457d4f81b70}{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution} (Vector$<$ Number $>$ \&b) const
\item 
void \hyperlink{classHMatrix_a94f9bb1bc4e584fc5f29541be6b85ef1}{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution} (Vector$<$ Number $>$ \&x, const Vector$<$ Number $>$ \&b) const
\item 
void \hyperlink{classHMatrix_aefa73f541d0b5eb8cddde5386fd140d0}{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution} (Vector$<$ Number $>$ \&b, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map) const
\item 
void \hyperlink{classHMatrix_a8e9c993ce276353fda2bfefd0b932670}{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution} (Vector$<$ Number $>$ \&x, const Vector$<$ Number $>$ \&b, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map) const
\item 
void \hyperlink{classHMatrix_a469507ef4061efcc29a65c413ac7acea}{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&X, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&Z, const unsigned int fixed\+\_\+rank)
\item 
void \hyperlink{classHMatrix_a41f0e0b791e50a3d9b5c0e73ee4423c6}{solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&X, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&Z, const unsigned int fixed\+\_\+rank)
\item 
void \hyperlink{classHMatrix_ab8b64d4a5b7120a2599ec3e3e0708775}{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution} (Vector$<$ Number $>$ \&b, const bool is\+\_\+unit\+\_\+block\+\_\+diagonal=true) const
\item 
void \hyperlink{classHMatrix_aa8046a87be454c81d4a884b53150685a}{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution} (Vector$<$ Number $>$ \&x, const Vector$<$ Number $>$ \&b, const bool is\+\_\+unit\+\_\+block\+\_\+diagonal=true) const
\item 
void \hyperlink{classHMatrix_a09beb710b79d47e34ff3283424cf2a22}{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution} (Vector$<$ Number $>$ \&b) const
\item 
void \hyperlink{classHMatrix_a59d32edbfaac9221dc5e219640c3ecd3}{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution} (Vector$<$ Number $>$ \&x, const Vector$<$ Number $>$ \&b) const
\item 
void \hyperlink{classHMatrix_a987af3012854b397b90f19f742085155}{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution} (Vector$<$ Number $>$ \&b, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map) const
\item 
void \hyperlink{classHMatrix_a0b81214fb9287b344dff8349c7122583}{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution} (Vector$<$ Number $>$ \&x, const Vector$<$ Number $>$ \&b, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map) const
\item 
void \hyperlink{classHMatrix_ac7231b00a53ef6b860d774d1daad738f}{solve\+\_\+by\+\_\+backward\+\_\+substitution} (Vector$<$ Number $>$ \&b, const bool is\+\_\+unit\+\_\+diagonal=false) const
\item 
void \hyperlink{classHMatrix_ab89582b86090d18d33f7ae04deda1f5f}{solve\+\_\+by\+\_\+backward\+\_\+substitution} (Vector$<$ Number $>$ \&x, const Vector$<$ Number $>$ \&b, const bool is\+\_\+unit\+\_\+diagonal=false) const
\item 
void \hyperlink{classHMatrix_aedc13c9cf448ec8b47147053d02f357b}{solve\+\_\+by\+\_\+backward\+\_\+substitution} (Vector$<$ Number $>$ \&b, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, const bool is\+\_\+unit\+\_\+diagonal=false) const
\item 
void \hyperlink{classHMatrix_aa90525e857add22b334bac84e6baacd2}{solve\+\_\+by\+\_\+backward\+\_\+substitution} (Vector$<$ Number $>$ \&x, const Vector$<$ Number $>$ \&b, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, const bool is\+\_\+unit\+\_\+diagonal=false) const
\item 
void \hyperlink{classHMatrix_aa81db0ff79182302de83d693bab9f9e3}{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution} (Vector$<$ Number $>$ \&b, const bool is\+\_\+unit\+\_\+block\+\_\+diagonal=false) const
\item 
void \hyperlink{classHMatrix_a69432f004b60ade76aaabf2c94dd205c}{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution} (Vector$<$ Number $>$ \&x, const Vector$<$ Number $>$ \&b, const bool is\+\_\+unit\+\_\+block\+\_\+diagonal=false) const
\item 
void \hyperlink{classHMatrix_a054ad84d52a9ee6df9df3bda0a17cfb7}{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution} (Vector$<$ Number $>$ \&b) const
\item 
void \hyperlink{classHMatrix_a880948492a7df252f3696219f6966703}{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution} (Vector$<$ Number $>$ \&x, const Vector$<$ Number $>$ \&b) const
\item 
void \hyperlink{classHMatrix_ae8bbf6f35a2099872fbcbfda2cb1abbd}{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution} (Vector$<$ Number $>$ \&b, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map) const
\item 
void \hyperlink{classHMatrix_a8dcb361dfb254ff716755ba8b7ed9cf1}{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution} (Vector$<$ Number $>$ \&x, const Vector$<$ Number $>$ \&b, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map) const
\item 
void \hyperlink{classHMatrix_acf95fce81ec83a759d1db8d10c3e34fb}{compute\+\_\+lu\+\_\+factorization} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&LU, const unsigned int fixed\+\_\+rank) const
\item 
void \hyperlink{classHMatrix_aba14c63550f42d8a971beab340337b0e}{compute\+\_\+lu\+\_\+factorization} (const unsigned int fixed\+\_\+rank)
\item 
void \hyperlink{classHMatrix_a7d6c76f7db2b9239f24df292e945a970}{compute\+\_\+cholesky\+\_\+factorization} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&L, const unsigned int fixed\+\_\+rank) const
\item 
void \hyperlink{classHMatrix_abc6e787e46fb082579b2d3aea1ad54f6}{compute\+\_\+cholesky\+\_\+factorization} (const unsigned int fixed\+\_\+rank)
\item 
void \hyperlink{classHMatrix_a83e9dd55091e7eaed11ffb803321c49d}{solve\+\_\+lu} (Vector$<$ Number $>$ \&x, const Vector$<$ Number $>$ \&b) const
\item 
void \hyperlink{classHMatrix_ac5582db8445ec15c69bc4bfdda19d547}{solve\+\_\+cholesky} (Vector$<$ Number $>$ \&x, const Vector$<$ Number $>$ \&b) const
\item 
void \hyperlink{classHMatrix_a27c7390b792e6e47ab2861616a997d99}{coarsen\+\_\+to\+\_\+subtree} (const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&subtree, const unsigned int fixed\+\_\+rank\+\_\+k)
\item 
void \hyperlink{classHMatrix_a525ad4d453f4f496b98cccb341c8b60b}{coarsen\+\_\+to\+\_\+partition} (const std\+::vector$<$ typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+pointer\+\_\+type $>$ \&partition, const unsigned int fixed\+\_\+rank\+\_\+k)
\item 
void \hyperlink{classHMatrix_a139f32982527ba981e0211b5663e3b43}{build\+\_\+leaf\+\_\+set} ()
\item 
std\+::vector$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ $>$ \& \hyperlink{classHMatrix_ac5c9102fc04997c1ae3627185379d9bb}{get\+\_\+leaf\+\_\+set} ()
\item 
const std\+::vector$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ $>$ \& \hyperlink{classHMatrix_a851d7bb3632bc1d18538d4d1dd5f6393}{get\+\_\+leaf\+\_\+set} () const
\item 
std\+::vector$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ $>$\+::iterator \hyperlink{classHMatrix_ab0f83de878e6079330ec3c374f587a04}{find\+\_\+block\+\_\+cluster\+\_\+in\+\_\+leaf\+\_\+set} (const \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim, Number $>$ \&block\+\_\+cluster)
\item 
std\+::vector$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ $>$\+::const\+\_\+iterator \hyperlink{classHMatrix_a723cc200afe31148fcc28f0120c5ec54}{find\+\_\+block\+\_\+cluster\+\_\+in\+\_\+leaf\+\_\+set} (const \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim, Number $>$ \&block\+\_\+cluster) const
\item 
void \hyperlink{classHMatrix_ad2b353962226c78910d6ddb6b5b8e460}{refine\+\_\+to\+\_\+supertree} ()
\item 
void \hyperlink{classHMatrix_af6fd60090b0de7bdea52fc84ddeb22c3}{convert\+\_\+between\+\_\+different\+\_\+block\+\_\+cluster\+\_\+trees} (\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&bct1, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&bct2, const unsigned int fixed\+\_\+rank\+\_\+k2=1)
\item 
void \hyperlink{classHMatrix_a9e023f39b1f8916117a63557895a91b4}{remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list} (const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$M1, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$M2)
\item 
void \hyperlink{classHMatrix_ae0ab9b3be4ea0ef959da40e81313b2e3}{remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list} (const std\+::pair$<$ const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$$>$ \&hmat\+\_\+pair)
\item 
\hyperlink{tree_8h_a922ca07db9633957939f697a65aff11d}{Tree\+Node\+Split\+Mode} \hyperlink{classHMatrix_a6f24998c7de1d0e336577be41c6281e3}{determine\+\_\+mm\+\_\+split\+\_\+mode\+\_\+from\+\_\+\+Sigma\+\_\+P} ()
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const unsigned int \hyperlink{classHMatrix_a8b5a9fb65c716187d95bcdb43542884c}{submatrix\+\_\+index\+\_\+invalid} = 9
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classHMatrix_afd8e08ec263ea524bef3c5c66796c61d}{\+\_\+print\+\_\+matrix\+\_\+info\+\_\+as\+\_\+dot\+\_\+node} (std\+::ostream \&out) const
\item 
{\footnotesize template$<$typename Matrix\+Type $>$ }\\void \hyperlink{classHMatrix_ab55b568236ffdd71b5378ac6c6ace50a}{\+\_\+convert\+To\+Full\+Matrix} (Matrix\+Type \&M) const
\item 
void \hyperlink{classHMatrix_a60934e84cc3c9f6c75d011a2005f512a}{\+\_\+build\+\_\+leaf\+\_\+set} (std\+::vector$<$ \hyperlink{classHMatrix}{H\+Matrix} $\ast$$>$ \&total\+\_\+leaf\+\_\+set) const
\item 
void \hyperlink{classHMatrix_a66979dbdf56155c63f0706649e8545b9}{distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves} (const unsigned int fixed\+\_\+rank=0)
\item 
\mbox{\Hypertarget{classHMatrix_a39e24569fe32027c840b160f9dcd1ad7}\label{classHMatrix_a39e24569fe32027c840b160f9dcd1ad7}} 
void {\bfseries distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves} (const unsigned int fixed\+\_\+rank=0)
\item 
void \hyperlink{classHMatrix_a187e0c009a7c28679df7e92e0b01929c}{\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&starting\+\_\+hmat, const unsigned int fixed\+\_\+rank=0)
\item 
void \hyperlink{classHMatrix_af74e3b0c19e9178cfe699a6620a51170}{\+\_\+invert\+\_\+by\+\_\+gauss\+\_\+elim} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&M\+\_\+inv, const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} fixed\+\_\+rank\+\_\+k)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494}{H\+Matrix\+Type} \hyperlink{classHMatrix_a89ef60f3ba737c04708195ca0bb13620}{type}
\item 
std\+::vector$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ $>$ \hyperlink{classHMatrix_a4bd1b9a32f2c7693e603a7c6ea916e4f}{submatrices}
\item 
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ \hyperlink{classHMatrix_a71690997092a4142799b2fa2dbf53db4}{parent}
\item 
unsigned int \hyperlink{classHMatrix_a64c851dd63ba1a466c19f451be369475}{submatrix\+\_\+index}
\item 
std\+::vector$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ $>$ \hyperlink{classHMatrix_a61dbd471077be0ad8325d0f2afe3d43f}{leaf\+\_\+set}
\item 
\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ $\ast$ \hyperlink{classHMatrix_aa97a8f5e42aba0f1d5faf41f35a27819}{rkmatrix}
\item 
\hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ $\ast$ \hyperlink{classHMatrix_a328134c9e9cb2c4b05d5431c0ca8a533}{fullmatrix}
\item 
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+pointer\+\_\+type \hyperlink{classHMatrix_a4a304494c970b5b267be1d8459d51586}{bc\+\_\+node}
\item 
std\+::vector$<$ types\+::global\+\_\+dof\+\_\+index $>$ $\ast$ \hyperlink{classHMatrix_a33b3a936f1b40e320e96d47471da07ae}{row\+\_\+indices}
\item 
std\+::vector$<$ types\+::global\+\_\+dof\+\_\+index $>$ $\ast$ \hyperlink{classHMatrix_ac30ae65e37ec5e4ccc7de2f6b9ea91e6}{col\+\_\+indices}
\item 
std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \hyperlink{classHMatrix_a4d64145335fc0521603b206a22a67578}{row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}
\item 
std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \hyperlink{classHMatrix_ab337c7b4f2f40699b9b7f3ab17a1e056}{col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}
\item 
\hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} \hyperlink{classHMatrix_aa5523463043e4d542eae17d262bd22ad}{m}
\item 
\hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} \hyperlink{classHMatrix_ab5ae2eb472f81f80653ed4411629c2d1}{n}
\item 
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \hyperlink{classHMatrix_a12da9454687e5ca15837d63e2bf0b595}{Tind}
\item 
std\+::vector$<$ std\+::pair$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ $>$ $>$ \hyperlink{classHMatrix_a3d96d0252ef8c873ae06cf87874acaf3}{Sigma\+\_\+P}
\item 
std\+::vector$<$ \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ $\ast$ $>$ \hyperlink{classHMatrix_a04d341b4e606d1be2d71b8ea636efe7b}{Sigma\+\_\+R}
\item 
std\+::vector$<$ \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ $\ast$ $>$ \hyperlink{classHMatrix_aa659b6df63d533432ec1a24435cd9c40}{Sigma\+\_\+F}
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classHMatrix_aa949159fde08b9c728ce2cd4c6b99de6}\label{classHMatrix_aa949159fde08b9c728ce2cd4c6b99de6}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type \hyperlink{classHMatrix_a4a304494c970b5b267be1d8459d51586}{bc\+\_\+node})
\item 
\mbox{\Hypertarget{classHMatrix_ab5b4274a06c4ec21a0c1ee4ed870d3a3}\label{classHMatrix_ab5b4274a06c4ec21a0c1ee4ed870d3a3}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type \hyperlink{classHMatrix_a4a304494c970b5b267be1d8459d51586}{bc\+\_\+node}, const std\+::vector$<$ std\+::pair$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$$>$$>$ \&\hyperlink{classHMatrix_a3d96d0252ef8c873ae06cf87874acaf3}{Sigma\+\_\+P})
\item 
\mbox{\Hypertarget{classHMatrix_abe123e0f8daa856e4b85e00829398b79}\label{classHMatrix_abe123e0f8daa856e4b85e00829398b79}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type \hyperlink{classHMatrix_a4a304494c970b5b267be1d8459d51586}{bc\+\_\+node}, const std\+::pair$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$$>$ \&hmat\+\_\+pair)
\item 
\mbox{\Hypertarget{classHMatrix_a69a9e7eae8c4fbab8c426552399d072a}\label{classHMatrix_a69a9e7eae8c4fbab8c426552399d072a}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type \hyperlink{classHMatrix_a4a304494c970b5b267be1d8459d51586}{bc\+\_\+node}, const bool is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map)
\item 
\mbox{\Hypertarget{classHMatrix_ac9dff162efb21e08ab5d6fc3bc2219fa}\label{classHMatrix_ac9dff162efb21e08ab5d6fc3bc2219fa}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries Init\+And\+Create\+H\+Matrix\+Children} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type \hyperlink{classHMatrix_a4a304494c970b5b267be1d8459d51586}{bc\+\_\+node}, const unsigned int fixed\+\_\+rank\+\_\+k, bool is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map)
\item 
\mbox{\Hypertarget{classHMatrix_a97abbebc640c23d742408edfa3526572}\label{classHMatrix_a97abbebc640c23d742408edfa3526572}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries Init\+And\+Create\+H\+Matrix\+Children} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type \hyperlink{classHMatrix_a4a304494c970b5b267be1d8459d51586}{bc\+\_\+node}, const unsigned int fixed\+\_\+rank\+\_\+k, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M, bool is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map)
\item 
\mbox{\Hypertarget{classHMatrix_a4b3f09c87b4186e3c99b57404c10f8b3}\label{classHMatrix_a4b3f09c87b4186e3c99b57404c10f8b3}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries Init\+And\+Create\+H\+Matrix\+Children} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type \hyperlink{classHMatrix_a4a304494c970b5b267be1d8459d51586}{bc\+\_\+node}, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M, bool is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map)
\item 
\mbox{\Hypertarget{classHMatrix_aac490314e7c775bf5bbaef5562aad650}\label{classHMatrix_aac490314e7c775bf5bbaef5562aad650}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries Init\+And\+Create\+H\+Matrix\+Children} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type \hyperlink{classHMatrix_a4a304494c970b5b267be1d8459d51586}{bc\+\_\+node}, const unsigned int fixed\+\_\+rank\+\_\+k, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+M, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+M, bool is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map)
\item 
\mbox{\Hypertarget{classHMatrix_a7ac91976ab243c469da338d960885847}\label{classHMatrix_a7ac91976ab243c469da338d960885847}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries Init\+And\+Create\+H\+Matrix\+Children} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type \hyperlink{classHMatrix_a4a304494c970b5b267be1d8459d51586}{bc\+\_\+node}, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+M, const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+M, bool is\+\_\+build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map)
\item 
\mbox{\Hypertarget{classHMatrix_ab0d91a693388f0f14c515f7c97c14aed}\label{classHMatrix_ab0d91a693388f0f14c515f7c97c14aed}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries Init\+And\+Create\+H\+Matrix\+Children} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$hmat, typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type \hyperlink{classHMatrix_a4a304494c970b5b267be1d8459d51586}{bc\+\_\+node}, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&\&H)
\item 
\mbox{\Hypertarget{classHMatrix_ac511284701f9f527c0480608242d0619}\label{classHMatrix_ac511284701f9f527c0480608242d0619}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$starting\+\_\+hmat, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$current\+\_\+hmat)
\item 
\mbox{\Hypertarget{classHMatrix_a47825229983c7fa5755b3be8d5ac03f7}\label{classHMatrix_a47825229983c7fa5755b3be8d5ac03f7}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries convert\+H\+Mat\+Block\+To\+Rk\+Matrix} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$hmat\+\_\+block, const unsigned int fixed\+\_\+rank\+\_\+k, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$hmat\+\_\+root\+\_\+block, size\+\_\+t $\ast$calling\+\_\+counter, const std\+::string \&output\+\_\+file\+\_\+base\+\_\+name)
\item 
\mbox{\Hypertarget{classHMatrix_aaa7e9489e842016dd9815a0490c7667d}\label{classHMatrix_aaa7e9489e842016dd9815a0490c7667d}} 
void {\bfseries build\+\_\+index\+\_\+set\+\_\+global\+\_\+to\+\_\+local\+\_\+map} (const std\+::vector$<$ types\+::global\+\_\+dof\+\_\+index $>$ \&index\+\_\+set\+\_\+as\+\_\+local\+\_\+to\+\_\+global\+\_\+map, std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&global\+\_\+to\+\_\+local\+\_\+map)
\item 
\mbox{\Hypertarget{classHMatrix_a1b5b4592067610eec18b830482897243}\label{classHMatrix_a1b5b4592067610eec18b830482897243}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+rk\+\_\+mmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_af04c7cb6f2968253cf41b1d1a93760c7}\label{classHMatrix_af04c7cb6f2968253cf41b1d1a93760c7}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+rk\+\_\+mmult} (const Number1 alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_ad59530b8595d7716e02b405e35dbc561}\label{classHMatrix_ad59530b8595d7716e02b405e35dbc561}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+rk\+\_\+m\+Tmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_a8cf5a4058289ffe89a9f88379e643e53}\label{classHMatrix_a8cf5a4058289ffe89a9f88379e643e53}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+rk\+\_\+m\+Tmult} (const Number1 alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_a614ba3b92b97d95cb3146db181611a34}\label{classHMatrix_a614ba3b92b97d95cb3146db181611a34}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+rk\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$M1, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$M2, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$M, bool is\+\_\+\+M1\+M2\+\_\+last\+\_\+in\+\_\+\+M\+\_\+\+Sigma\+\_\+P)
\item 
\mbox{\Hypertarget{classHMatrix_afa94f9688a9443024a2631d2bfae06c8}\label{classHMatrix_afa94f9688a9443024a2631d2bfae06c8}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries rk\+\_\+h\+\_\+mmult} (const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_a52a9c2821153dd59f0d230a997879ff3}\label{classHMatrix_a52a9c2821153dd59f0d230a997879ff3}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries rk\+\_\+h\+\_\+mmult} (const Number1 alpha, const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_a0c04e99e7f40fb0c9f3dcc042e95882a}\label{classHMatrix_a0c04e99e7f40fb0c9f3dcc042e95882a}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries rk\+\_\+h\+\_\+m\+Tmult} (const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_a2fddb7ff1c462d5605b63ea0b10bcc34}\label{classHMatrix_a2fddb7ff1c462d5605b63ea0b10bcc34}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries rk\+\_\+h\+\_\+m\+Tmult} (const Number1 alpha, const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_a9b12cf1aa7504c436b84394f2116f6a9}\label{classHMatrix_a9b12cf1aa7504c436b84394f2116f6a9}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries rk\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult} (const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$M2, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$M, bool is\+\_\+\+M1\+M2\+\_\+last\+\_\+in\+\_\+\+M\+\_\+\+Sigma\+\_\+P)
\item 
\mbox{\Hypertarget{classHMatrix_a85ccef980f81f9fb3c63675f3f9c014f}\label{classHMatrix_a85ccef980f81f9fb3c63675f3f9c014f}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+f\+\_\+mmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M2, \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_ab72731e18525c507f92b16d880858b93}\label{classHMatrix_ab72731e18525c507f92b16d880858b93}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+f\+\_\+mmult} (const Number1 alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M2, \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_adcedf4b5e2f14d085cce5cdc3f2b46cf}\label{classHMatrix_adcedf4b5e2f14d085cce5cdc3f2b46cf}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+f\+\_\+m\+Tmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M2, \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_a86eb2a4d2b7039163dd4f28650fe747e}\label{classHMatrix_a86eb2a4d2b7039163dd4f28650fe747e}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+f\+\_\+m\+Tmult} (const Number1 alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M2, \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_aea3866052a5345742ad9f44f11f33989}\label{classHMatrix_aea3866052a5345742ad9f44f11f33989}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+f\+\_\+mmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_ad090448398bf367cba0b208456144e7d}\label{classHMatrix_ad090448398bf367cba0b208456144e7d}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+f\+\_\+mmult} (const Number1 alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_a8f368b3c372ece4b6506d89bb9e255df}\label{classHMatrix_a8f368b3c372ece4b6506d89bb9e255df}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+f\+\_\+m\+Tmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_ad81f9d9c00ebd7bdabb28b6ea0646236}\label{classHMatrix_ad81f9d9c00ebd7bdabb28b6ea0646236}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+f\+\_\+m\+Tmult} (const Number1 alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_a897365f6716975f71b528f610498c69b}\label{classHMatrix_a897365f6716975f71b528f610498c69b}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$M1, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$M2, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$M, bool is\+\_\+\+M1\+M2\+\_\+last\+\_\+in\+\_\+\+M\+\_\+\+Sigma\+\_\+P)
\item 
\mbox{\Hypertarget{classHMatrix_a67b0f45b3a6734fef74d90f28fcefbc1}\label{classHMatrix_a67b0f45b3a6734fef74d90f28fcefbc1}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries f\+\_\+h\+\_\+mmult} (const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_a58df6eed9eb48d8d725476c8e289d859}\label{classHMatrix_a58df6eed9eb48d8d725476c8e289d859}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries f\+\_\+h\+\_\+mmult} (const Number1 alpha, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_a6a400c086f929a643da87cf6dc493c26}\label{classHMatrix_a6a400c086f929a643da87cf6dc493c26}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries f\+\_\+h\+\_\+m\+Tmult} (const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_ac2beff0c056d76818dc4e61dded73fe0}\label{classHMatrix_ac2beff0c056d76818dc4e61dded73fe0}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries f\+\_\+h\+\_\+m\+Tmult} (const Number1 alpha, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_a66d1ce72cb294b2c4da6536250905a32}\label{classHMatrix_a66d1ce72cb294b2c4da6536250905a32}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries f\+\_\+h\+\_\+mmult} (const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_ac6da79ad8924c127c5eb34acf396cf00}\label{classHMatrix_ac6da79ad8924c127c5eb34acf396cf00}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries f\+\_\+h\+\_\+mmult} (const Number1 alpha, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_a439a1469e55ddc97987ee592b920cedb}\label{classHMatrix_a439a1469e55ddc97987ee592b920cedb}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries f\+\_\+h\+\_\+m\+Tmult} (const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_a7c51795179e7c52726d2eb3a76a17914}\label{classHMatrix_a7c51795179e7c52726d2eb3a76a17914}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries f\+\_\+h\+\_\+m\+Tmult} (const Number1 alpha, const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_a311938523b49a053a8cf16bc96576cdf}\label{classHMatrix_a311938523b49a053a8cf16bc96576cdf}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult} (const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$M2, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$M, bool is\+\_\+\+M1\+M2\+\_\+last\+\_\+in\+\_\+\+M\+\_\+\+Sigma\+\_\+P)
\item 
\mbox{\Hypertarget{classHMatrix_ad755e8e3b11e19f553e77bae172ce849}\label{classHMatrix_ad755e8e3b11e19f553e77bae172ce849}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+h\+\_\+mmult\+\_\+phase1\+\_\+recursion} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ $\ast$M, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$ \&\hyperlink{classHMatrix_a12da9454687e5ca15837d63e2bf0b595}{Tind})
\item 
\mbox{\Hypertarget{classHMatrix_ac58016ed0bee33836c69eb23970c24df}\label{classHMatrix_ac58016ed0bee33836c69eb23970c24df}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+h\+\_\+mmult\+\_\+phase2} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M, \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim1, Number1 $>$ \&target\+\_\+bc\+\_\+tree, const unsigned int fixed\+\_\+rank)
\item 
\mbox{\Hypertarget{classHMatrix_ae51daefaa59911ec728910847e968027}\label{classHMatrix_ae51daefaa59911ec728910847e968027}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M0, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, const unsigned int fixed\+\_\+rank)
\item 
\mbox{\Hypertarget{classHMatrix_a93ecdcf004204cdf053251309abfe2a8}\label{classHMatrix_a93ecdcf004204cdf053251309abfe2a8}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M0, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M, const Number1 alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, const unsigned int fixed\+\_\+rank)
\item 
\mbox{\Hypertarget{classHMatrix_a983f20b2ffc0f0ad5f6e464f7244a2bf}\label{classHMatrix_a983f20b2ffc0f0ad5f6e464f7244a2bf}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M0, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, const unsigned int fixed\+\_\+rank)
\item 
\mbox{\Hypertarget{classHMatrix_a31200d7f85e3d9ec53117c80df47cdaf}\label{classHMatrix_a31200d7f85e3d9ec53117c80df47cdaf}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M0, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M, const Number1 alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, const unsigned int fixed\+\_\+rank)
\item 
\mbox{\Hypertarget{classHMatrix_a13cad078355a647e17dd33970f5449e0}\label{classHMatrix_a13cad078355a647e17dd33970f5449e0}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M0, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, const unsigned int fixed\+\_\+rank)
\item 
\mbox{\Hypertarget{classHMatrix_aec01211adffa740f7e6ef82fd31b68cf}\label{classHMatrix_aec01211adffa740f7e6ef82fd31b68cf}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M0, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M, const Number1 alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, const unsigned int fixed\+\_\+rank)
\item 
\mbox{\Hypertarget{classHMatrix_add5ee01109ae6f420d5d68444b212d68}\label{classHMatrix_add5ee01109ae6f420d5d68444b212d68}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M0, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, const unsigned int fixed\+\_\+rank)
\item 
\mbox{\Hypertarget{classHMatrix_aa5803f16610413cda0dcbcde5011ea3b}\label{classHMatrix_aa5803f16610413cda0dcbcde5011ea3b}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M0, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M, const Number1 alpha, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2, const unsigned int fixed\+\_\+rank)
\item 
\mbox{\Hypertarget{classHMatrix_a4ec67bee413b9db0bedfe58ddc0d91c1}\label{classHMatrix_a4ec67bee413b9db0bedfe58ddc0d91c1}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries copy\+\_\+hmatrix\+\_\+node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&hmat\+\_\+dst, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&hmat\+\_\+src)
\item 
\mbox{\Hypertarget{classHMatrix_a10e52ecf1ea024322e4318243e922a1c}\label{classHMatrix_a10e52ecf1ea024322e4318243e922a1c}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries copy\+\_\+hmatrix\+\_\+node} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&hmat\+\_\+dst, \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&\&hmat\+\_\+src)
\item 
\mbox{\Hypertarget{classHMatrix_a29ce56e1013c5060804023841e3ac93b}\label{classHMatrix_a29ce56e1013c5060804023841e3ac93b}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries copy\+\_\+hmatrix} (\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&hmat\+\_\+dst, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&hmat\+\_\+src)
\item 
\mbox{\Hypertarget{classHMatrix_a9eefa50a413f628f9b74c4b7ca7fd118}\label{classHMatrix_a9eefa50a413f628f9b74c4b7ca7fd118}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries print\+\_\+h\+\_\+submatrix\+\_\+accessor} (std\+::ostream \&out, const std\+::string \&name, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M)
\item 
\mbox{\Hypertarget{classHMatrix_adee7e6e1599718531085769438a918a7}\label{classHMatrix_adee7e6e1599718531085769438a918a7}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries print\+\_\+h\+\_\+h\+\_\+submatrix\+\_\+mmult\+\_\+accessor} (std\+::ostream \&out, const std\+::string \&name1, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M1, const std\+::string \&name2, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&M2)
\item 
\mbox{\Hypertarget{classHMatrix_aa5cbdadb17c9b375a0183d2172b678ff}\label{classHMatrix_aa5cbdadb17c9b375a0183d2172b678ff}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries hmatrix\+\_\+solve\+\_\+lu} (const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&L, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&U, Vector$<$ Number1 $>$ \&x, const Vector$<$ Number1 $>$ \&b)
\item 
\mbox{\Hypertarget{classHMatrix_a9f2e9410cc83312bd7d00cebf4584b75}\label{classHMatrix_a9f2e9410cc83312bd7d00cebf4584b75}} 
{\footnotesize template$<$int spacedim1, typename Number1 $>$ }\\void {\bfseries hmatrix\+\_\+solve\+\_\+cholesky} (const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim1, Number1 $>$ \&L, Vector$<$ Number1 $>$ \&x, const Vector$<$ Number1 $>$ \&b)
\end{DoxyCompactItemize}


\subsection{Member Typedef Documentation}
\mbox{\Hypertarget{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}\label{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}} 
\index{H\+Matrix@{H\+Matrix}!size\+\_\+type@{size\+\_\+type}}
\index{size\+\_\+type@{size\+\_\+type}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{size\+\_\+type}{size\_type}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
using \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::\hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} =  std\+::make\+\_\+unsigned$<$types\+::blas\+\_\+int$>$\+::\hyperlink{classHMatrix_a89ef60f3ba737c04708195ca0bb13620}{type}}

Declare the type for container size. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classHMatrix_ae3dc35e1aefee2580d27ad2d65c906de}\label{classHMatrix_ae3dc35e1aefee2580d27ad2d65c906de}} 
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{H\+Matrix()}{HMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/9]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::\hyperlink{classHMatrix}{H\+Matrix} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Default constructor. \mbox{\Hypertarget{classHMatrix_a6a4dead0321e8df38865bf6fbd0f6e81}\label{classHMatrix_a6a4dead0321e8df38865bf6fbd0f6e81}} 
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{H\+Matrix()}{HMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/9]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::\hyperlink{classHMatrix}{H\+Matrix} (\begin{DoxyParamCaption}\item[{const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{bct,  }\item[{const unsigned int}]{fixed\+\_\+rank\+\_\+k = {\ttfamily 1} }\end{DoxyParamCaption})}

Construct the hierarchical structure without data from the root node of a \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}. 

References H\+Matrix$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+root().

\mbox{\Hypertarget{classHMatrix_a4fe44a3aa2b813f593b787f24be56a1c}\label{classHMatrix_a4fe44a3aa2b813f593b787f24be56a1c}} 
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{H\+Matrix()}{HMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [3/9]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::\hyperlink{classHMatrix}{H\+Matrix} (\begin{DoxyParamCaption}\item[{typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type}]{bc\+\_\+node,  }\item[{const unsigned int}]{fixed\+\_\+rank\+\_\+k = {\ttfamily 1} }\end{DoxyParamCaption})}

Construct the hierarchical structure without data from a \hyperlink{classTreeNode}{Tree\+Node} in a \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}. 

References H\+Matrix$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set().

\mbox{\Hypertarget{classHMatrix_a8e7d103ec4f093870f9e792e26d6b915}\label{classHMatrix_a8e7d103ec4f093870f9e792e26d6b915}} 
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{H\+Matrix()}{HMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [4/9]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::\hyperlink{classHMatrix}{H\+Matrix} (\begin{DoxyParamCaption}\item[{const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{bct,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M,  }\item[{const unsigned int}]{fixed\+\_\+rank\+\_\+k = {\ttfamily 1} }\end{DoxyParamCaption})}

Construct from the root node of a \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree} while copying the data of a global full matrix, which is created on the complete block cluster $I \times J$. 

References H\+Matrix$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+root().

\mbox{\Hypertarget{classHMatrix_abb59b3981e9f32f319479088d786989d}\label{classHMatrix_abb59b3981e9f32f319479088d786989d}} 
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{H\+Matrix()}{HMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [5/9]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::\hyperlink{classHMatrix}{H\+Matrix} (\begin{DoxyParamCaption}\item[{typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type}]{bc\+\_\+node,  }\item[{const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ \&}]{M,  }\item[{const unsigned int}]{fixed\+\_\+rank\+\_\+k = {\ttfamily 1} }\end{DoxyParamCaption})}

Construct from a \hyperlink{classTreeNode}{Tree\+Node} in a \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree} while copying the data of a global full matrix, which is created on the complete block cluster $I \times J$. 

References H\+Matrix$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set().

\mbox{\Hypertarget{classHMatrix_abeb8d0add9bffecafc12f4c6b1dcab8e}\label{classHMatrix_abeb8d0add9bffecafc12f4c6b1dcab8e}} 
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{H\+Matrix()}{HMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [6/9]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::\hyperlink{classHMatrix}{H\+Matrix} (\begin{DoxyParamCaption}\item[{typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type}]{bc\+\_\+node,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&\&}]{H }\end{DoxyParamCaption})}

Construct from a {\ttfamily \hyperlink{classTreeNode}{Tree\+Node}} in a {\ttfamily \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}} while moving the data from the leaf set of the $\mathcal{H}$-\/matrix {\ttfamily H}.


\begin{DoxyParams}{Parameters}
{\em bc\+\_\+node} & \\
\hline
{\em H} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set().

\mbox{\Hypertarget{classHMatrix_a78aa967d7a99e27cc172f0db3791306b}\label{classHMatrix_a78aa967d7a99e27cc172f0db3791306b}} 
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{H\+Matrix()}{HMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [7/9]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::\hyperlink{classHMatrix}{H\+Matrix} (\begin{DoxyParamCaption}\item[{const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{bct,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&\&}]{H }\end{DoxyParamCaption})}

Construct from the root node of a \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree} while moving the data from the leaf set of the $\mathcal{H}$-\/matrix {\ttfamily H}.


\begin{DoxyParams}{Parameters}
{\em bct} & \\
\hline
{\em H} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+root().

\mbox{\Hypertarget{classHMatrix_a0b5227e35290f6c9fba1e8948e9a29c3}\label{classHMatrix_a0b5227e35290f6c9fba1e8948e9a29c3}} 
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{H\+Matrix()}{HMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [8/9]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::\hyperlink{classHMatrix}{H\+Matrix} (\begin{DoxyParamCaption}\item[{const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{H }\end{DoxyParamCaption})}

Deep copy constructor. 
\begin{DoxyParams}{Parameters}
{\em H} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set().

\mbox{\Hypertarget{classHMatrix_a556325d4cdaee699f17aa1be63bb58ee}\label{classHMatrix_a556325d4cdaee699f17aa1be63bb58ee}} 
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\index{H\+Matrix@{H\+Matrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{H\+Matrix()}{HMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [9/9]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::\hyperlink{classHMatrix}{H\+Matrix} (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&\&}]{H }\end{DoxyParamCaption})}

Shallow copy constructor.

After the copy operation, the data in the source matrix {\ttfamily H} are transferred to the current $\mathcal{H}$-\/matrix node and {\ttfamily H} is cleared.


\begin{DoxyParams}{Parameters}
{\em H} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classHMatrix_ae16c956c1b22eb307e9f360a83f4fa75}\label{classHMatrix_ae16c956c1b22eb307e9f360a83f4fa75}} 
\index{H\+Matrix@{H\+Matrix}!````~H\+Matrix@{$\sim$\+H\+Matrix}}
\index{````~H\+Matrix@{$\sim$\+H\+Matrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{$\sim$\+H\+Matrix()}{~HMatrix()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::$\sim$\hyperlink{classHMatrix}{H\+Matrix} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Destructor which releases the memory by recursion. 

References H\+Matrix$<$ spacedim, Number $>$\+::release().



\subsection{Member Function Documentation}
\mbox{\Hypertarget{classHMatrix_a60934e84cc3c9f6c75d011a2005f512a}\label{classHMatrix_a60934e84cc3c9f6c75d011a2005f512a}} 
\index{H\+Matrix@{H\+Matrix}!\+\_\+build\+\_\+leaf\+\_\+set@{\+\_\+build\+\_\+leaf\+\_\+set}}
\index{\+\_\+build\+\_\+leaf\+\_\+set@{\+\_\+build\+\_\+leaf\+\_\+set}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{\+\_\+build\+\_\+leaf\+\_\+set()}{\_build\_leaf\_set()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::\+\_\+build\+\_\+leaf\+\_\+set (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$$>$ \&}]{total\+\_\+leaf\+\_\+set }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [private]}}

Collect $\mathcal{H}$-\/matrix nodes in the leaf set into a vector. 
\begin{DoxyParams}{Parameters}
{\em total\+\_\+leaf\+\_\+set} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set().

\mbox{\Hypertarget{classHMatrix_ab55b568236ffdd71b5378ac6c6ace50a}\label{classHMatrix_ab55b568236ffdd71b5378ac6c6ace50a}} 
\index{H\+Matrix@{H\+Matrix}!\+\_\+convert\+To\+Full\+Matrix@{\+\_\+convert\+To\+Full\+Matrix}}
\index{\+\_\+convert\+To\+Full\+Matrix@{\+\_\+convert\+To\+Full\+Matrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{\+\_\+convert\+To\+Full\+Matrix()}{\_convertToFullMatrix()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
template$<$typename Matrix\+Type $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::\+\_\+convert\+To\+Full\+Matrix (\begin{DoxyParamCaption}\item[{Matrix\+Type \&}]{M }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [private]}}

Convert an \hyperlink{classHMatrix}{H\+Matrix} to a full matrix by recursion. 
\begin{DoxyParams}{Parameters}
{\em matrix} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::convert\+To\+Full\+Matrix().

\mbox{\Hypertarget{classHMatrix_a187e0c009a7c28679df7e92e0b01929c}\label{classHMatrix_a187e0c009a7c28679df7e92e0b01929c}} 
\index{H\+Matrix@{H\+Matrix}!\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves@{\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves}}
\index{\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves@{\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves()}{\_distribute\_sigma\_r\_and\_f\_to\_leaves()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{starting\+\_\+hmat,  }\item[{const unsigned int}]{fixed\+\_\+rank = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Restrict each rank-\/k matrix in the list {\ttfamily Sigma\+\_\+R} of {\ttfamily starting\+\_\+hmat} to the block as a full matrix.

Restrict each full matrix in the list {\ttfamily Sigma\+\_\+F} of {\ttfamily starting\+\_\+hmat} to the block as a full matrix.

Restrict each rank-\/k matrix in the list {\ttfamily Sigma\+\_\+R} of {\ttfamily starting\+\_\+hmat} to the block as a rank-\/k matrix.

Restrict each full matrix in the list {\ttfamily Sigma\+\_\+F} of {\ttfamily starting\+\_\+hmat} to the block as a rank-\/k matrix.

References H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Rk\+Matrix$<$ Number $>$\+::restrict\+To\+Full\+Matrix(), H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+F, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+R, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves().

\mbox{\Hypertarget{classHMatrix_af74e3b0c19e9178cfe699a6620a51170}\label{classHMatrix_af74e3b0c19e9178cfe699a6620a51170}} 
\index{H\+Matrix@{H\+Matrix}!\+\_\+invert\+\_\+by\+\_\+gauss\+\_\+elim@{\+\_\+invert\+\_\+by\+\_\+gauss\+\_\+elim}}
\index{\+\_\+invert\+\_\+by\+\_\+gauss\+\_\+elim@{\+\_\+invert\+\_\+by\+\_\+gauss\+\_\+elim}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{\+\_\+invert\+\_\+by\+\_\+gauss\+\_\+elim()}{\_invert\_by\_gauss\_elim()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::\+\_\+invert\+\_\+by\+\_\+gauss\+\_\+elim (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M\+\_\+inv,  }\item[{const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type}}]{fixed\+\_\+rank\+\_\+k }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Calculate the inverse of the $\mathcal{H}$-\/matrix node via Gauss elimination.


\begin{DoxyParams}{Parameters}
{\em M\+\_\+inv} & \\
\hline
{\em M\+\_\+root} & The $\mathcal{H}$-\/matrix node from which this recursive function is called for the first time. \\
\hline
{\em M\+\_\+root\+\_\+bct} & The block cluster tree associated with {\ttfamily M\+\_\+root}. \\
\hline
{\em fixed\+\_\+rank\+\_\+k} & \\
\hline
\end{DoxyParams}
If the current matrix block to be handled has a same $\tau$ cluster and $\sigma$ cluster and belongs to the leaf set of {\ttfamily M\+\_\+root}, directly calculate its inverse as full matrix.

{\bfseries 2021-\/10-\/05 At present, we assume the $\mathcal{H}$-\/matrix hierarchy is completely the same as the associated block cluster tree, or rather, the block cluster tree is not finer than the $\mathcal{H}$-\/matrix. Therefore, whether the block cluster node is a leaf is equivalent to whether the $\mathcal{H}$-\/matrix node is a leaf. In a more generalized implementation, the block cluster tree can be finer than the $\mathcal{H}$-\/matrix hierarchy.}

Number of matrix blocks in a row, which is also the number of matrix blocks in a column.

Stage 1\+: eliminate the lower triangular part of the matrix.

Calculate the inverse of the diagonal block $M \vert_{\tau[l]\times\tau[l]}$. The formula $l + l \cdot k$ calculates the 1D index of the diagonal block in {\ttfamily submatrices}. This is because the submatrices of the current $\mathcal{H}$-\/matrix node is stored in the following order\+:

{\ttfamily  submatrices = \{tau\mbox{[}0\mbox{]}$\ast$sigma\mbox{[}0\mbox{]}, tau\mbox{[}0\mbox{]}$\ast$sigma\mbox{[}1\mbox{]}, tau\mbox{[}1\mbox{]}$\ast$sigma\mbox{[}0\mbox{]}, tau\mbox{[}1\mbox{]}$\ast$sigma\mbox{[}1\mbox{]}\} }

Since $\tau$ is the same as $\sigma$, we have

{\ttfamily  submatrices = \{tau\mbox{[}0\mbox{]}$\ast$tau\mbox{[}0\mbox{]}, tau\mbox{[}0\mbox{]}$\ast$tau\mbox{[}1\mbox{]}, tau\mbox{[}1\mbox{]}$\ast$tau\mbox{[}0\mbox{]}, tau\mbox{[}1\mbox{]}$\ast$tau\mbox{[}1\mbox{]}\} }

Hence, the index of {\ttfamily tau}\mbox{[}0\mbox{]}$\ast$tau\mbox{[}0\mbox{]} in {\ttfamily submatrices} is 0 and the index of {\ttfamily tau}\mbox{[}1\mbox{]}$\ast$tau\mbox{[}1\mbox{]} in {\ttfamily submatrices} is 3. The former index is calculated as {\ttfamily 0 + 0 $\ast$ 2 = 0}, while the latter index is calculated as {\ttfamily 1 + 1 $\ast$ 2 = 3}.

Iterate over the columns from $l + 1$ to $k$ in the source matrix and scale each matrix block with the factor {\ttfamily M\+\_\+inv.\+submatrices}\mbox{[}diag\+\_\+block\+\_\+index\+\_\+in\+\_\+submatrices\mbox{]}. Also note that the column index starts from zero, therefore the loop variable $j \in [l+1, k)$.

Migrate the newly created $\mathcal{H}$-\/matrix to the target submatrix.

Iterate over the columns from $0$ to $l - 1$ in the inverse matrix and scale each matrix block with the factor {\ttfamily M\+\_\+inv.\+submatrices}\mbox{[}diag\+\_\+block\+\_\+index\+\_\+in\+\_\+submatrices\mbox{]}.

Migrate the newly created $\mathcal{H}$-\/matrix to the target submatrix.

Iterate over the rows from $l + 1$ to $k - 1$ in order to eliminate the matrix blocks $M_{l+1,l}, \cdots, M_{k - 1,l}$.

Stage 2\+: eliminate the upper triangular part of the matrix.

Eliminate the elements $M_{l-1,l}, \cdots, M_{1,l}$.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::invert\+\_\+by\+\_\+gauss\+\_\+elim().

\mbox{\Hypertarget{classHMatrix_afd8e08ec263ea524bef3c5c66796c61d}\label{classHMatrix_afd8e08ec263ea524bef3c5c66796c61d}} 
\index{H\+Matrix@{H\+Matrix}!\+\_\+print\+\_\+matrix\+\_\+info\+\_\+as\+\_\+dot\+\_\+node@{\+\_\+print\+\_\+matrix\+\_\+info\+\_\+as\+\_\+dot\+\_\+node}}
\index{\+\_\+print\+\_\+matrix\+\_\+info\+\_\+as\+\_\+dot\+\_\+node@{\+\_\+print\+\_\+matrix\+\_\+info\+\_\+as\+\_\+dot\+\_\+node}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{\+\_\+print\+\_\+matrix\+\_\+info\+\_\+as\+\_\+dot\+\_\+node()}{\_print\_matrix\_info\_as\_dot\_node()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::\+\_\+print\+\_\+matrix\+\_\+info\+\_\+as\+\_\+dot\+\_\+node (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [private]}}

Print the $\mathcal{H}$-\/matrix hierarchy information recursively as a node in the directional graph in Graphviz dot format.


\begin{DoxyParams}{Parameters}
{\em out} & \\
\hline
\end{DoxyParams}
Create the graph node for the current $\mathcal{H}$-\/matrix node. When the current $\mathcal{H}$-\/matrix node is a full matrix, use red background. When it is a rank-\/k matrix, use green background.

Construct the relationship between the current node and its children.

Print each submatrix node.

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::print\+\_\+matrix\+\_\+info\+\_\+as\+\_\+dot().

\mbox{\Hypertarget{classHMatrix_a8f96186426cd3147d5af32ca84ad25ea}\label{classHMatrix_a8f96186426cd3147d5af32ca84ad25ea}} 
\index{H\+Matrix@{H\+Matrix}!add@{add}}
\index{add@{add}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [1/10]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::add (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{C,  }\item[{const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{B,  }\item[{const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type}}]{fixed\+\_\+rank\+\_\+k }\end{DoxyParamCaption}) const}

Add the current \hyperlink{classHMatrix}{H\+Matrix} {\ttfamily A} with another \hyperlink{classHMatrix}{H\+Matrix} {\ttfamily B} into {\ttfamily C}, i.\+e. whole matrix addition instead of addition limited to a specific block, where {\ttfamily C} will be truncated to a fixed rank {\ttfamily fixed\+\_\+rank}.

This algorithm is intrinsically recursive, i.\+e. the addition of parent H\+Matrices will perform the addition of each pair of child H\+Matrices corresponding to a same block cluster. Strictly speaking, this member function {\ttfamily add} is not a recursive function, because the class instance which calls {\ttfamily add} changes from parent to child \hyperlink{classHMatrix}{H\+Matrix}.

N.\+B.


\begin{DoxyEnumerate}
\item The two operands should have the same partition.
\item The hierarchical structure of {\ttfamily C} should be pre-\/generated.
\end{DoxyEnumerate}


\begin{DoxyParams}{Parameters}
{\em C} & \\
\hline
{\em B} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}
{\bfseries Work flow}

Recursively add each pair of submatrices.

Perform addition of full matrices.

Perform addition of rank-\/k matrices.

References H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::add(), h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving(), h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving(), main(), and H\+Matrix$<$ spacedim, Number $>$\+::mmult().

\mbox{\Hypertarget{classHMatrix_aea42f5112b88270fef73342853fa386d}\label{classHMatrix_aea42f5112b88270fef73342853fa386d}} 
\index{H\+Matrix@{H\+Matrix}!add@{add}}
\index{add@{add}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [2/10]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::add (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{C,  }\item[{const Number}]{b,  }\item[{const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{B,  }\item[{const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type}}]{fixed\+\_\+rank\+\_\+k }\end{DoxyParamCaption}) const}

Perform the addition with factor $C = A + b B$. 
\begin{DoxyParams}{Parameters}
{\em C} & \\
\hline
{\em b} & \\
\hline
{\em B} & \\
\hline
{\em fixed\+\_\+rank\+\_\+k} & \\
\hline
\end{DoxyParams}
{\bfseries Work flow}

Recursively add each pair of submatrices.

Perform addition of full matrices.

Perform addition of rank-\/k matrices.

References H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.

\mbox{\Hypertarget{classHMatrix_a9bd48ada567962ab0dc75c31986bd1a6}\label{classHMatrix_a9bd48ada567962ab0dc75c31986bd1a6}} 
\index{H\+Matrix@{H\+Matrix}!add@{add}}
\index{add@{add}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [3/10]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::add (\begin{DoxyParamCaption}\item[{const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{B,  }\item[{const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type}}]{fixed\+\_\+rank\+\_\+k }\end{DoxyParamCaption}) const}

Add the \hyperlink{classHMatrix}{H\+Matrix} {\ttfamily B} into the current \hyperlink{classHMatrix}{H\+Matrix} {\ttfamily A}, i.\+e. whole matrix addition instead of addition limited to a specific block, where {\ttfamily C} will be truncated to a fixed rank {\ttfamily fixed\+\_\+rank}.

This algorithm is intrinsically recursive, i.\+e. the addition of parent H\+Matrices will perform the addition of each pair of child H\+Matrices corresponding to a same block cluster. Strictly speaking, this member function {\ttfamily add} is not a recursive function, because the class instance which calls {\ttfamily add} changes from parent to child \hyperlink{classHMatrix}{H\+Matrix}.

N.\+B. The two operands should have the same partition.


\begin{DoxyParams}{Parameters}
{\em B} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}
{\bfseries Work flow}

Recursively add each pair of submatrices.

Perform addition of full matrices.

Perform addition of rank-\/k matrices.

References H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.

\mbox{\Hypertarget{classHMatrix_af42aaa86b9f47c5c1514e4f06e343db6}\label{classHMatrix_af42aaa86b9f47c5c1514e4f06e343db6}} 
\index{H\+Matrix@{H\+Matrix}!add@{add}}
\index{add@{add}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [4/10]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::add (\begin{DoxyParamCaption}\item[{const Number}]{b,  }\item[{const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{B,  }\item[{const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type}}]{fixed\+\_\+rank\+\_\+k }\end{DoxyParamCaption}) const}

Perform the addition $A = A + b B$. 
\begin{DoxyParams}{Parameters}
{\em B} & \\
\hline
{\em fixed\+\_\+rank\+\_\+k} & \\
\hline
\end{DoxyParams}
{\bfseries Work flow}

Recursively add each pair of submatrices.

Perform addition of full matrices.

Perform addition of rank-\/k matrices.

References H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.

\mbox{\Hypertarget{classHMatrix_a1793dff400aeae649f909d7f45db8b8a}\label{classHMatrix_a1793dff400aeae649f909d7f45db8b8a}} 
\index{H\+Matrix@{H\+Matrix}!add@{add}}
\index{add@{add}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [5/10]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::add (\begin{DoxyParamCaption}\item[{const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{B,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+rk,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+rk,  }\item[{const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type}}]{fixed\+\_\+rank\+\_\+k }\end{DoxyParamCaption}) const}

Add a rank-\/k matrix into the current $\mathcal{H}$-\/matrix node.

The rank-\/k matrix will be restricted to each leaf node of the $\mathcal{H}$-\/matrix node and the addition will be performed there. In this implementation, the row and column global to local index maps with respect to {\ttfamily B} should be explicit provided.


\begin{DoxyParams}{Parameters}
{\em B} & \\
\hline
{\em fixed\+\_\+rank\+\_\+k} & \\
\hline
\end{DoxyParams}
Restrict the rank-\/k matrix to the local full matrix then perform the addition with the leaf node of the $\mathcal{H}$-\/matrix.

Create a local rank-\/k matrix by restricting from the original large rank-\/k matrix.

References H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, Rk\+Matrix$<$ Number $>$\+::restrict\+To\+Full\+Matrix(), H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.

\mbox{\Hypertarget{classHMatrix_ad3800d6fded523d5c8eeb8fd0c106a34}\label{classHMatrix_ad3800d6fded523d5c8eeb8fd0c106a34}} 
\index{H\+Matrix@{H\+Matrix}!add@{add}}
\index{add@{add}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [6/10]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::add (\begin{DoxyParamCaption}\item[{const Number}]{b,  }\item[{const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{B,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+rk,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\+\_\+for\+\_\+rk,  }\item[{const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type}}]{fixed\+\_\+rank\+\_\+k }\end{DoxyParamCaption}) const}

Add a rank-\/k matrix multiplied by a factor into the current $\mathcal{H}$-\/matrix node.

The rank-\/k matrix will be restricted to each leaf node of the $\mathcal{H}$-\/matrix node and the addition will be performed there. In this implementation, the row and column global to local index maps with respect to {\ttfamily B} should be explicitly provided.


\begin{DoxyParams}{Parameters}
{\em b} & \\
\hline
{\em B} & \\
\hline
{\em fixed\+\_\+rank\+\_\+k} & \\
\hline
\end{DoxyParams}
Restrict the rank-\/k matrix to the local full matrix then perform the addition with the leaf node of the $\mathcal{H}$-\/matrix.

Create a local rank-\/k matrix by restricting from the original large rank-\/k matrix.

References H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, Rk\+Matrix$<$ Number $>$\+::restrict\+To\+Full\+Matrix(), H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.

\mbox{\Hypertarget{classHMatrix_ab9000d7604e2045cf7cad7458daca340}\label{classHMatrix_ab9000d7604e2045cf7cad7458daca340}} 
\index{H\+Matrix@{H\+Matrix}!add@{add}}
\index{add@{add}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [7/10]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::add (\begin{DoxyParamCaption}\item[{const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{B,  }\item[{const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type}}]{fixed\+\_\+rank\+\_\+k }\end{DoxyParamCaption})}

Add a rank-\/k matrix into the current $\mathcal{H}$-\/matrix node.

The rank-\/k matrix will be restricted to each leaf node of the $\mathcal{H}$-\/matrix node and the addition will be performed there. In this implementation, the row and column global to local index maps with respect to {\ttfamily B} are the same as those associated with the $\mathcal{H}$-\/matrix, i.\+e. the rank-\/k matrix and $\mathcal{H}$-\/matrix are on a same block.


\begin{DoxyParams}{Parameters}
{\em B} & \\
\hline
{\em fixed\+\_\+rank\+\_\+k} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::add(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, Rk\+Matrix$<$ Number $>$\+::get\+\_\+m(), Rk\+Matrix$<$ Number $>$\+::get\+\_\+n(), H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, and H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices.

\mbox{\Hypertarget{classHMatrix_a94981e45b7d9aa0f2afae77d414f1c1a}\label{classHMatrix_a94981e45b7d9aa0f2afae77d414f1c1a}} 
\index{H\+Matrix@{H\+Matrix}!add@{add}}
\index{add@{add}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [8/10]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::add (\begin{DoxyParamCaption}\item[{const Number}]{b,  }\item[{const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{B,  }\item[{const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type}}]{fixed\+\_\+rank\+\_\+k }\end{DoxyParamCaption})}

Add a rank-\/k matrix multiplied by a factor into the current $\mathcal{H}$-\/matrix node.

The rank-\/k matrix will be restricted to each leaf node of the $\mathcal{H}$-\/matrix node and the addition will be performed there. In this implementation, the row and column global to local index maps with respect to {\ttfamily B} are the same as those associated with the $\mathcal{H}$-\/matrix, i.\+e. the rank-\/k matrix and $\mathcal{H}$-\/matrix are on a same block.


\begin{DoxyParams}{Parameters}
{\em b} & \\
\hline
{\em B} & \\
\hline
{\em fixed\+\_\+rank\+\_\+k} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::add(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, Rk\+Matrix$<$ Number $>$\+::get\+\_\+m(), Rk\+Matrix$<$ Number $>$\+::get\+\_\+n(), H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, and H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices.

\mbox{\Hypertarget{classHMatrix_a403d72a5eea3912d67fd0807ddd0baf8}\label{classHMatrix_a403d72a5eea3912d67fd0807ddd0baf8}} 
\index{H\+Matrix@{H\+Matrix}!add@{add}}
\index{add@{add}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [9/10]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::add (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{C,  }\item[{const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{B,  }\item[{const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type}}]{fixed\+\_\+rank\+\_\+k }\end{DoxyParamCaption})}

Perform the $\mathcal{H}$-\/matrix addition $C = A + B$. 
\begin{DoxyParams}{Parameters}
{\em C} & \\
\hline
{\em B} & \\
\hline
{\em fixed\+\_\+rank\+\_\+k} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::add().

\mbox{\Hypertarget{classHMatrix_af66071b53145fe007ac040fa0c4b47c6}\label{classHMatrix_af66071b53145fe007ac040fa0c4b47c6}} 
\index{H\+Matrix@{H\+Matrix}!add@{add}}
\index{add@{add}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [10/10]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::add (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{C,  }\item[{const Number}]{b,  }\item[{const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ \&}]{B,  }\item[{const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type}}]{fixed\+\_\+rank\+\_\+k }\end{DoxyParamCaption})}

Perform the $\mathcal{H}$-\/matrix addition $C = A + b B$. 
\begin{DoxyParams}{Parameters}
{\em C} & \\
\hline
{\em b} & \\
\hline
{\em B} & \\
\hline
{\em fixed\+\_\+rank\+\_\+k} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::add().

\mbox{\Hypertarget{classHMatrix_a139f32982527ba981e0211b5663e3b43}\label{classHMatrix_a139f32982527ba981e0211b5663e3b43}} 
\index{H\+Matrix@{H\+Matrix}!build\+\_\+leaf\+\_\+set@{build\+\_\+leaf\+\_\+set}}
\index{build\+\_\+leaf\+\_\+set@{build\+\_\+leaf\+\_\+set}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{build\+\_\+leaf\+\_\+set()}{build\_leaf\_set()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Build the leaf set of the current $\mathcal{H}$-\/matrix node. 

References H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+build\+\_\+leaf\+\_\+set(), and H\+Matrix$<$ spacedim, Number $>$\+::leaf\+\_\+set.



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::coarsen\+\_\+to\+\_\+subtree(), H\+Matrix$<$ spacedim, Number $>$\+::convert\+\_\+between\+\_\+different\+\_\+block\+\_\+cluster\+\_\+trees(), H\+Matrix$<$ spacedim, Number $>$\+::\+H\+Matrix(), H\+Matrix$<$ spacedim, Number $>$\+::invert\+\_\+by\+\_\+gauss\+\_\+elim(), H\+Matrix$<$ spacedim, Number $>$\+::mmult(), H\+Matrix$<$ spacedim, Number $>$\+::operator=(), H\+Matrix$<$ spacedim, Number $>$\+::refine\+\_\+to\+\_\+supertree(), and H\+Matrix$<$ spacedim, Number $>$\+::reinit().

\mbox{\Hypertarget{classHMatrix_a72191c447afaa0fd84505022cf1d174e}\label{classHMatrix_a72191c447afaa0fd84505022cf1d174e}} 
\index{H\+Matrix@{H\+Matrix}!calc\+\_\+rank\+\_\+upper\+\_\+bound\+\_\+for\+\_\+rkmatrices@{calc\+\_\+rank\+\_\+upper\+\_\+bound\+\_\+for\+\_\+rkmatrices}}
\index{calc\+\_\+rank\+\_\+upper\+\_\+bound\+\_\+for\+\_\+rkmatrices@{calc\+\_\+rank\+\_\+upper\+\_\+bound\+\_\+for\+\_\+rkmatrices}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{calc\+\_\+rank\+\_\+upper\+\_\+bound\+\_\+for\+\_\+rkmatrices()}{calc\_rank\_upper\_bound\_for\_rkmatrices()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::calc\+\_\+rank\+\_\+upper\+\_\+bound\+\_\+for\+\_\+rkmatrices (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Calculate and set the rank upper bound for each rank-\/k matrix in the $\mathcal{H}$-\/matrix hierarchy. 

References Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by main().

\mbox{\Hypertarget{classHMatrix_ae55bd45587b895bfdb977e7cbea46519}\label{classHMatrix_ae55bd45587b895bfdb977e7cbea46519}} 
\index{H\+Matrix@{H\+Matrix}!clear@{clear}}
\index{clear@{clear}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Clear the whole $\mathcal{H}$-\/matrix hierarchy. Recursively clear submatrices.

Clear the current matrix node.

References H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{classHMatrix_aec0815bc9c3654391bb2b3095383e6cb}\label{classHMatrix_aec0815bc9c3654391bb2b3095383e6cb}} 
\index{H\+Matrix@{H\+Matrix}!clear\+\_\+hmat\+\_\+node@{clear\+\_\+hmat\+\_\+node}}
\index{clear\+\_\+hmat\+\_\+node@{clear\+\_\+hmat\+\_\+node}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{clear\+\_\+hmat\+\_\+node()}{clear\_hmat\_node()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Clear the current $\mathcal{H}$-\/matrix node. 

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, H\+Matrix$<$ spacedim, Number $>$\+::leaf\+\_\+set, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::parent, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+F, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+P, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+R, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::submatrix\+\_\+index, H\+Matrix$<$ spacedim, Number $>$\+::submatrix\+\_\+index\+\_\+invalid, H\+Matrix$<$ spacedim, Number $>$\+::\+Tind, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::clear().

\mbox{\Hypertarget{classHMatrix_a525ad4d453f4f496b98cccb341c8b60b}\label{classHMatrix_a525ad4d453f4f496b98cccb341c8b60b}} 
\index{H\+Matrix@{H\+Matrix}!coarsen\+\_\+to\+\_\+partition@{coarsen\+\_\+to\+\_\+partition}}
\index{coarsen\+\_\+to\+\_\+partition@{coarsen\+\_\+to\+\_\+partition}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{coarsen\+\_\+to\+\_\+partition()}{coarsen\_to\_partition()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::coarsen\+\_\+to\+\_\+partition (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+pointer\+\_\+type $>$ \&}]{partition,  }\item[{const unsigned int}]{fixed\+\_\+rank\+\_\+k }\end{DoxyParamCaption})}

Coarsen the current $\mathcal{H}$-\/matrix via recursive call so that its leaf set complies with the given partition. Each rank-\/k matrix in the $\mathcal{H}$-\/matrix structure will be truncated to {\ttfamily fixed\+\_\+rank\+\_\+k}.

Since this is a recursive member function, it does not execute leaf set rebuilding, which is an operation on the overall $\mathcal{H}$-\/matrix hierarchy.

This member function implements the operator $\mathcal{T}_{P' \leftarrow P}^{\mathcal{H} \leftarrow \mathcal{H}}$ for the case $T(I \times J, P') \subset T(I \times J, P)$ in (7.\+9) in Hackbusch\textquotesingle{}s $\mathcal{H}$-\/matrix book. Because there is no internal check about this, users should ensure this set inclusion relationship.


\begin{DoxyParams}{Parameters}
{\em partition} & \\
\hline
{\em fixed\+\_\+rank\+\_\+k} & \\
\hline
\end{DoxyParams}
N.\+B. The function call {\ttfamily find\+\_\+pointer\+\_\+data} here involves the comparison of two block cluster nodes, which internally compares the contained two block clusters, which further compares the contained tau node and sigma node pointers. Therefore, at the moment, the inner most comparison is shallow comparison.

The block cluster node associated with the current $\mathcal{H}$-\/matrix node belongs to the given {\ttfamily partition}. Then $\mathcal{T}_r^{\mathcal{R} \leftarrow \mathcal{H}}$ will be applied to this $\mathcal{H}$-\/matrix node.

When the block cluster node associated with the current $\mathcal{H}$-\/matrix node does not belong to the {\ttfamily partition}, recursively call this same member function of its each child.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, find\+\_\+pointer\+\_\+data(), and H\+Matrix$<$ spacedim, Number $>$\+::submatrices.



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::coarsen\+\_\+to\+\_\+subtree(), and H\+Matrix$<$ spacedim, Number $>$\+::convert\+\_\+between\+\_\+different\+\_\+block\+\_\+cluster\+\_\+trees().

\mbox{\Hypertarget{classHMatrix_a27c7390b792e6e47ab2861616a997d99}\label{classHMatrix_a27c7390b792e6e47ab2861616a997d99}} 
\index{H\+Matrix@{H\+Matrix}!coarsen\+\_\+to\+\_\+subtree@{coarsen\+\_\+to\+\_\+subtree}}
\index{coarsen\+\_\+to\+\_\+subtree@{coarsen\+\_\+to\+\_\+subtree}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{coarsen\+\_\+to\+\_\+subtree()}{coarsen\_to\_subtree()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::coarsen\+\_\+to\+\_\+subtree (\begin{DoxyParamCaption}\item[{const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{subtree,  }\item[{const unsigned int}]{fixed\+\_\+rank\+\_\+k }\end{DoxyParamCaption})}

Coarsen the current $\mathcal{H}$-\/matrix so that it corresponds to the partition determined by the {\ttfamily subtree}. Each rank-\/k matrix in the hierarchical matrix structure will be truncated to {\ttfamily fixed\+\_\+rank\+\_\+k}.

This function calls {\ttfamily \hyperlink{classHMatrix_a525ad4d453f4f496b98cccb341c8b60b}{H\+Matrix$<$spacedim, Number$>$\+::coarsen\+\_\+to\+\_\+partition}} internally. After that, the leaf set is rebuilt.

This member function implements the operator $\mathcal{T}_{P' \leftarrow P}^{\mathcal{H} \leftarrow \mathcal{H}}$ for the case $T(I \times J, P') \subset T(I \times J, P)$ in (7.\+9) in Hackbusch\textquotesingle{}s $\mathcal{H}$-\/matrix book. Because there is no internal check about this, users should ensure that the given {\ttfamily subtree} is really a subtree of the block cluster tree associated with this $\mathcal{H}$-\/matrix hierarchy.


\begin{DoxyParams}{Parameters}
{\em subtree} & \\
\hline
{\em fixed\+\_\+rank\+\_\+k} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), H\+Matrix$<$ spacedim, Number $>$\+::coarsen\+\_\+to\+\_\+partition(), and Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+leaf\+\_\+set().



Referenced by main().

\mbox{\Hypertarget{classHMatrix_a7d6c76f7db2b9239f24df292e945a970}\label{classHMatrix_a7d6c76f7db2b9239f24df292e945a970}} 
\index{H\+Matrix@{H\+Matrix}!compute\+\_\+cholesky\+\_\+factorization@{compute\+\_\+cholesky\+\_\+factorization}}
\index{compute\+\_\+cholesky\+\_\+factorization@{compute\+\_\+cholesky\+\_\+factorization}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{compute\+\_\+cholesky\+\_\+factorization()}{compute\_cholesky\_factorization()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::compute\+\_\+cholesky\+\_\+factorization (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{L,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption}) const}

Compute the Cholesky factorization of an $\mathcal{H}$-\/matrix. Only the lower triangular $\mathcal{H}$-\/matrix factor $L$ is stored in the output variable {\ttfamily L}. The matrix $L$ should have the same hierarchical structure as the original matrix.


\begin{DoxyParams}{Parameters}
{\em L} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}
When the current $\mathcal{H}$-\/matrix node belongs to the leaf set, it must be a full matrix and the Cholesky factorization can be directly applied to it using L\+A\+P\+A\+CK.

N.\+B. Unlike the LU factorization, the Cholesky factorization performed by L\+A\+P\+A\+CK has no pivoting.

Copy the full matrix from the source matrix to the result matrix {\ttfamily L}.

After the Cholesky factorization, the matrix {\ttfamily L} is stored in the same full matrix. Hence, this operation is in situ.

At present, Cholesky factorization is only to be applied to square matrix and block square matrix.

When the current $\mathcal{H}$-\/matrix node is not a leaf, iterate over each block row.

Iterate over each block column from beginning to the diagonal block.

Create a local $\mathcal{H}$-\/matrix $Z_{ij}$ as the new R\+HS matrix.

Iterate over each block column before the $j$-\/th column.

When the current block column is before the i\textquotesingle{}th column, solve $L_{ij} L_{jj}^T = M_{ij}$ using the matrix-\/valued Cholesky transposed forward substitution.

When coming to the diagonal block, go down one level of recursion for Cholesky factorization.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::compute\+\_\+cholesky\+\_\+factorization(), H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::compute\+\_\+cholesky\+\_\+factorization(), and main().

\mbox{\Hypertarget{classHMatrix_abc6e787e46fb082579b2d3aea1ad54f6}\label{classHMatrix_abc6e787e46fb082579b2d3aea1ad54f6}} 
\index{H\+Matrix@{H\+Matrix}!compute\+\_\+cholesky\+\_\+factorization@{compute\+\_\+cholesky\+\_\+factorization}}
\index{compute\+\_\+cholesky\+\_\+factorization@{compute\+\_\+cholesky\+\_\+factorization}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{compute\+\_\+cholesky\+\_\+factorization()}{compute\_cholesky\_factorization()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::compute\+\_\+cholesky\+\_\+factorization (\begin{DoxyParamCaption}\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

Compute the Cholesky factorization of an $\mathcal{H}$-\/matrix in situ. Only the lower triangular $\mathcal{H}$-\/matrix factor $L$ is stored in the original matrix.


\begin{DoxyParams}{Parameters}
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}
When the current $\mathcal{H}$-\/matrix node belongs to the leaf set, it must be a full matrix and the Cholesky factorization can be directly applied to it using L\+A\+P\+A\+CK.

N.\+B. Unlike the LU factorization, the Cholesky factorization performed by L\+A\+P\+A\+CK has no pivoting.

After the Cholesky factorization, the matrix {\ttfamily L} is stored in the same full matrix. Hence, this operation is in situ.

At present, Cholesky factorization is only to be applied to square matrix and block square matrix.

When the current $\mathcal{H}$-\/matrix node is not a leaf, iterate over each block row.

Iterate over each block column from beginning to the diagonal block.

Create a local $\mathcal{H}$-\/matrix $Z_{ij}$ as the new R\+HS matrix.

Iterate over each block column before the $j$-\/th column.

When the current block column is before the i\textquotesingle{}th column, solve $L_{ij} L_{jj}^T = M_{ij}$ using the matrix-\/valued Cholesky transposed forward substitution.

When coming to the diagonal block, go down one level of recursion for Cholesky factorization.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::compute\+\_\+cholesky\+\_\+factorization(), H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{classHMatrix_acf95fce81ec83a759d1db8d10c3e34fb}\label{classHMatrix_acf95fce81ec83a759d1db8d10c3e34fb}} 
\index{H\+Matrix@{H\+Matrix}!compute\+\_\+lu\+\_\+factorization@{compute\+\_\+lu\+\_\+factorization}}
\index{compute\+\_\+lu\+\_\+factorization@{compute\+\_\+lu\+\_\+factorization}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{compute\+\_\+lu\+\_\+factorization()}{compute\_lu\_factorization()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::compute\+\_\+lu\+\_\+factorization (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{LU,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption}) const}

Compute the LU factorization of an $\mathcal{H}$-\/matrix. The resulted $L$ and $U$ factors are stored in a same $\mathcal{H}$-\/matrix $LU$. The matrix $LU$ should have the same hierarchical structure as the original matrix.


\begin{DoxyParams}{Parameters}
{\em LU} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}
When the current $\mathcal{H}$-\/matrix node belongs to the leaf set, it must be a full matrix and the LU factorization can be directly applied to it using L\+A\+P\+A\+CK.

N.\+B. The LU factorization performed by L\+A\+P\+A\+CK has row partial pivoting.

Copy the full matrix from the source matrix to the result matrix {\ttfamily LU}.

After the LU factorization, L and U matrices are stored in the same full matrix. Hence, this operation is in situ.

At present, LU factorization is only to be applied to square matrix and block square matrix.

When the current $\mathcal{H}$-\/matrix node is not a leaf, iterate over each block row.

Iterate over each block column.

Iterate over each block column before the $\min\{i, j\}$-\/th column using the loop counter $k$. The corresponding submatrix product $L_{i,k}U_{k,j}$ needs to be subtracted from the R\+HS submatrix $M_{ij}$.

Create a local $\mathcal{H}$-\/matrix $Z_{ij}$ as the new R\+HS matrix.

When the current block column is before the i\textquotesingle{}th column, solve $L_{ij} U_{jj}=M_{ij}$ to get $L_{ij}$ using the matrix-\/valued transposed forward substitution.

When the current block column is i, go down one level of recursion for LU factorization.

Solve $L_{ii}U_{ij}=M_{ij}$ for $L_{ii}$.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::compute\+\_\+lu\+\_\+factorization(), H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::compute\+\_\+lu\+\_\+factorization(), and main().

\mbox{\Hypertarget{classHMatrix_aba14c63550f42d8a971beab340337b0e}\label{classHMatrix_aba14c63550f42d8a971beab340337b0e}} 
\index{H\+Matrix@{H\+Matrix}!compute\+\_\+lu\+\_\+factorization@{compute\+\_\+lu\+\_\+factorization}}
\index{compute\+\_\+lu\+\_\+factorization@{compute\+\_\+lu\+\_\+factorization}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{compute\+\_\+lu\+\_\+factorization()}{compute\_lu\_factorization()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::compute\+\_\+lu\+\_\+factorization (\begin{DoxyParamCaption}\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

Compute the LU factorization of an $\mathcal{H}$-\/matrix in situ. The resulted $L$ and $U$ factors are stored in the original $\mathcal{H}$-\/matrix.


\begin{DoxyParams}{Parameters}
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}
When the current $\mathcal{H}$-\/matrix node belongs to the leaf set, it must be a full matrix and the LU factorization can be directly applied to it using L\+A\+P\+A\+CK.

N.\+B. The LU factorization performed by L\+A\+P\+A\+CK has row partial pivoting.

After the LU factorization, L and U matrices are stored in the same full matrix. Hence, this operation is in situ.

At present, LU factorization is only to be applied to square matrix and block square matrix.

When the current $\mathcal{H}$-\/matrix node is not a leaf, iterate over each block row.

Iterate over each block column.

Iterate over each block column before the $\min\{i, j\}$-\/th column using the loop counter $k$. The corresponding submatrix product $L_{i,k}U_{k,j}$ needs to be subtracted from the R\+HS submatrix $M_{ij}$.

Create a local $\mathcal{H}$-\/matrix $Z_{ij}$ as the new R\+HS matrix.

When the current block column is before the i\textquotesingle{}th column, solve $L_{ij} U_{jj}=M_{ij}$ to get $L_{ij}$ using the matrix-\/valued transposed forward substitution.

When the current block column is i, go down one level of recursion for LU factorization.

Solve $L_{ii}U_{ij}=M_{ij}$ for $L_{ii}$.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::compute\+\_\+lu\+\_\+factorization(), H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{classHMatrix_af6fd60090b0de7bdea52fc84ddeb22c3}\label{classHMatrix_af6fd60090b0de7bdea52fc84ddeb22c3}} 
\index{H\+Matrix@{H\+Matrix}!convert\+\_\+between\+\_\+different\+\_\+block\+\_\+cluster\+\_\+trees@{convert\+\_\+between\+\_\+different\+\_\+block\+\_\+cluster\+\_\+trees}}
\index{convert\+\_\+between\+\_\+different\+\_\+block\+\_\+cluster\+\_\+trees@{convert\+\_\+between\+\_\+different\+\_\+block\+\_\+cluster\+\_\+trees}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{convert\+\_\+between\+\_\+different\+\_\+block\+\_\+cluster\+\_\+trees()}{convert\_between\_different\_block\_cluster\_trees()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::convert\+\_\+between\+\_\+different\+\_\+block\+\_\+cluster\+\_\+trees (\begin{DoxyParamCaption}\item[{\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{bct1,  }\item[{\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{bct2,  }\item[{const unsigned int}]{fixed\+\_\+rank\+\_\+k2 = {\ttfamily 1} }\end{DoxyParamCaption})}

Convert an $\mathcal{H}$-\/matrix between two different block cluster trees $T$ and $T'$, where $T := T(I \times J, P)$ and $T' := T'(I \times J, P')$. The two trees have incompatible partitions and do not contain each other. However, they are constructed on the same cluster trees $T(I)$ and $T(J)$. This enables us to make a {\bfseries shallow} comparison of two block cluster nodes based on the pointer addresses related to the comprising clusters, which is useful for verify the equality of two block cluster nodes.

The procedures of this algorithm are as below. Assume the current $\mathcal{H}$-\/matrix to be converted is associated with the block cluster tree $T$.


\begin{DoxyEnumerate}
\item Extend $T$ to be finer than $T'$, from which we get the new block cluster tree $T''$.
\item Refine the original $\mathcal{H}$-\/matrix with respect to the extended tree $T''$.
\item Get and keep a record of the leaf set of the block cluster tree $T'$, which will be used for matrix coarsening in the last step.
\item Extend $T'$ to the finer block cluster tree $T''$, from which we get $\tilde{T}'$.
\item Build a new $\mathcal{H}$-\/matrix with respect to $\tilde{T}'$ with the actual data migrated from the leaf nodes of the original $\mathcal{H}$-\/matrix.
\item Coarsen the new $\mathcal{H}$-\/matrix to the original partition of $T'$.
\item Delete the hierarchy of the original $\mathcal{H}$-\/matrix.
\item Assign the new $\mathcal{H}$-\/matrix object to the original $\mathcal{H}$-\/matrix object.
\end{DoxyEnumerate}


\begin{DoxyParams}{Parameters}
{\em bct1} & The block cluster tree which is associated with the current $\mathcal{H}$-\/matrix. \\
\hline
{\em bct2} & The block cluster tree to which the current $\mathcal{H}$-\/matrix is to be converted. \\
\hline
\end{DoxyParams}
Make a copy of the leaf set of the target block cluster tree, which will be used for the final coarsening.

Extend the block cluster tree associated with the current $\mathcal{H}$-\/matrix to the coarsest tree which is finer than the target block cluster tree. If the block cluster tree has really been extended, refine the $\mathcal{H}$-\/matrix to its extended block cluster tree.

Extend {\ttfamily bct2} to the finer partition obtained from {\ttfamily bct1} as above. N.\+B. Now the leaf set of {\ttfamily bct1} after refinement is the same as that of {\ttfamily bct2} after this extension.

Create a new $\mathcal{H}$-\/matrix with respect to the extended {\ttfamily bct2}, which accepts the data migrated from the leaf set of the current $\mathcal{H}$-\/matrix.


\begin{DoxyDescription}
\item[Note ]
\begin{DoxyItemize}
\item This hierarchical structure of the new $\mathcal{H}$-\/matrix is built with respect to the extended block cluster tree {\ttfamily bct2}. 
\item The shallow copy constructor cannot be used here because the new $\mathcal{H}$-\/matrix has a different block cluster tree structure from the current $\mathcal{H}$-\/matrix, even though they have the same partition after tree extension. 
\end{DoxyItemize}
\end{DoxyDescription}

Coarsen the new $\mathcal{H}$-\/matrix to the original leaf set of {\ttfamily bct2}. Then rebuild its leaf set.


\begin{DoxyDescription}
\item[Note ]The structure of the block cluster tree associated with the $\mathcal{H}$-\/matrix is still same as before, which has more levels than the $\mathcal{H}$-\/matrix. Therefore, we should prune the block cluster tree to make it consistent with the $\mathcal{H}$-\/matrix. 
\end{DoxyDescription}

Move the new $\mathcal{H}$-\/matrix to the current $\mathcal{H}$-\/matrix by shallow assignment.

References H\+Matrix$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), H\+Matrix$<$ spacedim, Number $>$\+::coarsen\+\_\+to\+\_\+partition(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::extend\+\_\+finer\+\_\+than\+\_\+partition(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::extend\+\_\+to\+\_\+finer\+\_\+partition(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+leaf\+\_\+set(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::prune\+\_\+to\+\_\+partition(), and H\+Matrix$<$ spacedim, Number $>$\+::refine\+\_\+to\+\_\+supertree().



Referenced by h\+\_\+h\+\_\+mmult\+\_\+phase2(), and main().

\mbox{\Hypertarget{classHMatrix_a00bdd40f7fcf5c912c34c427df518300}\label{classHMatrix_a00bdd40f7fcf5c912c34c427df518300}} 
\index{H\+Matrix@{H\+Matrix}!convert\+To\+Full\+Matrix@{convert\+To\+Full\+Matrix}}
\index{convert\+To\+Full\+Matrix@{convert\+To\+Full\+Matrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{convert\+To\+Full\+Matrix()}{convertToFullMatrix()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
template$<$typename Matrix\+Type $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::convert\+To\+Full\+Matrix (\begin{DoxyParamCaption}\item[{Matrix\+Type \&}]{M }\end{DoxyParamCaption}) const}

Convert an \hyperlink{classHMatrix}{H\+Matrix} to a full matrix by calling the internal recursive function.


\begin{DoxyDescription}
\item[Note ]This function only has the verification purpose. In reality, a large dense matrix cannot be saved as a full matrix. 
\end{DoxyDescription}
\begin{DoxyParams}{Parameters}
{\em matrix} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+convert\+To\+Full\+Matrix(), H\+Matrix$<$ spacedim, Number $>$\+::m, and H\+Matrix$<$ spacedim, Number $>$\+::n.



Referenced by main().

\mbox{\Hypertarget{classHMatrix_a6f24998c7de1d0e336577be41c6281e3}\label{classHMatrix_a6f24998c7de1d0e336577be41c6281e3}} 
\index{H\+Matrix@{H\+Matrix}!determine\+\_\+mm\+\_\+split\+\_\+mode\+\_\+from\+\_\+\+Sigma\+\_\+P@{determine\+\_\+mm\+\_\+split\+\_\+mode\+\_\+from\+\_\+\+Sigma\+\_\+P}}
\index{determine\+\_\+mm\+\_\+split\+\_\+mode\+\_\+from\+\_\+\+Sigma\+\_\+P@{determine\+\_\+mm\+\_\+split\+\_\+mode\+\_\+from\+\_\+\+Sigma\+\_\+P}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{determine\+\_\+mm\+\_\+split\+\_\+mode\+\_\+from\+\_\+\+Sigma\+\_\+\+P()}{determine\_mm\_split\_mode\_from\_Sigma\_P()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{tree_8h_a922ca07db9633957939f697a65aff11d}{Tree\+Node\+Split\+Mode} \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::determine\+\_\+mm\+\_\+split\+\_\+mode\+\_\+from\+\_\+\+Sigma\+\_\+P (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Check the consistency of the tree node split modes which are associated with the $\mathcal{H}$-\/matrix node pairs stored in the list $\Sigma_P$ of the current $\mathcal{H}$-\/matrix node. \begin{DoxyReturn}{Returns}

\end{DoxyReturn}


References H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+P.



Referenced by h\+\_\+h\+\_\+mmult\+\_\+phase1\+\_\+recursion().

\mbox{\Hypertarget{classHMatrix_a66979dbdf56155c63f0706649e8545b9}\label{classHMatrix_a66979dbdf56155c63f0706649e8545b9}} 
\index{H\+Matrix@{H\+Matrix}!distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves@{distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves}}
\index{distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves@{distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves()}{distribute\_all\_non\_leaf\_nodes\_sigma\_r\_and\_f\_to\_leaves()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves (\begin{DoxyParamCaption}\item[{const unsigned int}]{fixed\+\_\+rank = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Only non-\/leaf $\mathcal{H}$-\/matrix nodes need to be processed.

Since the current $\mathcal{H}$-\/matrix node has children, its type should be {\ttfamily Hierarchical\+Matrix\+Type} and we make an assertion on it.

Distribute matrices in $\Sigma_b^R$ and $\Sigma_b^F$ of the current $\mathcal{H}$-\/matrix node to the leaf nodes which are its descendants. This is a recursive function call.

Distribute matrices in $\Sigma_b^R$ and $\Sigma_b^F$ of each child matrix of the current $\mathcal{H}$-\/matrix node to the leaf nodes which are its descendants.

References H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+F, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+R, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+build\+\_\+leaf\+\_\+set(), and h\+\_\+h\+\_\+mmult\+\_\+phase2().

\mbox{\Hypertarget{classHMatrix_ab0f83de878e6079330ec3c374f587a04}\label{classHMatrix_ab0f83de878e6079330ec3c374f587a04}} 
\index{H\+Matrix@{H\+Matrix}!find\+\_\+block\+\_\+cluster\+\_\+in\+\_\+leaf\+\_\+set@{find\+\_\+block\+\_\+cluster\+\_\+in\+\_\+leaf\+\_\+set}}
\index{find\+\_\+block\+\_\+cluster\+\_\+in\+\_\+leaf\+\_\+set@{find\+\_\+block\+\_\+cluster\+\_\+in\+\_\+leaf\+\_\+set}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{find\+\_\+block\+\_\+cluster\+\_\+in\+\_\+leaf\+\_\+set()}{find\_block\_cluster\_in\_leaf\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
std\+::vector$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ $>$\+::iterator \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::find\+\_\+block\+\_\+cluster\+\_\+in\+\_\+leaf\+\_\+set (\begin{DoxyParamCaption}\item[{const \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim, Number $>$ \&}]{block\+\_\+cluster }\end{DoxyParamCaption})}

Find a block cluster in the leaf set of the current $\mathcal{H}$-\/matrix and returns the iterator of the corresponding $\mathcal{H}$-\/matrix node in the leaf set.


\begin{DoxyParams}{Parameters}
{\em block\+\_\+cluster} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
Perform a shallow comparison, i.\+e. compare by pointer address, of the block clusters.


\begin{DoxyDescription}
\item[Note ]The data held by those previously found leaf nodes of the source $\mathcal{H}$-\/matrix have already been migrated to the leaf nodes of the new $\mathcal{H}$-\/matrix, which will make the data fields in these leaf nodes being empty. Hence, we will bypass them. 
\end{DoxyDescription}

References H\+Matrix$<$ spacedim, Number $>$\+::leaf\+\_\+set.

\mbox{\Hypertarget{classHMatrix_a723cc200afe31148fcc28f0120c5ec54}\label{classHMatrix_a723cc200afe31148fcc28f0120c5ec54}} 
\index{H\+Matrix@{H\+Matrix}!find\+\_\+block\+\_\+cluster\+\_\+in\+\_\+leaf\+\_\+set@{find\+\_\+block\+\_\+cluster\+\_\+in\+\_\+leaf\+\_\+set}}
\index{find\+\_\+block\+\_\+cluster\+\_\+in\+\_\+leaf\+\_\+set@{find\+\_\+block\+\_\+cluster\+\_\+in\+\_\+leaf\+\_\+set}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{find\+\_\+block\+\_\+cluster\+\_\+in\+\_\+leaf\+\_\+set()}{find\_block\_cluster\_in\_leaf\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
std\+::vector$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ $>$\+::const\+\_\+iterator \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::find\+\_\+block\+\_\+cluster\+\_\+in\+\_\+leaf\+\_\+set (\begin{DoxyParamCaption}\item[{const \hyperlink{classBlockCluster}{Block\+Cluster}$<$ spacedim, Number $>$ \&}]{block\+\_\+cluster }\end{DoxyParamCaption}) const}

Find a block cluster in the leaf set of the current $\mathcal{H}$-\/matrix and returns the iterator of the corresponding $\mathcal{H}$-\/matrix node in the leaf set (const version).


\begin{DoxyParams}{Parameters}
{\em block\+\_\+cluster} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
Perform a shallow comparison, i.\+e. compare by pointer address, of the block clusters.


\begin{DoxyDescription}
\item[Note ]The data held by those previously found leaf nodes of the source $\mathcal{H}$-\/matrix have already been migrated to the leaf nodes of the new $\mathcal{H}$-\/matrix, which will make the data fields in these leaf nodes being empty. Hence, we will bypass them. 
\end{DoxyDescription}

References H\+Matrix$<$ spacedim, Number $>$\+::leaf\+\_\+set.

\mbox{\Hypertarget{classHMatrix_a1ab763860706b9cbef8f5e73d995f29a}\label{classHMatrix_a1ab763860706b9cbef8f5e73d995f29a}} 
\index{H\+Matrix@{H\+Matrix}!find\+\_\+col\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block@{find\+\_\+col\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block}}
\index{find\+\_\+col\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block@{find\+\_\+col\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{find\+\_\+col\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block()}{find\_col\_diag\_block\_for\_offdiag\_block()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::find\+\_\+col\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Find the diagonal block corresponding to the column block cluster of the current $\mathcal{H}$-\/matrix node which is assumed in the lower triangular part of the whole matrix.

{\bfseries The algorithm does not check internally whether the current $\mathcal{H}$-\/matrix node locates in the lower triangular part of the whole matrix. The user should ensure this presumption.}

\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
We make an assertion here that the current $\mathcal{H}$-\/matrix node should not be on the top level in the $\mathcal{H}$-\/matrix hierarchy.

According to the currently adopted tensor product way of constructing block clusters from clusters, the diagonal block can only be the first or last sibling of the current $\mathcal{H}$-\/matrix node. Therefore, when the current $\mathcal{H}$-\/matrix node\textquotesingle{}s {\ttfamily submatrix\+\_\+index} is 1 (2), we will directly check if the first (last) sibling is a diagonal block on a same column.

We should also note that if an off-\/diagonal block is split into sub-\/blocks and such case will occur when the fine non-\/tensor product partition is adopted, none of its submatrices are diagonal blocks, even though the {\ttfamily submatrix\+\_\+index} of which is 0 or 3.

When the first or last sibling of the current $\mathcal{H}$-\/matrix node is not a diagonal block, we will look for the corresponding diagonal block on a same column by first recursing back to the top level of the $\mathcal{H}$-\/matrix hierarchy then recursing forward to the current level.

When the current $\mathcal{H}$-\/matrix node is on the top level of the $\mathcal{H}$-\/matrix hierarchy, throw an error, because the diaognal block should have been found already.

Check if the last (3rd) sibling of the current $\mathcal{H}$-\/matrix node is a diagonal block. Such checking is performed via shallow comparison, i.\+e. compare the pointer addresses of $\tau$ and $\sigma$ clusters.


\begin{DoxyDescription}
\item[Note ]By default, the submatrices are organized in the following order. $<$verbatim$>$ \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ 0 }&\textbf{ 1  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ 0 }&\textbf{ 1  }\\\cline{1-2}
\endhead
2 &3 \\\cline{1-2}
\end{longtabu}
$<$/verbatim$>$ 
\end{DoxyDescription}

Go one recursion level up for further searching.

Check if the first sibling of the current $\mathcal{H}$-\/matrix node is a diagonal block. Such checking is performed via shallow comparison, i.\+e. compare the pointer addresses of $\tau$ and $\sigma$ clusters.

Go one recursion level up for further searching.

Go one recursion level up for further searching.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::parent, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::submatrix\+\_\+index.

\mbox{\Hypertarget{classHMatrix_a1da518d5ca7e685e3e787f58dcad4e61}\label{classHMatrix_a1da518d5ca7e685e3e787f58dcad4e61}} 
\index{H\+Matrix@{H\+Matrix}!find\+\_\+row\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block@{find\+\_\+row\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block}}
\index{find\+\_\+row\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block@{find\+\_\+row\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{find\+\_\+row\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block()}{find\_row\_diag\_block\_for\_offdiag\_block()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::find\+\_\+row\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Find the diagonal block corresponding to the row block cluster of the current $\mathcal{H}$-\/matrix node which is assumed in the lower triangular part of the whole matrix.

{\bfseries The algorithm does not check internally whether the current $\mathcal{H}$-\/matrix node locates in the lower triangular part of the whole matrix. The user should ensure this presumption.}

\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
We make an assertion here that the current $\mathcal{H}$-\/matrix node should not be on the top level in the $\mathcal{H}$-\/matrix hierarchy.

According to the currently adopted tensor product way of constructing block clusters from clusters, the diagonal block can only be the first or last sibling of the current $\mathcal{H}$-\/matrix node. Therefore, when the current $\mathcal{H}$-\/matrix node\textquotesingle{}s {\ttfamily submatrix\+\_\+index} is 1 (2), we will directly check if the first (last) sibling is a diagonal block on a same row.

We should also note that if an off-\/diagonal block is split into sub-\/blocks and such case will occur when the fine non-\/tensor product partition is adopted, none of its submatrices are diagonal blocks, even though the {\ttfamily submatrix\+\_\+index} of which is 0 or 3.

When the first or last sibling of the current $\mathcal{H}$-\/matrix node is not a diagonal block, we will look for the corresponding diagonal block on a same row by first recursing back to the top level of the $\mathcal{H}$-\/matrix hierarchy then recursing forward to the current level.

When the current $\mathcal{H}$-\/matrix node is on the top level of the $\mathcal{H}$-\/matrix hierarchy, throw an error.

Check if the first sibling of the current $\mathcal{H}$-\/matrix node is a diagonal block. Such checking is performed via shallow comparison, i.\+e. compare the pointer addresses of $\tau$ and $\sigma$ clusters.


\begin{DoxyDescription}
\item[Note ]By default, the submatrices are organized in the following order. {\ttfamily  \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ 0 }&\textbf{ 1  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ 0 }&\textbf{ 1  }\\\cline{1-2}
\endhead
2 &3 \\\cline{1-2}
\end{longtabu}
} 
\end{DoxyDescription}

Go one recursion level up for further searching.

Check if the last (3rd) sibling of the current $\mathcal{H}$-\/matrix node is a diagonal block. Such checking is performed via shallow comparison, i.\+e. compare the pointer addresses of $\tau$ and $\sigma$ clusters.

Go one recursion level up for further searching.

Go one recursion level up for further searching.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::parent, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::submatrix\+\_\+index.



Referenced by main().

\mbox{\Hypertarget{classHMatrix_a9d914c27d4e990d476a4529b2daa64cd}\label{classHMatrix_a9d914c27d4e990d476a4529b2daa64cd}} 
\index{H\+Matrix@{H\+Matrix}!get\+\_\+fullmatrix@{get\+\_\+fullmatrix}}
\index{get\+\_\+fullmatrix@{get\+\_\+fullmatrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{get\+\_\+fullmatrix()}{get\_fullmatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ $\ast$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::get\+\_\+fullmatrix (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Get the pointer to the full matrix of the current $\mathcal{H}$-\/matrix node. \begin{DoxyReturn}{Returns}

\end{DoxyReturn}


References H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix.



Referenced by main().

\mbox{\Hypertarget{classHMatrix_aed550b5b41a64c6f1bbcde4f8f7eca91}\label{classHMatrix_aed550b5b41a64c6f1bbcde4f8f7eca91}} 
\index{H\+Matrix@{H\+Matrix}!get\+\_\+fullmatrix@{get\+\_\+fullmatrix}}
\index{get\+\_\+fullmatrix@{get\+\_\+fullmatrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{get\+\_\+fullmatrix()}{get\_fullmatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
const \hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$ Number $>$ $\ast$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::get\+\_\+fullmatrix (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the pointer to the full matrix of the current $\mathcal{H}$-\/matrix node (const version). \begin{DoxyReturn}{Returns}

\end{DoxyReturn}


References H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix.

\mbox{\Hypertarget{classHMatrix_ac5c9102fc04997c1ae3627185379d9bb}\label{classHMatrix_ac5c9102fc04997c1ae3627185379d9bb}} 
\index{H\+Matrix@{H\+Matrix}!get\+\_\+leaf\+\_\+set@{get\+\_\+leaf\+\_\+set}}
\index{get\+\_\+leaf\+\_\+set@{get\+\_\+leaf\+\_\+set}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{get\+\_\+leaf\+\_\+set()}{get\_leaf\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
std\+::vector$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ $>$ \& \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::get\+\_\+leaf\+\_\+set (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Get the reference to the leaf set of the current $\mathcal{H}$-\/matrix node. \begin{DoxyReturn}{Returns}

\end{DoxyReturn}


References H\+Matrix$<$ spacedim, Number $>$\+::leaf\+\_\+set.

\mbox{\Hypertarget{classHMatrix_a851d7bb3632bc1d18538d4d1dd5f6393}\label{classHMatrix_a851d7bb3632bc1d18538d4d1dd5f6393}} 
\index{H\+Matrix@{H\+Matrix}!get\+\_\+leaf\+\_\+set@{get\+\_\+leaf\+\_\+set}}
\index{get\+\_\+leaf\+\_\+set@{get\+\_\+leaf\+\_\+set}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{get\+\_\+leaf\+\_\+set()}{get\_leaf\_set()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
const std\+::vector$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ $>$ \& \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::get\+\_\+leaf\+\_\+set (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the reference to the leaf set of the current $\mathcal{H}$-\/matrix node (const version). \begin{DoxyReturn}{Returns}

\end{DoxyReturn}


References H\+Matrix$<$ spacedim, Number $>$\+::leaf\+\_\+set.

\mbox{\Hypertarget{classHMatrix_aabe735f7712a10ba5325ff116f8ca1c7}\label{classHMatrix_aabe735f7712a10ba5325ff116f8ca1c7}} 
\index{H\+Matrix@{H\+Matrix}!get\+\_\+m@{get\+\_\+m}}
\index{get\+\_\+m@{get\+\_\+m}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{get\+\_\+m()}{get\_m()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::\hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::get\+\_\+m (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the number of rows of the current $\mathcal{H}$-\/matrix node. \begin{DoxyReturn}{Returns}

\end{DoxyReturn}


References H\+Matrix$<$ spacedim, Number $>$\+::m.

\mbox{\Hypertarget{classHMatrix_abff89130116d62ea4159bc69ca11f8d5}\label{classHMatrix_abff89130116d62ea4159bc69ca11f8d5}} 
\index{H\+Matrix@{H\+Matrix}!get\+\_\+n@{get\+\_\+n}}
\index{get\+\_\+n@{get\+\_\+n}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{get\+\_\+n()}{get\_n()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::\hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::get\+\_\+n (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the number of columns of the current $\mathcal{H}$-\/matrix node. \begin{DoxyReturn}{Returns}

\end{DoxyReturn}


References H\+Matrix$<$ spacedim, Number $>$\+::n.

\mbox{\Hypertarget{classHMatrix_a0189de6e276fbd3425c4a7ef132f5e16}\label{classHMatrix_a0189de6e276fbd3425c4a7ef132f5e16}} 
\index{H\+Matrix@{H\+Matrix}!get\+\_\+rkmatrix@{get\+\_\+rkmatrix}}
\index{get\+\_\+rkmatrix@{get\+\_\+rkmatrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{get\+\_\+rkmatrix()}{get\_rkmatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ $\ast$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::get\+\_\+rkmatrix (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Get the pointer to the rank-\/k matrix of the current $\mathcal{H}$-\/matrix node. \begin{DoxyReturn}{Returns}

\end{DoxyReturn}


References H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix.



Referenced by main().

\mbox{\Hypertarget{classHMatrix_a64c81db6357d0e00b82fd523af001ae5}\label{classHMatrix_a64c81db6357d0e00b82fd523af001ae5}} 
\index{H\+Matrix@{H\+Matrix}!get\+\_\+rkmatrix@{get\+\_\+rkmatrix}}
\index{get\+\_\+rkmatrix@{get\+\_\+rkmatrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{get\+\_\+rkmatrix()}{get\_rkmatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
const \hyperlink{classRkMatrix}{Rk\+Matrix}$<$ Number $>$ $\ast$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::get\+\_\+rkmatrix (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the pointer to the rank-\/k matrix of the current $\mathcal{H}$-\/matrix node (const version). \begin{DoxyReturn}{Returns}

\end{DoxyReturn}


References H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix.

\mbox{\Hypertarget{classHMatrix_a0572b2c0484ce618db0034e3bc7988ed}\label{classHMatrix_a0572b2c0484ce618db0034e3bc7988ed}} 
\index{H\+Matrix@{H\+Matrix}!get\+\_\+submatrices@{get\+\_\+submatrices}}
\index{get\+\_\+submatrices@{get\+\_\+submatrices}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{get\+\_\+submatrices()}{get\_submatrices()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
std\+::vector$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ $>$ \& \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::get\+\_\+submatrices (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Get the reference to the vector of submatrices of the current $\mathcal{H}$-\/matrix node. \begin{DoxyReturn}{Returns}

\end{DoxyReturn}


References H\+Matrix$<$ spacedim, Number $>$\+::submatrices.



Referenced by main().

\mbox{\Hypertarget{classHMatrix_a8f8e9bc437ab86296d78950081ea34cd}\label{classHMatrix_a8f8e9bc437ab86296d78950081ea34cd}} 
\index{H\+Matrix@{H\+Matrix}!get\+\_\+submatrices@{get\+\_\+submatrices}}
\index{get\+\_\+submatrices@{get\+\_\+submatrices}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{get\+\_\+submatrices()}{get\_submatrices()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
const std\+::vector$<$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$ $>$ \& \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::get\+\_\+submatrices (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the reference to the vector of submatrices of the current $\mathcal{H}$-\/matrix node (const version). \begin{DoxyReturn}{Returns}

\end{DoxyReturn}


References H\+Matrix$<$ spacedim, Number $>$\+::submatrices.

\mbox{\Hypertarget{classHMatrix_aadea9fa59f420d22b3b1c939f6b573cc}\label{classHMatrix_aadea9fa59f420d22b3b1c939f6b573cc}} 
\index{H\+Matrix@{H\+Matrix}!get\+\_\+type@{get\+\_\+type}}
\index{get\+\_\+type@{get\+\_\+type}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{get\+\_\+type()}{get\_type()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494}{H\+Matrix\+Type} \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::get\+\_\+type (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Get the matrix type of the current $\mathcal{H}$-\/matrix node. \begin{DoxyReturn}{Returns}

\end{DoxyReturn}


References H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by main().

\mbox{\Hypertarget{classHMatrix_ab315324e3ece178943f406823f792746}\label{classHMatrix_ab315324e3ece178943f406823f792746}} 
\index{H\+Matrix@{H\+Matrix}!h\+\_\+h\+\_\+mmult\+\_\+cross\+\_\+split@{h\+\_\+h\+\_\+mmult\+\_\+cross\+\_\+split}}
\index{h\+\_\+h\+\_\+mmult\+\_\+cross\+\_\+split@{h\+\_\+h\+\_\+mmult\+\_\+cross\+\_\+split}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{h\+\_\+h\+\_\+mmult\+\_\+cross\+\_\+split()}{h\_h\_mmult\_cross\_split()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::h\+\_\+h\+\_\+mmult\+\_\+cross\+\_\+split (\begin{DoxyParamCaption}\item[{\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{bc\+\_\+tree }\end{DoxyParamCaption})}

This function implements {\ttfamily M\+M\+\_\+C} in Hackbusch\textquotesingle{}s $\mathcal{H}$-\/matrix book. Split the block cluster $b$ in $T_{\rm ind}$.

Append the initialized child to the list of submatrices of {\ttfamily M}.

Append the initialized child to the list of submatrices of {\ttfamily hmat}.

Append the initialized child to the list of submatrices of {\ttfamily M}.

Append the initialized child to the list of submatrices of {\ttfamily hmat}.

Iterate over each multiplication subtask.

Create $\mathcal{H}$-\/matrices corresponding to the child block clusters after splitting.

$\Sigma_{b_s(1)}^P := \Sigma_{b_s(1)}^P \cup \{[\tilde{M}_1(1), \tilde{M}_2(1)], [\tilde{M}_1(2), \tilde{M}_2(3)]\}$

$\Sigma_{b_s(2)}^P := \Sigma_{b_s(2)}^P \cup \{[\tilde{M}_1(1), \tilde{M}_2(2)], [\tilde{M}_1(2), \tilde{M}_2(4)]\}$

$\Sigma_{b_s(3)}^P := \Sigma_{b_s(3)}^P \cup \{[\tilde{M}_1(3), \tilde{M}_2(1)], [\tilde{M}_1(4), \tilde{M}_2(3)]\}$

$\Sigma_{b_s(4)}^P := \Sigma_{b_s(4)}^P \cup \{[\tilde{M}_1(3), \tilde{M}_2(2)], [\tilde{M}_1(4), \tilde{M}_2(4)]\}$

Remove the current $\mathcal{H}$-\/matrix pair from the list {\ttfamily Sigma\+\_\+P} of the current matrix node.

Remove the current $\mathcal{H}$-\/matrix pair from the list {\ttfamily Sigma\+\_\+P} of the current matrix node.

Update the matrix type of the current $\mathcal{H}$-\/matrix.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, and split\+\_\+block\+\_\+cluster\+\_\+node().

\mbox{\Hypertarget{classHMatrix_a38c88893c6ca784d4e56653d8b0e3e67}\label{classHMatrix_a38c88893c6ca784d4e56653d8b0e3e67}} 
\index{H\+Matrix@{H\+Matrix}!h\+\_\+h\+\_\+mmult\+\_\+horizontal\+\_\+split@{h\+\_\+h\+\_\+mmult\+\_\+horizontal\+\_\+split}}
\index{h\+\_\+h\+\_\+mmult\+\_\+horizontal\+\_\+split@{h\+\_\+h\+\_\+mmult\+\_\+horizontal\+\_\+split}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{h\+\_\+h\+\_\+mmult\+\_\+horizontal\+\_\+split()}{h\_h\_mmult\_horizontal\_split()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::h\+\_\+h\+\_\+mmult\+\_\+horizontal\+\_\+split (\begin{DoxyParamCaption}\item[{\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{bc\+\_\+tree }\end{DoxyParamCaption})}

This function implements {\ttfamily M\+M\+\_\+H} in Hackbusch\textquotesingle{}s $\mathcal{H}$-\/matrix book. Split the block cluster $b$ in $T_{\rm ind}$.

Append the initialized child to the list of submatrices of {\ttfamily M}.

Append the initialized child to the list of submatrices of {\ttfamily hmat}.

Iterate over each multiplication subtask.

Create $\mathcal{H}$-\/matrices corresponding to the child block clusters after splitting.

Remove the current $\mathcal{H}$-\/matrix pair from the list {\ttfamily Sigma\+\_\+P} of the current matrix node.

Remove the current $\mathcal{H}$-\/matrix pair from the list {\ttfamily Sigma\+\_\+P} of the current matrix node.

Update the matrix type of the current $\mathcal{H}$-\/matrix.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, and split\+\_\+block\+\_\+cluster\+\_\+node().

\mbox{\Hypertarget{classHMatrix_a168b6eea2e5b27528497850bf5ee2bbe}\label{classHMatrix_a168b6eea2e5b27528497850bf5ee2bbe}} 
\index{H\+Matrix@{H\+Matrix}!h\+\_\+h\+\_\+mmult\+\_\+reduction@{h\+\_\+h\+\_\+mmult\+\_\+reduction}}
\index{h\+\_\+h\+\_\+mmult\+\_\+reduction@{h\+\_\+h\+\_\+mmult\+\_\+reduction}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{h\+\_\+h\+\_\+mmult\+\_\+reduction()}{h\_h\_mmult\_reduction()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::h\+\_\+h\+\_\+mmult\+\_\+reduction (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Perform $\mathcal{H}$-\/matrix MM multiplication reduction. This is (7.\+21) in Hackbusch\textquotesingle{}s $\mathcal{H}$-\/matrix book. When one of the operands is either full matrix or rank-\/k matrix, perform direct multiplication.

Migrate the current H-\/matrix node pair to the list {\ttfamily Sigma\+\_\+\+P\+\_\+cannot\+\_\+reduced}.

Remove the current H-\/matrix node pair from the original list in {\ttfamily M}.

Merge the elements in {\ttfamily Sigma\+\_\+\+P\+\_\+cannot\+\_\+reduced} back to {\ttfamily Sigma\+\_\+P} in {\ttfamily M} for further processing.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, Full\+Matrix\+Type, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+P, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by h\+\_\+h\+\_\+mmult\+\_\+phase1\+\_\+recursion().

\mbox{\Hypertarget{classHMatrix_a253c23d09e89a9a37a7d808374b5ae4e}\label{classHMatrix_a253c23d09e89a9a37a7d808374b5ae4e}} 
\index{H\+Matrix@{H\+Matrix}!h\+\_\+h\+\_\+mmult\+\_\+vertical\+\_\+split@{h\+\_\+h\+\_\+mmult\+\_\+vertical\+\_\+split}}
\index{h\+\_\+h\+\_\+mmult\+\_\+vertical\+\_\+split@{h\+\_\+h\+\_\+mmult\+\_\+vertical\+\_\+split}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{h\+\_\+h\+\_\+mmult\+\_\+vertical\+\_\+split()}{h\_h\_mmult\_vertical\_split()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::h\+\_\+h\+\_\+mmult\+\_\+vertical\+\_\+split (\begin{DoxyParamCaption}\item[{\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{bc\+\_\+tree }\end{DoxyParamCaption})}

This function implements {\ttfamily M\+M\+\_\+V} in Hackbusch\textquotesingle{}s $\mathcal{H}$-\/matrix book. Split the block cluster $b$ in $T_{\rm ind}$.

Append the initialized child to the list of submatrices of {\ttfamily M}.

Append the initialized child to the list of submatrices of {\ttfamily hmat}.

Iterate over each multiplication subtask.

Create $\mathcal{H}$-\/matrices corresponding to the child block clusters after splitting.

Remove the current $\mathcal{H}$-\/matrix pair from the list {\ttfamily Sigma\+\_\+P} of the current matrix node.

Remove the current $\mathcal{H}$-\/matrix pair from the list {\ttfamily Sigma\+\_\+P} of the current matrix node.

Update the matrix type of the current $\mathcal{H}$-\/matrix.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, and split\+\_\+block\+\_\+cluster\+\_\+node().

\mbox{\Hypertarget{classHMatrix_af972cb62d436b8dca5d95a5b6e2ed964}\label{classHMatrix_af972cb62d436b8dca5d95a5b6e2ed964}} 
\index{H\+Matrix@{H\+Matrix}!invert\+\_\+by\+\_\+gauss\+\_\+elim@{invert\+\_\+by\+\_\+gauss\+\_\+elim}}
\index{invert\+\_\+by\+\_\+gauss\+\_\+elim@{invert\+\_\+by\+\_\+gauss\+\_\+elim}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{invert\+\_\+by\+\_\+gauss\+\_\+elim()}{invert\_by\_gauss\_elim()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::invert\+\_\+by\+\_\+gauss\+\_\+elim (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{M\+\_\+inv,  }\item[{const \hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type}}]{fixed\+\_\+rank\+\_\+k }\end{DoxyParamCaption})}

Calculate the inverse of the $\mathcal{H}$-\/matrix node via Gauss elimination by calling the recursive function \hyperlink{classHMatrix}{H\+Matrix}$<$spacedim, Number$>$\+::\+\_\+invert\+\_\+by\+\_\+gauss\+\_\+elim.


\begin{DoxyParams}{Parameters}
{\em M\+\_\+inv} & \\
\hline
{\em M\+\_\+root} & The $\mathcal{H}$-\/matrix node from which this recursive function is called for the first time. \\
\hline
{\em M\+\_\+root\+\_\+bct} & The block cluster tree associated with {\ttfamily M\+\_\+root}. \\
\hline
{\em fixed\+\_\+rank\+\_\+k} & \\
\hline
\end{DoxyParams}
Rebuild the leaf set of the current $\mathcal{H}$-\/matrix and its inverse.

References H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+invert\+\_\+by\+\_\+gauss\+\_\+elim(), and H\+Matrix$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set().



Referenced by main().

\mbox{\Hypertarget{classHMatrix_af40d53aabc8bec86fa543638d48ba64e}\label{classHMatrix_af40d53aabc8bec86fa543638d48ba64e}} 
\index{H\+Matrix@{H\+Matrix}!mmult@{mmult}}
\index{mmult@{mmult}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{mmult()}{mmult()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::mmult (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{C,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{B,  }\item[{const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{bct\+\_\+a,  }\item[{const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{bct\+\_\+b,  }\item[{\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{bct\+\_\+c,  }\item[{const unsigned int}]{fixed\+\_\+rank = {\ttfamily 1} }\end{DoxyParamCaption})}

Multiplication of two $\mathcal{H}$-\/matrices $C = A \cdot B$. 
\begin{DoxyParams}{Parameters}
{\em C} & \\
\hline
{\em B} & \\
\hline
{\em bct\+\_\+a} & \\
\hline
{\em bct\+\_\+b} & \\
\hline
{\em bct\+\_\+c} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}

\begin{DoxyDescription}
\item[Work flow ]


\begin{DoxyItemize}
\item Release the resource of the result matrix.


\item Initialize the induced block cluster tree $T_{\rm ind}$ for the result matrix with a single root node.


\item Associate with the root node of the induced block cluster tree $T_{\rm ind}$.


\item Perform recursive multiplication while constructing the induced block cluster tree $T_{\rm ind}$.


\item After the construction of the induced block cluster tree $T_{\rm ind}$, rebuild its leaf set as well as near field and far field sets, and update the tree depth and maximum level.

D\+E\+B\+UG\+: Print the structure of the $T_{\rm ind}$ block cluster tree.


\item Build the leaf set of the result matrix.

D\+E\+B\+UG\+: Print the structure of the $T_{\rm ind}$ block cluster tree.


\end{DoxyItemize}
\end{DoxyDescription}

References H\+Matrix$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), Tree\+Node$<$ T, N $>$\+::get\+\_\+data\+\_\+reference(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+n\+\_\+min(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+root(), H\+Matrix$<$ spacedim, Number $>$\+::release(), and H\+Matrix$<$ spacedim, Number $>$\+::\+Tind.



Referenced by main(), and H\+Matrix$<$ spacedim, Number $>$\+::mmult().

\mbox{\Hypertarget{classHMatrix_a4139e9069e3b18d4719c527ce2e0414c}\label{classHMatrix_a4139e9069e3b18d4719c527ce2e0414c}} 
\index{H\+Matrix@{H\+Matrix}!mmult@{mmult}}
\index{mmult@{mmult}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{mmult()}{mmult()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::mmult (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{C,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{B,  }\item[{const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{bct\+\_\+a,  }\item[{const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{bct\+\_\+b,  }\item[{\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{bct\+\_\+c,  }\item[{const unsigned int}]{fixed\+\_\+rank,  }\item[{const bool}]{adding }\end{DoxyParamCaption})}

Multiplication of two $\mathcal{H}$-\/matrices, the result of which will be appended to the target matrix {\ttfamily C}. 
\begin{DoxyParams}{Parameters}
{\em C} & \\
\hline
{\em B} & \\
\hline
{\em bct\+\_\+a} & \\
\hline
{\em bct\+\_\+b} & \\
\hline
{\em bct\+\_\+c} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
{\em adding} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::add(), and H\+Matrix$<$ spacedim, Number $>$\+::mmult().

\mbox{\Hypertarget{classHMatrix_a4ea0317bff2670e3ed7e48416f908873}\label{classHMatrix_a4ea0317bff2670e3ed7e48416f908873}} 
\index{H\+Matrix@{H\+Matrix}!mmult\+\_\+level\+\_\+conserving@{mmult\+\_\+level\+\_\+conserving}}
\index{mmult\+\_\+level\+\_\+conserving@{mmult\+\_\+level\+\_\+conserving}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{mmult\+\_\+level\+\_\+conserving()}{mmult\_level\_conserving()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::mmult\+\_\+level\+\_\+conserving (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{C,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{B,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

Level conserving $\mathcal{H}$-\/matrix multiplication, the result of which will be appended to the target matrix {\ttfamily C}, i.\+e. $C = C + AB$.


\begin{DoxyParams}{Parameters}
{\em C} & \\
\hline
{\em B} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}


Referenced by main().

\mbox{\Hypertarget{classHMatrix_aefdb7dbcff58654f53a149b94e545bf7}\label{classHMatrix_aefdb7dbcff58654f53a149b94e545bf7}} 
\index{H\+Matrix@{H\+Matrix}!mmult\+\_\+level\+\_\+conserving@{mmult\+\_\+level\+\_\+conserving}}
\index{mmult\+\_\+level\+\_\+conserving@{mmult\+\_\+level\+\_\+conserving}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{mmult\+\_\+level\+\_\+conserving()}{mmult\_level\_conserving()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::mmult\+\_\+level\+\_\+conserving (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{C,  }\item[{const Number}]{alpha,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{B,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

Level conserving $\mathcal{H}$-\/matrix multiplication with a factored multiplied to the matrix product, the result of which will be appended to the target matrix {\ttfamily C}, i.\+e. $C = C + \alpha \cdot A B$.


\begin{DoxyParams}{Parameters}
{\em C} & \\
\hline
{\em alpha} & \\
\hline
{\em B} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classHMatrix_a0b7fe2940b614a130d154a29b28b39d4}\label{classHMatrix_a0b7fe2940b614a130d154a29b28b39d4}} 
\index{H\+Matrix@{H\+Matrix}!m\+Tmult\+\_\+level\+\_\+conserving@{m\+Tmult\+\_\+level\+\_\+conserving}}
\index{m\+Tmult\+\_\+level\+\_\+conserving@{m\+Tmult\+\_\+level\+\_\+conserving}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{m\+Tmult\+\_\+level\+\_\+conserving()}{mTmult\_level\_conserving()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::m\+Tmult\+\_\+level\+\_\+conserving (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{C,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{B,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

Level conserving $\mathcal{H}$-\/matrix multiplication with the second operand being transposed, the result of which will be appended to the target matrix {\ttfamily C}, i.\+e. $C = C + \alpha \cdot A B^T$.


\begin{DoxyParams}{Parameters}
{\em C} & \\
\hline
{\em B} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}


Referenced by main().

\mbox{\Hypertarget{classHMatrix_aae163c33fc8d51f96df712ca192e0b6f}\label{classHMatrix_aae163c33fc8d51f96df712ca192e0b6f}} 
\index{H\+Matrix@{H\+Matrix}!m\+Tmult\+\_\+level\+\_\+conserving@{m\+Tmult\+\_\+level\+\_\+conserving}}
\index{m\+Tmult\+\_\+level\+\_\+conserving@{m\+Tmult\+\_\+level\+\_\+conserving}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{m\+Tmult\+\_\+level\+\_\+conserving()}{mTmult\_level\_conserving()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::m\+Tmult\+\_\+level\+\_\+conserving (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{C,  }\item[{const Number}]{alpha,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{B,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

Level conserving $\mathcal{H}$-\/matrix multiplication with the second operand being transposed, the result of which will be multiplied by a factor and then appended to the target matrix {\ttfamily C}, i.\+e. $C = C + \alpha \cdot A B^T$.


\begin{DoxyParams}{Parameters}
{\em C} & \\
\hline
{\em alpha} & \\
\hline
{\em B} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classHMatrix_a2c72ede65323af5b57a6b16f5774de50}\label{classHMatrix_a2c72ede65323af5b57a6b16f5774de50}} 
\index{H\+Matrix@{H\+Matrix}!operator=@{operator=}}
\index{operator=@{operator=}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \& \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::operator= (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&\&}]{H }\end{DoxyParamCaption})}

Assignment via shallow copy.


\begin{DoxyParams}{Parameters}
{\em H} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


References H\+Matrix$<$ spacedim, Number $>$\+::release().

\mbox{\Hypertarget{classHMatrix_a83958971f40409b3b2a192b71eae1513}\label{classHMatrix_a83958971f40409b3b2a192b71eae1513}} 
\index{H\+Matrix@{H\+Matrix}!operator=@{operator=}}
\index{operator=@{operator=}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \& \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::operator= (\begin{DoxyParamCaption}\item[{const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{H }\end{DoxyParamCaption})}

Assignment via deep copy.


\begin{DoxyParams}{Parameters}
{\em H} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


References H\+Matrix$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), and H\+Matrix$<$ spacedim, Number $>$\+::release().

\mbox{\Hypertarget{classHMatrix_aab0c393acf1c416ebc7ab05ca85d9e49}\label{classHMatrix_aab0c393acf1c416ebc7ab05ca85d9e49}} 
\index{H\+Matrix@{H\+Matrix}!print\+\_\+current\+\_\+matrix\+\_\+info@{print\+\_\+current\+\_\+matrix\+\_\+info}}
\index{print\+\_\+current\+\_\+matrix\+\_\+info@{print\+\_\+current\+\_\+matrix\+\_\+info}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{print\+\_\+current\+\_\+matrix\+\_\+info()}{print\_current\_matrix\_info()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::print\+\_\+current\+\_\+matrix\+\_\+info (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out }\end{DoxyParamCaption}) const}

Print the current $\mathcal{H}$-\/matrix node information.


\begin{DoxyParams}{Parameters}
{\em out} & \\
\hline
\end{DoxyParams}
Print the size of $\Sigma_b^P$, $\Sigma_b^R$ and $\Sigma_b^F$.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::parent, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+F, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+P, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+R, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::submatrix\+\_\+index.



Referenced by main(), and H\+Matrix$<$ spacedim, Number $>$\+::print\+\_\+matrix\+\_\+info().

\mbox{\Hypertarget{classHMatrix_a7e849f7e8f35e3ebdfcb2dbb7ad4ad01}\label{classHMatrix_a7e849f7e8f35e3ebdfcb2dbb7ad4ad01}} 
\index{H\+Matrix@{H\+Matrix}!print\+\_\+formatted@{print\+\_\+formatted}}
\index{print\+\_\+formatted@{print\+\_\+formatted}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{print\+\_\+formatted()}{print\_formatted()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::print\+\_\+formatted (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out,  }\item[{const unsigned int}]{precision = {\ttfamily 3},  }\item[{const bool}]{scientific = {\ttfamily true},  }\item[{const unsigned int}]{width = {\ttfamily 0},  }\item[{const char $\ast$}]{zero\+\_\+string = {\ttfamily \char`\"{}~\char`\"{}},  }\item[{const double}]{denominator = {\ttfamily 1.},  }\item[{const double}]{threshold = {\ttfamily 0.} }\end{DoxyParamCaption}) const}

Print the $\mathcal{H}$-\/matrix data.


\begin{DoxyParams}{Parameters}
{\em out} & \\
\hline
{\em precision} & \\
\hline
{\em scientific} & \\
\hline
{\em width} & \\
\hline
{\em zero\+\_\+string} & \\
\hline
{\em denominator} & \\
\hline
{\em threshold} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.



Referenced by main().

\mbox{\Hypertarget{classHMatrix_ad8f87883cf49080706233441c0e09171}\label{classHMatrix_ad8f87883cf49080706233441c0e09171}} 
\index{H\+Matrix@{H\+Matrix}!print\+\_\+matrix\+\_\+info@{print\+\_\+matrix\+\_\+info}}
\index{print\+\_\+matrix\+\_\+info@{print\+\_\+matrix\+\_\+info}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{print\+\_\+matrix\+\_\+info()}{print\_matrix\_info()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::print\+\_\+matrix\+\_\+info (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out }\end{DoxyParamCaption}) const}

Print the $\mathcal{H}$-\/matrix hierarchy information.


\begin{DoxyParams}{Parameters}
{\em out} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::print\+\_\+current\+\_\+matrix\+\_\+info(), and H\+Matrix$<$ spacedim, Number $>$\+::submatrices.



Referenced by main().

\mbox{\Hypertarget{classHMatrix_ae904288a7e0ac82d9fd2364b1c150bc2}\label{classHMatrix_ae904288a7e0ac82d9fd2364b1c150bc2}} 
\index{H\+Matrix@{H\+Matrix}!print\+\_\+matrix\+\_\+info\+\_\+as\+\_\+dot@{print\+\_\+matrix\+\_\+info\+\_\+as\+\_\+dot}}
\index{print\+\_\+matrix\+\_\+info\+\_\+as\+\_\+dot@{print\+\_\+matrix\+\_\+info\+\_\+as\+\_\+dot}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{print\+\_\+matrix\+\_\+info\+\_\+as\+\_\+dot()}{print\_matrix\_info\_as\_dot()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::print\+\_\+matrix\+\_\+info\+\_\+as\+\_\+dot (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out }\end{DoxyParamCaption}) const}

Print the $\mathcal{H}$-\/matrix hierarchy information as directional graph in Graphviz dot format.


\begin{DoxyParams}{Parameters}
{\em out} & \\
\hline
\end{DoxyParams}
Write the header of the Graphviz dot file.

Define the node style.

Add comment nodes.

Finalize the Graphviz dot file.

References H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+print\+\_\+matrix\+\_\+info\+\_\+as\+\_\+dot\+\_\+node().



Referenced by main().

\mbox{\Hypertarget{classHMatrix_ad2b353962226c78910d6ddb6b5b8e460}\label{classHMatrix_ad2b353962226c78910d6ddb6b5b8e460}} 
\index{H\+Matrix@{H\+Matrix}!refine\+\_\+to\+\_\+supertree@{refine\+\_\+to\+\_\+supertree}}
\index{refine\+\_\+to\+\_\+supertree@{refine\+\_\+to\+\_\+supertree}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{refine\+\_\+to\+\_\+supertree()}{refine\_to\_supertree()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::refine\+\_\+to\+\_\+supertree (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Refine the current $\mathcal{H}$-\/matrix, whose associated block cluster tree has been extended. The operation has no accuracy loss.

This member function implements the operator $\mathcal{T}_{P' \leftarrow P}^{\mathcal{H} \leftarrow \mathcal{H}}$ for the case $T(I \times J, P') \supset T(I \times J, P)$ in (7.\+9) in Hackbusch\textquotesingle{}s $\mathcal{H}$-\/matrix book. Because there is no internal check about this, users should ensure that the original block cluster tree associated with this $\mathcal{H}$-\/matrix hierarchy has really been extended. 
\begin{DoxyDescription}
\item[Work flow ]

Iterate over the leaf set of the $\mathcal{H}$-\/matrix hierarchy.

Refine from the current $\mathcal{H}$-\/matrix leaf node.

After the refinement operation, we check the number of child matrices of the current $\mathcal{H}$-\/matrix leaf node.

If the current $\mathcal{H}$-\/matrix leaf node has a non-\/empty collection of submatrices, it has really been refined. Then delete its originally associated matrix data, either a full matrix or a rank-\/k matrix, and modify its matrix type as {\ttfamily Hierarchical\+Matrix\+Type}.

After the refinement operation for all the leaf nodes of the original $\mathcal{H}$-\/matrix hierarchy finishes, rebuild the leaf set of the new $\mathcal{H}$-\/matrix hierarchy.


\end{DoxyDescription}

References H\+Matrix$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::leaf\+\_\+set, and Rk\+Matrix\+Type.



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::convert\+\_\+between\+\_\+different\+\_\+block\+\_\+cluster\+\_\+trees(), and main().

\mbox{\Hypertarget{classHMatrix_a83f804163e1695cfb952ddb6b0df2503}\label{classHMatrix_a83f804163e1695cfb952ddb6b0df2503}} 
\index{H\+Matrix@{H\+Matrix}!reinit@{reinit}}
\index{reinit@{reinit}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{reinit()}{reinit()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::reinit (\begin{DoxyParamCaption}\item[{const \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$ \&}]{bct,  }\item[{const unsigned int}]{fixed\+\_\+rank\+\_\+k = {\ttfamily 1} }\end{DoxyParamCaption})}

Reinitialize the hierarchical structure without data from the root node of a \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}. 
\begin{DoxyParams}{Parameters}
{\em bct} & \\
\hline
{\em fixed\+\_\+rank\+\_\+k} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), Block\+Cluster\+Tree$<$ spacedim, Number $>$\+::get\+\_\+root(), and H\+Matrix$<$ spacedim, Number $>$\+::release().

\mbox{\Hypertarget{classHMatrix_a41d20c1839f3d7a756107b8e4defea0b}\label{classHMatrix_a41d20c1839f3d7a756107b8e4defea0b}} 
\index{H\+Matrix@{H\+Matrix}!reinit@{reinit}}
\index{reinit@{reinit}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{reinit()}{reinit()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::reinit (\begin{DoxyParamCaption}\item[{typename \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$ spacedim, Number $>$\+::node\+\_\+const\+\_\+pointer\+\_\+type}]{bc\+\_\+node,  }\item[{const unsigned int}]{fixed\+\_\+rank\+\_\+k = {\ttfamily 1} }\end{DoxyParamCaption})}

Reinitialize the hierarchical structure without data from a \hyperlink{classTreeNode}{Tree\+Node} in a \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}. 
\begin{DoxyParams}{Parameters}
{\em bc\+\_\+node} & \\
\hline
{\em fixed\+\_\+rank\+\_\+k} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), and H\+Matrix$<$ spacedim, Number $>$\+::release().

\mbox{\Hypertarget{classHMatrix_a812e8276888b2ad866edf7ce9b286839}\label{classHMatrix_a812e8276888b2ad866edf7ce9b286839}} 
\index{H\+Matrix@{H\+Matrix}!release@{release}}
\index{release@{release}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{release()}{release()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::release (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

T\+O\+DO\+: Construct from a \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree} and a Sauter quadrature object/functor. Release the memory and status of the $\mathcal{H}$-\/matrix hierarchy. The deletion of {\ttfamily submatrix} will call the destructor of this sub-\/\+H\+Matrix, which will further recursively call the destructor of the submatrices of this sub-\/\+H\+Matrix. Hence, this destructor is intrinsically recursive.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, H\+Matrix$<$ spacedim, Number $>$\+::leaf\+\_\+set, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::parent, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+F, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+P, H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+R, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::submatrix\+\_\+index, H\+Matrix$<$ spacedim, Number $>$\+::submatrix\+\_\+index\+\_\+invalid, H\+Matrix$<$ spacedim, Number $>$\+::\+Tind, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::mmult(), H\+Matrix$<$ spacedim, Number $>$\+::operator=(), H\+Matrix$<$ spacedim, Number $>$\+::reinit(), and H\+Matrix$<$ spacedim, Number $>$\+::$\sim$\+H\+Matrix().

\mbox{\Hypertarget{classHMatrix_a9e023f39b1f8916117a63557895a91b4}\label{classHMatrix_a9e023f39b1f8916117a63557895a91b4}} 
\index{H\+Matrix@{H\+Matrix}!remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list@{remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list}}
\index{remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list@{remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list()}{remove\_hmat\_pair\_from\_mm\_product\_list()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list (\begin{DoxyParamCaption}\item[{const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{M1,  }\item[{const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$}]{M2 }\end{DoxyParamCaption})}

Remove a pair of $\mathcal{H}$-\/matrix nodes from the list of matrix-\/matrix product subtasks to be performed, i.\+e. from the list {\ttfamily \hyperlink{classHMatrix_a3d96d0252ef8c873ae06cf87874acaf3}{H\+Matrix\+::\+Sigma\+\_\+P}}. 

References H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+P.



Referenced by f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), h\+\_\+rk\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), and rk\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult().

\mbox{\Hypertarget{classHMatrix_ae0ab9b3be4ea0ef959da40e81313b2e3}\label{classHMatrix_ae0ab9b3be4ea0ef959da40e81313b2e3}} 
\index{H\+Matrix@{H\+Matrix}!remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list@{remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list}}
\index{remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list@{remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list()}{remove\_hmat\_pair\_from\_mm\_product\_list()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list (\begin{DoxyParamCaption}\item[{const std\+::pair$<$ const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$, const \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ $\ast$$>$ \&}]{hmat\+\_\+pair }\end{DoxyParamCaption})}

Remove a pair of $\mathcal{H}$-\/matrix nodes from the list of matrix-\/matrix product subtasks to be performed, i.\+e. from the list {\ttfamily \hyperlink{classHMatrix_a3d96d0252ef8c873ae06cf87874acaf3}{H\+Matrix\+::\+Sigma\+\_\+P}}. 

References H\+Matrix$<$ spacedim, Number $>$\+::\+Sigma\+\_\+P.

\mbox{\Hypertarget{classHMatrix_aa81db0ff79182302de83d693bab9f9e3}\label{classHMatrix_aa81db0ff79182302de83d693bab9f9e3}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution}}
\index{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution()}{solve\_block\_triangular\_by\_backward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{b,  }\item[{const bool}]{is\+\_\+unit\+\_\+block\+\_\+diagonal = {\ttfamily false} }\end{DoxyParamCaption}) const}

Solve the block upper triangular matrix $Ux=b$ by backward substitution.

Being different from the version for solving triangular $\mathcal{H}$-\/matrix,


\begin{DoxyEnumerate}
\item when the block upper triangular matrix is unit, its diagonal blocks in the leaf set, which must be in the full matrix format, should be an identity matrix, i.\+e. $L\vert_{\tau\times\tau} = I$ for $\tau\times\tau \in P$. In this case, there is no need to actually solve it.
\item when the block upper triangular matrix is not unit, its diagonal blocks in the leaf set should be full matrices. In this case, a general linear system solver should be adopted to solve it.
\end{DoxyEnumerate}

{\bfseries Even though the member variables of the current class will be not be modified, the actual heap memory data related to full matrix in the leaf set will be changed, since LU factorization will be performed.}


\begin{DoxyParams}{Parameters}
{\em b} & \\
\hline
{\em is\+\_\+unit\+\_\+diagonal} & \\
\hline
\end{DoxyParams}
The current $\mathcal{H}$-\/matrix node should be square.

When the current $\mathcal{H}$-\/matrix node belongs to the leaf set, it must be a full matrix and can be solved via LU factorization.

In this case, the diagonal block in the leaf set should be an identity matrix, the solution {\ttfamily x} is the same as the right hand side vector {\ttfamily b}, so here we do nothing.

In this case, the diagonal block in the leaf set should be general full matrix and forward substitution cannot be applied any more. Instead, LU factorization is adopted.

Restrict vector {\ttfamily b} to the column cluster of the current $\mathcal{H}$-\/matrix node.

Solve the full matrix using LU factorization.

Copy back the restricted vector {\ttfamily local\+\_\+b} to the original vector {\ttfamily b}.

Iterate over each block row of the matrix.

Iterate each block column after the i\textquotesingle{}th column, i.\+e. after the diagonal submatrix block.

Solve the current diagonal block using backward substitution.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by main(), and H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution().

\mbox{\Hypertarget{classHMatrix_a69432f004b60ade76aaabf2c94dd205c}\label{classHMatrix_a69432f004b60ade76aaabf2c94dd205c}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution}}
\index{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution()}{solve\_block\_triangular\_by\_backward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{x,  }\item[{const Vector$<$ Number $>$ \&}]{b,  }\item[{const bool}]{is\+\_\+unit\+\_\+block\+\_\+diagonal = {\ttfamily false} }\end{DoxyParamCaption}) const}

Solve the block upper triangular matrix $Lx=b$ by backward substitution.

Refer to {\ttfamily solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution}( Vector$<$\+Number$>$ \&b, const bool is\+\_\+unit\+\_\+block\+\_\+diagonal = false) const.


\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
{\em b} & \\
\hline
{\em is\+\_\+unit\+\_\+block\+\_\+diagonal} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution().

\mbox{\Hypertarget{classHMatrix_ab8b64d4a5b7120a2599ec3e3e0708775}\label{classHMatrix_ab8b64d4a5b7120a2599ec3e3e0708775}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution}}
\index{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution()}{solve\_block\_triangular\_by\_forward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{b,  }\item[{const bool}]{is\+\_\+unit\+\_\+block\+\_\+diagonal = {\ttfamily true} }\end{DoxyParamCaption}) const}

Solve the block lower triangular matrix $Lx=b$ by forward substitution.

Being different from the version for solving triangular $\mathcal{H}$-\/matrix,


\begin{DoxyEnumerate}
\item when the block lower triangular matrix is unit, its diagonal blocks in the leaf set, which must be in the full matrix format, should be an identity matrix, i.\+e. $L\vert_{\tau\times\tau} = I$ for $\tau\times\tau \in P$. In this case, there is no need to actually solve it.
\item when the block lower triangular matrix is not unit, its diagonal blocks in the leaf set should be full matrices. In this case, a general linear system solver should be adopted to solve it.
\end{DoxyEnumerate}

{\bfseries Even though the member variables of the current class will be not be modified, the actual heap memory data related to full matrix in the leaf set will be changed, since LU factorization will be performed.}


\begin{DoxyParams}{Parameters}
{\em b} & \\
\hline
{\em is\+\_\+unit\+\_\+diagonal} & \\
\hline
\end{DoxyParams}
The current $\mathcal{H}$-\/matrix node should be square.

When the current $\mathcal{H}$-\/matrix node belongs to the leaf set, it must be a full matrix and can be solved via LU factorization.

In this case, the diagonal block in the leaf set should be an identity matrix, the solution {\ttfamily x} is the same as the right hand side vector {\ttfamily b}, so here we do nothing.

In this case, the diagonal block in the leaf set should be general full matrix and forward substitution cannot be applied any more. Instead, LU factorization is adopted.

Restrict vector {\ttfamily b} to the column cluster of the current $\mathcal{H}$-\/matrix node.

Solve the full matrix using LU factorization.

Copy back the restricted vector {\ttfamily local\+\_\+b} to the original vector {\ttfamily b}.

Iterate over each block row of the matrix.

Iterate each block column before the i\textquotesingle{}th column, i.\+e. before the diagonal submatrix block.

Solve the current diagonal block using forward substitution.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by main(), and H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution().

\mbox{\Hypertarget{classHMatrix_aa8046a87be454c81d4a884b53150685a}\label{classHMatrix_aa8046a87be454c81d4a884b53150685a}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution}}
\index{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution()}{solve\_block\_triangular\_by\_forward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{x,  }\item[{const Vector$<$ Number $>$ \&}]{b,  }\item[{const bool}]{is\+\_\+unit\+\_\+block\+\_\+diagonal = {\ttfamily true} }\end{DoxyParamCaption}) const}

Solve the block lower triangular matrix $Lx=b$ by forward substitution.

Refer to {\ttfamily solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution}( Vector$<$\+Number$>$ \&b, const bool is\+\_\+unit\+\_\+block\+\_\+diagonal = false) const.


\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
{\em b} & \\
\hline
{\em is\+\_\+unit\+\_\+block\+\_\+diagonal} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution().

\mbox{\Hypertarget{classHMatrix_ac7231b00a53ef6b860d774d1daad738f}\label{classHMatrix_ac7231b00a53ef6b860d774d1daad738f}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+by\+\_\+backward\+\_\+substitution}}
\index{solve\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+by\+\_\+backward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+by\+\_\+backward\+\_\+substitution()}{solve\_by\_backward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+backward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{b,  }\item[{const bool}]{is\+\_\+unit\+\_\+diagonal = {\ttfamily false} }\end{DoxyParamCaption}) const}

Solve the upper triangular matrix $Ux=b$ by backward substitution.

The right hand side vector $b$ will be overwritten by the solution vector $x$.


\begin{DoxyParams}{Parameters}
{\em b} & Right hand side vector and after execution, it stores the result vector. \\
\hline
\end{DoxyParams}
The current $\mathcal{H}$-\/matrix node should be square.

When the current $\mathcal{H}$-\/matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via backward substitution.

Restrict vector {\ttfamily b} to the column cluster of the current $\mathcal{H}$-\/matrix node.

Perform backward substitution for the full matrix.

Copy back the restricted vector {\ttfamily local\+\_\+b} to the original vector {\ttfamily b}.

Iterate over each block row of the matrix.

Iterate each block column after the i\textquotesingle{}th column, i.\+e. after the diagonal submatrix block.

Solve the current diagonal block using backward substitution.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by main(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+backward\+\_\+substitution(), and H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+lu().

\mbox{\Hypertarget{classHMatrix_ab89582b86090d18d33f7ae04deda1f5f}\label{classHMatrix_ab89582b86090d18d33f7ae04deda1f5f}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+by\+\_\+backward\+\_\+substitution}}
\index{solve\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+by\+\_\+backward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+by\+\_\+backward\+\_\+substitution()}{solve\_by\_backward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+backward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{x,  }\item[{const Vector$<$ Number $>$ \&}]{b,  }\item[{const bool}]{is\+\_\+unit\+\_\+diagonal = {\ttfamily false} }\end{DoxyParamCaption}) const}

Solve the upper triangular matrix $Ux=b$ by backward substitution.


\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
{\em b} & \\
\hline
{\em is\+\_\+unit\+\_\+diagonal} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+backward\+\_\+substitution().

\mbox{\Hypertarget{classHMatrix_aedc13c9cf448ec8b47147053d02f357b}\label{classHMatrix_aedc13c9cf448ec8b47147053d02f357b}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+by\+\_\+backward\+\_\+substitution}}
\index{solve\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+by\+\_\+backward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+by\+\_\+backward\+\_\+substitution()}{solve\_by\_backward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+backward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{b,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map,  }\item[{const bool}]{is\+\_\+unit\+\_\+diagonal = {\ttfamily false} }\end{DoxyParamCaption}) const}

Solve the upper triangular matrix $Ux=b$ by backward substitution.

The right hand side vector $b$ will be overwritten by the solution vector $x$.

{\bfseries The vector {\ttfamily b} is to be accessed via local indices with the assistance of {\ttfamily vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}.}


\begin{DoxyParams}{Parameters}
{\em b} & Right hand side vector and after execution, it stores the result vector. \\
\hline
\end{DoxyParams}
The current $\mathcal{H}$-\/matrix node should be square.

When the current $\mathcal{H}$-\/matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via backward substitution.

Restrict vector {\ttfamily b} to the column cluster of the current $\mathcal{H}$-\/matrix node.

Perform backward substitution for the full matrix.

Copy back the restricted vector {\ttfamily local\+\_\+b} to the original vector {\ttfamily b}.

Iterate over each block row of the matrix.

Iterate each block column after the i\textquotesingle{}th column, i.\+e. after the diagonal submatrix block.

Solve the current diagonal block using backward substitution.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{classHMatrix_aa90525e857add22b334bac84e6baacd2}\label{classHMatrix_aa90525e857add22b334bac84e6baacd2}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+by\+\_\+backward\+\_\+substitution}}
\index{solve\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+by\+\_\+backward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+by\+\_\+backward\+\_\+substitution()}{solve\_by\_backward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+backward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{x,  }\item[{const Vector$<$ Number $>$ \&}]{b,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map,  }\item[{const bool}]{is\+\_\+unit\+\_\+diagonal = {\ttfamily false} }\end{DoxyParamCaption}) const}

Solve the upper triangular matrix $Ux=b$ by backward substitution.

{\bfseries The vectors {\ttfamily x} and {\ttfamily b} are to be accessed via local indices with the assistance of {\ttfamily vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}.}


\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
{\em b} & \\
\hline
{\em is\+\_\+unit\+\_\+diagonal} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+backward\+\_\+substitution().

\mbox{\Hypertarget{classHMatrix_aeee2443c3f85cd6a961e77e5287e43f9}\label{classHMatrix_aeee2443c3f85cd6a961e77e5287e43f9}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+by\+\_\+forward\+\_\+substitution}}
\index{solve\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+by\+\_\+forward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+by\+\_\+forward\+\_\+substitution()}{solve\_by\_forward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{b,  }\item[{const bool}]{is\+\_\+unit\+\_\+diagonal = {\ttfamily true} }\end{DoxyParamCaption}) const}

Solve the lower triangular matrix $Lx=b$ by forward substitution.

The right hand side vector $b$ will be overwritten by the solution vector $x$.

{\bfseries The vector {\ttfamily b} is accessed directly by using the DoF index stored in clusters.}


\begin{DoxyParams}{Parameters}
{\em b} & Right hand side global vector. After execution, it stores the result vector. \\
\hline
\end{DoxyParams}
The current $\mathcal{H}$-\/matrix node should be square.

When the current $\mathcal{H}$-\/matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via forward substitution.

Restrict vector {\ttfamily b} to the column cluster of the current $\mathcal{H}$-\/matrix node.

Perform forward substitution for the full matrix. N.\+B. The right hand side vector should be permuted if the current lower triangular matrix is obtained from the row pivoted LU factorization.

Copy back the restricted vector {\ttfamily local\+\_\+b} to the original vector {\ttfamily b}.

Iterate over each block row of the matrix.

Iterate each block column before the i\textquotesingle{}th column, i.\+e. before the diagonal submatrix block.

Solve the current diagonal block using forward substitution.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by main(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), and H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+lu().

\mbox{\Hypertarget{classHMatrix_a4c226aaa96ad7b1a7f0c1507d43bba89}\label{classHMatrix_a4c226aaa96ad7b1a7f0c1507d43bba89}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+by\+\_\+forward\+\_\+substitution}}
\index{solve\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+by\+\_\+forward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+by\+\_\+forward\+\_\+substitution()}{solve\_by\_forward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{x,  }\item[{const Vector$<$ Number $>$ \&}]{b,  }\item[{const bool}]{is\+\_\+unit\+\_\+diagonal = {\ttfamily true} }\end{DoxyParamCaption}) const}

Solve the lower triangular matrix $Lx=b$ by forward substitution.

{\bfseries The vectors {\ttfamily b} and {\ttfamily x} are accessed directly by using the DoF index stored in clusters.}


\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
{\em b} & Right hand side global vector. \\
\hline
{\em is\+\_\+unit\+\_\+diagonal} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution().

\mbox{\Hypertarget{classHMatrix_a898ed2cdcb0351a6a9b57251320b5d1d}\label{classHMatrix_a898ed2cdcb0351a6a9b57251320b5d1d}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+by\+\_\+forward\+\_\+substitution}}
\index{solve\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+by\+\_\+forward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+by\+\_\+forward\+\_\+substitution()}{solve\_by\_forward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{b,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map,  }\item[{const bool}]{is\+\_\+unit\+\_\+diagonal = {\ttfamily true} }\end{DoxyParamCaption}) const}

Solve the lower triangular matrix $Lx=b$ by forward substitution.

The right hand side vector $b$ will be overwritten by the solution vector $x$.

{\bfseries The vector {\ttfamily b} is to be accessed via local indices with the assistance of {\ttfamily vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}.}


\begin{DoxyParams}{Parameters}
{\em b} & Right hand side vector and after execution, it stores the result vector. \\
\hline
\end{DoxyParams}
The current $\mathcal{H}$-\/matrix node should be square.

When the current $\mathcal{H}$-\/matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via forward substitution.

Restrict vector {\ttfamily b} to the column cluster of the current $\mathcal{H}$-\/matrix node.

Perform forward substitution for the full matrix. N.\+B. The right hand side vector should be permuted if the current lower triangular matrix is obtained from the row pivoted LU factorization.

Copy back the restricted vector {\ttfamily local\+\_\+b} to the original vector {\ttfamily b}.

Iterate over each block row of the matrix.

Iterate each block column before the i\textquotesingle{}th column, i.\+e. before the diagonal submatrix block.

Solve the current diagonal block using forward substitution.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{classHMatrix_a5ddd48bc33e45d0b4221416cbb039cc3}\label{classHMatrix_a5ddd48bc33e45d0b4221416cbb039cc3}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+by\+\_\+forward\+\_\+substitution}}
\index{solve\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+by\+\_\+forward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+by\+\_\+forward\+\_\+substitution()}{solve\_by\_forward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{x,  }\item[{const Vector$<$ Number $>$ \&}]{b,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map,  }\item[{const bool}]{is\+\_\+unit\+\_\+diagonal = {\ttfamily true} }\end{DoxyParamCaption}) const}

Solve the lower triangular matrix $Lx=b$ by forward substitution.

{\bfseries The vectors {\ttfamily x} and {\ttfamily b} are to be accessed via local indices with the assistance of {\ttfamily vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}.}


\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
{\em b} & \\
\hline
{\em is\+\_\+unit\+\_\+diagonal} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution().

\mbox{\Hypertarget{classHMatrix_a20fa0ad9c55bb5225440ccab58608cf8}\label{classHMatrix_a20fa0ad9c55bb5225440ccab58608cf8}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued@{solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued}}
\index{solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued@{solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued()}{solve\_by\_forward\_substitution\_matrix\_valued()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{X,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{Z,  }\item[{const unsigned int}]{fixed\+\_\+rank,  }\item[{const bool}]{is\+\_\+unit\+\_\+diagonal = {\ttfamily true} }\end{DoxyParamCaption})}

Solve the matrix-\/valued problem $L\vert_{\tau\times\tau}X\vert_{\tau\times\sigma}=Z\vert_{\tau\times\sigma}$ using forward substitution.

{\bfseries The problem to be solved is restricted to specific block clusters. Hence, when this recursive algorithm for forward substitution comes to a leaf node of $Z$, it implies the column vectors stored in $Z$ are to be accessed via local indices. Therefore, when calling the procedure {\ttfamily H\+M\+Atrix$<$spacedim, Number$>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution}, the version with the argument {\ttfamily vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map} should be used, i.\+e. {\ttfamily \hyperlink{classHMatrix_a898ed2cdcb0351a6a9b57251320b5d1d}{H\+Matrix$<$spacedim, Number$>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution(\+Vector$<$\+Number$>$ \&b, const std\+::map$<$types\+::global\+\_\+dof\+\_\+index, size\+\_\+t$>$ \& vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, const bool is\+\_\+unit\+\_\+diagonal) const}}.}


\begin{DoxyDescription}
\item[Note ]Because the {\ttfamily col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map} in in some diagonal $\mathcal{H}$-\/matrix node in $L$ may be built, this member function is not {\ttfamily const}. 
\end{DoxyDescription}


\begin{DoxyParams}{Parameters}
{\em X} & \\
\hline
{\em Z} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
{\em is\+\_\+unit\+\_\+diagonal} & \\
\hline
\end{DoxyParams}
When the current $\mathcal{H}$-\/matrix node of {\ttfamily X} or {\ttfamily Z} is a full matrix, we need to solve a multiple R\+HS problem.

Iterate over each column of {\ttfamily X} and {\ttfamily Z}.

Solve the current lower triangular $\mathcal{H}$-\/matrix $L\vert_{\tau,\tau}X\vert_{\tau,j}=Z\vert_{\tau,j}$ using the forward substitution for $\mathcal{H}$-\/matrices.

Merge back the solution vector {\ttfamily X\+\_\+col} into {\ttfamily X}, while the matrix {\ttfamily Z} is intact.

When the current $\mathcal{H}$-\/matrix node of {\ttfamily X} or {\ttfamily Z} is a rank-\/k matrix, we iterate over each column of its component matrix {\ttfamily A} and solve a multiple R\+HS problem. The resulted solution matrix {\ttfamily A\textquotesingle{}} is just the component matrix {\ttfamily A} of the rank-\/k matrix {\ttfamily X}.

Copy the data of the rank-\/k matrix {\ttfamily Z} to the rank-\/k matrix {\ttfamily X}. The component matrix {\ttfamily B} of {\ttfamily X} will be intact, while the component matrix {\ttfamily A} of X will be solved by using the forward substitution for $\mathcal{H}$-\/matrices.

This can be further elucidated as\+: because $L\vert_{\tau\times\tau}X\vert_{\tau\times\sigma} = Z\vert_{\tau\times\sigma}$, where $Z\vert_{\tau\times\sigma} = AB^T$. Since $X$ is also a rank-\/k matrix, let $X=A'B^T$. Hence, the component matrix $A'$ of $X$ can be solved as $L\vert_{\tau\times\tau}A'=A$.

Merge back the column vector of {\ttfamily A\textquotesingle{}} into {\ttfamily A\textquotesingle{}}.

When the current $\mathcal{H}$-\/matrix node of {\ttfamily X} or {\ttfamily Z} does not belong to the leaf set, perform a recursive forward substitution based on the submatrix structure of the current $\mathcal{H}$-\/matrix $L$.

The number of row blocks and column blocks of $L\vert_{\tau\times\tau}$ should be the same.

Number of row blocks of $X\vert_{\tau\times\sigma}$ or $Z\vert_{\tau\times\sigma}$, which should be the same as the number of row or column blocks of $L\vert_{\tau\times\tau}$.

Number of column blocks of $X\vert_{\tau\times\sigma}$ or $Z\vert_{\tau\times\sigma}$.


\begin{DoxyDescription}
\item[Note ]N.\+B. {\ttfamily n\+\_\+row\+\_\+blocks} does not have to be equal to {\ttfamily n\+\_\+col\+\_\+blocks}, since {\ttfamily X} or {\ttfamily Z} may be rectangular. 
\end{DoxyDescription}

Iterate over each block row of $L\vert_{\tau\times\tau}$.

Iterate over each child cluster node of the cluster $\sigma$, i.\+e. each block column of $X\vert_{\tau\times\sigma}$ or $Z\vert_{\tau\times\sigma}$.

Iterate over each block column before the i\textquotesingle{}th column in $L\vert_{\tau\times\tau}$.

Go down one level of recursion and solve the current diagonal block matrix $L\vert_{\tau_i\times\tau_i}$.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by main(), and H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued().

\mbox{\Hypertarget{classHMatrix_ac5582db8445ec15c69bc4bfdda19d547}\label{classHMatrix_ac5582db8445ec15c69bc4bfdda19d547}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+cholesky@{solve\+\_\+cholesky}}
\index{solve\+\_\+cholesky@{solve\+\_\+cholesky}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+cholesky()}{solve\_cholesky()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+cholesky (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{x,  }\item[{const Vector$<$ Number $>$ \&}]{b }\end{DoxyParamCaption}) const}

Solve the whole linear system formed by the current $\mathcal{H}$-\/matrix, which should have been applied the Cholesky factorization. The right hand side vector {\ttfamily b} should be accessed via global indices.


\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
{\em b} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution(), and H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution().



Referenced by main().

\mbox{\Hypertarget{classHMatrix_a054ad84d52a9ee6df9df3bda0a17cfb7}\label{classHMatrix_a054ad84d52a9ee6df9df3bda0a17cfb7}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution}}
\index{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution()}{solve\_cholesky\_by\_backward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{b }\end{DoxyParamCaption}) const}

Solve the upper triangular matrix $Ux=b$ by backward substitution, where $U$ is the transpose of the current matrix $L$.

The right hand side vector $b$ will be overwritten by the solution vector $x$.


\begin{DoxyParams}{Parameters}
{\em b} & Right hand side vector and after execution, it stores the result vector. \\
\hline
\end{DoxyParams}
The current $\mathcal{H}$-\/matrix node should be square.

When the current $\mathcal{H}$-\/matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via backward substitution.

Restrict vector {\ttfamily b} to the {\bfseries row} cluster of the current $\mathcal{H}$-\/matrix node, since the actual matrix to be solved is the transposition of the current matrix.

Perform backward substitution for the full matrix, where the transposed matrix is solved.

Copy back the restricted vector {\ttfamily local\+\_\+b} to the original vector {\ttfamily b}.

Iterate over each block column of the matrix.

Iterate each row column after the j\textquotesingle{}th row, i.\+e. after the diagonal submatrix block.

Since the transpose of the current matrix is to be solved, {\ttfamily Tvmult} is used here instead of {\ttfamily vmult}.

Solve the current diagonal block using backward substitution.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by main(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky(), and H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution().

\mbox{\Hypertarget{classHMatrix_a880948492a7df252f3696219f6966703}\label{classHMatrix_a880948492a7df252f3696219f6966703}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution}}
\index{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution()}{solve\_cholesky\_by\_backward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{x,  }\item[{const Vector$<$ Number $>$ \&}]{b }\end{DoxyParamCaption}) const}

Solve the upper triangular matrix $Ux=b$ by backward substitution, where $U$ is the transpose of the current matrix $L$.


\begin{DoxyParams}{Parameters}
{\em x} & Result vector. \\
\hline
{\em b} & Right hand side vector. \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution().

\mbox{\Hypertarget{classHMatrix_ae8bbf6f35a2099872fbcbfda2cb1abbd}\label{classHMatrix_ae8bbf6f35a2099872fbcbfda2cb1abbd}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution}}
\index{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution()}{solve\_cholesky\_by\_backward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{b,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map }\end{DoxyParamCaption}) const}

Solve the upper triangular matrix $Ux=b$ by backward substitution, where $U$ is the transpose of the current matrix $L$.

The right hand side vector $b$ will be overwritten by the solution vector $x$.

{\bfseries The vector {\ttfamily b} is to be accessed via local indices with the assistance of {\ttfamily vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}.}


\begin{DoxyParams}{Parameters}
{\em b} & Right hand side vector and after execution, it stores the result vector. \\
\hline
\end{DoxyParams}
The current $\mathcal{H}$-\/matrix node should be square.

When the current $\mathcal{H}$-\/matrix node belongs to the leaf set, it must be a full matrix and can be directly solved via backward substitution.

Restrict vector {\ttfamily b} to the {\bfseries row} cluster of the current $\mathcal{H}$-\/matrix node, since the actual matrix to be solved is the transposition of the current matrix.

Perform backward substitution for the full matrix, where the transposed matrix is solved.

Copy back the restricted vector {\ttfamily local\+\_\+b} to the original vector {\ttfamily b}.

Iterate over each block column of the matrix.

Iterate each row column after the j\textquotesingle{}th row, i.\+e. after the diagonal submatrix block.

Since the transpose of the current matrix is to be solved, {\ttfamily Tvmult} is used here instead of {\ttfamily vmult}.

Solve the current diagonal block using backward substitution.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{classHMatrix_a8dcb361dfb254ff716755ba8b7ed9cf1}\label{classHMatrix_a8dcb361dfb254ff716755ba8b7ed9cf1}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution}}
\index{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution@{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution()}{solve\_cholesky\_by\_backward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{x,  }\item[{const Vector$<$ Number $>$ \&}]{b,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map }\end{DoxyParamCaption}) const}

Solve the upper triangular matrix $Ux=b$ by backward substitution, where $U$ is the transpose of the current matrix $L$.

{\bfseries The vectors {\ttfamily x} and {\ttfamily b} are to be accessed via local indices with the assistance of {\ttfamily vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}.}


\begin{DoxyParams}{Parameters}
{\em x} & Result vector. \\
\hline
{\em b} & Right hand side vector. \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution().

\mbox{\Hypertarget{classHMatrix_a09beb710b79d47e34ff3283424cf2a22}\label{classHMatrix_a09beb710b79d47e34ff3283424cf2a22}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution}}
\index{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution()}{solve\_cholesky\_by\_forward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{b }\end{DoxyParamCaption}) const}

Solve the lower triangular matrix $Lx=b$ by forward substitution, where $L$ is obtained from a Cholesky decomposition. Hence, $L$ is not normed.

This function directly calls {\ttfamily solve\+\_\+by\+\_\+forward\+\_\+substitution}(Vector$<$\+Number$>$ \&b, const bool is\+\_\+unit\+\_\+diagonal = false) with {\ttfamily is\+\_\+unit\+\_\+diagonal} being {\ttfamily false}.


\begin{DoxyParams}{Parameters}
{\em b} & Right hand side vector and after execution, it stores the result vector. \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution().



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky().

\mbox{\Hypertarget{classHMatrix_a59d32edbfaac9221dc5e219640c3ecd3}\label{classHMatrix_a59d32edbfaac9221dc5e219640c3ecd3}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution}}
\index{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution()}{solve\_cholesky\_by\_forward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{x,  }\item[{const Vector$<$ Number $>$ \&}]{b }\end{DoxyParamCaption}) const}

Solve the lower triangular matrix $Lx=b$ by forward substitution, where $L$ is obtained from a Cholesky decomposition. Hence, $L$ is not normed.

This function directly calls {\ttfamily void} solve\+\_\+by\+\_\+forward\+\_\+substitution(Vector$<$\+Number$>$ \& x, const Vector$<$\+Number$>$ \&b, const bool is\+\_\+unit\+\_\+diagonal = false) const with {\ttfamily is\+\_\+unit\+\_\+diagonal} being {\ttfamily false}.


\begin{DoxyParams}{Parameters}
{\em x} & Solution vector. \\
\hline
{\em b} & Right hand side vector. \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution().

\mbox{\Hypertarget{classHMatrix_a987af3012854b397b90f19f742085155}\label{classHMatrix_a987af3012854b397b90f19f742085155}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution}}
\index{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution()}{solve\_cholesky\_by\_forward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{b,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map }\end{DoxyParamCaption}) const}

Solve the lower triangular matrix $Lx=b$ by forward substitution, where $L$ is obtained from a Cholesky decomposition. Hence, $L$ is not normed.

This function directly calls {\ttfamily solve\+\_\+by\+\_\+forward\+\_\+substitution}(Vector$<$\+Number$>$ \&b, const std\+::map$<$types\+::global\+\_\+dof\+\_\+index, size\+\_\+t$>$ \& vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, const bool is\+\_\+unit\+\_\+diagonal = false) with {\ttfamily is\+\_\+unit\+\_\+diagonal} being {\ttfamily false}.


\begin{DoxyParams}{Parameters}
{\em b} & Right hand side vector and after execution, it stores the result vector. \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution().

\mbox{\Hypertarget{classHMatrix_a0b81214fb9287b344dff8349c7122583}\label{classHMatrix_a0b81214fb9287b344dff8349c7122583}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution}}
\index{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution()}{solve\_cholesky\_by\_forward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{x,  }\item[{const Vector$<$ Number $>$ \&}]{b,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map }\end{DoxyParamCaption}) const}

Solve the lower triangular matrix $Lx=b$ by forward substitution, where $L$ is obtained from a Cholesky decomposition. Hence, $L$ is not normed.

This function directly calls {\ttfamily solve\+\_\+by\+\_\+forward\+\_\+substitution}(Vector$<$\+Number$>$ \& x, const Vector$<$\+Number$>$ \&b, const std\+::map$<$types\+::global\+\_\+dof\+\_\+index, size\+\_\+t$>$ \& vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, const bool is\+\_\+unit\+\_\+diagonal = false) with {\ttfamily is\+\_\+unit\+\_\+diagonal} being {\ttfamily false}.


\begin{DoxyParams}{Parameters}
{\em x} & Solution vector. \\
\hline
{\em b} & Right hand side vector. \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution().

\mbox{\Hypertarget{classHMatrix_a948b0b53490cc7614ee82fec80fa245a}\label{classHMatrix_a948b0b53490cc7614ee82fec80fa245a}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued@{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued}}
\index{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued@{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued()}{solve\_cholesky\_by\_forward\_substitution\_matrix\_valued()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{X,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{Z,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

Solve the matrix-\/valued problem $L\vert_{\tau\times\tau}X\vert_{\tau\times\sigma}=Z\vert_{\tau\times\sigma}$ using forward substitution, where $L\vert_{\tau\times\tau}$ is obtained from a Cholesky decomposition. Hence, $L\vert_{\tau\times\tau}$ is not normed.

This function directly calls {\ttfamily solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued}( H\+Matrix$<$spacedim, Number$>$ \&X, H\+Matrix$<$spacedim, Number$>$ \&Z, const unsigned int fixed\+\_\+rank, const bool is\+\_\+unit\+\_\+diagonal = false) with {\ttfamily is\+\_\+unit\+\_\+diagonal} being {\ttfamily false}.


\begin{DoxyParams}{Parameters}
{\em X} & \\
\hline
{\em Z} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued().

\mbox{\Hypertarget{classHMatrix_a41f0e0b791e50a3d9b5c0e73ee4423c6}\label{classHMatrix_a41f0e0b791e50a3d9b5c0e73ee4423c6}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued@{solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued}}
\index{solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued@{solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued()}{solve\_cholesky\_transpose\_by\_forward\_substitution\_matrix\_valued()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{X,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{Z,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

Solve the matrix-\/valued problem $X\vert_{\tau\times\sigma}U\vert_{\sigma\times\sigma} = Z\vert_{\tau\times\sigma}$, where the upper triangular $\mathcal{H}$-\/matrix $U\vert_{\sigma\times\sigma}$ is obtained from a Cholesky factorization.

Since only the lower triangular part of a Cholesky factorization is stored or effective, $U\vert_{\sigma\times\sigma} = L^T\vert_{\sigma\times\sigma}$. Therefore, a transposed system is solved using forward substitution, i.\+e. $U^T\vert_{\sigma\times\sigma}X^T\vert_{\sigma\times\tau} = L\vert_{\sigma\times\sigma}X^T\vert_{\sigma\times\tau} = Z^T\vert_{\sigma\times\tau}$.


\begin{DoxyParams}{Parameters}
{\em X} & \\
\hline
{\em Z} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}
The current $\mathcal{H}$-\/matrix is $L\vert_{\sigma\times\sigma}$ and the equation is $L\vert_{\sigma\times\sigma}X\vert_{\sigma\times\tau}^T$, the column dimension of $L$ should be the same as the column dimension of $X$.

When the current $\mathcal{H}$-\/matrix node of {\ttfamily X} or {\ttfamily Z} is a full matrix, we need to solve a multiple R\+HS problem.

Iterate over each row of {\ttfamily X} and {\ttfamily Z}.

Solve the problem $L\vert_{\sigma\times\sigma}X\vert_{\sigma,i} = Z\vert_{\sigma,i}$ using the forward substitution for $\mathcal{H}$-\/matrices, while the lower triangular matrix is not unit.

Merge back the solution vector {\ttfamily X\+\_\+row} into {\ttfamily X}, while the matrix {\ttfamily Z} is intact.

Solve the lower triangular $\mathcal{H}$-\/matrix using the forward substitution for $\mathcal{H}$-\/matrices, while the matrix does not have unit diagonal.

Merge back the column vector into {\ttfamily B\textquotesingle{}}.

When the current $\mathcal{H}$-\/matrix node of {\ttfamily X} or {\ttfamily Z} does not belong to the leaf set, perform a recursive forward substitution based on the submatrix structure of the current $\mathcal{H}$-\/matrix $U$.

The number of row blocks and column blocks of $L\vert_{\sigma\times\sigma}$ should be the same.

Number of row blocks of $X\vert_{\tau\times\sigma}$ or $Z\vert_{\tau\times\sigma}$.

Number of column blocks of $X\vert_{\tau\times\sigma}$ or $Z\vert_{\tau\times\sigma}$, which should be the same as the number of row or column blocks of $L\vert_{\sigma\times\sigma}$.


\begin{DoxyDescription}
\item[Note ]N.\+B. {\ttfamily n\+\_\+row\+\_\+blocks} does not have to be equal to {\ttfamily n\+\_\+col\+\_\+blocks}, since {\ttfamily X} or {\ttfamily Z} may be rectangular. 
\end{DoxyDescription}

Iterate over each block column of $U\vert_{\sigma\times\sigma}$.

Iterate over each child cluster node of the cluster $\tau$, i.\+e. each block row of $X\vert_{\tau\times\sigma}$ or $Z\vert_{\tau\times\sigma}$.

Iterate over each block row before the j\textquotesingle{}th row in $U\vert_{\sigma\times\sigma}$.

Go down one level of recursion and solve the current diagonal block matrix $U\vert_{\sigma_i \times \sigma_i}$.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by main(), and H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued().

\mbox{\Hypertarget{classHMatrix_a83e9dd55091e7eaed11ffb803321c49d}\label{classHMatrix_a83e9dd55091e7eaed11ffb803321c49d}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+lu@{solve\+\_\+lu}}
\index{solve\+\_\+lu@{solve\+\_\+lu}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+lu()}{solve\_lu()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+lu (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{x,  }\item[{const Vector$<$ Number $>$ \&}]{b }\end{DoxyParamCaption}) const}

Solve the whole linear system formed by the current $\mathcal{H}$-\/matrix, which should have been applied the LU factorization. The right hand side vector {\ttfamily b} should be accessed via global indices.


\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
{\em b} & \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+backward\+\_\+substitution(), and H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution().



Referenced by main().

\mbox{\Hypertarget{classHMatrix_a624fc153099a20572a655457d4f81b70}\label{classHMatrix_a624fc153099a20572a655457d4f81b70}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution}}
\index{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution()}{solve\_transpose\_by\_forward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{b }\end{DoxyParamCaption}) const}

Solve the transpose of an upper triangular matrix $U^Tx=b$ by forward substitution.

The right hand side vector $b$ will be overwritten by the solution vector $x$.


\begin{DoxyParams}{Parameters}
{\em b} & Right hand side vector and after execution, it stores the result vector. \\
\hline
\end{DoxyParams}
The current $\mathcal{H}$-\/matrix node should be square.

When the current $\mathcal{H}$-\/matrix node belongs to the leaf set, it must be a full matrix, whose transpose can be directly solved via forward substitution.

Restrict vector {\ttfamily b} to the row cluster of the current $\mathcal{H}$-\/matrix node.

Perform forward substitution for the transpose of the full matrix. N.\+B. The right hand side vector will not be permuted.

Copy back the restricted vector {\ttfamily local\+\_\+b} to the original vector {\ttfamily b}.

Iterate over each block row of the matrix.

Iterate each block column.

Iterate each block row before the j\textquotesingle{}th row, i.\+e. before the diagonal submatrix block.

Solve the current diagonal block using forward substitution.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by main(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution(), and H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued().

\mbox{\Hypertarget{classHMatrix_a94f9bb1bc4e584fc5f29541be6b85ef1}\label{classHMatrix_a94f9bb1bc4e584fc5f29541be6b85ef1}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution}}
\index{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution()}{solve\_transpose\_by\_forward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{x,  }\item[{const Vector$<$ Number $>$ \&}]{b }\end{DoxyParamCaption}) const}

Solve the transpose of an upper triangular matrix $U^Tx=b$ by forward substitution.


\begin{DoxyParams}{Parameters}
{\em x} & Result vector. \\
\hline
{\em b} & Right hand side vector. \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution().

\mbox{\Hypertarget{classHMatrix_aefa73f541d0b5eb8cddde5386fd140d0}\label{classHMatrix_aefa73f541d0b5eb8cddde5386fd140d0}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution}}
\index{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution()}{solve\_transpose\_by\_forward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{b,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map }\end{DoxyParamCaption}) const}

Solve the transpose of an upper triangular matrix $U^Tx=b$ by forward substitution.

The right hand side vector $b$ will be overwritten by the solution vector $x$.

{\bfseries The vector {\ttfamily b} is to be accessed via local indices with the assistance of {\ttfamily vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}.}


\begin{DoxyParams}{Parameters}
{\em b} & Right hand side vector and after execution, it stores the result vector. \\
\hline
\end{DoxyParams}
The current $\mathcal{H}$-\/matrix node should be square.

When the current $\mathcal{H}$-\/matrix node belongs to the leaf set, it must be a full matrix, whose transpose can be directly solved via forward substitution.

Restrict vector {\ttfamily b} to the row cluster of the current $\mathcal{H}$-\/matrix node.

Perform forward substitution for the transpose of the full matrix. N.\+B. The right hand side vector will not be permuted.

Copy back the restricted vector {\ttfamily local\+\_\+b} to the original vector {\ttfamily b}.

Iterate over each block row of the matrix.

Iterate each block column.

Iterate each block row before the j\textquotesingle{}th row, i.\+e. before the diagonal submatrix block.

Solve the current diagonal block using forward substitution.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.

\mbox{\Hypertarget{classHMatrix_a8e9c993ce276353fda2bfefd0b932670}\label{classHMatrix_a8e9c993ce276353fda2bfefd0b932670}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution}}
\index{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution@{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution()}{solve\_transpose\_by\_forward\_substitution()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{x,  }\item[{const Vector$<$ Number $>$ \&}]{b,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map }\end{DoxyParamCaption}) const}

Solve the transpose of an upper triangular matrix $U^Tx=b$ by forward substitution.

{\bfseries The vectors {\ttfamily x} and {\ttfamily b} are to be accessed via local indices with the assistance of {\ttfamily vector\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}.}


\begin{DoxyParams}{Parameters}
{\em x} & Result vector. \\
\hline
{\em b} & Right hand side vector. \\
\hline
\end{DoxyParams}


References H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution(), and H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued().

\mbox{\Hypertarget{classHMatrix_a469507ef4061efcc29a65c413ac7acea}\label{classHMatrix_a469507ef4061efcc29a65c413ac7acea}} 
\index{H\+Matrix@{H\+Matrix}!solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued@{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued}}
\index{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued@{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued()}{solve\_transpose\_by\_forward\_substitution\_matrix\_valued()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{X,  }\item[{\hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$ \&}]{Z,  }\item[{const unsigned int}]{fixed\+\_\+rank }\end{DoxyParamCaption})}

Solve the matrix-\/valued problem $X\vert_{\tau\times\sigma}U\vert_{\sigma\times\sigma} = Z\vert_{\tau\times\sigma}$.

A transposed system is solved, i.\+e. $U^T\vert_{\sigma\times\sigma}X^T\vert_{\sigma\times\tau} = Z^T\vert_{\sigma\times\tau}$. Then $U^T\vert_{\sigma\times\sigma}$ is a lower triangular $\mathcal{H}$-\/matrix and a similar procedure as that in the matrix-\/valued forward substitution can be applied.


\begin{DoxyParams}{Parameters}
{\em X} & \\
\hline
{\em Z} & \\
\hline
{\em fixed\+\_\+rank} & \\
\hline
\end{DoxyParams}
When the current $\mathcal{H}$-\/matrix node of {\ttfamily X} or {\ttfamily Z} is a full matrix, we need to solve a multiple R\+HS problem.

Iterate over each row of {\ttfamily X} and {\ttfamily Z}.

Solve the problem $X\vert_{i,\sigma}U\vert_{\sigma\times\sigma} = Z\vert_{i,\sigma}$ using the transposed forward substitution for $\mathcal{H}$-\/matrices.

Merge back the solution vector {\ttfamily X\+\_\+row} into {\ttfamily X}, while the matrix {\ttfamily Z} is intact.

Solve the problem using the transposed forward substitution for $\mathcal{H}$-\/matrices.

Merge back the column vector of {\ttfamily B\textquotesingle{}} into {\ttfamily B\textquotesingle{}}.

When the current $\mathcal{H}$-\/matrix node of {\ttfamily X} or {\ttfamily Z} does not belong to the leaf set, perform a recursive forward substitution based on the submatrix structure of the current $\mathcal{H}$-\/matrix $U$.

The number of row blocks and column blocks of $L\vert_{\tau\times\tau}$ should be the same.

Number of row blocks of $X\vert_{\tau\times\sigma}$ or $Z\vert_{\tau\times\sigma}$.

Number of column blocks of $X\vert_{\tau\times\sigma}$ or $Z\vert_{\tau\times\sigma}$, which should be the same as the number of row or column blocks of $U\vert_{\sigma\times\sigma}$.


\begin{DoxyDescription}
\item[Note ]N.\+B. {\ttfamily n\+\_\+row\+\_\+blocks} does not have to be equal to {\ttfamily n\+\_\+col\+\_\+blocks}, since {\ttfamily X} or {\ttfamily Z} may be rectangular. 
\end{DoxyDescription}

Iterate over each block column of $U\vert_{\sigma\times\sigma}$.

Iterate over each child cluster node of the cluster $\tau$, i.\+e. each block row of $X\vert_{\tau\times\sigma}$ or $Z\vert_{\tau\times\sigma}$.

Iterate over each block row before the j\textquotesingle{}th row in $U\vert_{\sigma\times\sigma}$.

Go down one level of recursion and solve the current diagonal block matrix $U\vert_{\sigma_j\times\sigma_j}$.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::submatrices, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by main(), and H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution().

\mbox{\Hypertarget{classHMatrix_a64be687cacd167efc12b892aa154dcd3}\label{classHMatrix_a64be687cacd167efc12b892aa154dcd3}} 
\index{H\+Matrix@{H\+Matrix}!truncate\+\_\+to\+\_\+rank@{truncate\+\_\+to\+\_\+rank}}
\index{truncate\+\_\+to\+\_\+rank@{truncate\+\_\+to\+\_\+rank}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{truncate\+\_\+to\+\_\+rank()}{truncate\_to\_rank()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::truncate\+\_\+to\+\_\+rank (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type}}]{new\+\_\+rank }\end{DoxyParamCaption})}

Truncate all rank-\/k matrices in the leaf set of the $\mathcal{H}$-\/matrix to rank-\/k matrices with the given {\ttfamily new\+\_\+rank}, while the full matrices in the leaf set, i.\+e. those near-\/field matrices, are kept intact.


\begin{DoxyDescription}
\item[Note ]This method implements the operator $\mathcal{T}_{r \leftarrow s}^{\mathcal{H}}$ in (7.\+5) in Hackbusch\textquotesingle{}s $\mathcal{H}$-\/matrix book. 
\end{DoxyDescription}
\begin{DoxyParams}{Parameters}
{\em new\+\_\+rank} & \\
\hline
\end{DoxyParams}
Do nothing.

Truncate the \hyperlink{classRkMatrix}{Rk\+Matrix} in-\/place.

References Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.



Referenced by main().

\mbox{\Hypertarget{classHMatrix_a93834ac1b8a659dc2b81cd3af1dea997}\label{classHMatrix_a93834ac1b8a659dc2b81cd3af1dea997}} 
\index{H\+Matrix@{H\+Matrix}!truncate\+\_\+to\+\_\+rank\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite@{truncate\+\_\+to\+\_\+rank\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite}}
\index{truncate\+\_\+to\+\_\+rank\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite@{truncate\+\_\+to\+\_\+rank\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{truncate\+\_\+to\+\_\+rank\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite()}{truncate\_to\_rank\_diag\_preserve\_positive\_definite()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::truncate\+\_\+to\+\_\+rank\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type}}]{new\+\_\+rank }\end{DoxyParamCaption})}

At present, it is prescribed that the block cluster tree should be a quad tree.

Only handle the two diagonal blocks and one off-\/diagonal block.

Do nothing.

Do nothing.

Do nothing.

References Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.

\mbox{\Hypertarget{classHMatrix_a58c40b6db50fe3dbbf230f951d346b9c}\label{classHMatrix_a58c40b6db50fe3dbbf230f951d346b9c}} 
\index{H\+Matrix@{H\+Matrix}!truncate\+\_\+to\+\_\+rank\+\_\+off\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite@{truncate\+\_\+to\+\_\+rank\+\_\+off\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite}}
\index{truncate\+\_\+to\+\_\+rank\+\_\+off\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite@{truncate\+\_\+to\+\_\+rank\+\_\+off\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{truncate\+\_\+to\+\_\+rank\+\_\+off\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite()}{truncate\_to\_rank\_off\_diag\_preserve\_positive\_definite()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::truncate\+\_\+to\+\_\+rank\+\_\+off\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type}}]{new\+\_\+rank }\end{DoxyParamCaption})}

At present, it is prescribed that the block cluster tree should be a quad tree.

Handle the four lower triangular blocks.

Do nothing.

References Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.

\mbox{\Hypertarget{classHMatrix_a15191d30e94d5f54d30c5f612f606ce1}\label{classHMatrix_a15191d30e94d5f54d30c5f612f606ce1}} 
\index{H\+Matrix@{H\+Matrix}!truncate\+\_\+to\+\_\+rank\+\_\+preserve\+\_\+positive\+\_\+definite@{truncate\+\_\+to\+\_\+rank\+\_\+preserve\+\_\+positive\+\_\+definite}}
\index{truncate\+\_\+to\+\_\+rank\+\_\+preserve\+\_\+positive\+\_\+definite@{truncate\+\_\+to\+\_\+rank\+\_\+preserve\+\_\+positive\+\_\+definite}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{truncate\+\_\+to\+\_\+rank\+\_\+preserve\+\_\+positive\+\_\+definite()}{truncate\_to\_rank\_preserve\_positive\_definite()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::truncate\+\_\+to\+\_\+rank\+\_\+preserve\+\_\+positive\+\_\+definite (\begin{DoxyParamCaption}\item[{\hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type}}]{new\+\_\+rank }\end{DoxyParamCaption})}

Truncate all rank-\/k matrices in the leaf set of the $\mathcal{H}$-\/matrix to rank-\/k matrices with the given {\ttfamily new\+\_\+rank}, while the full matrices in the leaf set, i.\+e. those near-\/field matrices, are kept intact.

{\bfseries The original $\mathcal{H}$-\/matrix is assumed to be symmetric and positive definite (S\+PD), but both upper and lower triangular parts are stored. When rank truncation is performed for far field rank-\/k matrices, the truncation error matrix components will be added to diagonal blocks according to the stabilization method proposed in Bebendorf, M., and W. Hackbusch. 2007. \+Stabilized Rounded Addition of Hierarchical Matrices.\+ Numerical Linear Algebra with Applications 14 (5)\+: 40723. \href{https://doi.org/10.1002/nla.525}{\tt https\+://doi.\+org/10.\+1002/nla.\+525}.}


\begin{DoxyDescription}
\item[Note ]This method implements the operator $\mathcal{T}_{r \leftarrow s}^{\mathcal{H}}$ in (7.\+5) in Hackbusch\textquotesingle{}s $\mathcal{H}$-\/matrix book. 
\end{DoxyDescription}
\begin{DoxyParams}{Parameters}
{\em new\+\_\+rank} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classHMatrix_a72e5255eb5ce46136d0e2b195c82f016}\label{classHMatrix_a72e5255eb5ce46136d0e2b195c82f016}} 
\index{H\+Matrix@{H\+Matrix}!Tvmult@{Tvmult}}
\index{Tvmult@{Tvmult}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{Tvmult()}{Tvmult()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::Tvmult (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{y,  }\item[{const Vector$<$ Number $>$ \&}]{x }\end{DoxyParamCaption}) const}

Calculate matrix-\/vector multiplication as $y = y + M^T \cdot x$, i.\+e. the matrix $M$ is transposed.

Because the matrix $M$ is transposed, the roles for {\ttfamily row\+\_\+indices} and {\ttfamily col\+\_\+indices} should be swapped. Also refer to \hyperlink{classHMatrix_aa11b5761aba86606effd14b4bdf31912}{H\+Matrix\+::vmult}. 
\begin{DoxyParams}{Parameters}
{\em y} & \\
\hline
{\em x} & \\
\hline
\end{DoxyParams}
Restrict vector x to the current matrix block.

Merge back the result vector {\ttfamily local\+\_\+y} to {\ttfamily y}.

Restrict vector x to the current matrix block.

Merge back the result vector {\ttfamily local\+\_\+y} to {\ttfamily y}.

References H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.



Referenced by f\+\_\+h\+\_\+mmult(), and rk\+\_\+h\+\_\+mmult().

\mbox{\Hypertarget{classHMatrix_a46298efb74444db494068cc3fab73431}\label{classHMatrix_a46298efb74444db494068cc3fab73431}} 
\index{H\+Matrix@{H\+Matrix}!Tvmult@{Tvmult}}
\index{Tvmult@{Tvmult}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{Tvmult()}{Tvmult()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::Tvmult (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{y,  }\item[{const Number}]{alpha,  }\item[{const Vector$<$ Number $>$ \&}]{x }\end{DoxyParamCaption}) const}

Calculate matrix-\/vector multiplication as $y = y + \alpha \cdot M^T \cdot x$, i.\+e. the matrix $M$ is transposed.

Because the matrix $M$ is transposed, the roles for {\ttfamily row\+\_\+indices} and {\ttfamily col\+\_\+indices} should be swapped. Also refer to \hyperlink{classHMatrix_aa11b5761aba86606effd14b4bdf31912}{H\+Matrix\+::vmult}. 
\begin{DoxyParams}{Parameters}
{\em y} & \\
\hline
{\em alpha} & \\
\hline
{\em x} & \\
\hline
\end{DoxyParams}
Restrict vector x to the current matrix block.

Merge back the result vector {\ttfamily local\+\_\+y} to {\ttfamily y}.

Restrict vector x to the current matrix block.

Merge back the result vector {\ttfamily local\+\_\+y} to {\ttfamily y}.

References H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.

\mbox{\Hypertarget{classHMatrix_a52a9fb807eab3f9f0903c03dd637382c}\label{classHMatrix_a52a9fb807eab3f9f0903c03dd637382c}} 
\index{H\+Matrix@{H\+Matrix}!Tvmult@{Tvmult}}
\index{Tvmult@{Tvmult}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{Tvmult()}{Tvmult()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::Tvmult (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{y,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{y\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map,  }\item[{const Vector$<$ Number $>$ \&}]{x,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{x\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map }\end{DoxyParamCaption}) const}

Calculate matrix-\/vector multiplication as $y = y + M^T \cdot x$, i.\+e. the matrix $M$ is transposed.

Because the matrix $M$ is transposed, the roles for {\ttfamily row\+\_\+indices} and {\ttfamily col\+\_\+indices} should be swapped.


\begin{DoxyDescription}
\item[Note ]The input vectors {\ttfamily x} and {\ttfamily y} are to be accessed via local indices with the assistance of {\ttfamily row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map} and {\ttfamily col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}. 
\end{DoxyDescription}

Also refer to \hyperlink{classHMatrix_aa11b5761aba86606effd14b4bdf31912}{H\+Matrix\+::vmult}. 
\begin{DoxyParams}{Parameters}
{\em y} & \\
\hline
{\em x} & \\
\hline
\end{DoxyParams}
Restrict vector x to the current matrix block.

Merge back the result vector {\ttfamily local\+\_\+y} to {\ttfamily y}.

Restrict vector x to the current matrix block.

Merge back the result vector {\ttfamily local\+\_\+y} to {\ttfamily y}.

References H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.

\mbox{\Hypertarget{classHMatrix_a9ce6e0dd7cfa3dc0fff165d6ed819017}\label{classHMatrix_a9ce6e0dd7cfa3dc0fff165d6ed819017}} 
\index{H\+Matrix@{H\+Matrix}!Tvmult@{Tvmult}}
\index{Tvmult@{Tvmult}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{Tvmult()}{Tvmult()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::Tvmult (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{y,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{y\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map,  }\item[{const Number}]{alpha,  }\item[{const Vector$<$ Number $>$ \&}]{x,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{x\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map }\end{DoxyParamCaption}) const}

Calculate matrix-\/vector multiplication as $y = y + \alpha \cdot M^T \cdot x$, i.\+e. the matrix $M$ is transposed.

Because the matrix $M$ is transposed, the roles for {\ttfamily row\+\_\+indices} and {\ttfamily col\+\_\+indices} should be swapped.


\begin{DoxyDescription}
\item[Note ]The input vectors {\ttfamily x} and {\ttfamily y} are to be accessed via local indices with the assistance of {\ttfamily row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map} and {\ttfamily col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}. 
\end{DoxyDescription}

Also refer to \hyperlink{classHMatrix_aa11b5761aba86606effd14b4bdf31912}{H\+Matrix\+::vmult}. 
\begin{DoxyParams}{Parameters}
{\em y} & \\
\hline
{\em x} & \\
\hline
\end{DoxyParams}
Restrict vector x to the current matrix block.

Merge back the result vector {\ttfamily local\+\_\+y} to {\ttfamily y}.

Restrict vector x to the current matrix block.

Merge back the result vector {\ttfamily local\+\_\+y} to {\ttfamily y}.

References H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.

\mbox{\Hypertarget{classHMatrix_aa11b5761aba86606effd14b4bdf31912}\label{classHMatrix_aa11b5761aba86606effd14b4bdf31912}} 
\index{H\+Matrix@{H\+Matrix}!vmult@{vmult}}
\index{vmult@{vmult}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{vmult()}{vmult()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::vmult (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{y,  }\item[{const Vector$<$ Number $>$ \&}]{x }\end{DoxyParamCaption}) const}

Calculate matrix-\/vector multiplication as $y = y + M \cdot x$.


\begin{DoxyDescription}
\item[Note ]
\begin{DoxyEnumerate}
\item The recursive algorithm for $\mathcal{H}$-\/matrix-\/vector multiplication needs to collect the results from different components in the leaf set and corresponding vector block in $x$. More importantly, there will be a series of such results contributing to a same block in the result vector $y$. Therefore, if the interface of this function is designed with the parameter {\ttfamily add} as that in the {\ttfamily vmult} function of {\ttfamily L\+A\+P\+A\+C\+K\+Full\+Matrix} in deal.\+ii, in all recursive calls of {\ttfamily vmult} except the first one, this {\ttfamily add} flag should be set to {\ttfamily true}, irrespective of the original flag value passed into the first call of {\ttfamily vmult}. Hence, we do not include the {\ttfamily add} flag in the {\ttfamily vmult} function.
\item The input vectors {\ttfamily x} and {\ttfamily y} are to be accessed via global DoF indices.  
\end{DoxyEnumerate}
\end{DoxyDescription}


\begin{DoxyParams}{Parameters}
{\em y} & \\
\hline
{\em x} & \\
\hline
\end{DoxyParams}
Restrict vector x to the current matrix block.

Merge back the result vector {\ttfamily local\+\_\+y} to {\ttfamily y}.

Restrict vector x to the current matrix block.

Merge back the result vector {\ttfamily local\+\_\+y} to {\ttfamily y}.

References H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.



Referenced by f\+\_\+h\+\_\+m\+Tmult(), h\+\_\+f\+\_\+mmult(), h\+\_\+f\+\_\+m\+Tmult(), h\+\_\+rk\+\_\+mmult(), h\+\_\+rk\+\_\+m\+Tmult(), and rk\+\_\+h\+\_\+m\+Tmult().

\mbox{\Hypertarget{classHMatrix_a21ca2a043c8a02a531d5d08437356310}\label{classHMatrix_a21ca2a043c8a02a531d5d08437356310}} 
\index{H\+Matrix@{H\+Matrix}!vmult@{vmult}}
\index{vmult@{vmult}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{vmult()}{vmult()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::vmult (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{y,  }\item[{const Number}]{alpha,  }\item[{const Vector$<$ Number $>$ \&}]{x }\end{DoxyParamCaption}) const}

Calculate matrix-\/vector multiplication as $y = y + \alpha \codt M \cdot x$.


\begin{DoxyParams}{Parameters}
{\em y} & \\
\hline
{\em alpha} & \\
\hline
{\em x} & \\
\hline
\end{DoxyParams}
Restrict vector x to the current matrix block.

Merge back the result vector {\ttfamily local\+\_\+y} to {\ttfamily y}.

Restrict vector x to the current matrix block.

Merge back the result vector {\ttfamily local\+\_\+y} to {\ttfamily y}.

References H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.

\mbox{\Hypertarget{classHMatrix_a690927f0810d85d08f0ab2239e405ffe}\label{classHMatrix_a690927f0810d85d08f0ab2239e405ffe}} 
\index{H\+Matrix@{H\+Matrix}!vmult@{vmult}}
\index{vmult@{vmult}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{vmult()}{vmult()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::vmult (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{y,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{y\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map,  }\item[{const Vector$<$ Number $>$ \&}]{x,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{x\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map }\end{DoxyParamCaption}) const}

Calculate matrix-\/vector multiplication as $y = y + M \cdot x$.


\begin{DoxyDescription}
\item[Note ]
\begin{DoxyEnumerate}
\item The recursive algorithm for $\mathcal{H}$-\/matrix-\/vector multiplication needs to collect the results from different components in the leaf set and corresponding vector block in $x$. More importantly, there will be a series of such results contributing to a same block in the result vector $y$. Therefore, if the interface of this function is designed with the parameter {\ttfamily add} as that in the {\ttfamily vmult} function of {\ttfamily L\+A\+P\+A\+C\+K\+Full\+Matrix} in deal.\+ii, in all recursive calls of {\ttfamily vmult} except the first one, this {\ttfamily add} flag should be set to {\ttfamily true}, irrespective of the original flag value passed into the first call of {\ttfamily vmult}. Hence, we do not include the {\ttfamily add} flag in the {\ttfamily vmult} function.
\item The input vectors {\ttfamily x} and {\ttfamily y} are to be accessed via local indices with the assistance of {\ttfamily row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map} and {\ttfamily col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}. 
\end{DoxyEnumerate}
\end{DoxyDescription}


\begin{DoxyParams}{Parameters}
{\em y} & \\
\hline
{\em x} & \\
\hline
\end{DoxyParams}
Restrict vector x to the current matrix block.

Merge back the result vector {\ttfamily local\+\_\+y} to {\ttfamily y}.

Restrict vector x to the current matrix block.

Merge back the result vector {\ttfamily local\+\_\+y} to {\ttfamily y}.

References H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.

\mbox{\Hypertarget{classHMatrix_ab0a61c4d55a5d132b25589240be5c015}\label{classHMatrix_ab0a61c4d55a5d132b25589240be5c015}} 
\index{H\+Matrix@{H\+Matrix}!vmult@{vmult}}
\index{vmult@{vmult}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{vmult()}{vmult()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::vmult (\begin{DoxyParamCaption}\item[{Vector$<$ Number $>$ \&}]{y,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{y\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map,  }\item[{const Number}]{alpha,  }\item[{const Vector$<$ Number $>$ \&}]{x,  }\item[{const std\+::map$<$ types\+::global\+\_\+dof\+\_\+index, size\+\_\+t $>$ \&}]{x\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map }\end{DoxyParamCaption}) const}

Calculate matrix-\/vector multiplication as $y = y + \alpha \cdot M \cdot x$.


\begin{DoxyParams}{Parameters}
{\em y} & \\
\hline
{\em y\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map} & \\
\hline
{\em alpha} & \\
\hline
{\em x} & \\
\hline
{\em x\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map} & \\
\hline
\end{DoxyParams}
Restrict vector x to the current matrix block.

Merge back the result vector {\ttfamily local\+\_\+y} to {\ttfamily y}.

Restrict vector x to the current matrix block.

Merge back the result vector {\ttfamily local\+\_\+y} to {\ttfamily y}.

References H\+Matrix$<$ spacedim, Number $>$\+::col\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::fullmatrix, Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::m, H\+Matrix$<$ spacedim, Number $>$\+::n, H\+Matrix$<$ spacedim, Number $>$\+::rkmatrix, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::row\+\_\+indices, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, and Undefined\+Matrix\+Type.

\mbox{\Hypertarget{classHMatrix_a42f958a13c56d64564d59487e67bc8a2}\label{classHMatrix_a42f958a13c56d64564d59487e67bc8a2}} 
\index{H\+Matrix@{H\+Matrix}!write\+\_\+fullmatrix\+\_\+leaf\+\_\+node@{write\+\_\+fullmatrix\+\_\+leaf\+\_\+node}}
\index{write\+\_\+fullmatrix\+\_\+leaf\+\_\+node@{write\+\_\+fullmatrix\+\_\+leaf\+\_\+node}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{write\+\_\+fullmatrix\+\_\+leaf\+\_\+node()}{write\_fullmatrix\_leaf\_node()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::write\+\_\+fullmatrix\+\_\+leaf\+\_\+node (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out,  }\item[{const Number}]{singular\+\_\+value\+\_\+threshold = {\ttfamily 0.} }\end{DoxyParamCaption}) const}

Write formatted full matrix leaf node to the output stream.

The leaf node is written in the following format\+:

\begin{quote}


\end{quote}
\mbox{[}list-\/of-\/indices-\/in-\/cluster-\/tau\mbox{]},\mbox{[}list-\/of-\/indices-\/in-\/cluster-\/sigma\mbox{]},is\+\_\+near\+\_\+field,rank

For example,

\begin{quote}
\mbox{[}1 2 3 ...\mbox{]},\mbox{[}7 8 9 ...\mbox{]},1,1 \end{quote}



\begin{DoxyParams}{Parameters}
{\em out} & \\
\hline
{\em singular\+\_\+value\+\_\+threshold} & \\
\hline
\end{DoxyParams}
Print index set of cluster $\tau$.

Print index set of cluster $\sigma$.

Print the {\ttfamily is\+\_\+near\+\_\+field} flag.

Make a copy of the matrix block and calculate its rank using S\+VD.

Print the {\ttfamily rank} flag.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, Full\+Matrix\+Type, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::write\+\_\+leaf\+\_\+set().

\mbox{\Hypertarget{classHMatrix_aaf0ae0960a40ad78a941aee823e80315}\label{classHMatrix_aaf0ae0960a40ad78a941aee823e80315}} 
\index{H\+Matrix@{H\+Matrix}!write\+\_\+leaf\+\_\+set@{write\+\_\+leaf\+\_\+set}}
\index{write\+\_\+leaf\+\_\+set@{write\+\_\+leaf\+\_\+set}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{write\+\_\+leaf\+\_\+set()}{write\_leaf\_set()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::write\+\_\+leaf\+\_\+set (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out,  }\item[{const Number}]{singular\+\_\+value\+\_\+threshold = {\ttfamily 0.} }\end{DoxyParamCaption}) const}

Write formatted leaf set to the output stream as well as the rank of each matrix block by recursion.

Each leaf node is written in the following format\+:

\begin{quote}


\end{quote}
\mbox{[}list-\/of-\/indices-\/in-\/cluster-\/tau\mbox{]},\mbox{[}list-\/of-\/indices-\/in-\/cluster-\/sigma\mbox{]},is\+\_\+near\+\_\+field,rank

For example,

\begin{quote}
\mbox{[}1 2 3 ...\mbox{]},\mbox{[}7 8 9 ...\mbox{]},1,1 \end{quote}

\begin{DoxyParams}{Parameters}
{\em out} & \\
\hline
{\em singular\+\_\+value\+\_\+threshold} & \\
\hline
\end{DoxyParams}


References Full\+Matrix\+Type, Hierarchical\+Matrix\+Type, Rk\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::submatrices, H\+Matrix$<$ spacedim, Number $>$\+::type, H\+Matrix$<$ spacedim, Number $>$\+::write\+\_\+fullmatrix\+\_\+leaf\+\_\+node(), and H\+Matrix$<$ spacedim, Number $>$\+::write\+\_\+rkmatrix\+\_\+leaf\+\_\+node().



Referenced by main().

\mbox{\Hypertarget{classHMatrix_aac1e1ddbfeb133520dcd50c0174aab8d}\label{classHMatrix_aac1e1ddbfeb133520dcd50c0174aab8d}} 
\index{H\+Matrix@{H\+Matrix}!write\+\_\+leaf\+\_\+set\+\_\+by\+\_\+iteration@{write\+\_\+leaf\+\_\+set\+\_\+by\+\_\+iteration}}
\index{write\+\_\+leaf\+\_\+set\+\_\+by\+\_\+iteration@{write\+\_\+leaf\+\_\+set\+\_\+by\+\_\+iteration}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{write\+\_\+leaf\+\_\+set\+\_\+by\+\_\+iteration()}{write\_leaf\_set\_by\_iteration()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::write\+\_\+leaf\+\_\+set\+\_\+by\+\_\+iteration (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out,  }\item[{const Number}]{singular\+\_\+value\+\_\+threshold = {\ttfamily 0.} }\end{DoxyParamCaption}) const}

Write formatted leaf set to the output stream as well as the rank of each matrix block by iteration.

Each leaf node is written in the following format\+:

\begin{quote}


\end{quote}
\mbox{[}list-\/of-\/indices-\/in-\/cluster-\/tau\mbox{]},\mbox{[}list-\/of-\/indices-\/in-\/cluster-\/sigma\mbox{]},is\+\_\+near\+\_\+field,rank

For example,

\begin{quote}
\mbox{[}1 2 3 ...\mbox{]},\mbox{[}7 8 9 ...\mbox{]},1,1 \end{quote}

\begin{DoxyParams}{Parameters}
{\em out} & \\
\hline
{\em singular\+\_\+value\+\_\+threshold} & \\
\hline
\end{DoxyParams}


References Full\+Matrix\+Type, H\+Matrix$<$ spacedim, Number $>$\+::leaf\+\_\+set, Rk\+Matrix\+Type, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by main().

\mbox{\Hypertarget{classHMatrix_ac2c8ccd5763d3952505741c657b6468c}\label{classHMatrix_ac2c8ccd5763d3952505741c657b6468c}} 
\index{H\+Matrix@{H\+Matrix}!write\+\_\+rkmatrix\+\_\+leaf\+\_\+node@{write\+\_\+rkmatrix\+\_\+leaf\+\_\+node}}
\index{write\+\_\+rkmatrix\+\_\+leaf\+\_\+node@{write\+\_\+rkmatrix\+\_\+leaf\+\_\+node}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{write\+\_\+rkmatrix\+\_\+leaf\+\_\+node()}{write\_rkmatrix\_leaf\_node()}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number $>$ \\
void \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::write\+\_\+rkmatrix\+\_\+leaf\+\_\+node (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out }\end{DoxyParamCaption}) const}

Write formatted rank-\/k matrix leaf node to the output stream.

The leaf node is written in the following format\+:

\begin{quote}


\end{quote}
\mbox{[}list-\/of-\/indices-\/in-\/cluster-\/tau\mbox{]},\mbox{[}list-\/of-\/indices-\/in-\/cluster-\/sigma\mbox{]},is\+\_\+near\+\_\+field,rank

For example,

\begin{quote}
\mbox{[}1 2 3 ...\mbox{]},\mbox{[}7 8 9 ...\mbox{]},1,1 \end{quote}



\begin{DoxyParams}{Parameters}
{\em out} & \\
\hline
\end{DoxyParams}
Print index set of cluster $\tau$.

Print index set of cluster $\sigma$.

Print the {\ttfamily is\+\_\+near\+\_\+field} flag.

Print the {\ttfamily rank} flag.

References H\+Matrix$<$ spacedim, Number $>$\+::bc\+\_\+node, Rk\+Matrix\+Type, and H\+Matrix$<$ spacedim, Number $>$\+::type.



Referenced by H\+Matrix$<$ spacedim, Number $>$\+::write\+\_\+leaf\+\_\+set().



\subsection{Member Data Documentation}
\mbox{\Hypertarget{classHMatrix_a4a304494c970b5b267be1d8459d51586}\label{classHMatrix_a4a304494c970b5b267be1d8459d51586}} 
\index{H\+Matrix@{H\+Matrix}!bc\+\_\+node@{bc\+\_\+node}}
\index{bc\+\_\+node@{bc\+\_\+node}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{bc\+\_\+node}{bc\_node}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$spacedim, Number$>$\+::node\+\_\+pointer\+\_\+type \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::bc\+\_\+node\hspace{0.3cm}{\ttfamily [private]}}

Pointer to the corresponding block cluster node in a \hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+invert\+\_\+by\+\_\+gauss\+\_\+elim(), H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::coarsen\+\_\+to\+\_\+partition(), H\+Matrix$<$ spacedim, Number $>$\+::compute\+\_\+cholesky\+\_\+factorization(), H\+Matrix$<$ spacedim, Number $>$\+::compute\+\_\+lu\+\_\+factorization(), convert\+H\+Mat\+Block\+To\+Rk\+Matrix(), copy\+\_\+hmatrix\+\_\+node(), f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), H\+Matrix$<$ spacedim, Number $>$\+::find\+\_\+col\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block(), H\+Matrix$<$ spacedim, Number $>$\+::find\+\_\+row\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block(), h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), H\+Matrix$<$ spacedim, Number $>$\+::h\+\_\+h\+\_\+mmult\+\_\+cross\+\_\+split(), h\+\_\+h\+\_\+mmult\+\_\+from\+\_\+leaf\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::h\+\_\+h\+\_\+mmult\+\_\+horizontal\+\_\+split(), h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving(), H\+Matrix$<$ spacedim, Number $>$\+::h\+\_\+h\+\_\+mmult\+\_\+reduction(), H\+Matrix$<$ spacedim, Number $>$\+::h\+\_\+h\+\_\+mmult\+\_\+vertical\+\_\+split(), h\+\_\+h\+\_\+m\+Tmult\+\_\+from\+\_\+leaf\+\_\+node(), h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving(), Init\+And\+Create\+H\+Matrix\+Children(), Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc(), Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node(), H\+Matrix$<$ spacedim, Number $>$\+::print\+\_\+current\+\_\+matrix\+\_\+info(), Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree(), H\+Matrix$<$ spacedim, Number $>$\+::release(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::write\+\_\+fullmatrix\+\_\+leaf\+\_\+node(), and H\+Matrix$<$ spacedim, Number $>$\+::write\+\_\+rkmatrix\+\_\+leaf\+\_\+node().

\mbox{\Hypertarget{classHMatrix_ab337c7b4f2f40699b9b7f3ab17a1e056}\label{classHMatrix_ab337c7b4f2f40699b9b7f3ab17a1e056}} 
\index{H\+Matrix@{H\+Matrix}!col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map@{col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}}
\index{col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map@{col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}{col\_index\_global\_to\_local\_map}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
std\+::map$<$types\+::global\+\_\+dof\+\_\+index, size\+\_\+t$>$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::col\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\hspace{0.3cm}{\ttfamily [private]}}

Map from local column indices to global column indices for the cluster $\sigma$. The set of local column indices is the range $[0, \#\sigma - 1]$. The corresponding set of global column indices is a subset of $J$.


\begin{DoxyDescription}
\item[Note ]This mapping is only constructed for H-\/matrices in the leaf set. 
\end{DoxyDescription}

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), H\+Matrix$<$ spacedim, Number $>$\+::add(), H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), convert\+H\+Mat\+Block\+To\+Rk\+Matrix(), copy\+\_\+hmatrix\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), f\+\_\+h\+\_\+mmult(), f\+\_\+h\+\_\+m\+Tmult(), h\+\_\+f\+\_\+mmult(), h\+\_\+f\+\_\+m\+Tmult(), h\+\_\+rk\+\_\+mmult(), h\+\_\+rk\+\_\+m\+Tmult(), Init\+And\+Create\+H\+Matrix\+Children(), Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc(), Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree(), H\+Matrix$<$ spacedim, Number $>$\+::release(), rk\+\_\+h\+\_\+mmult(), rk\+\_\+h\+\_\+m\+Tmult(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), and H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued().

\mbox{\Hypertarget{classHMatrix_ac30ae65e37ec5e4ccc7de2f6b9ea91e6}\label{classHMatrix_ac30ae65e37ec5e4ccc7de2f6b9ea91e6}} 
\index{H\+Matrix@{H\+Matrix}!col\+\_\+indices@{col\+\_\+indices}}
\index{col\+\_\+indices@{col\+\_\+indices}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{col\+\_\+indices}{col\_indices}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
std\+::vector$<$types\+::global\+\_\+dof\+\_\+index$>$$\ast$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::col\+\_\+indices\hspace{0.3cm}{\ttfamily [private]}}

Pointer to the vector of global column indices, which is stored as the index set in the cluster $\sigma$. It is a subset of $J$. By accessing this vector using indices starting from 0, we actually obtain the mapping from the current matrix\textquotesingle{}s local column indices to the global column indices. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+convert\+To\+Full\+Matrix(), H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), H\+Matrix$<$ spacedim, Number $>$\+::add(), H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), convert\+H\+Mat\+Block\+To\+Rk\+Matrix(), copy\+\_\+hmatrix\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), f\+\_\+h\+\_\+mmult(), f\+\_\+h\+\_\+m\+Tmult(), h\+\_\+f\+\_\+mmult(), h\+\_\+f\+\_\+m\+Tmult(), h\+\_\+rk\+\_\+mmult(), h\+\_\+rk\+\_\+m\+Tmult(), Init\+And\+Create\+H\+Matrix\+Children(), Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc(), Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node(), Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree(), H\+Matrix$<$ spacedim, Number $>$\+::release(), rk\+\_\+h\+\_\+mmult(), rk\+\_\+h\+\_\+m\+Tmult(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::\+Tvmult(), and H\+Matrix$<$ spacedim, Number $>$\+::vmult().

\mbox{\Hypertarget{classHMatrix_a328134c9e9cb2c4b05d5431c0ca8a533}\label{classHMatrix_a328134c9e9cb2c4b05d5431c0ca8a533}} 
\index{H\+Matrix@{H\+Matrix}!fullmatrix@{fullmatrix}}
\index{fullmatrix@{fullmatrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{fullmatrix}{fullmatrix}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
\hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$Number$>$$\ast$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::fullmatrix\hspace{0.3cm}{\ttfamily [private]}}

Pointer to the full matrix. It is not null when the current \hyperlink{classHMatrix}{H\+Matrix} object belongs to the near field. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+convert\+To\+Full\+Matrix(), H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+invert\+\_\+by\+\_\+gauss\+\_\+elim(), H\+Matrix$<$ spacedim, Number $>$\+::add(), H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::compute\+\_\+cholesky\+\_\+factorization(), H\+Matrix$<$ spacedim, Number $>$\+::compute\+\_\+lu\+\_\+factorization(), copy\+\_\+hmatrix\+\_\+node(), f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), H\+Matrix$<$ spacedim, Number $>$\+::get\+\_\+fullmatrix(), h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving(), h\+\_\+h\+\_\+mmult\+\_\+phase2(), h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving(), Init\+And\+Create\+H\+Matrix\+Children(), Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc(), H\+Matrix$<$ spacedim, Number $>$\+::print\+\_\+formatted(), Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree(), H\+Matrix$<$ spacedim, Number $>$\+::release(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::\+Tvmult(), and H\+Matrix$<$ spacedim, Number $>$\+::vmult().

\mbox{\Hypertarget{classHMatrix_a61dbd471077be0ad8325d0f2afe3d43f}\label{classHMatrix_a61dbd471077be0ad8325d0f2afe3d43f}} 
\index{H\+Matrix@{H\+Matrix}!leaf\+\_\+set@{leaf\+\_\+set}}
\index{leaf\+\_\+set@{leaf\+\_\+set}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{leaf\+\_\+set}{leaf\_set}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
std\+::vector$<$\hyperlink{classHMatrix}{H\+Matrix}$<$spacedim, Number$>$ $\ast$$>$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::leaf\+\_\+set\hspace{0.3cm}{\ttfamily [private]}}

A list of submatrices in the leaf set. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::build\+\_\+leaf\+\_\+set(), H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), copy\+\_\+hmatrix\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::find\+\_\+block\+\_\+cluster\+\_\+in\+\_\+leaf\+\_\+set(), H\+Matrix$<$ spacedim, Number $>$\+::get\+\_\+leaf\+\_\+set(), h\+\_\+h\+\_\+mmult\+\_\+phase2(), H\+Matrix$<$ spacedim, Number $>$\+::refine\+\_\+to\+\_\+supertree(), H\+Matrix$<$ spacedim, Number $>$\+::release(), and H\+Matrix$<$ spacedim, Number $>$\+::write\+\_\+leaf\+\_\+set\+\_\+by\+\_\+iteration().

\mbox{\Hypertarget{classHMatrix_aa5523463043e4d542eae17d262bd22ad}\label{classHMatrix_aa5523463043e4d542eae17d262bd22ad}} 
\index{H\+Matrix@{H\+Matrix}!m@{m}}
\index{m@{m}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{m}{m}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
\hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::m\hspace{0.3cm}{\ttfamily [private]}}

Total number of rows in the matrix. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+convert\+To\+Full\+Matrix(), H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+invert\+\_\+by\+\_\+gauss\+\_\+elim(), H\+Matrix$<$ spacedim, Number $>$\+::add(), H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::convert\+To\+Full\+Matrix(), copy\+\_\+hmatrix\+\_\+node(), f\+\_\+h\+\_\+mmult(), f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), f\+\_\+h\+\_\+m\+Tmult(), H\+Matrix$<$ spacedim, Number $>$\+::get\+\_\+m(), h\+\_\+f\+\_\+mmult(), h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), h\+\_\+f\+\_\+m\+Tmult(), h\+\_\+rk\+\_\+mmult(), h\+\_\+rk\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), h\+\_\+rk\+\_\+m\+Tmult(), Init\+And\+Create\+H\+Matrix\+Children(), Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc(), Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node(), Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree(), H\+Matrix$<$ spacedim, Number $>$\+::release(), rk\+\_\+h\+\_\+mmult(), rk\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), rk\+\_\+h\+\_\+m\+Tmult(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::\+Tvmult(), and H\+Matrix$<$ spacedim, Number $>$\+::vmult().

\mbox{\Hypertarget{classHMatrix_ab5ae2eb472f81f80653ed4411629c2d1}\label{classHMatrix_ab5ae2eb472f81f80653ed4411629c2d1}} 
\index{H\+Matrix@{H\+Matrix}!n@{n}}
\index{n@{n}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{n}{n}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
\hyperlink{classHMatrix_a5ca8dc549783d38371a01ecd621ecb34}{size\+\_\+type} \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::n\hspace{0.3cm}{\ttfamily [private]}}

Total number of columns in the matrix. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+convert\+To\+Full\+Matrix(), H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+invert\+\_\+by\+\_\+gauss\+\_\+elim(), H\+Matrix$<$ spacedim, Number $>$\+::add(), H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::convert\+To\+Full\+Matrix(), copy\+\_\+hmatrix\+\_\+node(), f\+\_\+h\+\_\+mmult(), f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), f\+\_\+h\+\_\+m\+Tmult(), H\+Matrix$<$ spacedim, Number $>$\+::get\+\_\+n(), h\+\_\+f\+\_\+mmult(), h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), h\+\_\+f\+\_\+m\+Tmult(), h\+\_\+rk\+\_\+mmult(), h\+\_\+rk\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), h\+\_\+rk\+\_\+m\+Tmult(), Init\+And\+Create\+H\+Matrix\+Children(), Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc(), Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node(), Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree(), H\+Matrix$<$ spacedim, Number $>$\+::release(), rk\+\_\+h\+\_\+mmult(), rk\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), rk\+\_\+h\+\_\+m\+Tmult(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::\+Tvmult(), and H\+Matrix$<$ spacedim, Number $>$\+::vmult().

\mbox{\Hypertarget{classHMatrix_a71690997092a4142799b2fa2dbf53db4}\label{classHMatrix_a71690997092a4142799b2fa2dbf53db4}} 
\index{H\+Matrix@{H\+Matrix}!parent@{parent}}
\index{parent@{parent}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{parent}{parent}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
\hyperlink{classHMatrix}{H\+Matrix}$<$spacedim, Number$>$$\ast$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::parent\hspace{0.3cm}{\ttfamily [private]}}

Pointer to the parent $\mathcal{H}$-\/matrix. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), copy\+\_\+hmatrix(), copy\+\_\+hmatrix\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::find\+\_\+col\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block(), H\+Matrix$<$ spacedim, Number $>$\+::find\+\_\+row\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block(), Init\+And\+Create\+H\+Matrix\+Children(), Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc(), H\+Matrix$<$ spacedim, Number $>$\+::print\+\_\+current\+\_\+matrix\+\_\+info(), Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree(), and H\+Matrix$<$ spacedim, Number $>$\+::release().

\mbox{\Hypertarget{classHMatrix_aa97a8f5e42aba0f1d5faf41f35a27819}\label{classHMatrix_aa97a8f5e42aba0f1d5faf41f35a27819}} 
\index{H\+Matrix@{H\+Matrix}!rkmatrix@{rkmatrix}}
\index{rkmatrix@{rkmatrix}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{rkmatrix}{rkmatrix}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
\hyperlink{classRkMatrix}{Rk\+Matrix}$<$Number$>$$\ast$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::rkmatrix\hspace{0.3cm}{\ttfamily [private]}}

Pointer to the rank-\/k matrix. It is not null when the current \hyperlink{classHMatrix}{H\+Matrix} object belongs to the far field. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+convert\+To\+Full\+Matrix(), H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), H\+Matrix$<$ spacedim, Number $>$\+::add(), H\+Matrix$<$ spacedim, Number $>$\+::calc\+\_\+rank\+\_\+upper\+\_\+bound\+\_\+for\+\_\+rkmatrices(), H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), convert\+H\+Mat\+Block\+To\+Rk\+Matrix(), copy\+\_\+hmatrix\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::get\+\_\+rkmatrix(), h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving(), h\+\_\+h\+\_\+mmult\+\_\+phase2(), h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving(), h\+\_\+rk\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), Init\+And\+Create\+H\+Matrix\+Children(), Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc(), H\+Matrix$<$ spacedim, Number $>$\+::print\+\_\+formatted(), Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree(), H\+Matrix$<$ spacedim, Number $>$\+::release(), rk\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::truncate\+\_\+to\+\_\+rank(), H\+Matrix$<$ spacedim, Number $>$\+::\+Tvmult(), and H\+Matrix$<$ spacedim, Number $>$\+::vmult().

\mbox{\Hypertarget{classHMatrix_a4d64145335fc0521603b206a22a67578}\label{classHMatrix_a4d64145335fc0521603b206a22a67578}} 
\index{H\+Matrix@{H\+Matrix}!row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map@{row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}}
\index{row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map@{row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map}{row\_index\_global\_to\_local\_map}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
std\+::map$<$types\+::global\+\_\+dof\+\_\+index, size\+\_\+t$>$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::row\+\_\+index\+\_\+global\+\_\+to\+\_\+local\+\_\+map\hspace{0.3cm}{\ttfamily [private]}}

Map from local row indices to global row indices for the cluster $\tau$. The set of local row indices is the range $[0, \#\tau - 1]$. The corresponding set of global row indices is a subset of $I$.


\begin{DoxyDescription}
\item[Note ]This mapping is only constructed for H-\/matrices in the leaf set. 
\end{DoxyDescription}

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), H\+Matrix$<$ spacedim, Number $>$\+::add(), H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), convert\+H\+Mat\+Block\+To\+Rk\+Matrix(), copy\+\_\+hmatrix\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), f\+\_\+h\+\_\+mmult(), f\+\_\+h\+\_\+m\+Tmult(), h\+\_\+f\+\_\+mmult(), h\+\_\+f\+\_\+m\+Tmult(), h\+\_\+rk\+\_\+mmult(), h\+\_\+rk\+\_\+m\+Tmult(), Init\+And\+Create\+H\+Matrix\+Children(), Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc(), Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree(), H\+Matrix$<$ spacedim, Number $>$\+::release(), rk\+\_\+h\+\_\+mmult(), rk\+\_\+h\+\_\+m\+Tmult(), and H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued().

\mbox{\Hypertarget{classHMatrix_a33b3a936f1b40e320e96d47471da07ae}\label{classHMatrix_a33b3a936f1b40e320e96d47471da07ae}} 
\index{H\+Matrix@{H\+Matrix}!row\+\_\+indices@{row\+\_\+indices}}
\index{row\+\_\+indices@{row\+\_\+indices}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{row\+\_\+indices}{row\_indices}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
std\+::vector$<$types\+::global\+\_\+dof\+\_\+index$>$$\ast$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::row\+\_\+indices\hspace{0.3cm}{\ttfamily [private]}}

Pointer to the vector of global row indices, which is stored as the index in the cluster $\tau$. It is a subset of $I$. By accessing this vector using indices starting from 0, we actually obtain the mapping from the current matrix\textquotesingle{}s local row indices to the global row indices. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+convert\+To\+Full\+Matrix(), H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), H\+Matrix$<$ spacedim, Number $>$\+::add(), H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), convert\+H\+Mat\+Block\+To\+Rk\+Matrix(), copy\+\_\+hmatrix\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), f\+\_\+h\+\_\+mmult(), f\+\_\+h\+\_\+m\+Tmult(), h\+\_\+f\+\_\+mmult(), h\+\_\+f\+\_\+m\+Tmult(), h\+\_\+rk\+\_\+mmult(), h\+\_\+rk\+\_\+m\+Tmult(), Init\+And\+Create\+H\+Matrix\+Children(), Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc(), Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node(), Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree(), H\+Matrix$<$ spacedim, Number $>$\+::release(), rk\+\_\+h\+\_\+mmult(), rk\+\_\+h\+\_\+m\+Tmult(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::\+Tvmult(), and H\+Matrix$<$ spacedim, Number $>$\+::vmult().

\mbox{\Hypertarget{classHMatrix_aa659b6df63d533432ec1a24435cd9c40}\label{classHMatrix_aa659b6df63d533432ec1a24435cd9c40}} 
\index{H\+Matrix@{H\+Matrix}!Sigma\+\_\+F@{Sigma\+\_\+F}}
\index{Sigma\+\_\+F@{Sigma\+\_\+F}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{Sigma\+\_\+F}{Sigma\_F}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
std\+::vector$<$\hyperlink{classLAPACKFullMatrixExt}{L\+A\+P\+A\+C\+K\+Full\+Matrix\+Ext}$<$Number$>$ $\ast$$>$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::Sigma\+\_\+F\hspace{0.3cm}{\ttfamily [private]}}

List of full matrix pointers used in $\mathcal{H}$-\/matrix multiplication. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), copy\+\_\+hmatrix\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), h\+\_\+h\+\_\+mmult\+\_\+phase2(), h\+\_\+rk\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node(), H\+Matrix$<$ spacedim, Number $>$\+::print\+\_\+current\+\_\+matrix\+\_\+info(), H\+Matrix$<$ spacedim, Number $>$\+::release(), and rk\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult().

\mbox{\Hypertarget{classHMatrix_a3d96d0252ef8c873ae06cf87874acaf3}\label{classHMatrix_a3d96d0252ef8c873ae06cf87874acaf3}} 
\index{H\+Matrix@{H\+Matrix}!Sigma\+\_\+P@{Sigma\+\_\+P}}
\index{Sigma\+\_\+P@{Sigma\+\_\+P}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{Sigma\+\_\+P}{Sigma\_P}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
std\+::vector$<$ std\+::pair$<$\hyperlink{classHMatrix}{H\+Matrix}$<$spacedim, Number$>$ $\ast$, \hyperlink{classHMatrix}{H\+Matrix}$<$spacedim, Number$>$ $\ast$$>$ $>$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::Sigma\+\_\+P\hspace{0.3cm}{\ttfamily [private]}}

List of pairs of pointers to $\mathcal{H}$-\/matrix nodes for multiplication. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), copy\+\_\+hmatrix\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::determine\+\_\+mm\+\_\+split\+\_\+mode\+\_\+from\+\_\+\+Sigma\+\_\+\+P(), f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), h\+\_\+h\+\_\+mmult\+\_\+phase1\+\_\+recursion(), h\+\_\+h\+\_\+mmult\+\_\+phase2(), H\+Matrix$<$ spacedim, Number $>$\+::h\+\_\+h\+\_\+mmult\+\_\+reduction(), h\+\_\+rk\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node(), H\+Matrix$<$ spacedim, Number $>$\+::print\+\_\+current\+\_\+matrix\+\_\+info(), H\+Matrix$<$ spacedim, Number $>$\+::release(), H\+Matrix$<$ spacedim, Number $>$\+::remove\+\_\+hmat\+\_\+pair\+\_\+from\+\_\+mm\+\_\+product\+\_\+list(), and rk\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult().

\mbox{\Hypertarget{classHMatrix_a04d341b4e606d1be2d71b8ea636efe7b}\label{classHMatrix_a04d341b4e606d1be2d71b8ea636efe7b}} 
\index{H\+Matrix@{H\+Matrix}!Sigma\+\_\+R@{Sigma\+\_\+R}}
\index{Sigma\+\_\+R@{Sigma\+\_\+R}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{Sigma\+\_\+R}{Sigma\_R}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
std\+::vector$<$\hyperlink{classRkMatrix}{Rk\+Matrix}$<$Number$>$ $\ast$$>$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::Sigma\+\_\+R\hspace{0.3cm}{\ttfamily [private]}}

List of rank-\/k matrix pointers used in $\mathcal{H}$-\/matrix multiplication. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), copy\+\_\+hmatrix\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), h\+\_\+h\+\_\+mmult\+\_\+phase2(), h\+\_\+rk\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), Init\+H\+Matrix\+Wrt\+Block\+Cluster\+Node(), H\+Matrix$<$ spacedim, Number $>$\+::print\+\_\+current\+\_\+matrix\+\_\+info(), H\+Matrix$<$ spacedim, Number $>$\+::release(), and rk\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult().

\mbox{\Hypertarget{classHMatrix_a4bd1b9a32f2c7693e603a7c6ea916e4f}\label{classHMatrix_a4bd1b9a32f2c7693e603a7c6ea916e4f}} 
\index{H\+Matrix@{H\+Matrix}!submatrices@{submatrices}}
\index{submatrices@{submatrices}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{submatrices}{submatrices}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
std\+::vector$<$\hyperlink{classHMatrix}{H\+Matrix}$<$spacedim, Number$>$ $\ast$$>$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::submatrices\hspace{0.3cm}{\ttfamily [private]}}

A list of submatrices of type $\mathcal{H}$-\/matrix. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+build\+\_\+leaf\+\_\+set(), H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+convert\+To\+Full\+Matrix(), H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+invert\+\_\+by\+\_\+gauss\+\_\+elim(), H\+Matrix$<$ spacedim, Number $>$\+::add(), H\+Matrix$<$ spacedim, Number $>$\+::calc\+\_\+rank\+\_\+upper\+\_\+bound\+\_\+for\+\_\+rkmatrices(), H\+Matrix$<$ spacedim, Number $>$\+::clear(), H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::coarsen\+\_\+to\+\_\+partition(), H\+Matrix$<$ spacedim, Number $>$\+::compute\+\_\+cholesky\+\_\+factorization(), H\+Matrix$<$ spacedim, Number $>$\+::compute\+\_\+lu\+\_\+factorization(), convert\+H\+Mat\+Block\+To\+Rk\+Matrix(), copy\+\_\+hmatrix(), copy\+\_\+hmatrix\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), H\+Matrix$<$ spacedim, Number $>$\+::find\+\_\+col\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block(), H\+Matrix$<$ spacedim, Number $>$\+::find\+\_\+row\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block(), H\+Matrix$<$ spacedim, Number $>$\+::get\+\_\+submatrices(), h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving(), h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving(), Init\+And\+Create\+H\+Matrix\+Children(), Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc(), H\+Matrix$<$ spacedim, Number $>$\+::print\+\_\+current\+\_\+matrix\+\_\+info(), H\+Matrix$<$ spacedim, Number $>$\+::print\+\_\+formatted(), H\+Matrix$<$ spacedim, Number $>$\+::print\+\_\+matrix\+\_\+info(), Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree(), H\+Matrix$<$ spacedim, Number $>$\+::release(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::truncate\+\_\+to\+\_\+rank(), H\+Matrix$<$ spacedim, Number $>$\+::truncate\+\_\+to\+\_\+rank\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite(), H\+Matrix$<$ spacedim, Number $>$\+::truncate\+\_\+to\+\_\+rank\+\_\+off\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite(), H\+Matrix$<$ spacedim, Number $>$\+::\+Tvmult(), H\+Matrix$<$ spacedim, Number $>$\+::vmult(), and H\+Matrix$<$ spacedim, Number $>$\+::write\+\_\+leaf\+\_\+set().

\mbox{\Hypertarget{classHMatrix_a64c851dd63ba1a466c19f451be369475}\label{classHMatrix_a64c851dd63ba1a466c19f451be369475}} 
\index{H\+Matrix@{H\+Matrix}!submatrix\+\_\+index@{submatrix\+\_\+index}}
\index{submatrix\+\_\+index@{submatrix\+\_\+index}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{submatrix\+\_\+index}{submatrix\_index}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
unsigned int \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::submatrix\+\_\+index\hspace{0.3cm}{\ttfamily [private]}}

Submatrix index of the current $\mathcal{H}$-\/matrix node wrt. its parent $\mathcal{H}$-\/matrix node. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), copy\+\_\+hmatrix\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::find\+\_\+col\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block(), H\+Matrix$<$ spacedim, Number $>$\+::find\+\_\+row\+\_\+diag\+\_\+block\+\_\+for\+\_\+offdiag\+\_\+block(), Init\+And\+Create\+H\+Matrix\+Children(), Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc(), H\+Matrix$<$ spacedim, Number $>$\+::print\+\_\+current\+\_\+matrix\+\_\+info(), Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree(), and H\+Matrix$<$ spacedim, Number $>$\+::release().

\mbox{\Hypertarget{classHMatrix_a8b5a9fb65c716187d95bcdb43542884c}\label{classHMatrix_a8b5a9fb65c716187d95bcdb43542884c}} 
\index{H\+Matrix@{H\+Matrix}!submatrix\+\_\+index\+\_\+invalid@{submatrix\+\_\+index\+\_\+invalid}}
\index{submatrix\+\_\+index\+\_\+invalid@{submatrix\+\_\+index\+\_\+invalid}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{submatrix\+\_\+index\+\_\+invalid}{submatrix\_index\_invalid}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
const unsigned int \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::submatrix\+\_\+index\+\_\+invalid = 9\hspace{0.3cm}{\ttfamily [static]}}

Invalid submatrix index of the current $\mathcal{H}$-\/matrix node wrt. its parent $\mathcal{H}$-\/matrix node, which is used for initializing the {\ttfamily submatrix\+\_\+index} member variable. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), and H\+Matrix$<$ spacedim, Number $>$\+::release().

\mbox{\Hypertarget{classHMatrix_a12da9454687e5ca15837d63e2bf0b595}\label{classHMatrix_a12da9454687e5ca15837d63e2bf0b595}} 
\index{H\+Matrix@{H\+Matrix}!Tind@{Tind}}
\index{Tind@{Tind}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{Tind}{Tind}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
\hyperlink{classBlockClusterTree}{Block\+Cluster\+Tree}$<$spacedim, Number$>$ \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::Tind\hspace{0.3cm}{\ttfamily [private]}}

Block cluster tree when this matrix is the product of two $\mathcal{H}$-\/matrices. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), copy\+\_\+hmatrix\+\_\+node(), h\+\_\+h\+\_\+mmult\+\_\+phase2(), H\+Matrix$<$ spacedim, Number $>$\+::mmult(), and H\+Matrix$<$ spacedim, Number $>$\+::release().

\mbox{\Hypertarget{classHMatrix_a89ef60f3ba737c04708195ca0bb13620}\label{classHMatrix_a89ef60f3ba737c04708195ca0bb13620}} 
\index{H\+Matrix@{H\+Matrix}!type@{type}}
\index{type@{type}!H\+Matrix@{H\+Matrix}}
\subsubsection{\texorpdfstring{type}{type}}
{\footnotesize\ttfamily template$<$int spacedim, typename Number = double$>$ \\
\hyperlink{hmatrix_8h_ac04719e202c88f36e4533fe1d326a494}{H\+Matrix\+Type} \hyperlink{classHMatrix}{H\+Matrix}$<$ spacedim, Number $>$\+::type\hspace{0.3cm}{\ttfamily [private]}}

Matrix type. 

Referenced by H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+build\+\_\+leaf\+\_\+set(), H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+convert\+To\+Full\+Matrix(), H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+distribute\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), H\+Matrix$<$ spacedim, Number $>$\+::\+\_\+invert\+\_\+by\+\_\+gauss\+\_\+elim(), H\+Matrix$<$ spacedim, Number $>$\+::add(), H\+Matrix$<$ spacedim, Number $>$\+::calc\+\_\+rank\+\_\+upper\+\_\+bound\+\_\+for\+\_\+rkmatrices(), H\+Matrix$<$ spacedim, Number $>$\+::clear(), H\+Matrix$<$ spacedim, Number $>$\+::clear\+\_\+hmat\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::compute\+\_\+cholesky\+\_\+factorization(), H\+Matrix$<$ spacedim, Number $>$\+::compute\+\_\+lu\+\_\+factorization(), convert\+H\+Mat\+Block\+To\+Rk\+Matrix(), copy\+\_\+hmatrix\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::distribute\+\_\+all\+\_\+non\+\_\+leaf\+\_\+nodes\+\_\+sigma\+\_\+r\+\_\+and\+\_\+f\+\_\+to\+\_\+leaves(), f\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), H\+Matrix$<$ spacedim, Number $>$\+::get\+\_\+type(), h\+\_\+f\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), h\+\_\+h\+\_\+mmult\+\_\+level\+\_\+conserving(), h\+\_\+h\+\_\+mmult\+\_\+phase2(), H\+Matrix$<$ spacedim, Number $>$\+::h\+\_\+h\+\_\+mmult\+\_\+reduction(), h\+\_\+h\+\_\+m\+Tmult\+\_\+level\+\_\+conserving(), h\+\_\+rk\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), Init\+And\+Create\+H\+Matrix\+Children(), Init\+And\+Create\+H\+Matrix\+Children\+Without\+Alloc(), H\+Matrix$<$ spacedim, Number $>$\+::print\+\_\+formatted(), Refine\+H\+Matrix\+Wrt\+Extended\+Block\+Cluster\+Tree(), H\+Matrix$<$ spacedim, Number $>$\+::release(), rk\+\_\+h\+\_\+mmult\+\_\+for\+\_\+h\+\_\+h\+\_\+mmult(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+block\+\_\+triangular\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+by\+\_\+backward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+cholesky\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution(), H\+Matrix$<$ spacedim, Number $>$\+::solve\+\_\+transpose\+\_\+by\+\_\+forward\+\_\+substitution\+\_\+matrix\+\_\+valued(), H\+Matrix$<$ spacedim, Number $>$\+::truncate\+\_\+to\+\_\+rank(), H\+Matrix$<$ spacedim, Number $>$\+::truncate\+\_\+to\+\_\+rank\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite(), H\+Matrix$<$ spacedim, Number $>$\+::truncate\+\_\+to\+\_\+rank\+\_\+off\+\_\+diag\+\_\+preserve\+\_\+positive\+\_\+definite(), H\+Matrix$<$ spacedim, Number $>$\+::\+Tvmult(), H\+Matrix$<$ spacedim, Number $>$\+::vmult(), H\+Matrix$<$ spacedim, Number $>$\+::write\+\_\+fullmatrix\+\_\+leaf\+\_\+node(), H\+Matrix$<$ spacedim, Number $>$\+::write\+\_\+leaf\+\_\+set(), H\+Matrix$<$ spacedim, Number $>$\+::write\+\_\+leaf\+\_\+set\+\_\+by\+\_\+iteration(), and H\+Matrix$<$ spacedim, Number $>$\+::write\+\_\+rkmatrix\+\_\+leaf\+\_\+node().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/jihuan/\+Projects/deal.\+ii/program/dealii-\/9.\+1.\+1/examples/laplace-\/bem/include/\hyperlink{hmatrix_8h}{hmatrix.\+h}\end{DoxyCompactItemize}
