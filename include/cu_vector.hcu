/**
 * @file cu_vector.hcu
 * @brief Introduction of cu_vector.hcu
 *
 * @date 2023-02-09
 * @author Jihuan Tian
 */
#ifndef INCLUDE_CU_VECTOR_HCU_
#define INCLUDE_CU_VECTOR_HCU_

#include <assert.h>

namespace HierBEM
{
  namespace CUDAWrappers
  {
    /**
     * Wrapper class for a vector of values, which has no memory management.
     *
     * @tparam T
     */
    template <typename T = double>
    class CUDAVector
    {
    public:
      using pointer         = T *;
      using const_pointer   = const T *;
      using reference       = T &;
      using const_reference = const T &;
      using size_type       = std::size_t;

      /**
       * Default constructor.
       */
      __host__ __device__
      CUDAVector();

      /**
       * Constructor from a pointer allocated with memory and specified vector
       * size.
       *
       * @param p
       * @param n
       */
      __host__ __device__
      CUDAVector(pointer p, const size_type _n);

      /**
       * Deep copy constructor is disabled. Since this class has no
       * memory allocation because all memory allocation on GPU has been
       * performed in the host code by calling @p cudaMalloc, the copy
       * constructor is disabled.
       *
       * @param
       */
      __host__ __device__
      CUDAVector(const CUDAVector<T> &) = delete;

      /**
       * Shallow copy constructor is still available.
       *
       * @param vec
       */
      __host__ __device__
      CUDAVector(CUDAVector<T> &&vec);

      /**
       * Deep assignment. N.B. The target vector must have the same number of
       * entries as the source vector.
       *
       * @param vec
       * @return
       */
      __host__ __device__ CUDAVector<T>                     &
      operator=(const CUDAVector<T> &vec);

      /**
       * Shallow assignment.
       *
       * @param vec
       * @return
       */
      __host__ __device__ CUDAVector<T>                     &
      operator=(CUDAVector<T> &&vec);


      /**
       * Fill the vector from the source data pointer.
       *
       * @param data
       * @param source_offset
       * @param target_offset
       */
      __host__ __device__ void
      fill(const size_type n_elements_for_copy,
           const_pointer   data,
           const size_type source_offset = 0,
           const size_type target_offset = 0);

      /**
       * Get the vector size.
       *
       * @return
       */
      __host__ __device__ size_type
      size() const;

      /**
       * Get the internal data pointer.
       *
       * @return
       */
      __host__ __device__ pointer
      data();

      /**
       * Get the internal data pointer (const version).
       *
       * @return
       */
      __host__ __device__ const_pointer
      data() const;

      /**
       * Get the reference to the i'th element in the vector.
       */
      __host__ __device__ reference
      operator()(const size_type i);

      /**
       * Get the reference to the i'th element in the vector.
       *
       * @param i
       * @return
       */
      __host__ __device__ reference
      operator[](const size_type i);

      /**
       * Get the const reference to the i'th element in the vector.
       *
       * @param i
       * @return
       */
      __host__ __device__ const_reference
      operator()(const size_type i) const;

      /**
       * Get the const reference to the i'th element in the vector.
       *
       * @param i
       * @return
       */
      __host__ __device__ const_reference
      operator[](const size_type i) const;

      /**
       * Print all the values in the vector.
       */
      __host__ __device__ void
      print(const bool scientific = true) const;

      /**
       * Set all vector entries to zero.
       */
      __host__ __device__ void
      reinit();

    private:
      pointer   values;
      size_type n;
    };


    template <typename T>
    __host__ __device__
    CUDAVector<T>::CUDAVector()
      : values(nullptr)
      , n(0)
    {}


    template <typename T>
    __host__ __device__
    CUDAVector<T>::CUDAVector(pointer p, const size_type _n)
      : values(p)
      , n(_n)
    {}


    template <typename T>
    __host__ __device__
    CUDAVector<T>::CUDAVector(CUDAVector<T> &&vec)
      : values(vec.values)
      , n(vec.n)
    {}


    template <typename T>
    __host__ __device__ CUDAVector<T>                     &
    CUDAVector<T>::operator=(const CUDAVector<T> &vec)
    {
      assert(n == vec.n);

      for (size_t i = 0; i < vec.n; i++)
        {
          values[i] = vec.values[i];
        }

      return *this;
    }


    template <typename T>
    __host__ __device__ CUDAVector<T>                     &
    CUDAVector<T>::operator=(CUDAVector<T> &&vec)
    {
      values = vec.values;
      n      = vec.n;

      return *this;
    }


    template <typename T>
    __host__ __device__ void
    CUDAVector<T>::fill(const size_type n_elements_for_copy,
                        const_pointer   data,
                        const size_type source_offset,
                        const size_type target_offset)
    {
      [[maybe_unused]] const size_type allowed_n_elements_for_copy =
        n - target_offset;

      assert(n_elements_for_copy <= allowed_n_elements_for_copy);

      for (size_type i = 0; i < n_elements_for_copy; i++)
        {
          values[target_offset + i] = data[source_offset + i];
        }
    }


    template <typename T>
    __host__ __device__ inline typename CUDAVector<T>::size_type
             CUDAVector<T>::size() const
    {
      return n;
    }


    template <typename T>
    __host__ __device__ inline typename CUDAVector<T>::pointer
             CUDAVector<T>::data()
    {
      return values;
    }


    template <typename T>
    __host__ __device__ inline typename CUDAVector<T>::const_pointer
             CUDAVector<T>::data() const
    {
      return values;
    }


    template <typename T>
    __host__ __device__ inline typename CUDAVector<T>::reference
             CUDAVector<T>::operator()(const size_type i)
    {
      return values[i];
    }


    template <typename T>
    __host__ __device__ inline typename CUDAVector<T>::reference
             CUDAVector<T>::operator[](const size_type i)
    {
      return values[i];
    }


    template <typename T>
    __host__ __device__ inline typename CUDAVector<T>::const_reference
             CUDAVector<T>::operator()(const size_type i) const
    {
      return values[i];
    }


    template <typename T>
    __host__ __device__ inline typename CUDAVector<T>::const_reference
             CUDAVector<T>::operator[](const size_type i) const
    {
      return values[i];
    }


    template <typename T>
    __host__ __device__ void
    CUDAVector<T>::print(const bool scientific) const
    {
      for (size_type i = 0; i < n; i++)
        {
          if (scientific)
            {
              printf("%20.8e\n", values[i]);
            }
          else
            {
              printf("%20.8f\n", values[i]);
            }
        }
    }


    template <typename T>
    __host__ __device__ void
    CUDAVector<T>::reinit()
    {
      for (size_type i = 0; i < n; i++)
        {
          values[i] = 0;
        }
    }
  } // namespace CUDAWrappers
} // namespace HierBEM



#endif /* INCLUDE_CU_VECTOR_HCU_ */
