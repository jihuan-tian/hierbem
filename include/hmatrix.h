/**
 * \file hmatrix.h
 * \brief Definition of hierarchical matrix.
 * \ingroup hierarchical_matrices
 * \date 2021-06-06
 * \author Jihuan Tian
 */

#ifndef INCLUDE_HMATRIX_H_
#define INCLUDE_HMATRIX_H_

#include <deal.II/base/logstream.h>

#include <deal.II/lac/full_matrix.h>

#include <tbb/tbb.h>

#include <algorithm>
#include <fstream>
#include <iostream>
#include <mutex>
#include <queue>
#include <sstream>
#include <string>
#include <utility>
#include <vector>

#include "block_cluster.h"
#include "block_cluster_tree.h"
#include "config.h"
#include "generic_functors.h"
#include "hmatrix_support.h"
#include "lapack_full_matrix_ext.h"
#include "rkmatrix.h"

namespace HierBEM
{
  using namespace dealii;

  /**
   * Matrix type of an HMaxtrix, which can be full matrix in the near field,
   * rank-k matrix in the far field and hierarchical matrix which does not
   * belong to the leaf set of a block cluster tree.
   */
  enum HMatrixType
  {
    FullMatrixType,         //!< FullMatrixType
    RkMatrixType,           //!< RkMatrixType
    HierarchicalMatrixType, //!< HierarchicalType
    UndefinedMatrixType     //!< UndefinedMatrixType
  };

  /**
   * Exception for invalid \hmatrix node type (@p HMatrixType).
   */
  DeclException1(ExcInvalidHMatrixType,
                 HMatrixType,
                 << "Invalid H-matrix node type: " << arg1);

  /**
   * Exception for invalid \hmatrix node state (@p HMatrixSupport:State).
   */
  DeclException1(ExcInvalidHMatrixState,
                 HMatrixSupport::State,
                 << "Invalid H-matrix node state: " << arg1);

  /**
   * Exception for invalid \hmatrix node property (@p HMatrixSupport::Property).
   */
  DeclException1(ExcInvalidHMatrixProperty,
                 HMatrixSupport::Property,
                 << "Invalid H-matrix node property: " << arg1);

  /**
   * Exception for invalid \hmatrix node block type
   * (@p HMatrixSupport::BlockType).
   */
  DeclException1(ExcInvalidHMatrixBlockType,
                 HMatrixSupport::BlockType,
                 << "Invalid H-matrix node block type: " << arg1);

  template <int spacedim, typename Number = double>
  class HMatrix
  {
  public:
    /**
     * Declare the type for container size.
     */
    using size_type = std::make_unsigned<types::blas_int>::type;

    /**
     * Space-filling curve used for traversing the leaf nodes of the H-matrix.
     */
    enum SpaceFillingCurveType
    {
      /**
       * Z curve, which is obtained from a depth-first-search (DFS).
       */
      Z,
      /**
       * Hilbert curve
       */
      Hilbert
    };

    /**
     * BLock type during leaf node traversal by following the Hilbert curve.
     */
    enum HilbertBlockType
    {
      A,
      B,
      C,
      D
    };

    static void
    set_leaf_set_traversal_method(const SpaceFillingCurveType type)
    {
      leaf_set_traversal_method = type;
    }

    /**
     * Declare the type for TBB flow graph node.
     */
    using TaskNode    = tbb::flow::continue_node<tbb::flow::continue_msg>;
    using TaskNodePtr = std::shared_ptr<TaskNode>;

    /**
     * Class for the task node storing an @p update task which is used H-LU or
     * H-Cholesky factorization.
     *
     * N.B. An @p update task is performed with respect to a diagonal block on
     * a specific level. For a H-matrix node, there may be several such
     * @p update tasks on different levels. Therefore, this class also stores
     * the pointer to the said diagonal block.
     */
    class UpdateTaskNodeForLUOrCholesky
    {
    public:
      UpdateTaskNodeForLUOrCholesky(HMatrix<spacedim, Number> *diag,
                                    TaskNodePtr                node)
        : diagonal_hmat_node(diag)
        , update(node)
      {}

      /**
       * Estimate of the memory consumption.
       *
       * N.B. This is not accurate.
       */
      std::size_t
      memory_consumption() const
      {
        return sizeof(*this);
      }

      HMatrix    *diagonal_hmat_node;
      TaskNodePtr update;
    };

    template <int spacedim1, typename Number1>
    friend void
    InitHMatrixWrtBlockClusterNode(
      HMatrix<spacedim1, Number1> &hmat,
      typename BlockClusterTree<spacedim1, Number1>::node_const_pointer_type
        bc_node);

    template <int spacedim1, typename Number1>
    friend void
    InitHMatrixWrtBlockClusterNode(
      HMatrix<spacedim1, Number1> &hmat,
      typename BlockClusterTree<spacedim1, Number1>::node_const_pointer_type
                                                                   bc_node,
      const std::vector<std::pair<HMatrix<spacedim1, Number1> *,
                                  HMatrix<spacedim1, Number1> *>> &Sigma_P);

    template <int spacedim1, typename Number1>
    friend void
    InitHMatrixWrtBlockClusterNode(
      HMatrix<spacedim1, Number1> &hmat,
      typename BlockClusterTree<spacedim1, Number1>::node_const_pointer_type
                                                      bc_node,
      const std::pair<HMatrix<spacedim1, Number1> *,
                      HMatrix<spacedim1, Number1> *> &hmat_pair);

    template <int spacedim1, typename Number1>
    friend void
    InitAndCreateHMatrixChildrenWithoutAlloc(
      HMatrix<spacedim1, Number1> *hmat,
      typename BlockClusterTree<spacedim1, Number1>::node_const_pointer_type
        bc_node);

    template <int spacedim1, typename Number1>
    friend void
    InitAndCreateHMatrixChildren(
      HMatrix<spacedim1, Number1> *hmat,
      typename BlockClusterTree<spacedim1, Number1>::node_const_pointer_type
                                     bc_node,
      const unsigned int             fixed_rank_k,
      const HMatrixSupport::Property top_hmat_node_property);

    template <int spacedim1, typename Number1>
    friend void
    InitAndCreateHMatrixChildren(
      HMatrix<spacedim1, Number1> *hmat,
      typename BlockClusterTree<spacedim1, Number1>::node_const_pointer_type
                                          bc_node,
      const unsigned int                  fixed_rank_k,
      const LAPACKFullMatrixExt<Number1> &M,
      const HMatrixSupport::Property      top_hmat_node_property);

    template <int spacedim1, typename Number1>
    friend void
    InitAndCreateHMatrixChildren(
      HMatrix<spacedim1, Number1> *hmat,
      typename BlockClusterTree<spacedim1, Number1>::node_const_pointer_type
                                          bc_node,
      const LAPACKFullMatrixExt<Number1> &M,
      const HMatrixSupport::Property      top_hmat_node_property);

    template <int spacedim1, typename Number1>
    friend void
    InitAndCreateHMatrixChildren(
      HMatrix<spacedim1, Number1> *hmat,
      typename BlockClusterTree<spacedim1, Number1>::node_const_pointer_type
                                                    bc_node,
      const unsigned int                            fixed_rank_k,
      const LAPACKFullMatrixExt<Number1>           &M,
      const std::array<types::global_dof_index, 2> &M_row_index_range,
      const std::array<types::global_dof_index, 2> &M_col_index_range,
      const HMatrixSupport::Property                top_hmat_node_property);

    template <int spacedim1, typename Number1>
    friend void
    InitAndCreateHMatrixChildren(
      HMatrix<spacedim1, Number1> *hmat,
      typename BlockClusterTree<spacedim1, Number1>::node_const_pointer_type
                                                    bc_node,
      const LAPACKFullMatrixExt<Number1>           &M,
      const std::array<types::global_dof_index, 2> &M_row_index_range,
      const std::array<types::global_dof_index, 2> &M_col_index_range,
      const HMatrixSupport::Property                top_hmat_node_property);

    template <int spacedim1, typename Number1>
    friend void
    InitAndCreateHMatrixChildren(
      HMatrix<spacedim1, Number1> *hmat,
      typename BlockClusterTree<spacedim1, Number1>::node_const_pointer_type
                                    bc_node,
      HMatrix<spacedim1, Number1> &&H);

    template <int spacedim1, typename Number1>
    friend void
    RefineHMatrixWrtExtendedBlockClusterTree(
      HMatrix<spacedim1, Number1> *starting_hmat,
      HMatrix<spacedim1, Number1> *current_hmat);

    template <int spacedim1, typename Number1>
    friend void
    convertHMatBlockToRkMatrix(
      HMatrix<spacedim1, Number1>       *hmat_block,
      const unsigned int                 fixed_rank_k,
      const HMatrix<spacedim1, Number1> *hmat_root_block,
      size_t                            *calling_counter,
      const std::string                 &output_file_base_name);

    // Friend functions for \hmatrix arithmetic operations.
    template <int spacedim1, typename Number1>
    friend void
    h_rk_mmult(HMatrix<spacedim1, Number1> &M1,
               const RkMatrix<Number1>     &M2,
               RkMatrix<Number1>           &M);

    template <int spacedim1, typename Number1>
    friend void
    h_rk_mmult(const Number1                alpha,
               HMatrix<spacedim1, Number1> &M1,
               const RkMatrix<Number1>     &M2,
               RkMatrix<Number1>           &M);

    template <int spacedim1, typename Number1>
    friend void
    h_rk_mTmult(HMatrix<spacedim1, Number1> &M1,
                const RkMatrix<Number1>     &M2,
                RkMatrix<Number1>           &M);

    template <int spacedim1, typename Number1>
    friend void
    h_rk_mTmult(const Number1                alpha,
                HMatrix<spacedim1, Number1> &M1,
                const RkMatrix<Number1>     &M2,
                RkMatrix<Number1>           &M);

    template <int spacedim1, typename Number1>
    friend void
    h_rk_Tmmult(HMatrix<spacedim1, Number1> &M1,
                const RkMatrix<Number1>     &M2,
                RkMatrix<Number1>           &M);

    template <int spacedim1, typename Number1>
    friend void
    h_rk_Tmmult(const Number1                alpha,
                HMatrix<spacedim1, Number1> &M1,
                const RkMatrix<Number1>     &M2,
                RkMatrix<Number1>           &M);

    template <int spacedim1, typename Number1>
    friend void
    h_rk_mmult_for_h_h_mmult(HMatrix<spacedim1, Number1>       *M1,
                             const HMatrix<spacedim1, Number1> *M2,
                             HMatrix<spacedim1, Number1>       *M,
                             bool is_M1M2_last_in_M_Sigma_P);

    template <int spacedim1, typename Number1>
    friend void
    rk_h_mmult(const RkMatrix<Number1>     &M1,
               HMatrix<spacedim1, Number1> &M2,
               RkMatrix<Number1>           &M);

    template <int spacedim1, typename Number1>
    friend void
    rk_h_mmult(const Number1                alpha,
               const RkMatrix<Number1>     &M1,
               HMatrix<spacedim1, Number1> &M2,
               RkMatrix<Number1>           &M);

    template <int spacedim1, typename Number1>
    friend void
    rk_h_mTmult(const RkMatrix<Number1>     &M1,
                HMatrix<spacedim1, Number1> &M2,
                RkMatrix<Number1>           &M);

    template <int spacedim1, typename Number1>
    friend void
    rk_h_mTmult(const Number1                alpha,
                const RkMatrix<Number1>     &M1,
                HMatrix<spacedim1, Number1> &M2,
                RkMatrix<Number1>           &M);

    template <int spacedim1, typename Number1>
    friend void
    rk_h_Tmmult(const RkMatrix<Number1>     &M1,
                HMatrix<spacedim1, Number1> &M2,
                RkMatrix<Number1>           &M);

    template <int spacedim1, typename Number1>
    friend void
    rk_h_Tmmult(const Number1                alpha,
                const RkMatrix<Number1>     &M1,
                HMatrix<spacedim1, Number1> &M2,
                RkMatrix<Number1>           &M);

    template <int spacedim1, typename Number1>
    friend void
    rk_h_mmult_for_h_h_mmult(const HMatrix<spacedim1, Number1> *M1,
                             HMatrix<spacedim1, Number1>       *M2,
                             HMatrix<spacedim1, Number1>       *M,
                             bool is_M1M2_last_in_M_Sigma_P);

    template <int spacedim1, typename Number1>
    friend void
    h_f_mmult(HMatrix<spacedim1, Number1>        &M1,
              const LAPACKFullMatrixExt<Number1> &M2,
              LAPACKFullMatrixExt<Number1>       &M);

    template <int spacedim1, typename Number1>
    friend void
    h_f_mmult(const Number1                       alpha,
              HMatrix<spacedim1, Number1>        &M1,
              const LAPACKFullMatrixExt<Number1> &M2,
              LAPACKFullMatrixExt<Number1>       &M);

    template <int spacedim1, typename Number1>
    friend void
    h_f_mTmult(HMatrix<spacedim1, Number1>        &M1,
               const LAPACKFullMatrixExt<Number1> &M2,
               LAPACKFullMatrixExt<Number1>       &M);

    template <int spacedim1, typename Number1>
    friend void
    h_f_mTmult(const Number1                       alpha,
               HMatrix<spacedim1, Number1>        &M1,
               const LAPACKFullMatrixExt<Number1> &M2,
               LAPACKFullMatrixExt<Number1>       &M);

    template <int spacedim1, typename Number1>
    friend void
    h_f_Tmmult(HMatrix<spacedim1, Number1>        &M1,
               const LAPACKFullMatrixExt<Number1> &M2,
               LAPACKFullMatrixExt<Number1>       &M);

    template <int spacedim1, typename Number1>
    friend void
    h_f_Tmmult(const Number1                       alpha,
               HMatrix<spacedim1, Number1>        &M1,
               const LAPACKFullMatrixExt<Number1> &M2,
               LAPACKFullMatrixExt<Number1>       &M);

    template <int spacedim1, typename Number1>
    friend void
    h_f_mmult(HMatrix<spacedim1, Number1>        &M1,
              const LAPACKFullMatrixExt<Number1> &M2,
              RkMatrix<Number1>                  &M);

    template <int spacedim1, typename Number1>
    friend void
    h_f_mmult(const Number1                       alpha,
              HMatrix<spacedim1, Number1>        &M1,
              const LAPACKFullMatrixExt<Number1> &M2,
              RkMatrix<Number1>                  &M);

    template <int spacedim1, typename Number1>
    friend void
    h_f_mTmult(HMatrix<spacedim1, Number1>        &M1,
               const LAPACKFullMatrixExt<Number1> &M2,
               RkMatrix<Number1>                  &M);

    template <int spacedim1, typename Number1>
    friend void
    h_f_mTmult(const Number1                       alpha,
               HMatrix<spacedim1, Number1>        &M1,
               const LAPACKFullMatrixExt<Number1> &M2,
               RkMatrix<Number1>                  &M);

    template <int spacedim1, typename Number1>
    friend void
    h_f_Tmmult(HMatrix<spacedim1, Number1>        &M1,
               const LAPACKFullMatrixExt<Number1> &M2,
               RkMatrix<Number1>                  &M);

    template <int spacedim1, typename Number1>
    friend void
    h_f_Tmmult(const Number1                       alpha,
               HMatrix<spacedim1, Number1>        &M1,
               const LAPACKFullMatrixExt<Number1> &M2,
               RkMatrix<Number1>                  &M);

    template <int spacedim1, typename Number1>
    friend void
    h_f_mmult_for_h_h_mmult(HMatrix<spacedim1, Number1>       *M1,
                            const HMatrix<spacedim1, Number1> *M2,
                            HMatrix<spacedim1, Number1>       *M,
                            bool is_M1M2_last_in_M_Sigma_P);

    template <int spacedim1, typename Number1>
    friend void
    f_h_mmult(const LAPACKFullMatrixExt<Number1> &M1,
              HMatrix<spacedim1, Number1>        &M2,
              LAPACKFullMatrixExt<Number1>       &M);

    template <int spacedim1, typename Number1>
    friend void
    f_h_mmult(const Number1                       alpha,
              const LAPACKFullMatrixExt<Number1> &M1,
              HMatrix<spacedim1, Number1>        &M2,
              LAPACKFullMatrixExt<Number1>       &M);

    template <int spacedim1, typename Number1>
    friend void
    f_h_mTmult(const LAPACKFullMatrixExt<Number1> &M1,
               HMatrix<spacedim1, Number1>        &M2,
               LAPACKFullMatrixExt<Number1>       &M);

    template <int spacedim1, typename Number1>
    friend void
    f_h_mTmult(const Number1                       alpha,
               const LAPACKFullMatrixExt<Number1> &M1,
               HMatrix<spacedim1, Number1>        &M2,
               LAPACKFullMatrixExt<Number1>       &M);

    template <int spacedim1, typename Number1>
    friend void
    f_h_Tmmult(const LAPACKFullMatrixExt<Number1> &M1,
               HMatrix<spacedim1, Number1>        &M2,
               LAPACKFullMatrixExt<Number1>       &M);

    template <int spacedim1, typename Number1>
    friend void
    f_h_Tmmult(const Number1                       alpha,
               const LAPACKFullMatrixExt<Number1> &M1,
               HMatrix<spacedim1, Number1>        &M2,
               LAPACKFullMatrixExt<Number1>       &M);

    template <int spacedim1, typename Number1>
    friend void
    f_h_mmult(const LAPACKFullMatrixExt<Number1> &M1,
              HMatrix<spacedim1, Number1>        &M2,
              RkMatrix<Number1>                  &M);

    template <int spacedim1, typename Number1>
    friend void
    f_h_mmult(const Number1                       alpha,
              const LAPACKFullMatrixExt<Number1> &M1,
              HMatrix<spacedim1, Number1>        &M2,
              RkMatrix<Number1>                  &M);

    template <int spacedim1, typename Number1>
    friend void
    f_h_mTmult(const LAPACKFullMatrixExt<Number1> &M1,
               HMatrix<spacedim1, Number1>        &M2,
               RkMatrix<Number1>                  &M);

    template <int spacedim1, typename Number1>
    friend void
    f_h_mTmult(const Number1                       alpha,
               const LAPACKFullMatrixExt<Number1> &M1,
               HMatrix<spacedim1, Number1>        &M2,
               RkMatrix<Number1>                  &M);

    template <int spacedim1, typename Number1>
    friend void
    f_h_Tmmult(const LAPACKFullMatrixExt<Number1> &M1,
               HMatrix<spacedim1, Number1>        &M2,
               RkMatrix<Number1>                  &M);

    template <int spacedim1, typename Number1>
    friend void
    f_h_Tmmult(const Number1                       alpha,
               const LAPACKFullMatrixExt<Number1> &M1,
               HMatrix<spacedim1, Number1>        &M2,
               RkMatrix<Number1>                  &M);

    template <int spacedim1, typename Number1>
    friend void
    f_h_mmult_for_h_h_mmult(const HMatrix<spacedim1, Number1> *M1,
                            HMatrix<spacedim1, Number1>       *M2,
                            HMatrix<spacedim1, Number1>       *M,
                            bool is_M1M2_last_in_M_Sigma_P);

    template <int spacedim1, typename Number1>
    friend void
    h_h_mmult_phase1_recursion(HMatrix<spacedim1, Number1>          *M,
                               BlockClusterTree<spacedim1, Number1> &Tind);

    template <int spacedim1, typename Number1>
    friend void
    h_h_mmult_phase2(HMatrix<spacedim1, Number1>          &M,
                     BlockClusterTree<spacedim1, Number1> &target_bc_tree,
                     const unsigned int                    fixed_rank);

    template <int spacedim1, typename Number1>
    friend void
    h_h_mmult_from_leaf_node(
      HMatrix<spacedim1, Number1>    &M0,
      HMatrix<spacedim1, Number1>    &M,
      HMatrix<spacedim1, Number1>    &M1,
      HMatrix<spacedim1, Number1>    &M2,
      const HMatrixSupport::BlockType block_type_for_local_Z,
      const unsigned int              fixed_rank,
      const bool                      is_result_matrix_symm_apriori);

    template <int spacedim1, typename Number1>
    friend void
    h_h_mmult_from_leaf_node(
      HMatrix<spacedim1, Number1>    &M0,
      HMatrix<spacedim1, Number1>    &M,
      const Number1                   alpha,
      HMatrix<spacedim1, Number1>    &M1,
      HMatrix<spacedim1, Number1>    &M2,
      const HMatrixSupport::BlockType block_type_for_local_Z,
      const unsigned int              fixed_rank,
      const bool                      is_result_matrix_store_tril_only);

    template <int spacedim1, typename Number1>
    friend void
    h_h_mmult_from_leaf_node_for_parallel_lu(
      HMatrix<spacedim1, Number1>    &M0,
      HMatrix<spacedim1, Number1>    &M,
      const Number1                   alpha,
      HMatrix<spacedim1, Number1>    &M1,
      HMatrix<spacedim1, Number1>    &M2,
      const HMatrixSupport::BlockType block_type_for_local_Z,
      const unsigned int              fixed_rank,
      const bool                      is_result_matrix_store_tril_only);

    template <int spacedim1, typename Number1>
    friend void
    h_h_mTmult_from_leaf_node(
      HMatrix<spacedim1, Number1>    &M0,
      HMatrix<spacedim1, Number1>    &M,
      HMatrix<spacedim1, Number1>    &M1,
      HMatrix<spacedim1, Number1>    &M2,
      const HMatrixSupport::BlockType block_type_for_local_Z,
      const unsigned int              fixed_rank,
      const bool                      is_result_matrix_store_tril_only);

    template <int spacedim1, typename Number1>
    friend void
    h_h_mTmult_from_leaf_node(
      HMatrix<spacedim1, Number1>    &M0,
      HMatrix<spacedim1, Number1>    &M,
      const Number1                   alpha,
      HMatrix<spacedim1, Number1>    &M1,
      HMatrix<spacedim1, Number1>    &M2,
      const HMatrixSupport::BlockType block_type_for_local_Z,
      const unsigned int              fixed_rank,
      const bool                      is_result_matrix_store_tril_only);

    template <int spacedim1, typename Number1>
    friend void
    h_h_mTmult_from_leaf_node_for_parallel_cholesky(
      HMatrix<spacedim1, Number1>    &M0,
      HMatrix<spacedim1, Number1>    &M,
      const Number1                   alpha,
      HMatrix<spacedim1, Number1>    &M1,
      HMatrix<spacedim1, Number1>    &M2,
      const HMatrixSupport::BlockType block_type_for_local_Z,
      const unsigned int              fixed_rank,
      const bool                      is_result_matrix_store_tril_only);

    template <int spacedim1, typename Number1>
    friend void
    h_h_Tmmult_from_leaf_node(
      HMatrix<spacedim1, Number1>    &M0,
      HMatrix<spacedim1, Number1>    &M,
      HMatrix<spacedim1, Number1>    &M1,
      HMatrix<spacedim1, Number1>    &M2,
      const HMatrixSupport::BlockType block_type_for_local_Z,
      const unsigned int              fixed_rank,
      const bool                      is_result_matrix_store_tril_only);

    template <int spacedim1, typename Number1>
    friend void
    h_h_Tmmult_from_leaf_node(
      HMatrix<spacedim1, Number1>    &M0,
      HMatrix<spacedim1, Number1>    &M,
      const Number1                   alpha,
      HMatrix<spacedim1, Number1>    &M1,
      HMatrix<spacedim1, Number1>    &M2,
      const HMatrixSupport::BlockType block_type_for_local_Z,
      const unsigned int              fixed_rank,
      const bool                      is_result_matrix_store_tril_only);

    template <int spacedim1, typename Number1>
    friend void
    h_h_mmult_level_conserving(HMatrix<spacedim1, Number1> &M,
                               HMatrix<spacedim1, Number1> &M1,
                               HMatrix<spacedim1, Number1> &M2,
                               const unsigned int           fixed_rank,
                               const bool is_result_matrix_store_tril_only);

    template <int spacedim1, typename Number1>
    friend void
    h_h_mmult_level_conserving(HMatrix<spacedim1, Number1> &M,
                               const Number1                alpha,
                               HMatrix<spacedim1, Number1> &M1,
                               HMatrix<spacedim1, Number1> &M2,
                               const unsigned int           fixed_rank,
                               const bool is_result_matrix_store_tril_only);

    template <int spacedim1, typename Number1>
    friend void
    h_h_mmult_level_conserving_for_parallel_lu(
      HMatrix<spacedim1, Number1> &M,
      const Number1                alpha,
      HMatrix<spacedim1, Number1> &M1,
      HMatrix<spacedim1, Number1> &M2,
      const unsigned int           fixed_rank,
      const bool                   is_result_matrix_store_tril_only);

    template <int spacedim1, typename Number1>
    friend void
    h_h_mTmult_level_conserving(HMatrix<spacedim1, Number1> &M,
                                HMatrix<spacedim1, Number1> &M1,
                                HMatrix<spacedim1, Number1> &M2,
                                const unsigned int           fixed_rank,
                                const bool is_result_matrix_store_tril_only);

    template <int spacedim1, typename Number1>
    friend void
    h_h_mTmult_level_conserving(HMatrix<spacedim1, Number1> &M,
                                const Number1                alpha,
                                HMatrix<spacedim1, Number1> &M1,
                                HMatrix<spacedim1, Number1> &M2,
                                const unsigned int           fixed_rank,
                                const bool is_result_matrix_store_tril_only);

    template <int spacedim1, typename Number1>
    friend void
    h_h_mTmult_level_conserving_for_parallel_cholesky(
      HMatrix<spacedim1, Number1> &M,
      const Number1                alpha,
      HMatrix<spacedim1, Number1> &M1,
      HMatrix<spacedim1, Number1> &M2,
      const unsigned int           fixed_rank,
      const bool                   is_result_matrix_store_tril_only);

    template <int spacedim1, typename Number1>
    friend void
    h_h_Tmmult_level_conserving(HMatrix<spacedim1, Number1> &M,
                                HMatrix<spacedim1, Number1> &M1,
                                HMatrix<spacedim1, Number1> &M2,
                                const unsigned int           fixed_rank,
                                const bool is_result_matrix_store_tril_only);

    template <int spacedim1, typename Number1>
    friend void
    h_h_Tmmult_level_conserving(HMatrix<spacedim1, Number1> &M,
                                const Number1                alpha,
                                HMatrix<spacedim1, Number1> &M1,
                                HMatrix<spacedim1, Number1> &M2,
                                const unsigned int           fixed_rank,
                                const bool is_result_matrix_store_tril_only);

    template <int spacedim1, typename Number1>
    friend void
    copy_hmatrix_node(HMatrix<spacedim1, Number1>       &hmat_dst,
                      const HMatrix<spacedim1, Number1> &hmat_src);

    template <int spacedim1, typename Number1>
    friend void
    copy_hmatrix_node(HMatrix<spacedim1, Number1>  &hmat_dst,
                      HMatrix<spacedim1, Number1> &&hmat_src);

    template <int spacedim1, typename Number1>
    friend void
    copy_hmatrix(HMatrix<spacedim1, Number1>       &hmat_dst,
                 const HMatrix<spacedim1, Number1> &hmat_src);

    template <int spacedim1, typename Number1>
    friend void
    print_h_submatrix_accessor(std::ostream                      &out,
                               const std::string                 &name,
                               const HMatrix<spacedim1, Number1> &M);

    template <int spacedim1, typename Number1>
    friend void
    print_h_h_submatrix_mmult_accessor(std::ostream                      &out,
                                       const std::string                 &name1,
                                       const HMatrix<spacedim1, Number1> &M1,
                                       const std::string                 &name2,
                                       const HMatrix<spacedim1, Number1> &M2);

    template <int spacedim1, typename Number1>
    friend void
    hmatrix_solve_lu(const HMatrix<spacedim1, Number1> &L,
                     const HMatrix<spacedim1, Number1> &U,
                     Vector<Number1>                   &x,
                     const Vector<Number1>             &b);

    template <int spacedim1, typename Number1>
    friend void
    hmatrix_solve_cholesky(const HMatrix<spacedim1, Number1> &L,
                           Vector<Number1>                   &x,
                           const Vector<Number1>             &b);

    /**
     * Invalid submatrix index of the current \hmatnode wrt. its parent
     * \hmatnode,
     * which is used for initializing the @p submatrix_index member variable.
     */
    static const unsigned int submatrix_index_invalid = 9;

    /**
     * Default constructor.
     *
     * \mynote{Because an empty \hmatrix is to be created, its \hmatrix type is
     * set to @p UndefinedMatrixType and block type is set to @p undefined_block.}
     */
    HMatrix();

    /**
     * Construct the hierarchical structure without data from the root node of a
     * BlockClusterTree.
     *
     * \mynote{In case the \bct is only a subtree and the \hmatrix to be built
     * is just a block in the global \hmatrix, the block type is set to
     * @p HMatrixSupport::undefined_block by default.}
     */
    HMatrix(const BlockClusterTree<spacedim, Number> &bct,
            const unsigned int                        fixed_rank_k = 1,
            const HMatrixSupport::Property  property = HMatrixSupport::general,
            const HMatrixSupport::BlockType block_type =
              HMatrixSupport::BlockType::undefined_block);

    /**
     * Construct the hierarchical structure without data from a TreeNode in a
     * BlockClusterTree.
     *
     * \mynote{In case the \bcn is not the root node of the \bct and the
     * \hmatrix to be built is just a block in the global \hmatrix, the block
     * type is set
     * to @p HMatrixSupport::undefined_block by default.}
     */
    HMatrix(typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
                                            bc_node,
            const unsigned int              fixed_rank_k = 1,
            const HMatrixSupport::Property  property = HMatrixSupport::general,
            const HMatrixSupport::BlockType block_type =
              HMatrixSupport::BlockType::undefined_block);

    /**
     * Construct from the root node of a BlockClusterTree while copying the data
     * of a <strong>global</strong> full matrix, which is created on the
     * complete block cluster \f$I \times J\f$.
     *
     * \mynote{Since this \hmatrix is the global matrix, i.e. on the same level
     * as the global full matrix @p M in the \hmatrix hierarchy, its block type
     * is set to @p HMatrixSupport::diagonal_block by default and its property
     * is inferred from the full matrix @p M inside this constructor's body.}
     */
    HMatrix(const BlockClusterTree<spacedim, Number> &bct,
            const LAPACKFullMatrixExt<Number>        &M,
            const unsigned int                        fixed_rank_k,
            const HMatrixSupport::BlockType           block_type =
              HMatrixSupport::BlockType::diagonal_block);

    /**
     * Construct from the root node of a BlockClusterTree while copying the data
     * of a <strong>global</strong> full matrix, which is created on the
     * complete block cluster \f$I \times J\f$.
     *
     * This version has no rank truncation.
     *
     * \mynote{Since this \hmatrix is the global matrix, i.e. on the same level
     * as the global full matrix @p M in the \hmatrix hierarchy, its block type
     * is set to @p HMatrixSupport::diagonal_block by default and its property
     * is inferred from the full matrix @p M inside this constructor's body.}
     */
    HMatrix(const BlockClusterTree<spacedim, Number> &bct,
            const LAPACKFullMatrixExt<Number>        &M,
            const HMatrixSupport::BlockType           block_type =
              HMatrixSupport::BlockType::diagonal_block);

    /**
     * Construct from a TreeNode in a BlockClusterTree while copying the data of
     * a global full matrix, which is created on the complete block cluster \f$I
     * \times J\f$.
     *
     * \mynote{The current \hmatrix to be built may only be a matrix block in
     * the
     * global matrix, while the full matrix @p M is global, i.e., the \hmatrix
     * and the full matrix @p M are not on a same level in the \hmatrix
     * hierarchy. Therefore, the block type of this \hmatrix should be set to
     * @p undefined_block by default and its property cannot be inferred from the
     * global matrix.}
     */
    HMatrix(typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
                                               bc_node,
            const LAPACKFullMatrixExt<Number> &M,
            const unsigned int                 fixed_rank_k,
            const HMatrixSupport::Property  property = HMatrixSupport::general,
            const HMatrixSupport::BlockType block_type =
              HMatrixSupport::BlockType::undefined_block);

    /**
     * Construct from a TreeNode in a BlockClusterTree while copying the data of
     * a global full matrix, which is created on the complete block cluster \f$I
     * \times J\f$.
     *
     * This version has no rank truncation.
     *
     * \mynote{The current \hmatrix to be built may only be a matrix block in
     * the
     * global matrix, while the full matrix @p M is global, i.e., the \hmatrix
     * and the full matrix @p M are not on a same level in the \hmatrix
     * hierarchy. Therefore, the block type of this \hmatrix should be set to
     * @p undefined_block by default and its property cannot be inferred from the
     * global matrix.}
     */
    HMatrix(typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
                                               bc_node,
            const LAPACKFullMatrixExt<Number> &M,
            const HMatrixSupport::Property  property = HMatrixSupport::general,
            const HMatrixSupport::BlockType block_type =
              HMatrixSupport::BlockType::undefined_block);

    /**
     * Construct from a \p TreeNode in a \p BlockClusterTree while moving the data
     * from the leaf set of the \hmatrix \p H.
     *
     * @param bc_node
     * @param H
     */
    HMatrix(typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
                                            bc_node,
            HMatrix<spacedim, Number>     &&H,
            const HMatrixSupport::Property  property = HMatrixSupport::general,
            const HMatrixSupport::BlockType block_type =
              HMatrixSupport::BlockType::undefined_block);

    /**
     * Construct from the root node of a BlockClusterTree while moving the data
     * from the leaf set of the \hmatrix \p H.
     *
     * \mynote{Since this \hmatrix is the global matrix because it is construct
     * with respect to the root node of the \bct, its block type is set to
     * @p HMatrixSupport::diagonal_block.}
     *
     * @param bct
     * @param H
     */
    HMatrix(const BlockClusterTree<spacedim, Number> &bct,
            HMatrix<spacedim, Number>               &&H,
            const HMatrixSupport::Property  property = HMatrixSupport::general,
            const HMatrixSupport::BlockType block_type =
              HMatrixSupport::BlockType::diagonal_block);

    /**
     * Deep copy constructor.
     * @param H
     */
    HMatrix(const HMatrix<spacedim, Number> &H);

    /**
     * Shallow copy constructor.
     *
     * After the copy operation, the data in the source matrix \p H are
     * transferred to the current \hmatnode and \p H is
     * cleared.
     *
     * @param H
     */
    HMatrix(HMatrix<spacedim, Number> &&H) noexcept;

    /**
     * Reinitialize the hierarchical structure without data from the root node
     * of a BlockClusterTree.
     *
     * @param bct
     * @param fixed_rank_k
     */
    void
    reinit(const BlockClusterTree<spacedim, Number> &bct,
           const unsigned int                        fixed_rank_k = 1,
           const HMatrixSupport::Property  property = HMatrixSupport::general,
           const HMatrixSupport::BlockType block_type =
             HMatrixSupport::BlockType::diagonal_block);

    /**
     * Reinitialize the hierarchical structure without data from a TreeNode in a
     * BlockClusterTree.
     * @param bc_node
     * @param fixed_rank_k
     */
    void
    reinit(typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
                                           bc_node,
           const unsigned int              fixed_rank_k = 1,
           const HMatrixSupport::Property  property = HMatrixSupport::general,
           const HMatrixSupport::BlockType block_type =
             HMatrixSupport::undefined_block);

    /**
     * Assignment via shallow copy.
     *
     * @param H
     * @return
     */
    HMatrix<spacedim, Number> &
    operator=(HMatrix<spacedim, Number> &&H) noexcept;

    /**
     * Assignment via deep copy.
     *
     * @param H
     * @return
     */
    HMatrix<spacedim, Number> &
    operator=(const HMatrix<spacedim, Number> &H);

    /**
     * Convert an HMatrix to a full matrix by calling the internal recursive
     * function.
     *
     * <dl class="section note">
     *   <dt>Note</dt>
     *   <dd>This function only has the verification purpose. In reality, a
     * large dense matrix cannot be saved as a full matrix.</dd>
     * </dl>
     *
     * If the current \hmatrix is symmetric, after conversion, the obtained full
     * matrix may not be symmetric anymore, because when constructing an
     * \hmatrix based on a real mesh, the indices stored in a cluster are
     * usually not continuous.
     *
     * @param matrix
     */
    template <typename MatrixType>
    void
    convertToFullMatrix(MatrixType &M) const;

    /**
     * Release the memory and status of the \hmatrix hierarchy.
     */
    void
    release();

    /**
     * Clear the whole \hmatrix hierarchy.
     */
    void
    clear();

    /**
     * Clear the current \hmatnode.
     */
    void
    clear_hmat_node();

    /**
     * Clear all LU or Cholesky factorization task nodes.
     */
    void
    clear_lu_or_cholesky_task_nodes();

    /**
     * Clear LU or Cholesky factorization task nodes associated with a
     * \hmatnode.
     */
    void
    clear_lu_or_cholesky_task_nodes_in_hmat();

    /**
     * Destructor which releases the memory by recursion.
     */
    ~HMatrix();

    /**
     * Get the matrix type of the current \hmatnode.
     * @return
     */
    HMatrixType
    get_type() const;

    /**
     * If the \hmatnode belongs to the near field leaf set.
     *
     * @return
     */
    bool
    is_near_field() const;

    /**
     * If the \hmatnode belongs to the far field leaf set.
     *
     * @return
     */
    bool
    is_far_field() const;

    /**
     * If the \hmatnode blongs to the leaf set.
     *
     * @return
     */
    bool
    is_leaf() const;

    /**
     * Get the number of rows of the current \hmatnode.
     * @return
     */
    size_type
    get_m() const;

    /**
     * Get the number of row blocks of the current \hmatnode.
     * @return
     */
    unsigned int
    get_n_row_blocks() const;

    /**
     * Get the number of column blocks of the current \hmatnode.
     * @return
     */
    unsigned int
    get_n_col_blocks() const;

    /**
     * Get the property of the current \hmatnode.
     * @return
     */
    HMatrixSupport::Property
    get_property() const;

    /**
     * Set the property of the current \hmatnode.
     * @param property
     */
    void
    set_current_matrix_property(const HMatrixSupport::Property property);

    /**
     * Set the property of the current \hmatnode according to the property of
     * the associated full matrix.
     *
     * @param M
     */
    void
    set_current_matrix_property(const LAPACKFullMatrixExt<Number> &M);

    /**
     * Recursively set the property of all \hmatnodes in the \hmatrix hierarchy.
     *
     * \mynote{This recursive operation relies on appropriately set block
     * types.}
     *
     * @param property
     */
    void
    set_property(const HMatrixSupport::Property property);

    /**
     * Set the property of all \hmatnodes in the \hmatrix hierarchy. The
     * property of the top level \hmatnode is determined from the associated
     * full matrix.
     *
     * \mynote{This recursive operation relies on appropriately set block
     * types.}
     *
     * @param M
     */
    void
    set_property(const LAPACKFullMatrixExt<Number> &M);

    /**
     * Set the state of the current \hmatnode.
     *
     * @param state
     */
    void
    set_current_matrix_state(const HMatrixSupport::State state);

    /**
     * Get the state of the current \hmatnode.
     *
     * @return
     */
    HMatrixSupport::State
    get_state() const;

    /**
     * Recursively set the state of all \hmatnodes in the \hmatrix hierarchy.
     *
     * @param state
     */
    void
    set_state(const HMatrixSupport::State state);

    /**
     * Get the block type of the current \hmatnode.
     * @return
     */
    HMatrixSupport::BlockType
    get_block_type() const;

    /**
     * Set the block type of the current \hmatnode.
     *
     * @param block_type
     */
    void
    set_current_matrix_block_type(const HMatrixSupport::BlockType block_type);

    /**
     * Set the block type of all \hmatnodes in the \hmatrix hierarchy.
     *
     * @param block_type
     */
    void
    set_block_type(const HMatrixSupport::BlockType block_type);

    /**
     * Get the number of columns of the current \hmatnode.
     * @return
     */
    size_type
    get_n() const;

    /**
     * Get the pointer to the rank-k matrix of the current
     * \hmatnode.
     * @return
     */
    RkMatrix<Number> *
    get_rkmatrix();

    /**
     * Get the pointer to the rank-k matrix of the current
     * \hmatnode (const version).
     * @return
     */
    const RkMatrix<Number> *
    get_rkmatrix() const;

    /**
     * Calculate and set the rank upper bound for each rank-k matrix in the
     * \hmatrix hierarchy.
     */
    void
    calc_rank_upper_bound_for_rkmatrices() const;

    /**
     * Get the pointer to the full matrix of the current \hmatrix
     * node.
     * @return
     */
    LAPACKFullMatrixExt<Number> *
    get_fullmatrix();

    /**
     * Get the pointer to the full matrix of the current \hmatrix
     * node (const version).
     * @return
     */
    const LAPACKFullMatrixExt<Number> *
    get_fullmatrix() const;

    /**
     * Get the reference to the vector of submatrices of the current
     * \hmatnode.
     * @return
     */
    std::vector<HMatrix<spacedim, Number> *> &
    get_submatrices();

    /**
     * Get the reference to the vector of submatrices of the current
     * \hmatnode (const version).
     * @return
     */
    const std::vector<HMatrix<spacedim, Number> *> &
    get_submatrices() const;

    /**
     * Print the \hmatrix data.
     *
     * @param out
     * @param precision
     * @param scientific
     * @param width
     * @param zero_string
     * @param denominator
     * @param threshold
     */
    void
    print_formatted(std::ostream      &out,
                    const unsigned int precision   = 3,
                    const bool         scientific  = true,
                    const unsigned int width       = 0,
                    const char        *zero_string = " ",
                    const double       denominator = 1.,
                    const double       threshold   = 0.) const;

    /**
     * Print the \hmatrix hierarchy information.
     *
     * @param out
     */
    void
    print_matrix_info(std::ostream &out) const;

    /**
     * Print the current \hmatnode information.
     *
     * @param out
     */
    void
    print_current_matrix_info(std::ostream &out) const;

    /**
     * Print the \hmatrix hierarchy information as directional graph in Graphviz
     * dot format.
     *
     * @param out
     */
    void
    print_matrix_info_as_dot(std::ostream &out);

    /**
     * Print the \hmatrix as a @p LAPACKFullMatrixExt to Octave mat format.
     *
     * @param out
     * @param name
     * @param precision
     * @param scientific
     * @param width
     * @param zero_string
     * @param denominator
     * @param threshold
     */
    void
    print_as_formatted_full_matrix(std::ostream      &out,
                                   const std::string &name,
                                   const unsigned int precision   = 8,
                                   const bool         scientific  = true,
                                   const unsigned int width       = 0,
                                   const char        *zero_string = "0",
                                   const double       denominator = 1.,
                                   const double       threshold   = 0.) const;

    /**
     * Print the leaf set information.
     *
     * @param out
     */
    void
    print_leaf_set_info(std::ostream &out) const;

    /**
     * Write formatted full matrix leaf node to the output stream.
     *
     * The leaf node is written in the following format:
     *
     * >
     * [list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field,rank
     *
     * For example,
     *
     * > [1 2 3 ...],[7 8 9 ...],1,1
     *
     * @param out
     * @param singular_value_threshold
     */
    void
    write_fullmatrix_leaf_node(
      std::ostream &out,
      const Number  singular_value_threshold = 0.) const;

    /**
     * Write formatted rank-k matrix leaf node to the output stream.
     *
     * The leaf node is written in the following format:
     *
     * >
     * [list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field,rank
     *
     * For example,
     *
     * > [1 2 3 ...],[7 8 9 ...],1,1
     *
     * @param out
     */
    void
    write_rkmatrix_leaf_node(std::ostream &out) const;

    /**
     * Write formatted leaf set to the output stream as well as the rank of each
     * matrix block by recursion.
     *
     * Each leaf node is written in the following format:
     *
     * >
     * [list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field,rank
     *
     * For example,
     *
     * > [1 2 3 ...],[7 8 9 ...],1,1
     * @param out
     * @param singular_value_threshold
     */
    void
    write_leaf_set(std::ostream &out,
                   const Number  singular_value_threshold = 0.) const;

    /**
     * Write formatted leaf set to the output stream as well as the rank of each
     * matrix block by iteration.
     *
     * Each leaf node is written in the following format:
     *
     * >
     * [list-of-indices-in-cluster-tau],[list-of-indices-in-cluster-sigma],is_near_field,rank
     *
     * For example,
     *
     * > [1 2 3 ...],[7 8 9 ...],1,1
     * @param out
     * @param singular_value_threshold
     */
    void
    write_leaf_set_by_iteration(
      std::ostream &out,
      const Number  singular_value_threshold = 0.) const;

    /**
     * Find the diagonal block corresponding to the row block cluster of the
     * current \hmatnode which is assumed in the lower triangular part of the
     * whole matrix.
     *
     * \alert{The algorithm does not check internally whether the current
     * \hmatnode locates in the lower triangular part of the whole matrix. The
     * user should ensure this presumption.}
     *
     * @return
     */
    HMatrix *
    find_row_diag_block_for_offdiag_block();

    /**
     * Find the diagonal block corresponding to the column block cluster of the
     * current \hmatnode which is assumed in the lower triangular part of the
     * whole matrix.
     *
     * \alert{The algorithm does not check internally whether the current
     * \hmatnode locates in the lower triangular part of the whole matrix. The
     * user should ensure this presumption.}
     *
     * @return
     */
    HMatrix *
    find_col_diag_block_for_offdiag_block();

    /**
     * Truncate all rank-k matrices in the leaf set of the
     * \hmatrix to rank-k matrices with the given \p new_rank,
     * while the full matrices in the leaf set, i.e. those near-field matrices,
     * are kept intact.
     *
     * <dl class="section note">
     *   <dt>Note</dt>
     *   <dd>This method implements the operator \f$\mathcal{T}_{r \leftarrow
     * s}^{\mathcal{H}}\f$ in (7.5) in Hackbusch's \hmatrix
     * book.</dd>
     * </dl>
     * @param new_rank
     */
    void
    truncate_to_rank(size_type new_rank);

    /**
     * Truncate all rank-k matrices in the leaf set of the
     * \hmatrix to rank-k matrices with the given \p new_rank,
     * while the full matrices in the leaf set, i.e. those near-field matrices,
     * are kept intact.
     *
     * \alert{The original \hmatrix is assumed to be symmetric and positive
     * definite (SPD). When rank truncation is performed for far field rank-k
     * matrices, the truncation error matrix components will be added to
     * diagonal blocks according to the stabilization method proposed in
     * Bebendorf, M., and W. Hackbusch. 2007. “Stabilized Rounded Addition of
     * Hierarchical Matrices.” Numerical Linear Algebra with Applications 14
     * (5): 407–23. https://doi.org/10.1002/nla.525.}
     *
     * <dl class="section note">
     *   <dt>Note</dt>
     *   <dd>This method implements the operator \f$\mathcal{T}_{r \leftarrow
     * s}^{\mathcal{H}}\f$ in (7.5) in Hackbusch's \hmatrix
     * book.</dd>
     * </dl>
     * @param new_rank
     */
    void
    truncate_to_rank_preserve_positive_definite(
      size_type  new_rank,
      const bool is_only_handle_tril = true);

    /**
     * Truncate all rank-k matrices in the leaf set of the
     * \hmatrix to rank-k matrices with the given \p new_rank,
     * while the full matrices in the leaf set, i.e. those near-field matrices,
     * are kept intact. In this version, the initial \hmatrix is a diagonal
     * block.
     *
     * @param new_rank
     */
    void
    truncate_to_rank_diag_preserve_positive_definite(
      size_type  new_rank,
      const bool is_only_handle_tril = true);

    /**
     * Truncate all rank-k matrices in the leaf set of the
     * \hmatrix to rank-k matrices with the given \p new_rank,
     * while the full matrices in the leaf set, i.e. those near-field matrices,
     * are kept intact. In this version, the initial \hmatrix is an off-diagonal
     * block.
     *
     * @param new_rank
     */
    void
    truncate_to_rank_off_diag_preserve_positive_definite(
      size_type  new_rank,
      const bool is_compensate_diag_blocks = true);

    /**
     * Calculate matrix-vector multiplication as \f$y = y + M \cdot x\f$.
     *
     * \mynote{
     * 1. The recursive algorithm for \hmatrix-vector
     * multiplication needs to collect the results from different components in
     * the leaf set and corresponding vector block in \f$x\f$. More importantly,
     * there will be a series of such results contributing to a same block in
     * the result vector \f$y\f$. Therefore, if the interface of this function
     * is
     * designed with the parameter \p add as that in the \p vmult function of \p
     * LAPACKFullMatrix in deal.ii, in all recursive calls of \p vmult except the
     * first one, this \p add flag should be set to \p true, irrespective of the
     * original flag value passed into the first call of \p vmult. Hence, we do
     * not include the \p add flag in the \p vmult function.
     * 2. The input vectors \p x and \p y are with respect to root cluster nodes
     * and should be directly accessed via **global** DoF indices.}
     *
     * @param y
     * @param x
     * @param top_hmat_property When the \hmatnode on the top level is symmetric
     * for example, there will be special internal treatment.
     */
    void
    vmult(Vector<Number>                &y,
          const Vector<Number>          &x,
          const HMatrixSupport::Property top_hmat_property =
            HMatrixSupport::general) const;

    /**
     * Calculate matrix-vector multiplication as \f$y = y + \alpha \cdot M \cdot
     * x\f$.
     *
     * \mynote{
     * 1. The recursive algorithm for \hmatrix-vector
     * multiplication needs to collect the results from different components in
     * the leaf set and corresponding vector block in \f$x\f$. More importantly,
     * there will be a series of such results contributing to a same block in
     * the result vector \f$y\f$. Therefore, if the interface of this function
     * is
     * designed with the parameter \p add as that in the \p vmult function of \p
     * LAPACKFullMatrix in deal.ii, in all recursive calls of \p vmult except the
     * first one, this \p add flag should be set to \p true, irrespective of the
     * original flag value passed into the first call of \p vmult. Hence, we do
     * not include the \p add flag in the \p vmult function.
     * 2. The input vectors \p x and \p y are with respect to root cluster nodes
     * and should be directly accessed via **global** DoF indices.}
     *
     * @param y
     * @param alpha
     * @param x
     */
    void
    vmult(Vector<Number>                &y,
          const Number                   alpha,
          const Vector<Number>          &x,
          const HMatrixSupport::Property top_hmat_property =
            HMatrixSupport::general) const;

    /**
     * Calculate matrix-vector multiplication as \f$y = y + M \cdot x\f$ by
     * starting from a block in the matrix and vector. Therefore, the starting
     * \hmat should be explicitly specified.
     *
     * @param y
     * @param x
     * @param starting_hmat
     * @param top_hmat_property
     */
    void
    vmult(Vector<Number>                  &y,
          const Vector<Number>            &x,
          const HMatrix<spacedim, Number> &starting_hmat,
          const HMatrixSupport::Property   top_hmat_property =
            HMatrixSupport::general) const;

    /**
     * Calculate matrix-vector multiplication as \f$y = y + \alpha \cdot M \cdot
     * x\f$ by starting from a block in the matrix and vector. Therefore, the
     * starting should be explicitly specified.
     *
     * @param y
     * @param alpha
     * @param x
     * @param starting_hmat
     * @param top_hmat_property
     */
    void
    vmult(Vector<Number>                  &y,
          const Number                     alpha,
          const Vector<Number>            &x,
          const HMatrix<spacedim, Number> &starting_hmat,
          const HMatrixSupport::Property   top_hmat_property =
            HMatrixSupport::general) const;

    /**
     * Calculate matrix-vector multiplication as \f$y = y +
     * M^T \cdot x\f$, i.e. the matrix \f$M\f$ is transposed.
     *
     * Because the matrix \f$M\f$ is transposed, the roles for \p row_index_range and
     * \p col_index_range should be swapped. Also refer to HMatrix::vmult.
     *
     * \mynote{The input vectors \p x and \p y are with respect to root cluster
     * nodes and should be directly accessed via **global** DoF indices.}
     *
     * @param y
     * @param x
     */
    void
    Tvmult(Vector<Number>                &y,
           const Vector<Number>          &x,
           const HMatrixSupport::Property top_hmat_property =
             HMatrixSupport::Property::general) const;

    /**
     * Calculate matrix-vector multiplication as \f$y = y +
     * \alpha \cdot M^T \cdot x\f$, i.e. the matrix \f$M\f$ is transposed.
     *
     * Because the matrix \f$M\f$ is transposed, the roles for \p row_index_range and
     * \p col_index_range should be swapped. Also refer to HMatrix::vmult.
     *
     * \mynote{The input vectors \p x and \p y are with respect to root cluster
     * nodes and should be directly accessed via **global** DoF indices.}
     *
     * @param y
     * @param alpha
     * @param x
     */
    void
    Tvmult(Vector<Number>                &y,
           const Number                   alpha,
           const Vector<Number>          &x,
           const HMatrixSupport::Property top_hmat_property =
             HMatrixSupport::Property::general) const;

    /**
     * Calculate matrix-vector multiplication as \f$y = y + M^T \cdot x\f$ by
     * starting from a block in the matrix and vector. Therefore, the starting
     * \hmat is specified.
     *
     * @param y
     * @param x
     * @param starting_hmat
     * @param top_hmat_property
     */
    void
    Tvmult(Vector<Number>                  &y,
           const Vector<Number>            &x,
           const HMatrix<spacedim, Number> &starting_hmat,
           const HMatrixSupport::Property   top_hmat_property =
             HMatrixSupport::Property::general) const;

    /**
     * Calculate matrix-vector multiplication as \f$y = y + \alpha \cdot M^T
     * \cdot x\f$ by starting from a block in the matrix and vector. Therefore,
     * the starting \hmat is specified.
     *
     * @param y
     * @param alpha
     * @param x
     * @param starting_hmat
     * @param top_hmat_property
     */
    void
    Tvmult(Vector<Number>                  &y,
           const Number                     alpha,
           const Vector<Number>            &x,
           const HMatrix<spacedim, Number> &starting_hmat,
           const HMatrixSupport::Property   top_hmat_property =
             HMatrixSupport::Property::general) const;

    /**
     * Perform \hmatrix MM multiplication reduction. This is
     * (7.21) in Hackbusch's \hmatrix book.
     */
    void
    h_h_mmult_reduction();

    /**
     * This function implements \p MM_H in Hackbusch's \hmatrix
     * book.
     */
    void
    h_h_mmult_horizontal_split(BlockClusterTree<spacedim, Number> &bc_tree);

    /**
     * This function implements \p MM_V in Hackbusch's \hmatrix
     * book.
     */
    void
    h_h_mmult_vertical_split(BlockClusterTree<spacedim, Number> &bc_tree);

    /**
     * This function implements \p MM_C in Hackbusch's \hmatrix
     * book.
     */
    void
    h_h_mmult_cross_split(BlockClusterTree<spacedim, Number> &bc_tree);

    /**
     * Multiplication of two \f$\mathcal{H}\f$-matrices \f$C = A \cdot B\f$.
     * @param C
     * @param B
     * @param bct_a
     * @param bct_b
     * @param bct_c
     * @param fixed_rank
     */
    void
    mmult(HMatrix<spacedim, Number>                &C,
          HMatrix<spacedim, Number>                &B,
          const BlockClusterTree<spacedim, Number> &bct_a,
          const BlockClusterTree<spacedim, Number> &bct_b,
          BlockClusterTree<spacedim, Number>       &bct_c,
          const unsigned int                        fixed_rank = 1);

    /**
     * Multiplication of two \f$\mathcal{H}\f$-matrices, the result of which
     * will
     * be appended to the target matrix \p C.
     * @param C
     * @param B
     * @param bct_a
     * @param bct_b
     * @param bct_c
     * @param fixed_rank
     * @param adding
     */
    void
    mmult(HMatrix<spacedim, Number>                &C,
          HMatrix<spacedim, Number>                &B,
          const BlockClusterTree<spacedim, Number> &bct_a,
          const BlockClusterTree<spacedim, Number> &bct_b,
          BlockClusterTree<spacedim, Number>       &bct_c,
          const unsigned int                        fixed_rank,
          const bool                                adding);

    /**
     * Level conserving \hmatrix multiplication, the result of which will be
     * appended to the target matrix \p C, i.e. \f$C = C + AB\f$.
     *
     * @param C
     * @param B
     * @param fixed_rank
     * @param is_result_matrix_store_tril_only
     */
    void
    mmult_level_conserving(HMatrix<spacedim, Number> &C,
                           HMatrix<spacedim, Number> &B,
                           const unsigned int         fixed_rank,
                           const bool is_result_matrix_store_tril_only = false);

    /**
     * Level conserving \hmatrix multiplication with a factored multiplied to
     * the matrix product, the result of which will be appended to the target
     * matrix \p C, i.e. \f$C = C + \alpha \cdot A B\f$.
     *
     * @param C
     * @param alpha
     * @param B
     * @param fixed_rank
     * @param is_result_matrix_store_tril_only
     */
    void
    mmult_level_conserving(HMatrix<spacedim, Number> &C,
                           const Number               alpha,
                           HMatrix<spacedim, Number> &B,
                           const unsigned int         fixed_rank,
                           const bool is_result_matrix_store_tril_only = false);

    void
    mmult_level_conserving_for_parallel_lu(
      HMatrix<spacedim, Number> &C,
      const Number               alpha,
      HMatrix<spacedim, Number> &B,
      const unsigned int         fixed_rank,
      const bool                 is_result_matrix_store_tril_only = false);

    /**
     * Level conserving \hmatrix multiplication with the second operand being
     * transposed, the result of which will be appended to the target matrix
     * @p C, i.e. \f$C = C + A B^T\f$.
     *
     * @param C
     * @param B
     * @param fixed_rank
     * @param is_result_matrix_store_tril_only
     */
    void
    mTmult_level_conserving(
      HMatrix<spacedim, Number> &C,
      HMatrix<spacedim, Number> &B,
      const unsigned int         fixed_rank,
      const bool                 is_result_matrix_store_tril_only = false);

    /**
     * Level conserving \hmatrix multiplication with the second operand being
     * transposed, the result of which will be multiplied by a factor and then
     * appended to the target matrix @p C, i.e. \f$C = C + \alpha \cdot A B^T\f$.
     *
     * @param C
     * @param alpha
     * @param B
     * @param fixed_rank
     * @param is_result_matrix_store_tril_only
     */
    void
    mTmult_level_conserving(
      HMatrix<spacedim, Number> &C,
      const Number               alpha,
      HMatrix<spacedim, Number> &B,
      const unsigned int         fixed_rank,
      const bool                 is_result_matrix_store_tril_only = false);

    void
    mTmult_level_conserving_for_parallel_cholesky(
      HMatrix<spacedim, Number> &C,
      const Number               alpha,
      HMatrix<spacedim, Number> &B,
      const unsigned int         fixed_rank,
      const bool                 is_result_matrix_store_tril_only = false);

    /**
     * Level conserving \hmatrix multiplication with the first operand being
     * transposed, the result of which will be appended to the target matrix
     * @p C, i.e. \f$C = C + A^T B\f$.
     *
     * @param C
     * @param B
     * @param fixed_rank
     * @param is_result_matrix_store_tril_only
     */
    void
    Tmmult_level_conserving(
      HMatrix<spacedim, Number> &C,
      HMatrix<spacedim, Number> &B,
      const unsigned int         fixed_rank,
      const bool                 is_result_matrix_store_tril_only = false);

    /**
     * Level conserving \hmatrix multiplication with the first operand being
     * transposed, the result of which will be multiplied by a factor and then
     * appended to the target matrix @p C, i.e. \f$C = C + \alpha \cdot A^T B\f$.
     *
     * @param C
     * @param alpha
     * @param B
     * @param fixed_rank
     * @param is_result_matrix_store_tril_only
     */
    void
    Tmmult_level_conserving(
      HMatrix<spacedim, Number> &C,
      const Number               alpha,
      HMatrix<spacedim, Number> &B,
      const unsigned int         fixed_rank,
      const bool                 is_result_matrix_store_tril_only = false);

    /**
     * Add the current HMatrix \p A with another HMatrix \p B into \p C, i.e.
     * whole matrix addition instead of addition limited to a specific block,
     * where \p C will be truncated to a fixed rank \p fixed_rank.
     *
     * This algorithm is intrinsically recursive, i.e. the addition of parent
     * HMatrices will perform the addition of each pair of child HMatrices
     * corresponding to a same block cluster. Strictly speaking, this member
     * function \p add is not a recursive function, because the class instance
     * which calls \p add changes from parent to child HMatrix.
     *
     * N.B.
     *
     * 1. The two operands should have the same partition.
     * 2. The hierarchical structure of \p C should be pre-generated.
     *
     * @param C
     * @param B
     * @param fixed_rank
     */
    void
    add(HMatrix<spacedim, Number>       &C,
        const HMatrix<spacedim, Number> &B,
        const size_type                  fixed_rank_k) const;

    /**
     * Perform the addition with factor \f$C = A + b B\f$.
     * @param C
     * @param b
     * @param B
     * @param fixed_rank_k
     */
    void
    add(HMatrix<spacedim, Number>       &C,
        const Number                     b,
        const HMatrix<spacedim, Number> &B,
        const size_type                  fixed_rank_k) const;

    /**
     * Add the HMatrix \p B into the current HMatrix \p A, i.e.
     * whole matrix addition instead of addition limited to a specific block,
     * where \p C will be truncated to a fixed rank \p fixed_rank.
     *
     * This algorithm is intrinsically recursive, i.e. the addition of parent
     * HMatrices will perform the addition of each pair of child HMatrices
     * corresponding to a same block cluster. Strictly speaking, this member
     * function \p add is not a recursive function, because the class instance
     * which calls \p add changes from parent to child HMatrix.
     *
     * N.B. The two operands should have the same partition.
     *
     * @param B
     * @param fixed_rank
     */
    void
    add(const HMatrix<spacedim, Number> &B, const size_type fixed_rank_k) const;

    /**
     * Perform the addition \f$A = A + b B\f$.
     * @param B
     * @param fixed_rank_k
     */
    void
    add(const Number                     b,
        const HMatrix<spacedim, Number> &B,
        const size_type                  fixed_rank_k) const;

    /**
     * Add a rank-k matrix into the current \hmatnode.
     *
     * The rank-k matrix will be restricted to each leaf node of the \hmatnode
     * and the addition will be performed there. In this implementation, the row
     * and column global to local index maps with respect to \p B should be
     * explicit provided.
     *
     * @param B
     * @param fixed_rank_k
     */
    void
    add(const RkMatrix<Number>                       &B,
        const std::array<types::global_dof_index, 2> &B_row_index_range,
        const std::array<types::global_dof_index, 2> &B_col_index_range,
        const size_type                               fixed_rank_k,
        const bool is_result_matrix_store_tril_only = false) const;

    void
    add_for_parallel_lu_or_cholesky(
      const RkMatrix<Number>                       &B,
      const std::array<types::global_dof_index, 2> &B_row_index_range,
      const std::array<types::global_dof_index, 2> &B_col_index_range,
      const size_type                               fixed_rank_k,
      const bool is_result_matrix_store_tril_only = false);

    /**
     * Add a rank-k matrix multiplied by a factor into the current \hmatnode.
     *
     * The rank-k matrix will be restricted to each leaf node of the \hmatnode
     * and the addition will be performed there. In this implementation, the row
     * and column global to local index maps with respect to \p B should be
     * explicitly provided.
     *
     * @param b
     * @param B
     * @param fixed_rank_k
     */
    void
    add(const Number                                  b,
        const RkMatrix<Number>                       &B,
        const std::array<types::global_dof_index, 2> &B_row_index_range,
        const std::array<types::global_dof_index, 2> &B_col_index_range,
        const size_type                               fixed_rank_k,
        const bool is_result_matrix_store_tril_only = false) const;

    /**
     * Add a rank-k matrix into the current \hmatnode.
     *
     * The rank-k matrix will be restricted to each leaf node of the \hmatnode
     * and the addition will be performed there respectively. In this
     * implementation, the row and column index ranges with respect
     * to \p B are the same as those associated with the \hmatrix, i.e. the
     * rank-k matrix and \hmatrix are on a same block.
     *
     * When the flag @p is_result_matrix_symm_apriori is true, the result matrix
     * is known to be symmetric a priori. Then, the internal addition operation
     * on upper triangular part will be ignored. If the addition operation is
     * performed on a diagonal full matrix block, only its diagonal and lower
     * triangular elements will be computed.
     *
     * @param B
     * @param fixed_rank_k
     * @param is_result_matrix_store_tril_only
     */
    void
    add(const RkMatrix<Number> &B,
        const size_type         fixed_rank_k,
        const bool              is_result_matrix_store_tril_only = false);

    void
    add_for_parallel_lu_or_cholesky(
      const RkMatrix<Number> &B,
      const size_type         fixed_rank_k,
      const bool              is_result_matrix_store_tril_only = false);

    /**
     * Add a rank-k matrix multiplied by a factor into the current \hmatnode.
     *
     * The rank-k matrix will be restricted to each leaf node of the \hmatnode
     * and the addition will be performed there. In this implementation, the row
     * and column index ranges with respect to \p B are the same as
     * those associated with the \hmatrix, i.e. the rank-k matrix and \hmatrix
     * are on a same block.
     *
     * @param b
     * @param B
     * @param fixed_rank_k
     */
    void
    add(const Number            b,
        const RkMatrix<Number> &B,
        const size_type         fixed_rank_k,
        const bool              is_result_matrix_store_tril_only = false);

    /**
     * Add the error matrix \f$EE^H\f$ recursively to the leaf diagonal blocks
     * of the current \hmatnode for preserving positive definiteness.
     *
     * @param E
     */
    void
    addsym_diag(const LAPACKFullMatrixExt<Number> &E);

    /**
     * Perform the \hmatrix addition \f$C = A + B\f$.
     * @param C
     * @param B
     * @param fixed_rank_k
     */
    void
    add(HMatrix<spacedim, Number> &C,
        const RkMatrix<Number>    &B,
        const size_type            fixed_rank_k);

    /**
     * Perform the \hmatrix addition \f$C = A + b B\f$.
     * @param C
     * @param b
     * @param B
     * @param fixed_rank_k
     */
    void
    add(HMatrix<spacedim, Number> &C,
        const Number               b,
        const RkMatrix<Number>    &B,
        const size_type            fixed_rank_k);

    /**
     * Calculate the inverse of the \hmatnode via Gauss
     * elimination by calling the recursive function HMatrix<spacedim,
     * Number>::_invert_by_gauss_elim.
     *
     * @param M_inv
     * @param M_root The \hmatnode from which this recursive function is called for
     * the first time.
     * @param M_root_bct The \bct associated with \p M_root.
     * @param fixed_rank_k
     */
    void
    invert_by_gauss_elim(HMatrix<spacedim, Number> &M_inv,
                         const size_type            fixed_rank_k);

    /**
     * Solve the lower triangular matrix \f$Lx=b\f$ by forward substitution.
     *
     * The right hand side vector \f$b\f$ will be overwritten by the solution
     * vector \f$x\f$.
     *
     * \alert{The vector \p b is **global**, which can be directly accessed by
     * DoF indices in the cluster's index range.}
     *
     * @param b Right hand side global vector. After execution, it stores the
     * result vector.
     */
    void
    solve_by_forward_substitution(Vector<Number> &b,
                                  const bool is_unit_diagonal = true) const;

    /**
     * Solve the lower triangular matrix \f$Lx=b\f$ by forward substitution.
     *
     * \alert{The vector \p b is **global**, which can be directly accessed by
     * DoF indices in the cluster's index range.}
     *
     * @param x
     * @param b Right hand side global vector.
     * @param is_unit_diagonal
     */
    void
    solve_by_forward_substitution(Vector<Number>       &x,
                                  const Vector<Number> &b,
                                  const bool is_unit_diagonal = true) const;

    /**
     * Solve the lower triangular matrix \f$Lx=b\f$ by forward substitution.
     *
     * The right hand side vector \f$b\f$ will be overwritten by the solution
     * vector \f$x\f$.
     *
     * \alert{The vector \p b is **local**, i.e. associated with a cluster.
     * Therefore, the \hmat passed at the beginning of the recursion should be
     * explicitly specified.}
     *
     * @param b Right hand side global vector. After execution, it stores the
     * result vector.
     * @param starting_hmat
     * @param is_unit_diagonal
     */
    void
    solve_by_forward_substitution(
      Vector<Number>                  &b,
      const HMatrix<spacedim, Number> &starting_hmat,
      const bool                       is_unit_diagonal = true) const;

    /**
     * Solve the lower triangular matrix \f$Lx=b\f$ by forward substitution.
     *
     * \alert{The vector \p b is **local**, i.e. associated with a cluster.
     * Therefore, the starting \hmat should be explicitly specified.}
     *
     * @param x
     * @param b
     * @param starting_hmat
     * @param is_unit_diagonal
     */
    void
    solve_by_forward_substitution(
      Vector<Number>                  &x,
      const Vector<Number>            &b,
      const HMatrix<spacedim, Number> &starting_hmat,
      const bool                       is_unit_diagonal = true) const;

    /**
     * Solve the matrix-valued problem
     * \f$L\vert_{\tau\times\tau}X\vert_{\tau\times\sigma}=Z\vert_{\tau\times\sigma}\f$
     * using forward substitution.
     *
     * \alert{1. The problem to be solved is restricted to specific \bcs. Hence,
     * when this recursive algorithm for forward substitution comes to a leaf
     * node of \f$Z\f$, it implies the column vectors stored in \f$Z\f$ are to
     * be accessed via local indices.
     * 2. The right hand side matrix \f$Z\f$ will be modified in this algorithm
     * during the update stage:
     * \f$Z \big\vert_{\tau[i]\times\sigma[j]} \coloneqq Z
     * \big\vert_{\tau[i]\times\sigma[j]} - L \big\vert_{\tau[i]\times\tau[k]}X
     * \big\vert_{\tau[k]\times\sigma[j]}\f$}.
     *
     * @param X
     * @param Z
     * @param fixed_rank
     * @param is_unit_diagonal
     */
    void
    solve_by_forward_substitution_matrix_valued(
      HMatrix<spacedim, Number> &X,
      HMatrix<spacedim, Number> &Z,
      const unsigned int         fixed_rank,
      const bool                 is_unit_diagonal = true) const;

    /**
     * Solve the matrix-valued problem
     * \f$L\vert_{\tau\times\tau}X\vert_{\tau\times\sigma}=Z\vert_{\tau\times\sigma}\f$
     * using forward substitution.
     *
     * This version is in situ, i.e. the solution is directly saved into
     * \f$Z\f$.
     *
     * @param Z
     * @param fixed_rank
     * @param is_unit_diagonal
     */
    void
    solve_by_forward_substitution_matrix_valued(
      HMatrix<spacedim, Number> &Z,
      const unsigned int         fixed_rank,
      const bool                 is_unit_diagonal = true) const;

    /**
     * Solve the matrix-valued problem
     * \f$L\vert_{\tau\times\tau}X\vert_{\tau\times\sigma}=Z\vert_{\tau\times\sigma}\f$
     * using forward substitution, where \f$L\vert_{\tau\times\tau}\f$ is
     * obtained from a Cholesky decomposition. Hence,
     * \f$L\vert_{\tau\times\tau}\f$ is not normed.
     *
     * This function directly calls \p
     * solve_by_forward_substitution_matrix_valued( HMatrix<spacedim, Number>
     * &X, HMatrix<spacedim, Number> &Z, const unsigned int fixed_rank, const
     * bool
     * is_unit_diagonal = false) with \p is_unit_diagonal being \p false.
     *
     * @param X
     * @param Z
     * @param fixed_rank
     */
    void
    solve_cholesky_by_forward_substitution_matrix_valued(
      HMatrix<spacedim, Number> &X,
      HMatrix<spacedim, Number> &Z,
      const unsigned int         fixed_rank) const;

    void
    solve_cholesky_by_forward_substitution_matrix_valued(
      HMatrix<spacedim, Number> &Z,
      const unsigned int         fixed_rank) const;

    /**
     * Solve the transpose of an upper triangular matrix \f$U^Tx=b\f$ by forward
     * substitution.
     *
     * The right hand side vector \f$b\f$ will be overwritten by the solution
     * vector \f$x\f$.
     *
     * \alert{The vector \p b is **global**, which can be directly accessed by
     * DoF indices in the cluster's index range.}
     *
     * @param b Right hand side vector and after execution, it stores the result
     * vector.
     */
    void
    solve_transpose_by_forward_substitution(Vector<Number> &b) const;

    /**
     * Solve the transpose of an upper triangular matrix \f$U^Tx=b\f$ by forward
     * substitution.
     *
     * \alert{The vector \p b is **global**, which can be directly accessed by
     * DoF indices in the cluster's index range.}
     *
     * @param x Result vector.
     * @param b Right hand side vector.
     */
    void
    solve_transpose_by_forward_substitution(Vector<Number>       &x,
                                            const Vector<Number> &b) const;

    /**
     * Solve the transpose of an upper triangular matrix \f$U^Tx=b\f$ by forward
     * substitution.
     *
     * The right hand side vector \f$b\f$ will be overwritten by the solution
     * vector \f$x\f$.
     *
     * \alert{The vector \p b is **local**, i.e. associated with a cluster.
     * Therefore, the starting \hmat should be explicitly specified.}
     *
     * @param b
     * @param starting_hmat
     */
    void
    solve_transpose_by_forward_substitution(
      Vector<Number>                  &b,
      const HMatrix<spacedim, Number> &starting_hmat) const;

    /**
     * Solve the transpose of an upper triangular matrix \f$U^Tx=b\f$ by forward
     * substitution.
     *
     * \alert{The vector \p b is **local**, i.e. associated with a cluster.
     * Therefore, the starting \hmat should be explicitly specified.}
     *
     * @param x
     * @param b
     * @param starting_hmat
     */
    void
    solve_transpose_by_forward_substitution(
      Vector<Number>                  &x,
      const Vector<Number>            &b,
      const HMatrix<spacedim, Number> &starting_hmat) const;

    /**
     * Solve the matrix-valued problem
     * \f$X\vert_{\tau\times\sigma}U\vert_{\sigma\times\sigma} =
     * Z\vert_{\tau\times\sigma}\f$.
     *
     * A transposed system is solved, i.e.
     * \f$U^T\vert_{\sigma\times\sigma}X^T\vert_{\sigma\times\tau} =
     * Z^T\vert_{\sigma\times\tau}\f$. Then \f$U^T\vert_{\sigma\times\sigma}\f$
     * is a lower triangular \hmatrix and a similar procedure as that in the
     * matrix-valued forward substitution can be applied.
     *
     * @param X
     * @param Z
     * @param fixed_rank
     */
    void
    solve_transpose_by_forward_substitution_matrix_valued(
      HMatrix<spacedim, Number> &X,
      HMatrix<spacedim, Number> &Z,
      const unsigned int         fixed_rank) const;

    /**
     * Solve the matrix-valued problem
     * \f$X\vert_{\tau\times\sigma}U\vert_{\sigma\times\sigma} =
     * Z\vert_{\tau\times\sigma}\f$.
     *
     * This version is in situ, i.e. the solution is directly saved into
     * \f$Z\f$.
     *
     * @param Z
     * @param fixed_rank
     */
    void
    solve_transpose_by_forward_substitution_matrix_valued(
      HMatrix<spacedim, Number> &Z,
      const unsigned int         fixed_rank) const;

    /**
     * Solve the matrix-valued problem
     * \f$X\vert_{\tau\times\sigma}U\vert_{\sigma\times\sigma} =
     * Z\vert_{\tau\times\sigma}\f$, where the upper triangular \hmatrix
     * \f$U\vert_{\sigma\times\sigma}\f$ is obtained from a Cholesky
     * factorization, i.e. it is the the transpose of \f$L\f$.
     *
     * Since only the lower triangular part of a Cholesky factorization is
     * stored or effective, \f$U\vert_{\sigma\times\sigma} =
     * L^T\vert_{\sigma\times\sigma}\f$. Therefore, a transposed system is
     * solved using forward substitution, i.e.
     * \f$U^T\vert_{\sigma\times\sigma}X^T\vert_{\sigma\times\tau} =
     * L\vert_{\sigma\times\sigma}X^T\vert_{\sigma\times\tau} =
     * Z^T\vert_{\sigma\times\tau}\f$.
     *
     * @param X
     * @param Z
     * @param fixed_rank
     */
    void
    solve_cholesky_transpose_by_forward_substitution_matrix_valued(
      HMatrix<spacedim, Number> &X,
      HMatrix<spacedim, Number> &Z,
      const unsigned int         fixed_rank) const;

    void
    solve_cholesky_transpose_by_forward_substitution_matrix_valued(
      HMatrix<spacedim, Number> &Z,
      const unsigned int         fixed_rank) const;

    /**
     * Solve the block lower triangular matrix \f$Lx=b\f$ by forward
     * substitution.
     *
     * It has two differences from the version for solving a lower triangular
     * \hmatrix,
     *
     * 1. when the block lower triangular matrix is unit, each of its diagonal
     * blocks in the leaf set, which must be a full matrix, should be an
     * identity matrix instead of a lower triangular full matrix with unit
     * diagonal, i.e. \f$L\vert_{\tau\times\tau} = I\f$ for \f$\tau\times\tau
     * \in P\f$. In this case, there is no need to actually solve it.
     *
     * 2. when the block lower triangular matrix is not unit, its diagonal
     * blocks in the leaf set should be general full matrices instead of lower
     * triangular full matrices. In this case, a general linear system solver
     * should be adopted to solve it.
     *
     * \alert{Even though the member variables of the current class will be not
     * be modified, the actual heap memory data related to full matrix in the
     * leaf set will be changed, since LU factorization will be performed.}
     *
     * \alert{The vector \p b is **global**, which can be directly accessed by
     * DoF indices in the cluster's index range.}
     *
     * @param b
     * @param is_unit_diagonal
     */
    void
    solve_block_triangular_by_forward_substitution(
      Vector<Number> &b,
      const bool      is_unit_block_diagonal = true) const;

    /**
     * Solve the block lower triangular matrix \f$Lx=b\f$ by forward
     * substitution.
     *
     * \alert{The vector \p b is **global**, which can be directly accessed by
     * DoF indices in the cluster's index range.}
     *
     * @param x
     * @param b
     * @param is_unit_block_diagonal
     */
    void
    solve_block_triangular_by_forward_substitution(
      Vector<Number>       &x,
      const Vector<Number> &b,
      const bool            is_unit_block_diagonal = true) const;

    /**
     * Solve the block lower triangular matrix \f$Lx=b\f$ by forward
     * substitution.
     * The result vector will overwrite the RHS vector @p b.
     *
     * It has two differences from the version for solving a lower triangular
     * \hmatrix,
     *
     * 1. when the block lower triangular matrix is unit, each of its diagonal
     * blocks in the leaf set, which must be a full matrix, should be an
     * identity matrix instead of a lower triangular full matrix with unit
     * diagonal, i.e. \f$L\vert_{\tau\times\tau} = I\f$ for \f$\tau\times\tau
     * \in P\f$. In this case, there is no need to actually solve it.
     *
     * 2. when the block lower triangular matrix is not unit, its diagonal
     * blocks in the leaf set should be general full matrices instead of lower
     * triangular full matrices. In this case, a general linear system solver
     * should be adopted to solve it.
     *
     * \alert{Even though the member variables of the current class will be not
     * be modified, the actual heap memory data related to full matrix in the
     * leaf set will be changed, since LU factorization will be performed.}
     *
     * \alert{The vector \p b is **local**, i.e. associated with a cluster.
     * Therefore, the starting \hmat should be explicitly specified.}
     *
     * @param b
     * @param starting_hmat
     * @param is_unit_block_diagonal
     */
    void
    solve_block_triangular_by_forward_substitution(
      Vector<Number>                  &b,
      const HMatrix<spacedim, Number> &starting_hmat,
      const bool                       is_unit_block_diagonal = true) const;

    /**
     * Solve the block lower triangular matrix \f$Lx=b\f$ by forward
     * substitution.
     *
     * It has two differences from the version for solving a lower triangular
     * \hmatrix,
     *
     * 1. when the block lower triangular matrix is unit, each of its diagonal
     * blocks in the leaf set, which must be a full matrix, should be an
     * identity matrix instead of a lower triangular full matrix with unit
     * diagonal, i.e. \f$L\vert_{\tau\times\tau} = I\f$ for \f$\tau\times\tau
     * \in P\f$. In this case, there is no need to actually solve it.
     *
     * 2. when the block lower triangular matrix is not unit, its diagonal
     * blocks in the leaf set should be general full matrices instead of lower
     * triangular full matrices. In this case, a general linear system solver
     * should be adopted to solve it.
     *
     * \alert{Even though the member variables of the current class will be not
     * be modified, the actual heap memory data related to full matrix in the
     * leaf set will be changed, since LU factorization will be performed.}
     *
     * \alert{The vector \p b is **local**, i.e. associated with a cluster.
     * Therefore, the starting \hmat should be explicitly specified.}
     *
     * @param x
     * @param b
     * @param starting_hmat
     * @param is_unit_block_diagonal
     */
    void
    solve_block_triangular_by_forward_substitution(
      Vector<Number>                  &x,
      const Vector<Number>            &b,
      const HMatrix<spacedim, Number> &starting_hmat,
      const bool                       is_unit_block_diagonal = true) const;

    /**
     * Solve the lower triangular matrix \f$Lx=b\f$ by forward substitution,
     * where \f$L\f$ is obtained from a Cholesky decomposition. Hence, \f$L\f$
     * is not normed.
     *
     * This function directly calls \p
     * solve_by_forward_substitution(Vector<Number> &b, const bool
     * is_unit_diagonal = false) with \p is_unit_diagonal being \p false.
     *
     * \alert{The vector \p b is **global**, which can be directly accessed by
     * DoF indices in the cluster's index range.}
     *
     * @param b Right hand side vector and after execution, it stores the result
     * vector.
     */
    void
    solve_cholesky_by_forward_substitution(Vector<Number> &b) const;

    /**
     * Solve the lower triangular matrix \f$Lx=b\f$ by forward substitution,
     * where \f$L\f$ is obtained from a Cholesky decomposition. Hence, \f$L\f$
     * is not normed.
     *
     * This function directly calls \p void
     * solve_by_forward_substitution(Vector<Number> & x, const Vector<Number>
     * &b,
     * const bool is_unit_diagonal = false) const with \p is_unit_diagonal being
     * \p false.
     *
     * \alert{The vector \p b is **global**, which can be directly accessed by
     * DoF indices in the cluster's index range.}
     *
     * @param x Solution vector.
     * @param b Right hand side vector.
     */
    void
    solve_cholesky_by_forward_substitution(Vector<Number>       &x,
                                           const Vector<Number> &b) const;

    /**
     * Solve the lower triangular matrix \f$Lx=b\f$ by forward substitution,
     * where \f$L\f$ is obtained from a Cholesky decomposition. Hence, \f$L\f$
     * is not normed.
     *
     * \alert{The vector \p b is **local**, i.e. associated with a cluster.}
     *
     * @param b Right hand side vector and after execution, it stores the result
     * vector.
     * @param starting_hmat
     */
    void
    solve_cholesky_by_forward_substitution(
      Vector<Number>                  &b,
      const HMatrix<spacedim, Number> &starting_hmat) const;

    /**
     * Solve the lower triangular matrix \f$Lx=b\f$ by forward substitution,
     * where \f$L\f$ is obtained from a Cholesky decomposition. Hence, \f$L\f$
     * is not normed.
     *
     * \alert{The vector \p b is **local**, i.e. associated with a cluster.}
     *
     * @param x
     * @param b
     * @param starting_hmat
     */
    void
    solve_cholesky_by_forward_substitution(
      Vector<Number>                  &x,
      const Vector<Number>            &b,
      const HMatrix<spacedim, Number> &starting_hmat) const;

    /**
     * Solve the upper triangular matrix \f$Ux=b\f$ by backward substitution.
     *
     * The right hand side vector \f$b\f$ will be overwritten by the solution
     * vector \f$x\f$.
     *
     * \alert{The vector \p b is **global**, which can be directly accessed by
     * DoF indices in the cluster's index range.}
     *
     * \mynote{N.B. The default value for @p is_unit_diagonal is @p false, while
     * in @p solve_by_forward_substitution, this the default value is @p true.
     * This is because the matrix to be solved is usually derived from a LU
     * factorization, which ensures the lower triangular matrix has unit
     * diagonal while the upper triangular matrix does not.}
     *
     * @param b Right hand side vector and after execution, it stores the result vector.
     */
    void
    solve_by_backward_substitution(Vector<Number> &b,
                                   const bool is_unit_diagonal = false) const;

    /**
     * Solve the upper triangular matrix \f$Ux=b\f$ by backward substitution.
     *
     * \alert{The vector \p b is **global**, which can be directly accessed by
     * DoF indices in the cluster's index range.}
     *
     * \mynote{N.B. The default value for @p is_unit_diagonal is @p false, while
     * in @p solve_by_forward_substitution, this the default value is @p true.
     * This is because the matrix to be solved is usually derived from a LU
     * factorization, which ensures the lower triangular matrix has unit
     * diagonal while the upper triangular matrix does not.}
     *
     * @param x
     * @param b
     * @param is_unit_diagonal
     */
    void
    solve_by_backward_substitution(Vector<Number>       &x,
                                   const Vector<Number> &b,
                                   const bool is_unit_diagonal = false) const;

    /**
     * Solve the upper triangular matrix \f$Ux=b\f$ by backward substitution.
     *
     * The right hand side vector \f$b\f$ will be overwritten by the solution
     * vector \f$x\f$.
     *
     * \alert{The vector \p b is **local**, i.e. associated with a cluster.
     * Therefore, the starting \hmat should be explicitly specified.}
     *
     * \mynote{N.B. The default value for @p is_unit_diagonal is @p false, while
     * in @p solve_by_forward_substitution, this the default value is @p true.
     * This is because the matrix to be solved is usually derived from a LU
     * factorization, which ensures the lower triangular matrix has unit
     * diagonal while the upper triangular matrix does not.}
     *
     * @param b
     * @param starting_hmat
     * @param is_unit_diagonal
     */
    void
    solve_by_backward_substitution(
      Vector<Number>                  &b,
      const HMatrix<spacedim, Number> &starting_hmat,
      const bool                       is_unit_diagonal = false) const;

    /**
     * Solve the upper triangular matrix \f$Ux=b\f$ by backward substitution.
     *
     * \alert{The vector \p b is **local**, i.e. associated with a cluster.
     * Therefore, the starting \hmat should be explicitly specified.}
     *
     * \mynote{N.B. The default value for @p is_unit_diagonal is @p false, while
     * in @p solve_by_forward_substitution, this the default value is @p true.
     * This is because the matrix to be solved is usually derived from a LU
     * factorization, which ensures the lower triangular matrix has unit
     * diagonal while the upper triangular matrix does not.}
     *
     * @param x
     * @param b
     * @param starting_hmat
     * @param is_unit_diagonal
     */
    void
    solve_by_backward_substitution(
      Vector<Number>                  &x,
      const Vector<Number>            &b,
      const HMatrix<spacedim, Number> &starting_hmat,
      const bool                       is_unit_diagonal = false) const;

    /**
     * Solve the block upper triangular matrix \f$Ux=b\f$ by backward
     * substitution. The result vector will overwrite the RHS vector @p b.
     *
     * It has two differences from the version for solving an upper triangular
     * \hmatrix,
     *
     * 1. when the block upper triangular matrix is unit, each of its diagonal
     * blocks in the leaf set, which must be a full matrix, should be an
     * identity matrix instead of an upper triangular full matrix with unit
     * diagonal, i.e. \f$L\vert_{\tau\times\tau} = I\f$ for \f$\tau\times\tau
     * \in P\f$. In this case, there is no need to actually solve it.
     *
     * 2. when the block upper triangular matrix is not unit, its diagonal
     * blocks in the leaf set should be general full matrices instead of upper
     * triangular full matrices. In this case, a general linear system solver
     * should be adopted to solve it.
     *
     * \alert{Even though the member variables of the current class will be not
     * be modified, the actual heap memory data related to full matrix in the
     * leaf set will be changed, since LU factorization will be performed.}
     *
     * \alert{The vector \p b is **global**, which can be directly accessed by
     * DoF indices in the cluster's index range.}
     *
     * @param b
     * @param is_unit_diagonal
     */
    void
    solve_block_triangular_by_backward_substitution(
      Vector<Number> &b,
      const bool      is_unit_block_diagonal = false) const;

    /**
     * Solve the block upper triangular matrix \f$Ux=b\f$ by backward
     * substitution.
     *
     * It has two differences from the version for solving an upper triangular
     * \hmatrix,
     *
     * 1. when the block upper triangular matrix is unit, each of its diagonal
     * blocks in the leaf set, which must be a full matrix, should be an
     * identity matrix instead of an upper triangular full matrix with unit
     * diagonal, i.e. \f$L\vert_{\tau\times\tau} = I\f$ for \f$\tau\times\tau
     * \in P\f$. In this case, there is no need to actually solve it.
     *
     * 2. when the block upper triangular matrix is not unit, its diagonal
     * blocks in the leaf set should be general full matrices instead of upper
     * triangular full matrices. In this case, a general linear system solver
     * should be adopted to solve it.
     *
     * \alert{Even though the member variables of the current class will be not
     * be modified, the actual heap memory data related to full matrix in the
     * leaf set will be changed, since LU factorization will be performed.}
     *
     * \alert{The vector \p b is **global**, which can be directly accessed by
     * DoF indices in the cluster's index range.}
     *
     * @param x
     * @param b
     * @param is_unit_block_diagonal
     */
    void
    solve_block_triangular_by_backward_substitution(
      Vector<Number>       &x,
      const Vector<Number> &b,
      const bool            is_unit_block_diagonal = false) const;

    /**
     * Solve the block upper triangular matrix \f$Ux=b\f$ by backward
     * substitution. The result vector will overwrite the RHS vector @p b.
     *
     * It has two differences from the version for solving an upper triangular
     * \hmatrix,
     *
     * 1. when the block upper triangular matrix is unit, each of its diagonal
     * blocks in the leaf set, which must be a full matrix, should be an
     * identity matrix instead of an upper triangular full matrix with unit
     * diagonal, i.e. \f$L\vert_{\tau\times\tau} = I\f$ for \f$\tau\times\tau
     * \in P\f$. In this case, there is no need to actually solve it.
     *
     * 2. when the block upper triangular matrix is not unit, its diagonal
     * blocks in the leaf set should be general full matrices instead of upper
     * triangular full matrices. In this case, a general linear system solver
     * should be adopted to solve it.
     *
     * \alert{Even though the member variables of the current class will be not
     * be modified, the actual heap memory data related to full matrix in the
     * leaf set will be changed, since LU factorization will be performed.}
     *
     * \alert{The vector \p b is **local**, i.e. associated with a cluster.
     * Therefore, the starting \hmat should be explicitly specified.}
     *
     * @param b
     * @param starting_hmat
     * @param is_unit_block_diagonal
     */
    void
    solve_block_triangular_by_backward_substitution(
      Vector<Number>                  &b,
      const HMatrix<spacedim, Number> &starting_hmat,
      const bool                       is_unit_block_diagonal = false) const;

    /**
     * Solve the block upper triangular matrix \f$Ux=b\f$ by backward
     * substitution.
     *
     * It has two differences from the version for solving an upper triangular
     * \hmatrix,
     *
     * 1. when the block upper triangular matrix is unit, each of its diagonal
     * blocks in the leaf set, which must be a full matrix, should be an
     * identity matrix instead of an upper triangular full matrix with unit
     * diagonal, i.e. \f$L\vert_{\tau\times\tau} = I\f$ for \f$\tau\times\tau
     * \in P\f$. In this case, there is no need to actually solve it.
     *
     * 2. when the block upper triangular matrix is not unit, its diagonal
     * blocks in the leaf set should be general full matrices instead of upper
     * triangular full matrices. In this case, a general linear system solver
     * should be adopted to solve it.
     *
     * \alert{Even though the member variables of the current class will be not
     * be modified, the actual heap memory data related to full matrix in the
     * leaf set will be changed, since LU factorization will be performed.}
     *
     * \alert{The vector \p b is **local**, i.e. associated with a cluster.
     * Therefore, the starting \hmat should be explicitly specified.}
     *
     * @param x
     * @param b
     * @param starting_hmat
     * @param is_unit_block_diagonal
     */
    void
    solve_block_triangular_by_backward_substitution(
      Vector<Number>                  &x,
      const Vector<Number>            &b,
      const HMatrix<spacedim, Number> &starting_hmat,
      const bool                       is_unit_block_diagonal = false) const;

    /**
     * Solve \f$L^T x=b\f$ by backward substitution.
     *
     * The right hand side vector \f$b\f$ will be overwritten by the solution
     * vector \f$x\f$.
     *
     * \alert{The vector \p b is **global**, which can be directly accessed by
     * DoF indices in the cluster's index range.}
     *
     * @param b Right hand side vector and after execution, it stores the result
     * vector.
     */
    void
    solve_cholesky_by_backward_substitution(Vector<Number> &b) const;

    /**
     * Solve \f$L^T x=b\f$ by backward substitution.
     *
     * \alert{The vector \p b is **global**, which can be directly accessed by
     * DoF indices in the cluster's index range.}
     *
     * @param x Result vector.
     * @param b Right hand side vector.
     */
    void
    solve_cholesky_by_backward_substitution(Vector<Number>       &x,
                                            const Vector<Number> &b) const;

    /**
     * Solve \f$L^T x=b\f$ by backward substitution.
     *
     * The right hand side vector \f$b\f$ will be overwritten by the solution
     * vector \f$x\f$.
     *
     * \alert{The vector \p b is **local**, i.e. associated with a cluster.
     * Therefore, the starting \hmat should be explicitly specified.}
     *
     * @param b
     * @param starting_hmat
     */
    void
    solve_cholesky_by_backward_substitution(
      Vector<Number>                  &b,
      const HMatrix<spacedim, Number> &starting_hmat) const;

    /**
     * Solve \f$L^T x=b\f$ by backward substitution.
     *
     * \alert{The vector \p b is **local**, i.e. associated with a cluster.
     * Therefore, the starting \hmat should be explicitly specified.}
     *
     * @param x
     * @param b
     * @param starting_hmat
     */
    void
    solve_cholesky_by_backward_substitution(
      Vector<Number>                  &x,
      const Vector<Number>            &b,
      const HMatrix<spacedim, Number> &starting_hmat) const;

    /**
     * Compute the LU factorization of an \hmatrix. The resulted \f$L\f$ and
     * \f$U\f$ factors are stored in a same \hmatrix \f$LU\f$. The matrix
     * \f$LU\f$ should have the same hierarchical structure as the original
     * matrix.
     *
     * \mynote{After LU factorization, the state of the result matrix is set to
     * @p lu and that of the original matrix is @p unusable.}
     *
     * @param LU
     * @param fixed_rank
     */
    void
    compute_lu_factorization(HMatrix<spacedim, Number> &LU,
                             const unsigned int         fixed_rank);

    /**
     * Compute the LU factorization of an \hmatrix in situ. The resulted \f$L\f$
     * and \f$U\f$ factors are stored in the original \hmatrix.
     *
     * @param fixed_rank
     */
    void
    compute_lu_factorization(const unsigned int fixed_rank);

    /**
     * Compute the LU factorization of an \hmatrix in situ using task based
     * parallelism. The resulted \f$L\f$ and \f$U\f$ factors are stored in the
     * original \hmatrix.
     *
     * @param fixed_rank
     */
    void
    compute_lu_factorization_task_parallel(const unsigned int fixed_rank);


    /**
     * Compute the Cholesky factorization of an \hmatrix. Only the lower
     * triangular \hmatrix factor \f$L\f$ is stored in the output variable \p L.
     * The matrix \f$L\f$ should have the same hierarchical structure as the
     * original matrix.
     *
     * \mynote{1. The result H-matrix @p L should have be constructed and
     * allocated with memory.
     * 2. After calling this function, the state of the original \hmatrix is
     * set to @p unusable, while the result matrix @p L has @p cholesky state and
     * @p lower_triangular property.}
     *
     * @param L
     * @param fixed_rank
     */
    void
    compute_cholesky_factorization(HMatrix<spacedim, Number> &L,
                                   const unsigned int         fixed_rank);

    /**
     * Compute the Cholesky factorization of an \hmatrix in situ. Only the lower
     * triangular \hmatrix factor \f$L\f$ is stored in the original matrix.
     *
     * \mynote{Before the factorization, the \hmatrix has @p matrix state,
     * @p symmetric property and @p diagonal_type block type. After the
     * factorization, it has @p cholesky state, @p lower_triangular property and
     * @p diagonal_type block type.}
     *
     * @param fixed_rank
     */
    void
    compute_cholesky_factorization(const unsigned int fixed_rank);

    /**
     * Compute the Cholesky factorization of an \hmatrix in situ using task
     * based parallelism. The resulted \f$L\f$ factor is stored in the original
     * \hmatrix.
     *
     * @param fixed_rank
     */
    void
    compute_cholesky_factorization_task_parallel(const unsigned int fixed_rank);

    /**
     * Solve the whole linear system formed by the current \hmatrix, which
     * should
     * have been applied the LU factorization. The right hand side vector \p b
     * should be accessed via global indices.
     *
     * \mynote{After LU factorization, the obtained @p L has unit diagonal while
     * @p U does not.}
     *
     * @param x
     * @param b
     */
    void
    solve_lu(Vector<Number> &x, const Vector<Number> &b) const;

    /**
     * Solve the whole linear system formed by the current \hmatrix, which
     * should have been applied the Cholesky factorization. The right hand side
     * vector
     * \p b should be accessed via global indices.
     *
     * @param x
     * @param b
     */
    void
    solve_cholesky(Vector<Number> &x, const Vector<Number> &b) const;

    /**
     * Coarsen the current \hmatrix so that it corresponds to the
     * partition determined by the \p subtree. Each rank-k matrix in the
     * hierarchical matrix structure will be truncated to \p fixed_rank_k.
     *
     * This function calls \p HMatrix<spacedim, Number>::coarsen_to_partition
     * internally. After that, the leaf set is rebuilt.
     *
     * This member function implements the operator \f$\mathcal{T}_{P'
     * \leftarrow P}^{\mathcal{H} \leftarrow \mathcal{H}}\f$ for the case \f$T(I
     * \times J, P') \subset T(I \times J, P)\f$ in (7.9) in Hackbusch's
     * \hmatrix book. Because there is no internal check about
     * this, users should ensure that the given \p subtree is really a subtree of
     * the block cluster tree associated with this \hmatrix
     * hierarchy.
     *
     * @param subtree
     * @param fixed_rank_k
     */
    void
    coarsen_to_subtree(const BlockClusterTree<spacedim, Number> &subtree,
                       const unsigned int                        fixed_rank_k);

    /**
     * Coarsen the current \hmatrix via recursive call so that its leaf set
     * complies with the given partition. Each rank-k matrix in the \hmatrix
     * structure will be truncated to \p fixed_rank_k.
     *
     * Since this is a recursive member function, it does not execute leaf set
     * rebuilding, which is an operation on the overall \hmat hierarchy.
     *
     * This member function implements the operator \f$\mathcal{T}_{P'
     * \leftarrow P}^{\mathcal{H} \leftarrow \mathcal{H}}\f$ for the case \f$T(I
     * \times J, P') \subset T(I \times J, P)\f$ in (7.9) in Hackbusch's
     * \hmatrix book. Because there is no internal check about
     * this, users should ensure this set inclusion relationship.
     *
     * @param partition
     * @param fixed_rank_k
     */
    void
    coarsen_to_partition(
      const std::vector<
        typename BlockClusterTree<spacedim, Number>::node_pointer_type>
                        &partition,
      const unsigned int fixed_rank_k);

    /**
     * Link \hmatrix nodes on a same level according to the top level H-matrix
     * property.
     */
    void
    link_hmat_nodes_on_same_levels();

    /**
     * Starting from a diagonal block, link \hmatrix nodes on a same level and
     * same row as well as \hmatrix nodes on a same level and same column. This
     * member function should only be called when the \hmatrix object is a
     * diagonal block.
     *
     * This is function is only needed by H-LU factorization at the moment.
     */
    void
    link_hmat_nodes_on_cross_from_diagonal_blocks(
      const HMatrixSupport::Property top_hmat_property);

    /**
     * Build the leaf set of the current \hmatnode.
     */
    void
    build_leaf_set();

    /**
     * Get the reference to the leaf set of the current \hmatrix
     * node.
     * @return
     */
    std::vector<HMatrix<spacedim, Number> *> &
    get_leaf_set();

    /**
     * Get the reference to the leaf set of the current \hmatrix
     * node (const version).
     * @return
     */
    const std::vector<HMatrix<spacedim, Number> *> &
    get_leaf_set() const;

    std::vector<HMatrix<spacedim, Number> *> &
    get_near_field_leaf_set();

    const std::vector<HMatrix<spacedim, Number> *> &
    get_near_field_leaf_set() const;

    std::vector<HMatrix<spacedim, Number> *> &
    get_far_field_leaf_set();

    const std::vector<HMatrix<spacedim, Number> *> &
    get_far_field_leaf_set() const;

    /**
     * Get the pointer to the global row index range.
     *
     * \mynote{The index range follows the internal DoF numbering.}
     *
     * @return
     */
    std::array<types::global_dof_index, 2> *
    get_row_index_range();

    /**
     * Get the pointer to the global row index range (const version).
     *
     * \mynote{The index range follows the internal DoF numbering.}
     *
     * @return
     */
    const std::array<types::global_dof_index, 2> *
    get_row_index_range() const;

    /**
     * Get the pointer to the global column index range.
     *
     * \mynote{The index range follows the internal DoF numbering.}
     *
     * @return
     */
    std::array<types::global_dof_index, 2> *
    get_col_index_range();

    /**
     * Get the pointer to the global column index range (const version).
     *
     * \mynote{The index range follows the internal DoF numbering.}
     *
     * @return
     */
    const std::array<types::global_dof_index, 2> *
    get_col_index_range() const;

    /**
     * Find a block cluster in the leaf set of the current
     * \hmatrix and returns the iterator of the corresponding
     * \hmatnode in the leaf set.
     *
     * @param block_cluster
     * @return
     */
    typename std::vector<HMatrix<spacedim, Number> *>::iterator
    find_block_cluster_in_leaf_set(
      const BlockCluster<spacedim, Number> &block_cluster);

    /**
     * Find a block cluster in the leaf set of the current
     * \hmatrix and returns the iterator of the corresponding
     * \hmatnode in the leaf set (const version).
     *
     * @param block_cluster
     * @return
     */
    typename std::vector<HMatrix<spacedim, Number> *>::const_iterator
    find_block_cluster_in_leaf_set(
      const BlockCluster<spacedim, Number> &block_cluster) const;

    /**
     * Refine the current \hmatrix, whose associated block cluster
     * tree has been extended. The operation has no accuracy loss.
     *
     * This member function implements the operator \f$\mathcal{T}_{P'
     * \leftarrow P}^{\mathcal{H} \leftarrow \mathcal{H}}\f$ for the case \f$T(I
     * \times J, P') \supset T(I \times J, P)\f$ in (7.9) in Hackbusch's
     * \hmatrix book. Because there is no internal check about
     * this, users should ensure that the original block cluster tree associated
     * with this \hmatrix hierarchy has really been extended.
     */
    void
    refine_to_supertree();

    /**
     * Convert an \hmatrix between two different block cluster
     * trees \f$T\f$ and \f$T'\f$, where \f$T := T(I \times J, P)\f$ and \f$T'
     * := T'(I \times J, P')\f$. The two trees have incompatible partitions and
     * do not contain each other. However, they are constructed on the same
     * cluster trees \f$T(I)\f$ and \f$T(J)\f$. This enables us to make a
     * <strong>shallow</strong> comparison of two block cluster nodes based on
     * the pointer addresses related to the comprising clusters, which is useful
     * for verify the equality of two block cluster nodes.
     *
     * The procedures of this algorithm are as below. Assume the current
     * \hmatrix to be converted is associated with the block
     * cluster tree \f$T\f$.
     *
     * 1. Extend \f$T\f$ to be finer than \f$T'\f$, from which we get the new
     * block cluster tree \f$T''\f$.
     * 2. Refine the original \hmatrix with respect to the
     * extended tree \f$T''\f$.
     * 3. Get and keep a record of the leaf set of the block cluster tree
     * \f$T'\f$, which will be used for matrix coarsening in the last step.
     * 4. Extend \f$T'\f$ to the finer block cluster tree \f$T''\f$, from which
     * we get \f$\widetilde{T}'\f$.
     * 5. Build a new \hmatrix with respect to \f$\widetilde{T}'\f$
     * with the actual data migrated from the leaf nodes of the original
     * \hmatrix.
     * 6. Coarsen the new \hmatrix to the original partition of
     * \f$T'\f$.
     * 7. Delete the hierarchy of the original \hmatrix.
     * 8. Assign the new \hmatrix object to the original
     * \hmatrix object.
     *
     * @param bct1 The block cluster tree which is associated with the current
     * \hmatrix.
     * @param bct2 The block cluster tree to which the current
     * \hmatrix is to be converted.
     */
    void
    convert_between_different_block_cluster_trees(
      BlockClusterTree<spacedim, Number> &bct1,
      BlockClusterTree<spacedim, Number> &bct2,
      const unsigned int                  fixed_rank_k2 = 1);

    /**
     * Remove a pair of \hmatnodes from the list of
     * matrix-matrix product subtasks to be performed, i.e. from the list
     * \p HMatrix::Sigma_P.
     */
    void
    remove_hmat_pair_from_mm_product_list(const HMatrix<spacedim, Number> *M1,
                                          const HMatrix<spacedim, Number> *M2);

    /**
     * Remove a pair of \hmatnodes from the list of
     * matrix-matrix product subtasks to be performed, i.e. from the list
     * \p HMatrix::Sigma_P.
     */
    void
    remove_hmat_pair_from_mm_product_list(
      const std::pair<const HMatrix<spacedim, Number> *,
                      const HMatrix<spacedim, Number> *> &hmat_pair);

    /**
     * Check the consistency of the tree node split modes which are associated
     * with the \hmatnode pairs stored in the list
     * \f$\Sigma_P\f$ of the current \hmatnode.
     * @return
     */
    TreeNodeSplitMode
    determine_mm_split_mode_from_Sigma_P();

    /**
     * Determine an estimate for the memory consumption (in bytes) of the
     * current \hmatnode.
     *
     * @return
     */
    std::size_t
    memory_consumption_of_current_hmat_node() const;

    /**
     * Determine an estimate for the memory consumption (in bytes) of the whole
     * \hmatrix hierarchy.
     *
     * @return
     */
    std::size_t
    memory_consumption() const;

    /**
     * Determine an estimate for the memory consumption (in bytes) of H-matrices
     * in the leaf set.
     */
    std::size_t
    memory_consumption_of_leaf_set() const;

    /**
     * Determine an estimate for the memory consumption (in bytes) of H-matrices
     * in the near field leaf set.
     */
    std::size_t
    memory_consumption_of_near_field_leaf_set() const;

    /**
     * Determine an estimate for the memory consumption (in bytes) of H-matrices
     * in the far field leaf set.
     */
    std::size_t
    memory_consumption_of_far_field_leaf_set() const;

  private:
    /**
     * Assign IDs to \hmatnodes, which will be used to generate the dot
     * directed graph.
     *
     * @param current_id
     */
    void
    assign_node_ids_for_dot();

    /**
     * Print the \hmatrix hierarchy information recursively as a node in the
     * directional graph in Graphviz dot format.
     *
     * @param out
     */
    void
    _print_matrix_info_as_dot_node(std::ostream &out) const;

    /**
     * Set the matrix property of the converted full matrix based on the
     * property of the current \hmatrix.
     *
     * @param M
     */
    void
    set_property_for_converted_fullmatrix(LAPACKFullMatrixExt<Number> &M) const;

    /**
     * Convert an HMatrix to a full matrix by recursion.
     * @param matrix
     */
    template <typename MatrixType>
    void
    _convertToFullMatrix(MatrixType                    &M,
                         const HMatrixSupport::Property top_hmat_property =
                           HMatrixSupport::general) const;

    /**
     * Collect \hmatnodes in the leaf set into a vector using Z-curve traversal.
     *
     * @param total_leaf_set
     */
    void
    _build_leaf_set_z_traversal(
      std::vector<HMatrix *> &total_leaf_set,
      std::vector<HMatrix *> &total_near_field_leaf_set,
      std::vector<HMatrix *> &total_far_field_leaf_set) const;

    void
    _build_leaf_set_hilbert_traversal(
      std::vector<HMatrix *> &total_leaf_set,
      std::vector<HMatrix *> &total_near_field_leaf_set,
      std::vector<HMatrix *> &total_far_field_leaf_set,
      HilbertBlockType        current_hilbert_block_type) const;

    void
    distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves(
      const unsigned int fixed_rank = 0);

    void
    distribute_sigma_r_and_f_to_leaves(const unsigned int fixed_rank = 0);

    void
    _distribute_sigma_r_and_f_to_leaves(
      HMatrix<spacedim, Number> &starting_hmat,
      const unsigned int         fixed_rank = 0);

    /**
     * Calculate the inverse of the \hmatnode via Gauss
     * elimination.
     *
     * @param M_inv
     * @param M_root The \hmatnode from which this recursive function is called for
     * the first time.
     * @param M_root_bct The \bct associated with \p M_root.
     * @param fixed_rank_k
     */
    void
    _invert_by_gauss_elim(HMatrix<spacedim, Number> &M_inv,
                          const size_type            fixed_rank_k);

    /**
     * Internal recursive function to be called by
     * @code{c++}
     * HMatrix::compute_lu_factorization(HMatrix<spacedim, Number> &LU, const
     * unsigned int fixed_rank).
     * @endcode
     *
     * @param LU
     * @param fixed_rank
     */
    void
    _compute_lu_factorization(HMatrix<spacedim, Number> &LU,
                              const unsigned int         fixed_rank) const;

    /**
     * Internal recursive function to be called by
     * @code{c++}
     * HMatrix::compute_lu_factorization(const unsigned int fixed_rank).
     * @endcode
     *
     * This algorithm is in situ.
     *
     * @param fixed_rank
     */
    void
    _compute_lu_factorization(const unsigned int fixed_rank);

    /**
     * Compute the directed acyclic graph for H-LU factorization.
     *
     * @param fixed_rank
     */
    void
    compute_lu_dag(tbb::flow::graph  &dag,
                   const unsigned int fixed_rank,
                   std::mutex        &log_stream_lock);

    /**
     * Create a task node for the LU factorization of the current diagonal
     * block. It only has actual computation when the current \hmatnode belongs
     * to the leaf set.
     */
    void
    lu_factorize_diagonal_block_task(tbb::flow::graph &dag,
                                     std::mutex       &log_stream_lock);

    /**
     * Solve the problem of \f$XU=Z\f$.
     *
     * @param dag
     * @param Z
     * @param fixed_rank
     */
    void
    lu_solve_upper_task(tbb::flow::graph          &dag,
                        HMatrix<spacedim, Number> &Z,
                        const unsigned int         fixed_rank,
                        std::mutex                &log_stream_lock);

    /**
     * Solve the problem of \f$LX=Z\f$.
     *
     * @param dag
     * @param Z
     * @param fixed_rank
     */
    void
    lu_solve_lower_task(tbb::flow::graph          &dag,
                        HMatrix<spacedim, Number> &Z,
                        const unsigned int         fixed_rank,
                        std::mutex                &log_stream_lock);

    /**
     * Create the task node for updating the current \hmatnode. The task node
     * will be added to the list of update nodes associated with the
     * current \hmatnode.
     *
     * @param dag
     * @param same_level_column_block It corresponds to the \hmatnode \f$L_{ri}\f$.
     * @param same_level_row_block It corresponds to the \hmatnode \f$U_{is}\f$.
     */
    void
    lu_update_task(tbb::flow::graph          &dag,
                   HMatrix<spacedim, Number> &diag_block,
                   HMatrix<spacedim, Number> &diag_column_block,
                   HMatrix<spacedim, Number> &diag_row_block,
                   const unsigned int         fixed_rank,
                   std::mutex                &log_stream_lock);

    /**
     * Create the task node dependencies from a @p solve_upper task to an @p update task.
     */
    void
    lu_or_cholesky_build_solve_upper_to_update_dependencies(
      HMatrix<spacedim, Number> &update_block);

    /**
     * Create the task node dependencies from a @p solve_lower task to an @p update task.
     */
    void
    lu_build_solve_lower_to_update_dependencies(
      HMatrix<spacedim, Number> &update_block);

    /**
     * Create the task node dependencies from @p update task to @p factorize task.
     *
     * @param factorize_node
     */
    void
    lu_build_update_to_factorize_dependencies(
      HMatrix<spacedim, Number> &factorize_block);

    /**
     * Create the task node dependencies from @p update task to @p solve_upper
     * task or @p solve_lower task by starting from a \hmatnode which is itself
     * associated with a @p solve_upper or @p solve_lower task node.
     */
    void
    lu_build_update_to_solve_upper_or_lower_dependencies(
      HMatrix<spacedim, Number> &solve_upper_or_lower_block);

    /**
     * Build task dependencies between @p update tasks, @p solve_upper tasks
     * @p solve_lower tasks and @p factorize tasks.
     *
     * The following operations will be prformed:
     *
     * 1. Build @p update task to @p solve_upper or @p solve_lower task
     * dependencies.
     * 2. Transfer the @p update tasks of the current \hmatnode to its
     * descendants.
     * 3. Build @p update task to @p factorize task dependencies.
     * 4. Build task dependencies between @p factorize tasks on successive
     * H-matrix levels.
     */
    void
    lu_assign_update_to_solve_and_factorize_dependencies();

    /**
     * Internal recursive function to be called by
     * @code{c++}
     * HMatrix::compute_cholesky_fatorization(HMatrix<spacedim, Number> &L,
     * const unsigned int fixed_rank).
     * @endcode
     *
     * @param L
     * @param fixed_rank
     */
    void
    _compute_cholesky_factorization(HMatrix<spacedim, Number> &L,
                                    const unsigned int fixed_rank) const;

    /**
     * Internal recursive function to be called by
     * <code>{c++}
     * HMatrix::compute_cholesky_factorization(const unsigned int fixed_rank).
     * </code>
     *
     * @param fixed_rank
     */
    void
    _compute_cholesky_factorization(const unsigned int fixed_rank);

    /**
     * Compute the directed acyclic graph for H-Cholesky factorization.
     *
     * @param fixed_rank
     */
    void
    compute_cholesky_dag(tbb::flow::graph  &dag,
                         const unsigned int fixed_rank,
                         std::mutex        &log_stream_lock);

    /**
     * Create a task node for the Cholesky factorization of the current diagonal
     * block. It only has actual computation when the current \hmatnode belongs
     * to the leaf set.
     */
    void
    cholesky_factorize_diagonal_block_task(tbb::flow::graph &dag,
                                           std::mutex       &log_stream_lock);

    /**
     * Solve the problem of \f$XL^T=Z\f$.
     *
     * @param dag
     * @param Z
     * @param fixed_rank
     */
    void
    cholesky_solve_upper_task(tbb::flow::graph          &dag,
                              HMatrix<spacedim, Number> &Z,
                              const unsigned int         fixed_rank,
                              std::mutex                &log_stream_lock);

    /**
     * Create the task node for updating the current \hmatnode. The task node
     * will be added to the list of update nodes associated with the
     * current \hmatnode.
     *
     * @param dag
     * @param same_level_column_block It corresponds to the \hmatnode \f$L_{ri}\f$.
     * @param same_level_row_block It corresponds to the \hmatnode \f$U_{is}\f$.
     */
    void
    cholesky_update_task(tbb::flow::graph          &dag,
                         HMatrix<spacedim, Number> &diag_block,
                         HMatrix<spacedim, Number> &diag_column_block1,
                         HMatrix<spacedim, Number> &diag_column_block2,
                         const unsigned int         fixed_rank,
                         std::mutex                &log_stream_lock);

    /**
     * Create the task node dependencies from @p update task to @p factorize task.
     *
     * @param factorize_node
     */
    void
    cholesky_build_update_to_factorize_dependencies(
      HMatrix<spacedim, Number> &factorize_block);

    /**
     * Create the task node dependencies from @p update task to @p solve_upper
     * task by starting from a \hmatnode which is itself associated with a
     * @p solve_upper task node.
     */
    void
    cholesky_build_update_to_solve_upper_dependencies(
      HMatrix<spacedim, Number> &solve_upper_block);

    /**
     * Build task dependencies between @p update tasks, @p solve_upper tasks and
     * @p factorize tasks.
     *
     * The following operations will be prformed:
     *
     * 1. Build @p update task to @p solve_upper task dependencies.
     * 2. Transfer the @p update tasks of the current \hmatnode to its
     * descendants.
     * 3. Build @p update task to @p factorize task dependencies.
     * 4. Build task dependencies between @p factorize tasks on successive
     * H-matrix levels.
     */
    void
    cholesky_assign_update_to_solve_and_factorize_dependencies();

    /**
     * Method used for traversing the leaf set by following a space-filling
     * curve.
     */
    static SpaceFillingCurveType leaf_set_traversal_method;

    /**
     * Matrix type, which is one of @p FullMatrixType, @p RkMatrixType and
     * @p HierarchicalMatrixType.
     */
    HMatrixType type;

    /**
     * State of the \hmatrix, such as @p matrix, @p lu, @p cholesky, etc.
     */
    HMatrixSupport::State state;

    /**
     * Property of the \hmatrix, such as @p general, @p symmetric,
     * @p lower triangular, etc.
     */
    HMatrixSupport::Property property;

    /**
     * Block type for the current \hmatnode, which can be @p diagonal_block,
     * @p upper_triangular_block or @p lower_triangular_block.
     */
    HMatrixSupport::BlockType block_type;

    /**
     * Node ID used for generating the directed graph in GraphViz dot.
     */
    size_type dot_node_id;

    /**
     * A list of submatrices of type \hmatrix.
     */
    std::vector<HMatrix<spacedim, Number> *> submatrices;

    /**
     * Pointer to the parent \hmatrix.
     */
    HMatrix<spacedim, Number> *parent;

    /**
     * Pointer to the next \hmatrix node on a same level.
     */
    HMatrix<spacedim, Number> *next_same_level_hmat_node;

    /**
     * Pointer to the next \hmatrix node on a same level, which is also in a
     * same row as the same-level diagonal block.
     */
    HMatrix<spacedim, Number> *next_same_level_same_row_hmat_node;

    /**
     * Pointer to the next \hmatrix node on a same level, which is also in a
     * same column as the same-level diagonal block.
     */
    HMatrix<spacedim, Number> *next_same_level_same_column_hmat_node;

    /**
     * Pointer to the previous \hmatrix node on a same level, which is also in a
     * same row as the same-level diagonal block.
     */
    HMatrix<spacedim, Number> *previous_same_level_same_row_hmat_node;

    /**
     * Pointer to the previous \hmatrix node on a same level, which is also in a
     * same column as the same-level diagonal block.
     */
    HMatrix<spacedim, Number> *previous_same_level_same_column_hmat_node;

    /**
     * Submatrix index of the current \hmatnode wrt. its parent \hmatnode.
     */
    unsigned int submatrix_index;

    /**
     * A list of submatrices in the leaf set.
     */
    std::vector<HMatrix<spacedim, Number> *> leaf_set;

    /**
     * Near field \hmatrix leaf node set.
     */
    std::vector<HMatrix<spacedim, Number> *> near_field_leaf_set;

    /**
     * Far field \hmatrix leaf node set.
     */
    std::vector<HMatrix<spacedim, Number> *> far_field_leaf_set;

    /**
     * Pointer to the rank-k matrix. It is not null when the current HMatrix
     * object belongs to the far field.
     */
    RkMatrix<Number> *rkmatrix;

    /**
     * Pointer to the full matrix. It is not null when the current HMatrix
     * object belongs to the near field.
     */
    LAPACKFullMatrixExt<Number> *fullmatrix;

    /**
     * Pointer to the corresponding block cluster node in a BlockClusterTree.
     */
    typename BlockClusterTree<spacedim, Number>::node_pointer_type bc_node;

    /**
     * Pointer to the range of row indices (in internal DoF numbering), which
     * has been stored in the cluster \f$\tau\f$. It is a subset of \f$I\f$.
     */
    std::array<types::global_dof_index, 2> *row_index_range;

    /**
     * Pointer to the range of column indices (in internal DoF numbering), which
     * has been stored in the cluster \f$\sigma\f$. It is a subset of \f$J\f$.
     */
    std::array<types::global_dof_index, 2> *col_index_range;

    /**
     * Total number of rows in the matrix.
     */
    size_type m;

    /**
     * Total number of columns in the matrix.
     */
    size_type n;

    /**
     * Block cluster tree when this matrix is the product of two
     * \f$\mathcal{H}\f$-matrices.
     */
    BlockClusterTree<spacedim, Number> Tind;

    /**
     * List of pairs of pointers to \hmatnodes for
     * multiplication.
     */
    std::vector<
      std::pair<HMatrix<spacedim, Number> *, HMatrix<spacedim, Number> *>>
      Sigma_P;

    /**
     * List of rank-k matrix pointers used in \hmatrix
     * multiplication.
     */
    std::vector<RkMatrix<Number> *> Sigma_R;

    /**
     * List of full matrix pointers used in \hmatrix
     * multiplication.
     */
    std::vector<LAPACKFullMatrixExt<Number> *> Sigma_F;

    /**
     * Pointer to the task node for LU factorization of a diagonal
     * \hmatnode.
     */
    TaskNodePtr factorize_lu_or_cholesky_graph_node;

    /**
     * Pointer to the task node for solving a non-diagonal \hmatnode.
     */
    TaskNodePtr solve_upper_or_lower_lu_or_cholesky_graph_node;

    /**
     * List of pointers to the task nodes for updating the current \hmatnode.
     */
    std::vector<UpdateTaskNodeForLUOrCholesky>
      update_lu_or_cholesky_graph_nodes;

    /**
     * Lock to prevent simultaneous execution of update tasks on a same
     * \hmatnode.
     */
    std::mutex update_lock;
  };

  // Initialization of the static member of H-matrix to Z curve.
  template <int spacedim, typename Number>
  typename HMatrix<spacedim, Number>::SpaceFillingCurveType
    HMatrix<spacedim, Number>::leaf_set_traversal_method =
      HMatrix<spacedim, Number>::SpaceFillingCurveType::Z;

  /**
   * Initialize an \hmatnode with respect to a block cluster
   * node. The list \f$\Sigma_b^P\f$ is set to empty.
   *
   * @param hmat
   * @param bc_node
   * @param Sigma_P
   */
  template <int spacedim, typename Number = double>
  void
  InitHMatrixWrtBlockClusterNode(
    HMatrix<spacedim, Number> &hmat,
    typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
      bc_node)
  {
    /**
     * Link \p hmat with \p bc_node.
     */
    hmat.bc_node = const_cast<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type>(bc_node);

    /**
     * Link row and column indices stored in the clusters \f$\tau\f$ and
     * \f$\sigma\f$ respectively.
     */
    hmat.row_index_range = const_cast<std::array<types::global_dof_index, 2> *>(
      &(hmat.bc_node->get_data_reference()
          .get_tau_node()
          ->get_data_reference()
          .get_index_range()));
    hmat.col_index_range = const_cast<std::array<types::global_dof_index, 2> *>(
      &(hmat.bc_node->get_data_reference()
          .get_sigma_node()
          ->get_data_reference()
          .get_index_range()));

    /**
     * Update the matrix dimension of \p hmat.
     */
    hmat.m = (*hmat.row_index_range)[1] - (*hmat.row_index_range)[0];
    hmat.n = (*hmat.col_index_range)[1] - (*hmat.col_index_range)[0];

    hmat.Sigma_P.clear();
    hmat.Sigma_R.clear();
    hmat.Sigma_F.clear();
  }


  /**
   * Initialize an \hmatnode with respect to a block cluster
   * node. Its member list \f$\Sigma_b^P\f$ will be merged with the given \p
   * Sigma_P.
   *
   * @param hmat
   * @param bc_node
   * @param Sigma_P
   */
  template <int spacedim, typename Number = double>
  void
  InitHMatrixWrtBlockClusterNode(
    HMatrix<spacedim, Number> &hmat,
    typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
                                                               bc_node,
    const std::vector<std::pair<HMatrix<spacedim, Number> *,
                                HMatrix<spacedim, Number> *>> &Sigma_P)
  {
    /**
     * Link \p hmat with \p bc_node.
     */
    hmat.bc_node = const_cast<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type>(bc_node);

    /**
     * Link row and column indices stored in the clusters \f$\tau\f$ and
     * \f$\sigma\f$ respectively.
     */
    hmat.row_index_range = const_cast<std::array<types::global_dof_index, 2> *>(
      &(hmat.bc_node->get_data_reference()
          .get_tau_node()
          ->get_data_reference()
          .get_index_range()));
    hmat.col_index_range = const_cast<std::array<types::global_dof_index, 2> *>(
      &(hmat.bc_node->get_data_reference()
          .get_sigma_node()
          ->get_data_reference()
          .get_index_range()));

    /**
     * Update the matrix dimension of \p hmat.
     */
    hmat.m = (*hmat.row_index_range)[1] - (*hmat.row_index_range)[0];
    hmat.n = (*hmat.col_index_range)[1] - (*hmat.col_index_range)[0];

    for (std::pair<HMatrix<spacedim, Number> *, HMatrix<spacedim, Number> *>
           &hmat_pair : Sigma_P)
      {
        hmat.Sigma_P.push_back(hmat_pair);
      }

    hmat.Sigma_R.clear();
    hmat.Sigma_F.clear();
  }


  /**
   * Initialize an \hmatnode with respect to a block cluster
   * node. The given \p hmat_pair will be appended to the list
   * \f$\Sigma_b^P\f$.
   *
   * @param hmat
   * @param bc_node
   * @param hmat_pair
   */
  template <int spacedim, typename Number = double>
  void
  InitHMatrixWrtBlockClusterNode(
    HMatrix<spacedim, Number> &hmat,
    typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
      bc_node,
    const std::pair<HMatrix<spacedim, Number> *, HMatrix<spacedim, Number> *>
      &hmat_pair)
  {
    /**
     * Link \p hmat with \p bc_node.
     */
    hmat.bc_node = const_cast<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type>(bc_node);

    /**
     * Link row and column indices stored in the clusters \f$\tau\f$ and
     * \f$\sigma\f$ respectively.
     */
    hmat.row_index_range = const_cast<std::array<types::global_dof_index, 2> *>(
      &(hmat.bc_node->get_data_reference()
          .get_tau_node()
          ->get_data_reference()
          .get_index_range()));
    hmat.col_index_range = const_cast<std::array<types::global_dof_index, 2> *>(
      &(hmat.bc_node->get_data_reference()
          .get_sigma_node()
          ->get_data_reference()
          .get_index_range()));

    /**
     * Update the matrix dimension of \p hmat.
     */
    hmat.m = (*hmat.row_index_range)[1] - (*hmat.row_index_range)[0];
    hmat.n = (*hmat.col_index_range)[1] - (*hmat.col_index_range)[0];

    hmat.Sigma_P.push_back(hmat_pair);
    hmat.Sigma_R.clear();
    hmat.Sigma_F.clear();
  }


  /**
   * Recursively construct the children of an \hmatrix with
   * respect to a block cluster tree by starting from a tree node which is
   * to be associated with the current \hmatrix.
   *
   * @param hmat Pointer to the current \hmatnode, <strong>which has already been
   * created on the heap but with its internal data left empty.</strong>
   * @param bc_node Pointer to a TreeNode in a BlockClusterTree, which is to be
   * associated with \p hmat.
   */
  template <int spacedim, typename Number = double>
  void
  InitAndCreateHMatrixChildrenWithoutAlloc(
    HMatrix<spacedim, Number> *hmat,
    typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
      bc_node)
  {
    /**
     * Link \p hmat with \p bc_node.
     */
    hmat->bc_node = const_cast<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type>(bc_node);

    /**
     * Link row and column indices stored in the clusters \f$\tau\f$ and
     * \f$\sigma\f$ respectively.
     */
    hmat->row_index_range =
      const_cast<std::array<types::global_dof_index, 2> *>(
        &(hmat->bc_node->get_data_reference()
            .get_tau_node()
            ->get_data_reference()
            .get_index_range()));
    hmat->col_index_range =
      const_cast<std::array<types::global_dof_index, 2> *>(
        &(hmat->bc_node->get_data_reference()
            .get_sigma_node()
            ->get_data_reference()
            .get_index_range()));

    /**
     * Update the matrix dimension of \p hmat.
     */
    hmat->m = (*hmat->row_index_range)[1] - (*hmat->row_index_range)[0];
    hmat->n = (*hmat->col_index_range)[1] - (*hmat->col_index_range)[0];

    const unsigned int bc_node_child_num = bc_node->get_child_num();
    if (bc_node_child_num > 0)
      {
        /**
         * When the block cluster node \p bc_node has children, set the current \p
         * hmat type as \p HierarchicalMatrixType.
         */
        hmat->type = HierarchicalMatrixType;

        /**
         * Then we will continue constructing its hierarchical submatrices.
         */
        for (unsigned int i = 0; i < bc_node_child_num; i++)
          {
            /**
             * Create an empty HMatrix on the heap.
             */
            HMatrix<spacedim, Number> *child_hmat =
              new HMatrix<spacedim, Number>();

            /**
             * Set the state of the child \hmatrix, which is the same as its
             * parent.
             */
            child_hmat->state = hmat->state;

            /**
             * Set the block type of the child \hmatrix, which depends on the
             * block type of its parent.
             */
            switch (hmat->block_type)
              {
                  case HMatrixSupport::undefined_block: {
                    /**
                     * When the current \hmatrix block is @p undefined_block, all
                     * child \hmatrices are @p undefined_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  case HMatrixSupport::diagonal_block: {
                    /**
                     * When the current \hmatrix is @p diagonal_block, the first and
                     * fourth child \hmatrices are @p diagonal_block, while the second
                     * child \hmatrix is @p upper_triangular_block and the third child
                     * \hmatrix is @p lower_triangular_block.
                     */
                    switch (i)
                      {
                          case 0: {
                            child_hmat->block_type =
                              HMatrixSupport::diagonal_block;

                            break;
                          }
                          case 1: {
                            child_hmat->block_type =
                              HMatrixSupport::upper_triangular_block;

                            break;
                          }
                          case 2: {
                            child_hmat->block_type =
                              HMatrixSupport::lower_triangular_block;

                            break;
                          }
                          case 3: {
                            child_hmat->block_type =
                              HMatrixSupport::diagonal_block;

                            break;
                          }
                          default: {
                            Assert(false, ExcNotImplemented());
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::upper_triangular_block: {
                    /**
                     * When the current \hmatrix is @p upper_triangular_block,
                     * all child \hmatrices are @p upper_triangular_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  case HMatrixSupport::lower_triangular_block: {
                    /**
                     * When the current \hmatrix is @p lower_triangular_block,
                     * all child \hmatrices are @p lower_triangular_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  default: {
                    Assert(false,
                           ExcMessage(
                             std::string("Invalid H-matrix block type: ") +
                             std::to_string(hmat->block_type)));
                  }
              }

            /**
             * Set the property of the child \hmatrix, which depends on the
             * property of its parent.
             */
            switch (hmat->property)
              {
                  case HMatrixSupport::general: {
                    /**
                     * When the property of the current \hmatrix is @p general,
                     * all of its children have the same property @p general.
                     */
                    child_hmat->property = HMatrixSupport::general;

                    break;
                  }
                  case HMatrixSupport::symmetric: {
                    /**
                     * When the property of the current \hmatrix is @p symmetric,
                     * only those diagonal submatrices are @p symmetric, while
                     * the other submatrices are @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::symmetric;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  case HMatrixSupport::upper_triangular: {
                    /**
                     * When the property of the current \hmatrix is
                     * @p upper_triangular, only those diagonal submatrices are
                     * @p upper_triangular, while the other submatrices are
                     * @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::upper_triangular;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  case HMatrixSupport::lower_triangular: {
                    /**
                     * When the property of the current \hmatrix is
                     * @p lower_triangular, only those diagonal submatrices are
                     * @p lower_triangular, while the other submatrices are
                     * @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::lower_triangular;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  default: {
                    Assert(false,
                           ExcMessage("Invalid H-matrix property: " +
                                      std::to_string(hmat->property)));
                  }
              }

            InitAndCreateHMatrixChildrenWithoutAlloc(
              child_hmat, bc_node->get_child_pointer(i));

            /**
             * Append the initialized child to the list of submatrices of \p hmat.
             */
            hmat->submatrices.push_back(child_hmat);

            /**
             * Set the pointer to the parent \hmatnode of the current child
             * \hmatnode.
             */
            child_hmat->parent = hmat;

            child_hmat->submatrix_index = i;
          }
      }
    else
      {
        /**
         * Update the current matrix type according to the identity of the block
         * cluster node. When the block cluster belongs to the near field, \p hmat
         * should be represented as a \p LAPACKFullMatrixExt. When the block
         * cluster belongs to the far field, \p hmat should be represented as an
         * \p RkMatrix. Correspondingly, new matrices, either full matrix or
         * rank-k matrix will be created on the heap and assigned to the current
         * \hmatrix.
         */
        if (bc_node->get_data_reference().get_is_near_field())
          {
            hmat->type       = FullMatrixType;
            hmat->fullmatrix = new LAPACKFullMatrixExt<Number>();

            /**
             * Set the full matrix's property according to the current \hmatnode
             * property only when the current \hmatnode is a diagonal block.
             *
             * \mynote{The @p state of the full matrix will be taken care of by
             * itself, i.e. its state will change accordingly when some specific
             * operation is applied to it.}
             */
            if (hmat->block_type == HMatrixSupport::diagonal_block)
              {
                switch (hmat->property)
                  {
                      case HMatrixSupport::general: {
                        hmat->fullmatrix->set_property(LAPACKSupport::general);

                        break;
                      }
                      case HMatrixSupport::symmetric: {
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::symmetric);

                        break;
                      }
                      case HMatrixSupport::upper_triangular: {
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::upper_triangular);

                        break;
                      }
                      case HMatrixSupport::lower_triangular: {
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::lower_triangular);

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcMessage("Invalid H-matrix property: " +
                                          std::to_string(hmat->property)));
                      }
                  }
              }
          }
        else
          {
            hmat->type     = RkMatrixType;
            hmat->rkmatrix = new RkMatrix<Number>();
          }
      }
  }


  /**
   * Recursively construct the children of an \hmatrix with
   * respect to a block cluster tree by starting from a tree node which is
   * associated with the current \hmatrix.
   *
   * The matrices in the leaf set are initialized with zero values. The rank of
   * the near field matrices are predefined fixed values.
   *
   * @param hmat Pointer to the current \hmatnode, <strong>which has already been
   * created on the heap but with its internal data left empty.</strong>
   * @param bc_node Pointer to a TreeNode in a BlockClusterTree, which is to be
   * associated with \p hmat.
   * @param top_hmat_node_property The property of the \hmatnode on the top level
   */
  template <int spacedim, typename Number = double>
  void
  InitAndCreateHMatrixChildren(
    HMatrix<spacedim, Number> *hmat,
    typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
                                   bc_node,
    const unsigned int             fixed_rank_k,
    const HMatrixSupport::Property top_hmat_node_property =
      HMatrixSupport::general)
  {
    /**
     * Link \p hmat with \p bc_node.
     */
    hmat->bc_node = const_cast<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type>(bc_node);

    /**
     * Link row and column indices stored in the clusters \f$\tau\f$ and
     * \f$\sigma\f$ respectively.
     */
    hmat->row_index_range =
      const_cast<std::array<types::global_dof_index, 2> *>(
        &(hmat->bc_node->get_data_reference()
            .get_tau_node()
            ->get_data_reference()
            .get_index_range()));
    hmat->col_index_range =
      const_cast<std::array<types::global_dof_index, 2> *>(
        &(hmat->bc_node->get_data_reference()
            .get_sigma_node()
            ->get_data_reference()
            .get_index_range()));

    /**
     * Update the matrix dimension of \p hmat.
     */
    hmat->m = (*hmat->row_index_range)[1] - (*hmat->row_index_range)[0];
    hmat->n = (*hmat->col_index_range)[1] - (*hmat->col_index_range)[0];

    const unsigned int bc_node_child_num = bc_node->get_child_num();
    if (bc_node_child_num > 0)
      {
        /**
         * When the block cluster node \p bc_node has children, set the current \p
         * hmat type as \p HierarchicalMatrixType.
         */
        hmat->type = HierarchicalMatrixType;

        /**
         * Then we will continue constructing its hierarchical submatrices.
         */
        for (unsigned int i = 0; i < bc_node_child_num; i++)
          {
            /**
             * Create an empty \hmatrix on the heap.
             */
            HMatrix<spacedim, Number> *child_hmat =
              new HMatrix<spacedim, Number>();

            /**
             * Set the state of the child \hmatrix, which is the same as its
             * parent.
             */
            child_hmat->state = hmat->state;

            /**
             * Set the block type of the child \hmatrix, which depends on the
             * block type of its parent.
             */
            switch (hmat->block_type)
              {
                  case HMatrixSupport::undefined_block: {
                    /**
                     * When the current \hmatrix block is @p undefined_block, all
                     * child \hmatrices are @p undefined_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  case HMatrixSupport::diagonal_block: {
                    /**
                     * When the current \hmatrix is @p diagonal_block, the first and
                     * fourth child \hmatrices are @p diagonal_block, while the second
                     * child \hmatrix is @p upper_triangular_block and the third child
                     * \hmatrix is @p lower_triangular_block.
                     */
                    switch (i)
                      {
                          case 0: {
                            child_hmat->block_type =
                              HMatrixSupport::diagonal_block;

                            break;
                          }
                          case 1: {
                            child_hmat->block_type =
                              HMatrixSupport::upper_triangular_block;

                            break;
                          }
                          case 2: {
                            child_hmat->block_type =
                              HMatrixSupport::lower_triangular_block;

                            break;
                          }
                          case 3: {
                            child_hmat->block_type =
                              HMatrixSupport::diagonal_block;

                            break;
                          }
                          default: {
                            Assert(false, ExcNotImplemented());
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::upper_triangular_block: {
                    /**
                     * When the current \hmatrix is @p upper_triangular_block,
                     * all child \hmatrices are @p upper_triangular_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  case HMatrixSupport::lower_triangular_block: {
                    /**
                     * When the current \hmatrix is @p lower_triangular_block,
                     * all child \hmatrices are @p lower_triangular_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  default: {
                    Assert(false,
                           ExcMessage("Invalid H-matrix block type: " +
                                      std::to_string(hmat->block_type)));
                  }
              }

            /**
             * Set the property of the child \hmatrix, which depends on the
             * property of its parent.
             */
            switch (hmat->property)
              {
                  case HMatrixSupport::general: {
                    /**
                     * When the property of the current \hmatrix is @p general,
                     * all of its children have the same property @p general.
                     */
                    child_hmat->property = HMatrixSupport::general;

                    break;
                  }
                  case HMatrixSupport::symmetric: {
                    /**
                     * When the property of the current \hmatrix is @p symmetric,
                     * only those diagonal submatrices are @p symmetric, while
                     * the other submatrices are @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::symmetric;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  case HMatrixSupport::upper_triangular: {
                    /**
                     * When the property of the current \hmatrix is
                     * @p upper_triangular, only those diagonal submatrices are
                     * @p upper_triangular, while the other submatrices are
                     * @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::upper_triangular;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  case HMatrixSupport::lower_triangular: {
                    /**
                     * When the property of the current \hmatrix is
                     * @p lower_triangular, only those diagonal submatrices are
                     * @p lower_triangular, while the other submatrices are
                     * @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::lower_triangular;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  default: {
                    Assert(false,
                           ExcMessage("Invalid H-matrix property: " +
                                      std::to_string(hmat->property)));
                  }
              }

            InitAndCreateHMatrixChildren(child_hmat,
                                         bc_node->get_child_pointer(i),
                                         fixed_rank_k,
                                         top_hmat_node_property);

            /**
             * Append the initialized child to the list of submatrices of \p hmat.
             */
            hmat->submatrices.push_back(child_hmat);

            /**
             * Set the pointer to the parent \hmatnode of the current child
             * \hmatnode.
             */
            child_hmat->parent = hmat;

            child_hmat->submatrix_index = i;
          }
      }
    else
      {
        /**
         * Update the current matrix type according to the identity of the block
         * cluster node. When the block cluster belongs to the near field, \p hmat
         * should be represented as a \p LAPACKFullMatrixExt. When the block
         * cluster belongs to the far field, \p hmat should be represented as an
         * \p RkMatrix. Correspondingly, new matrices, either full matrix or
         * rank-k matrix will be created on the heap and assigned to the current
         * \hmatrix.
         */
        switch (top_hmat_node_property)
          {
              case HMatrixSupport::general: {
                /**
                 * When the top level \hmatnode has the @p general property, all
                 * \hmatnodes in the leaf set should be created with allocated
                 * memory.
                 */
                if (bc_node->get_data_reference().get_is_near_field())
                  {
                    hmat->type = FullMatrixType;
                    hmat->fullmatrix =
                      new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                  }
                else
                  {
                    hmat->type = RkMatrixType;
                    hmat->rkmatrix =
                      new RkMatrix<Number>(hmat->m, hmat->n, fixed_rank_k);
                  }

                break;
              }
              case HMatrixSupport::symmetric: {
                /**
                 * When the top level \hmatnode has the @p symmetric property,
                 * only those \hmatnodes in the leaf set that belong to the
                 * diagonal or lower triangular part of the original H-matrix
                 * will be created with allocated memory.
                 */
                switch (hmat->block_type)
                  {
                      case HMatrixSupport::diagonal_block: {
                        /**
                         * When the current \hmatnode in the leaf set is a
                         * diagonal block in the top level \hmatrix, it can only
                         * be a symmetric full matrix. Its memory will be
                         * allocated and its
                         * @p LAPACKFullMatrix type will be set to @p symmetric.
                         */

                        /**
                         * Here we make an assertion about the fact that a
                         * diagonal \hmatrix block in the leaf set should belong
                         * to the near field.
                         */
                        Assert(
                          bc_node->get_data_reference().get_is_near_field(),
                          ExcMessage(
                            "H-matrix node in the leaf set should belong to the near field if it is a diagonal block!"));
                        /**
                         * And we further make an assertion about the fact that
                         * the diagonal \hmatrix block should have the same
                         * property as the top level \hmatnode.
                         */
                        Assert(
                          hmat->property == top_hmat_node_property,
                          ExcMessage(
                            "A diagonal block should have the same property as that of the top level H-matrix node!"));

                        hmat->type = FullMatrixType;
                        hmat->fullmatrix =
                          new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::symmetric);

                        break;
                      }
                      case HMatrixSupport::lower_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the lower triangular part in the top level \hmatrix,
                         * it can be either a full matrix or a rank-k matrix.
                         * Its memory will be allocated because it contains
                         * effective data.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                          }
                        else
                          {
                            hmat->type     = RkMatrixType;
                            hmat->rkmatrix = new RkMatrix<Number>(hmat->m,
                                                                  hmat->n,
                                                                  fixed_rank_k);
                          }

                        break;
                      }
                      case HMatrixSupport::upper_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the upper triangular part in the top level \hmatrix,
                         * only set its \hmatrix type without allocating memory
                         * because it is symmetric to the corresponding block in
                         * the lower triangular part.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>();
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(hmat->m, hmat->n, 0);
                          }

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcMessage(
                                 std::string("Invalid H-matrix block type: ") +
                                 std::string(HMatrixSupport::block_type_name(
                                   hmat->block_type))));
                      }
                  }

                break;
              }
              case HMatrixSupport::lower_triangular: {
                /**
                 * When the top level \hmatnode has the @p lower_triangular
                 * property, only those \hmatnodes in the leaf set that belong
                 * to the diagonal or lower triangular part in the top level
                 * \hmatrix will be created with allocated memory.
                 */
                switch (hmat->block_type)
                  {
                      case HMatrixSupport::diagonal_block: {
                        /**
                         * When the current \hmatnode in the leaf set is a
                         * diagonal block in the top level \hmatrix, it can only
                         * be a lower triangular full matrix. Its memory will be
                         * allocated and its
                         * @p LAPACKFullMatrix type will be set to @p lower_triangular.
                         */

                        /**
                         * Here we make an assertion about the fact that a
                         * diagonal \hmatrix block in the leaf set should belong
                         * to the near field.
                         */
                        Assert(
                          bc_node->get_data_reference().get_is_near_field(),
                          ExcMessage(
                            "H-matrix node in the leaf set should belong to the near field if it is a diagonal block!"));
                        /**
                         * And we further make an assertion about the fact that
                         * the diagonal \hmatrix block should have the same
                         * property as the top level \hmatnode.
                         */
                        Assert(
                          hmat->property == top_hmat_node_property,
                          ExcMessage(
                            "A diagonal block should have the same property as that of the top level H-matrix node!"));

                        hmat->type = FullMatrixType;
                        hmat->fullmatrix =
                          new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::lower_triangular);

                        break;
                      }
                      case HMatrixSupport::lower_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the lower triangular part in the top level \hmatrix,
                         * it can be either a full matrix or a rank-k matrix.
                         * Its memory will be allocated because it contains
                         * effective data.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                          }
                        else
                          {
                            hmat->type     = RkMatrixType;
                            hmat->rkmatrix = new RkMatrix<Number>(hmat->m,
                                                                  hmat->n,
                                                                  fixed_rank_k);
                          }

                        break;
                      }
                      case HMatrixSupport::upper_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the upper triangular part in the top level \hmatrix,
                         * only set its \hmatrix type without allocating memory
                         * because it is zero-valued.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>();
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(hmat->m, hmat->n, 0);
                          }

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcMessage(
                                 std::string("Invalid H-matrix block type: ") +
                                 std::string(HMatrixSupport::block_type_name(
                                   hmat->block_type))));
                      }
                  }

                break;
              }
              case HMatrixSupport::upper_triangular: {
                /**
                 * When the top level \hmatnode has the @p upper_triangular
                 * property, only those \hmatnodes in the leaf set that belong
                 * to the diagonal or upper triangular part in the top level
                 * \hmatrix will be created with allocated memory.
                 */
                switch (hmat->block_type)
                  {
                      case HMatrixSupport::diagonal_block: {
                        /**
                         * When the current \hmatnode in the leaf set is a
                         * diagonal block in the top level \hmatrix, it can only
                         * be a upper triangular full matrix. Its memory will be
                         * allocated and its
                         * @p LAPACKFullMatrix type will be set to @p upper_triangular.
                         */

                        /**
                         * Here we make an assertion about the fact that a
                         * diagonal \hmatrix block in the leaf set should belong
                         * to the near field.
                         */
                        Assert(
                          bc_node->get_data_reference().get_is_near_field(),
                          ExcMessage(
                            "H-matrix node in the leaf set should belong to the near field if it is a diagonal block!"));
                        /**
                         * And we further make an assertion about the fact that
                         * the diagonal \hmatrix block should have the same
                         * property as the top level \hmatnode.
                         */
                        Assert(
                          hmat->property == top_hmat_node_property,
                          ExcMessage(
                            "A diagonal block should have the same property as that of the top level H-matrix node!"));

                        hmat->type = FullMatrixType;
                        hmat->fullmatrix =
                          new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::upper_triangular);

                        break;
                      }
                      case HMatrixSupport::upper_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the upper triangular part in the top level \hmatrix,
                         * it can be either a full matrix or a rank-k matrix.
                         * Its memory will be allocated because it contains
                         * effective data.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                          }
                        else
                          {
                            hmat->type     = RkMatrixType;
                            hmat->rkmatrix = new RkMatrix<Number>(hmat->m,
                                                                  hmat->n,
                                                                  fixed_rank_k);
                          }

                        break;
                      }
                      case HMatrixSupport::lower_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the lower triangular part in the top level \hmatrix,
                         * only set its \hmatrix type without allocating memory
                         * because it is zero-valued.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>();
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(hmat->m, hmat->n, 0);
                          }

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcMessage(
                                 std::string("Invalid H-matrix block type: ") +
                                 std::string(HMatrixSupport::block_type_name(
                                   hmat->block_type))));
                      }
                  }

                break;
              }
              default: {
                Assert(
                  false,
                  ExcMessage(
                    std::string(
                      "Invalid property of the top level H-matrix node: ") +
                    std::string(
                      HMatrixSupport::property_name(top_hmat_node_property))));
              }
          }
      }
  }


  /**
   * Recursively construct the children of an \hmatrix with
   * respect to a block cluster tree by starting from a tree node which is
   * associated with the current \hmatrix.
   *
   * The matrices in the leaf set are initialized with the data in the given
   * global full matrix \p M. @p M is created on the complete block cluster index
   * set \f$I \times J\f$ and whose elements should be accessed via indices
   * stored in the block cluster. The rank of the far field matrices are
   * predefined fixed values.
   *
   * During the recursive calling of this function, the source data matrix \p M is
   * kept intact, which will not be restricted to small matrix blocks.
   *
   * \mynote{@p hmat may not be global, but only a block in the global matrix, and
   * @p bc_node in this case is not the root node of the \bct.}
   *
   * @param hmat Pointer to the current \hmatnode, <strong>which has already been
   * created on the heap but with its internal data left empty.</strong>
   * @param bc_node Pointer to a TreeNode in a BlockClusterTree, which is to be
   * associated with \p hmat.
   * @param M The global full matrix containing all the data required to initialize the
   * \hmatrix.
   */
  template <int spacedim, typename Number = double>
  void
  InitAndCreateHMatrixChildren(
    HMatrix<spacedim, Number> *hmat,
    typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
                                       bc_node,
    const unsigned int                 fixed_rank_k,
    const LAPACKFullMatrixExt<Number> &M,
    const HMatrixSupport::Property     top_hmat_node_property =
      HMatrixSupport::general)
  {
    /**
     * Link \p hmat with \p bc_node.
     */
    hmat->bc_node = const_cast<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type>(bc_node);

    /**
     * Link row and column indices.
     */
    hmat->row_index_range =
      const_cast<std::array<types::global_dof_index, 2> *>(
        &(hmat->bc_node->get_data_reference()
            .get_tau_node()
            ->get_data_reference()
            .get_index_range()));
    hmat->col_index_range =
      const_cast<std::array<types::global_dof_index, 2> *>(
        &(hmat->bc_node->get_data_reference()
            .get_sigma_node()
            ->get_data_reference()
            .get_index_range()));

    /**
     * Update the matrix dimension of \p hmat.
     */
    hmat->m = (*hmat->row_index_range)[1] - (*hmat->row_index_range)[0];
    hmat->n = (*hmat->col_index_range)[1] - (*hmat->col_index_range)[0];

    const unsigned int bc_node_child_num = bc_node->get_child_num();

    if (bc_node_child_num > 0)
      {
        /**
         * When the block cluster node \p bc_node has children, set the current \p
         * hmat type as \p HierarchicalMatrixType. Then we will
         * continue constructing hierarchical submatrices.
         */
        hmat->type = HierarchicalMatrixType;

        for (unsigned int i = 0; i < bc_node_child_num; i++)
          {
            /**
             * Create an empty HMatrix on the heap.
             */
            HMatrix<spacedim, Number> *child_hmat =
              new HMatrix<spacedim, Number>();

            /**
             * Set the state of the child \hmatrix, which is the same as its
             * parent.
             */
            child_hmat->state = hmat->state;

            /**
             * Set the block type of the child \hmatrix, which depends on the
             * block type of its parent.
             */
            switch (hmat->block_type)
              {
                  case HMatrixSupport::undefined_block: {
                    /**
                     * When the current \hmatrix block is @p undefined_block, all
                     * child \hmatrices are @p undefined_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  case HMatrixSupport::diagonal_block: {
                    /**
                     * When the current \hmatrix is @p diagonal_block, the first and
                     * fourth child \hmatrices are @p diagonal_block, while the second
                     * child \hmatrix is @p upper_triangular_block and the third child
                     * \hmatrix is @p lower_triangular_block.
                     */
                    switch (i)
                      {
                          case 0: {
                            child_hmat->block_type =
                              HMatrixSupport::diagonal_block;

                            break;
                          }
                          case 1: {
                            child_hmat->block_type =
                              HMatrixSupport::upper_triangular_block;

                            break;
                          }
                          case 2: {
                            child_hmat->block_type =
                              HMatrixSupport::lower_triangular_block;

                            break;
                          }
                          case 3: {
                            child_hmat->block_type =
                              HMatrixSupport::diagonal_block;

                            break;
                          }
                          default: {
                            Assert(false, ExcNotImplemented());
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::upper_triangular_block: {
                    /**
                     * When the current \hmatrix is @p upper_triangular_block,
                     * all child \hmatrices are @p upper_triangular_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  case HMatrixSupport::lower_triangular_block: {
                    /**
                     * When the current \hmatrix is @p lower_triangular_block,
                     * all child \hmatrices are @p lower_triangular_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  default: {
                    Assert(false, ExcInvalidHMatrixBlockType(hmat->block_type));
                  }
              }

            /**
             * Set the property of the child \hmatrix, which depends on the
             * property of its parent.
             */
            switch (hmat->property)
              {
                  case HMatrixSupport::general: {
                    /**
                     * When the property of the current \hmatrix is @p general,
                     * all of its children have the same property @p general.
                     */
                    child_hmat->property = HMatrixSupport::general;

                    break;
                  }
                  case HMatrixSupport::symmetric: {
                    /**
                     * When the property of the current \hmatrix is @p symmetric,
                     * only those diagonal submatrices are @p symmetric, while
                     * the other submatrices are @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::symmetric;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  case HMatrixSupport::upper_triangular: {
                    /**
                     * When the property of the current \hmatrix is
                     * @p upper_triangular, only those diagonal submatrices are
                     * @p upper_triangular, while the other submatrices are
                     * @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::upper_triangular;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  case HMatrixSupport::lower_triangular: {
                    /**
                     * When the property of the current \hmatrix is
                     * @p lower_triangular, only those diagonal submatrices are
                     * @p lower_triangular, while the other submatrices are
                     * @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::lower_triangular;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  default: {
                    Assert(false, ExcInvalidHMatrixProperty(hmat->property));
                  }
              }

            InitAndCreateHMatrixChildren(child_hmat,
                                         bc_node->get_child_pointer(i),
                                         fixed_rank_k,
                                         M,
                                         top_hmat_node_property);

            /**
             * Append the initialized child to the list of submatrices of \p hmat.
             */
            hmat->submatrices.push_back(child_hmat);

            /**
             * Set the pointer to the parent \hmatnode of the current child
             * \hmatnode.
             */
            child_hmat->parent = hmat;

            child_hmat->submatrix_index = i;
          }
      }
    else
      {
        /**
         * Update the current matrix type according to the identity of the block
         * cluster node. When the block cluster belongs to the near field, \p hmat
         * should be represented as a \p LAPACKFullMatrixExt. When the block
         * cluster belongs to the far field, \p hmat should be represented as an
         * \p RkMatrix. Correspondingly, new matrices, either full matrix or
         * rank-k matrix will be created on the heap and assigned to the current
         * \hmatrix.
         */
        switch (top_hmat_node_property)
          {
              case HMatrixSupport::general: {
                /**
                 * When the top level \hmatnode has the @p general property, all
                 * \hmatnodes in the leaf set should be created with allocated
                 * memory.
                 */
                if (bc_node->get_data_reference().get_is_near_field())
                  {
                    hmat->type = FullMatrixType;
                    hmat->fullmatrix =
                      new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);

                    /**
                     * Assign matrix values from \p M to the current \hmat.
                     */
                    for (unsigned int i = 0; i < hmat->m; i++)
                      {
                        for (unsigned int j = 0; j < hmat->n; j++)
                          {
                            (*hmat->fullmatrix)(i, j) =
                              M((*hmat->row_index_range)[0] + i,
                                (*hmat->col_index_range)[0] + j);
                          }
                      }
                  }
                else
                  {
                    hmat->type = RkMatrixType;
                    hmat->rkmatrix =
                      new RkMatrix<Number>(*(hmat->row_index_range),
                                           *(hmat->col_index_range),
                                           fixed_rank_k,
                                           M);
                  }

                break;
              }
              case HMatrixSupport::symmetric: {
                /**
                 * When the top level \hmatnode has the @p symmetric property,
                 * only those \hmatnodes in the leaf set that belong to the
                 * diagonal or lower triangular part of the original H-matrix
                 * will be created with allocated memory.
                 */
                switch (hmat->block_type)
                  {
                      case HMatrixSupport::diagonal_block: {
                        /**
                         * When the current \hmatnode in the leaf set is a
                         * diagonal block in the top level \hmatrix, it can only
                         * be a symmetric full matrix. Its memory will be
                         * allocated and its
                         * @p LAPACKFullMatrix type will be set to @p symmetric.
                         */

                        /**
                         * Here we make an assertion about the fact that a
                         * diagonal \hmatrix block in the leaf set should belong
                         * to the near field.
                         */
                        Assert(
                          bc_node->get_data_reference().get_is_near_field(),
                          ExcMessage(
                            "H-matrix node in the leaf set should belong to the near field if it is a diagonal block!"));
                        /**
                         * And we further make an assertion about the fact that
                         * the diagonal \hmatrix block should have the same
                         * property as the top level \hmatnode.
                         */
                        Assert(
                          hmat->property == top_hmat_node_property,
                          ExcMessage(
                            "A diagonal block should have the same property as that of the top level H-matrix node!"));

                        hmat->type = FullMatrixType;
                        hmat->fullmatrix =
                          new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::symmetric);

                        /**
                         * Assign matrix values from \p M to the current HMatrix.
                         */
                        for (unsigned int i = 0; i < hmat->m; i++)
                          {
                            for (unsigned int j = 0; j < hmat->n; j++)
                              {
                                (*hmat->fullmatrix)(i, j) =
                                  M((*hmat->row_index_range)[0] + i,
                                    (*hmat->col_index_range)[0] + j);
                              }
                          }

                        break;
                      }
                      case HMatrixSupport::lower_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the lower triangular part in the top level \hmatrix,
                         * it can be either a full matrix or a rank-k matrix.
                         * Its memory will be allocated because it contains
                         * effective data.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);

                            /**
                             * Assign matrix values from \p M to the current HMatrix.
                             */
                            for (unsigned int i = 0; i < hmat->m; i++)
                              {
                                for (unsigned int j = 0; j < hmat->n; j++)
                                  {
                                    (*hmat->fullmatrix)(i, j) =
                                      M((*hmat->row_index_range)[0] + i,
                                        (*hmat->col_index_range)[0] + j);
                                  }
                              }
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(*(hmat->row_index_range),
                                                   *(hmat->col_index_range),
                                                   fixed_rank_k,
                                                   M);
                          }

                        break;
                      }
                      case HMatrixSupport::upper_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the upper triangular part in the top level \hmatrix,
                         * only set its \hmatrix type without allocating memory
                         * because it is symmetric to the corresponding block in
                         * the lower triangular part.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>();
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(hmat->m, hmat->n, 0);
                          }

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcMessage(
                                 std::string("Invalid H-matrix block type: ") +
                                 std::string(HMatrixSupport::block_type_name(
                                   hmat->block_type))));
                      }
                  }

                break;
              }
              case HMatrixSupport::lower_triangular: {
                /**
                 * When the top level \hmatnode has the @p lower_triangular
                 * property, only those \hmatnodes in the leaf set that belong
                 * to the diagonal or lower triangular part in the top level
                 * \hmatrix will be created with allocated memory.
                 */
                switch (hmat->block_type)
                  {
                      case HMatrixSupport::diagonal_block: {
                        /**
                         * When the current \hmatnode in the leaf set is a
                         * diagonal block in the top level \hmatrix, it can only
                         * be a lower triangular full matrix. Its memory will be
                         * allocated and its
                         * @p LAPACKFullMatrix type will be set to @p lower_triangular.
                         */

                        /**
                         * Here we make an assertion about the fact that a
                         * diagonal \hmatrix block in the leaf set should belong
                         * to the near field.
                         */
                        Assert(
                          bc_node->get_data_reference().get_is_near_field(),
                          ExcMessage(
                            "H-matrix node in the leaf set should belong to the near field if it is a diagonal block!"));
                        /**
                         * And we further make an assertion about the fact that
                         * the diagonal \hmatrix block should have the same
                         * property as the top level \hmatnode.
                         */
                        Assert(
                          hmat->property == top_hmat_node_property,
                          ExcMessage(
                            "A diagonal block should have the same property as that of the top level H-matrix node!"));

                        hmat->type = FullMatrixType;
                        hmat->fullmatrix =
                          new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::lower_triangular);

                        /**
                         * Assign matrix values from \p M to the current HMatrix.
                         */
                        for (unsigned int i = 0; i < hmat->m; i++)
                          {
                            for (unsigned int j = 0; j < hmat->n; j++)
                              {
                                (*hmat->fullmatrix)(i, j) =
                                  M((*hmat->row_index_range)[0] + i,
                                    (*hmat->col_index_range)[0] + j);
                              }
                          }

                        break;
                      }
                      case HMatrixSupport::lower_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the lower triangular part in the top level \hmatrix,
                         * it can be either a full matrix or a rank-k matrix.
                         * Its memory will be allocated because it contains
                         * effective data.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);

                            /**
                             * Assign matrix values from \p M to the current HMatrix.
                             */
                            for (unsigned int i = 0; i < hmat->m; i++)
                              {
                                for (unsigned int j = 0; j < hmat->n; j++)
                                  {
                                    (*hmat->fullmatrix)(i, j) =
                                      M((*hmat->row_index_range)[0] + i,
                                        (*hmat->col_index_range)[0] + j);
                                  }
                              }
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(*(hmat->row_index_range),
                                                   *(hmat->col_index_range),
                                                   fixed_rank_k,
                                                   M);
                          }

                        break;
                      }
                      case HMatrixSupport::upper_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the upper triangular part in the top level \hmatrix,
                         * only set its \hmatrix type without allocating memory
                         * because it is zero-valued.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>();
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(hmat->m, hmat->n, 0);
                          }

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcMessage(
                                 std::string("Invalid H-matrix block type: ") +
                                 std::string(HMatrixSupport::block_type_name(
                                   hmat->block_type))));
                      }
                  }

                break;
              }
              case HMatrixSupport::upper_triangular: {
                /**
                 * When the top level \hmatnode has the @p upper_triangular
                 * property, only those \hmatnodes in the leaf set that belong
                 * to the diagonal or upper triangular part in the top level
                 * \hmatrix will be created with allocated memory.
                 */
                switch (hmat->block_type)
                  {
                      case HMatrixSupport::diagonal_block: {
                        /**
                         * When the current \hmatnode in the leaf set is a
                         * diagonal block in the top level \hmatrix, it can only
                         * be a upper triangular full matrix. Its memory will be
                         * allocated and its
                         * @p LAPACKFullMatrix type will be set to @p upper_triangular.
                         */

                        /**
                         * Here we make an assertion about the fact that a
                         * diagonal \hmatrix block in the leaf set should belong
                         * to the near field.
                         */
                        Assert(
                          bc_node->get_data_reference().get_is_near_field(),
                          ExcMessage(
                            "H-matrix node in the leaf set should belong to the near field if it is a diagonal block!"));
                        /**
                         * And we further make an assertion about the fact that
                         * the diagonal \hmatrix block should have the same
                         * property as the top level \hmatnode.
                         */
                        Assert(
                          hmat->property == top_hmat_node_property,
                          ExcMessage(
                            "A diagonal block should have the same property as that of the top level H-matrix node!"));

                        hmat->type = FullMatrixType;
                        hmat->fullmatrix =
                          new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::upper_triangular);

                        /**
                         * Assign matrix values from \p M to the current HMatrix.
                         */
                        for (unsigned int i = 0; i < hmat->m; i++)
                          {
                            for (unsigned int j = 0; j < hmat->n; j++)
                              {
                                (*hmat->fullmatrix)(i, j) =
                                  M((*hmat->row_index_range)[0] + i,
                                    (*hmat->col_index_range)[0] + j);
                              }
                          }

                        break;
                      }
                      case HMatrixSupport::upper_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the upper triangular part in the top level \hmatrix,
                         * it can be either a full matrix or a rank-k matrix.
                         * Its memory will be allocated because it contains
                         * effective data.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);

                            /**
                             * Assign matrix values from \p M to the current HMatrix.
                             */
                            for (unsigned int i = 0; i < hmat->m; i++)
                              {
                                for (unsigned int j = 0; j < hmat->n; j++)
                                  {
                                    (*hmat->fullmatrix)(i, j) =
                                      M((*hmat->row_index_range)[0] + i,
                                        (*hmat->col_index_range)[0] + j);
                                  }
                              }
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(*(hmat->row_index_range),
                                                   *(hmat->col_index_range),
                                                   fixed_rank_k,
                                                   M);
                          }

                        break;
                      }
                      case HMatrixSupport::lower_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the lower triangular part in the top level \hmatrix,
                         * only set its \hmatrix type without allocating memory
                         * because it is zero-valued.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>();
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(hmat->m, hmat->n, 0);
                          }

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcMessage(
                                 std::string("Invalid H-matrix block type: ") +
                                 std::string(HMatrixSupport::block_type_name(
                                   hmat->block_type))));
                      }
                  }

                break;
              }
              default: {
                Assert(
                  false,
                  ExcMessage(
                    std::string(
                      "Invalid property of the top level H-matrix node: ") +
                    std::string(
                      HMatrixSupport::property_name(top_hmat_node_property))));
              }
          }
      }
  }


  /**
   * Recursively construct the children of an \hmatrix with
   * respect to a block cluster tree by starting from a tree node which is
   * associated with the current \hmatrix. There is no rank truncation to the
   * rank-k matrices.
   *
   * The matrices in the leaf set are initialized with the data in the given
   * global full matrix \p M, which is created on the complete block cluster index
   * set \f$I \times J\f$ and whose elements should be accessed via indices
   * stored in the block cluster.
   *
   * During the recursive calling of this function, the source data matrix \p M is
   * kept intact, which will not be restricted to small matrix blocks.
   *
   * \mynote{The full matrix @p M is global, while @p hmat may not be global, but
   * only a block in the global matrix, and @p bc_node in this case is not the
   * root node of the \bct.}
   *
   * @param hmat Pointer to the current \hmatnode, <strong>which has already been
   * created on the heap but with its internal data left empty.</strong>
   * @param bc_node Pointer to a TreeNode in a BlockClusterTree, which is to be
   * associated with \p hmat. It is not necessarily the root node.
   * @param M The global full matrix containing all the data required to initialize the
   * \hmatrix.
   */
  template <int spacedim, typename Number = double>
  void
  InitAndCreateHMatrixChildren(
    HMatrix<spacedim, Number> *hmat,
    typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
                                       bc_node,
    const LAPACKFullMatrixExt<Number> &M,
    const HMatrixSupport::Property     top_hmat_node_property =
      HMatrixSupport::general)
  {
    /**
     * Link \p hmat with \p bc_node.
     */
    hmat->bc_node = const_cast<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type>(bc_node);

    /**
     * Link row and column indices.
     */
    hmat->row_index_range =
      const_cast<std::array<types::global_dof_index, 2> *>(
        &(hmat->bc_node->get_data_reference()
            .get_tau_node()
            ->get_data_reference()
            .get_index_range()));
    hmat->col_index_range =
      const_cast<std::array<types::global_dof_index, 2> *>(
        &(hmat->bc_node->get_data_reference()
            .get_sigma_node()
            ->get_data_reference()
            .get_index_range()));

    /**
     * Update the matrix dimension of \p hmat.
     */
    hmat->m = (*hmat->row_index_range)[1] - (*hmat->row_index_range)[0];
    hmat->n = (*hmat->col_index_range)[1] - (*hmat->col_index_range)[0];

    const unsigned int bc_node_child_num = bc_node->get_child_num();

    if (bc_node_child_num > 0)
      {
        /**
         * When the block cluster node \p bc_node has children, set the current \p
         * hmat type as \p HierarchicalMatrixType. Then we will
         * continue constructing hierarchical submatrices.
         */
        hmat->type = HierarchicalMatrixType;

        for (unsigned int i = 0; i < bc_node_child_num; i++)
          {
            /**
             * Create an empty HMatrix on the heap.
             */
            HMatrix<spacedim, Number> *child_hmat =
              new HMatrix<spacedim, Number>();

            /**
             * Set the state of the child \hmatrix, which is the same as its
             * parent.
             */
            child_hmat->state = hmat->state;

            /**
             * Set the block type of the child \hmatrix, which depends on the
             * block type of its parent.
             */
            switch (hmat->block_type)
              {
                  case HMatrixSupport::undefined_block: {
                    /**
                     * When the current \hmatrix block is @p undefined_block, all
                     * child \hmatrices are @p undefined_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  case HMatrixSupport::diagonal_block: {
                    /**
                     * When the current \hmatrix is @p diagonal_block, the first and
                     * fourth child \hmatrices are @p diagonal_block, while the second
                     * child \hmatrix is @p upper_triangular_block and the third child
                     * \hmatrix is @p lower_triangular_block.
                     */
                    switch (i)
                      {
                          case 0: {
                            child_hmat->block_type =
                              HMatrixSupport::diagonal_block;

                            break;
                          }
                          case 1: {
                            child_hmat->block_type =
                              HMatrixSupport::upper_triangular_block;

                            break;
                          }
                          case 2: {
                            child_hmat->block_type =
                              HMatrixSupport::lower_triangular_block;

                            break;
                          }
                          case 3: {
                            child_hmat->block_type =
                              HMatrixSupport::diagonal_block;

                            break;
                          }
                          default: {
                            Assert(false, ExcNotImplemented());
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::upper_triangular_block: {
                    /**
                     * When the current \hmatrix is @p upper_triangular_block,
                     * all child \hmatrices are @p upper_triangular_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  case HMatrixSupport::lower_triangular_block: {
                    /**
                     * When the current \hmatrix is @p lower_triangular_block,
                     * all child \hmatrices are @p lower_triangular_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  default: {
                    Assert(false,
                           ExcMessage("Invalid H-matrix block type: " +
                                      std::to_string(hmat->block_type)));
                  }
              }

            /**
             * Set the property of the child \hmatrix, which depends on the
             * property of its parent.
             */
            switch (hmat->property)
              {
                  case HMatrixSupport::general: {
                    /**
                     * When the property of the current \hmatrix is @p general,
                     * all of its children have the same property @p general.
                     */
                    child_hmat->property = HMatrixSupport::general;

                    break;
                  }
                  case HMatrixSupport::symmetric: {
                    /**
                     * When the property of the current \hmatrix is @p symmetric,
                     * only those diagonal submatrices are @p symmetric, while
                     * the other submatrices are @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::symmetric;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  case HMatrixSupport::upper_triangular: {
                    /**
                     * When the property of the current \hmatrix is
                     * @p upper_triangular, only those diagonal submatrices are
                     * @p upper_triangular, while the other submatrices are
                     * @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::upper_triangular;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  case HMatrixSupport::lower_triangular: {
                    /**
                     * When the property of the current \hmatrix is
                     * @p lower_triangular, only those diagonal submatrices are
                     * @p lower_triangular, while the other submatrices are
                     * @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::lower_triangular;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  default: {
                    Assert(false,
                           ExcMessage("Invalid H-matrix property: " +
                                      std::to_string(hmat->property)));
                  }
              }

            InitAndCreateHMatrixChildren(child_hmat,
                                         bc_node->get_child_pointer(i),
                                         M,
                                         top_hmat_node_property);

            /**
             * Append the initialized child to the list of submatrices of \p hmat.
             */
            hmat->submatrices.push_back(child_hmat);

            /**
             * Set the pointer to the parent \hmatnode of the current child
             * \hmatnode.
             */
            child_hmat->parent = hmat;

            child_hmat->submatrix_index = i;
          }
      }
    else
      {
        /**
         * Update the current matrix type according to the identity of the block
         * cluster node. When the block cluster belongs to the near field, \p hmat
         * should be represented as a \p LAPACKFullMatrixExt. When the block
         * cluster belongs to the far field, \p hmat should be represented as an
         * \p RkMatrix. Correspondingly, new matrices, either full matrix or
         * rank-k matrix will be created on the heap and assigned to the current
         * \hmatrix.
         */
        switch (top_hmat_node_property)
          {
              case HMatrixSupport::general: {
                /**
                 * When the top level \hmatnode has the @p general property, all
                 * \hmatnodes in the leaf set should be created with allocated
                 * memory.
                 */
                if (bc_node->get_data_reference().get_is_near_field())
                  {
                    hmat->type = FullMatrixType;
                    hmat->fullmatrix =
                      new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);

                    /**
                     * Assign matrix values from \p M to the current HMatrix.
                     */
                    for (unsigned int i = 0; i < hmat->m; i++)
                      {
                        for (unsigned int j = 0; j < hmat->n; j++)
                          {
                            (*hmat->fullmatrix)(i, j) =
                              M((*hmat->row_index_range)[0] + i,
                                (*hmat->col_index_range)[0] + j);
                          }
                      }
                  }
                else
                  {
                    hmat->type = RkMatrixType;
                    hmat->rkmatrix =
                      new RkMatrix<Number>(*(hmat->row_index_range),
                                           *(hmat->col_index_range),
                                           M);
                  }

                break;
              }
              case HMatrixSupport::symmetric: {
                /**
                 * When the top level \hmatnode has the @p symmetric property,
                 * only those \hmatnodes in the leaf set that belong to the
                 * diagonal or lower triangular part of the original H-matrix
                 * will be created with allocated memory.
                 */
                switch (hmat->block_type)
                  {
                      case HMatrixSupport::diagonal_block: {
                        /**
                         * When the current \hmatnode in the leaf set is a
                         * diagonal block in the top level \hmatrix, it can only
                         * be a symmetric full matrix. Its memory will be
                         * allocated and its
                         * @p LAPACKFullMatrix type will be set to @p symmetric.
                         */

                        /**
                         * Here we make an assertion about the fact that a
                         * diagonal \hmatrix block in the leaf set should belong
                         * to the near field.
                         */
                        Assert(
                          bc_node->get_data_reference().get_is_near_field(),
                          ExcMessage(
                            "H-matrix node in the leaf set should belong to the near field if it is a diagonal block!"));
                        /**
                         * And we further make an assertion about the fact that
                         * the diagonal \hmatrix block should have the same
                         * property as the top level \hmatnode.
                         */
                        Assert(
                          hmat->property == top_hmat_node_property,
                          ExcMessage(
                            "A diagonal block should have the same property as that of the top level H-matrix node!"));

                        hmat->type = FullMatrixType;
                        hmat->fullmatrix =
                          new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::symmetric);

                        /**
                         * Assign matrix values from \p M to the current HMatrix.
                         */
                        for (unsigned int i = 0; i < hmat->m; i++)
                          {
                            for (unsigned int j = 0; j < hmat->n; j++)
                              {
                                (*hmat->fullmatrix)(i, j) =
                                  M((*hmat->row_index_range)[0] + i,
                                    (*hmat->col_index_range)[0] + j);
                              }
                          }

                        break;
                      }
                      case HMatrixSupport::lower_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the lower triangular part in the top level \hmatrix,
                         * it can be either a full matrix or a rank-k matrix.
                         * Its memory will be allocated because it contains
                         * effective data.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);

                            /**
                             * Assign matrix values from \p M to the current HMatrix.
                             */
                            for (unsigned int i = 0; i < hmat->m; i++)
                              {
                                for (unsigned int j = 0; j < hmat->n; j++)
                                  {
                                    (*hmat->fullmatrix)(i, j) =
                                      M((*hmat->row_index_range)[0] + i,
                                        (*hmat->col_index_range)[0] + j);
                                  }
                              }
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(*(hmat->row_index_range),
                                                   *(hmat->col_index_range),
                                                   M);
                          }

                        break;
                      }
                      case HMatrixSupport::upper_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the upper triangular part in the top level \hmatrix,
                         * only set its \hmatrix type without allocating memory
                         * because it is symmetric to the corresponding block in
                         * the lower triangular part.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>();
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(hmat->m, hmat->n, 0);
                          }

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcInvalidHMatrixBlockType(hmat->block_type));
                      }
                  }

                break;
              }
              case HMatrixSupport::lower_triangular: {
                /**
                 * When the top level \hmatnode has the @p lower_triangular
                 * property, only those \hmatnodes in the leaf set that belong
                 * to the diagonal or lower triangular part in the top level
                 * \hmatrix will be created with allocated memory.
                 */
                switch (hmat->block_type)
                  {
                      case HMatrixSupport::diagonal_block: {
                        /**
                         * When the current \hmatnode in the leaf set is a
                         * diagonal block in the top level \hmatrix, it can only
                         * be a lower triangular full matrix. Its memory will be
                         * allocated and its
                         * @p LAPACKFullMatrix type will be set to @p lower_triangular.
                         */

                        /**
                         * Here we make an assertion about the fact that a
                         * diagonal \hmatrix block in the leaf set should belong
                         * to the near field.
                         */
                        Assert(
                          bc_node->get_data_reference().get_is_near_field(),
                          ExcMessage(
                            "H-matrix node in the leaf set should belong to the near field if it is a diagonal block!"));
                        /**
                         * And we further make an assertion about the fact that
                         * the diagonal \hmatrix block should have the same
                         * property as the top level \hmatnode.
                         */
                        Assert(
                          hmat->property == top_hmat_node_property,
                          ExcMessage(
                            "A diagonal block should have the same property as that of the top level H-matrix node!"));

                        hmat->type = FullMatrixType;
                        hmat->fullmatrix =
                          new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::lower_triangular);

                        /**
                         * Assign matrix values from \p M to the current HMatrix.
                         */
                        for (unsigned int i = 0; i < hmat->m; i++)
                          {
                            for (unsigned int j = 0; j < hmat->n; j++)
                              {
                                (*hmat->fullmatrix)(i, j) =
                                  M((*hmat->row_index_range)[0] + i,
                                    (*hmat->col_index_range)[0] + j);
                              }
                          }

                        break;
                      }
                      case HMatrixSupport::lower_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the lower triangular part in the top level \hmatrix,
                         * it can be either a full matrix or a rank-k matrix.
                         * Its memory will be allocated because it contains
                         * effective data.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);

                            /**
                             * Assign matrix values from \p M to the current HMatrix.
                             */
                            for (unsigned int i = 0; i < hmat->m; i++)
                              {
                                for (unsigned int j = 0; j < hmat->n; j++)
                                  {
                                    (*hmat->fullmatrix)(i, j) =
                                      M((*hmat->row_index_range)[0] + i,
                                        (*hmat->col_index_range)[0] + j);
                                  }
                              }
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(*(hmat->row_index_range),
                                                   *(hmat->col_index_range),
                                                   M);
                          }

                        break;
                      }
                      case HMatrixSupport::upper_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the upper triangular part in the top level \hmatrix,
                         * only set its \hmatrix type without allocating memory
                         * because it is zero-valued.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>();
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(hmat->m, hmat->n, 0);
                          }

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcInvalidHMatrixBlockType(hmat->block_type));
                      }
                  }

                break;
              }
              case HMatrixSupport::upper_triangular: {
                /**
                 * When the top level \hmatnode has the @p upper_triangular
                 * property, only those \hmatnodes in the leaf set that belong
                 * to the diagonal or upper triangular part in the top level
                 * \hmatrix will be created with allocated memory.
                 */
                switch (hmat->block_type)
                  {
                      case HMatrixSupport::diagonal_block: {
                        /**
                         * When the current \hmatnode in the leaf set is a
                         * diagonal block in the top level \hmatrix, it can only
                         * be a upper triangular full matrix. Its memory will be
                         * allocated and its
                         * @p LAPACKFullMatrix type will be set to @p upper_triangular.
                         */

                        /**
                         * Here we make an assertion about the fact that a
                         * diagonal \hmatrix block in the leaf set should belong
                         * to the near field.
                         */
                        Assert(
                          bc_node->get_data_reference().get_is_near_field(),
                          ExcMessage(
                            "H-matrix node in the leaf set should belong to the near field if it is a diagonal block!"));
                        /**
                         * And we further make an assertion about the fact that
                         * the diagonal \hmatrix block should have the same
                         * property as the top level \hmatnode.
                         */
                        Assert(
                          hmat->property == top_hmat_node_property,
                          ExcMessage(
                            "A diagonal block should have the same property as that of the top level H-matrix node!"));

                        hmat->type = FullMatrixType;
                        hmat->fullmatrix =
                          new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::upper_triangular);

                        /**
                         * Assign matrix values from \p M to the current HMatrix.
                         */
                        for (unsigned int i = 0; i < hmat->m; i++)
                          {
                            for (unsigned int j = 0; j < hmat->n; j++)
                              {
                                (*hmat->fullmatrix)(i, j) =
                                  M((*hmat->row_index_range)[0] + i,
                                    (*hmat->col_index_range)[0] + j);
                              }
                          }

                        break;
                      }
                      case HMatrixSupport::upper_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the upper triangular part in the top level \hmatrix,
                         * it can be either a full matrix or a rank-k matrix.
                         * Its memory will be allocated because it contains
                         * effective data.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);

                            /**
                             * Assign matrix values from \p M to the current HMatrix.
                             */
                            for (unsigned int i = 0; i < hmat->m; i++)
                              {
                                for (unsigned int j = 0; j < hmat->n; j++)
                                  {
                                    (*hmat->fullmatrix)(i, j) =
                                      M((*hmat->row_index_range)[0] + i,
                                        (*hmat->col_index_range)[0] + j);
                                  }
                              }
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(*(hmat->row_index_range),
                                                   *(hmat->col_index_range),
                                                   M);
                          }

                        break;
                      }
                      case HMatrixSupport::lower_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the lower triangular part in the top level \hmatrix,
                         * only set its \hmatrix type without allocating memory
                         * because it is zero-valued.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>();
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(hmat->m, hmat->n, 0);
                          }

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcInvalidHMatrixBlockType(hmat->block_type));
                      }
                  }

                break;
              }
              default: {
                Assert(false,
                       ExcInvalidHMatrixProperty(top_hmat_node_property));
              }
          }
      }
  }


  /**
   * Recursively construct the children of an \hmatrix with
   * respect to a block cluster tree by starting from a tree node which is
   * associated with the current \hmatrix.
   *
   * The matrices in the leaf set are initialized with the data in the given
   * full
   * matrix \p M, which is created on the block cluster index set
   * \f$\tau \times \sigma\f$. <strong>N.B. This block cluster should be one of
   * the ancestors of the block cluster associated with @p hmat that has been
   * passed to the initial call of this function (let's call it @p hmat_first).
   * Only in this way, it is valid to restrict this full matrix @p M to each leaf
   * node of @p hmat.</strong> Hence, this full matrix is just a block of the
   * original global full matrix (the global full matrix is created on the block
   * cluster index set \f$I \times J\f$). The rank of the far field matrices are
   * predefined fixed values.
   *
   * During the recursive calling of this function, the source data matrix \p M is
   * kept intact, which will not be restricted to small matrix blocks.
   *
   * @param hmat
   * @param bc_node
   * @param fixed_rank_k
   * @param M
   * @param M_tau_index_range
   * @param M_sigma_index_range
   * @param top_hmat_node_property
   */
  template <int spacedim, typename Number = double>
  void
  InitAndCreateHMatrixChildren(
    HMatrix<spacedim, Number> *hmat,
    typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
                                                  bc_node,
    const unsigned int                            fixed_rank_k,
    const LAPACKFullMatrixExt<Number>            &M,
    const std::array<types::global_dof_index, 2> &M_row_index_range,
    const std::array<types::global_dof_index, 2> &M_col_index_range,
    const HMatrixSupport::Property                top_hmat_node_property =
      HMatrixSupport::general)
  {
    /**
     * Update the matrix dimension of \p hmat.
     */
    hmat->m = (*hmat->row_index_range)[1] - (*hmat->row_index_range)[0];
    hmat->n = (*hmat->col_index_range)[1] - (*hmat->col_index_range)[0];

    const unsigned int bc_node_child_num = bc_node->get_child_num();

    if (bc_node_child_num > 0)
      {
        /**
         * When the block cluster node \p bc_node has children, set the current \p
         * hmat type as \p HierarchicalMatrixType. Then we will
         * continue constructing hierarchical submatrices.
         */
        hmat->type = HierarchicalMatrixType;

        for (unsigned int i = 0; i < bc_node_child_num; i++)
          {
            /**
             * Create an empty HMatrix on the heap.
             */
            HMatrix<spacedim, Number> *child_hmat =
              new HMatrix<spacedim, Number>();

            /**
             * Set the state of the child \hmatrix, which is the same as its
             * parent.
             */
            child_hmat->state = hmat->state;

            /**
             * Set the block type of the child \hmatrix, which depends on the
             * block type of its parent.
             */
            switch (hmat->block_type)
              {
                  case HMatrixSupport::undefined_block: {
                    /**
                     * When the current \hmatrix block is @p undefined_block, all
                     * child \hmatrices are @p undefined_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  case HMatrixSupport::diagonal_block: {
                    /**
                     * When the current \hmatrix is @p diagonal_block, the first and
                     * fourth child \hmatrices are @p diagonal_block, while the second
                     * child \hmatrix is @p upper_triangular_block and the third child
                     * \hmatrix is @p lower_triangular_block.
                     */
                    switch (i)
                      {
                          case 0: {
                            child_hmat->block_type =
                              HMatrixSupport::diagonal_block;

                            break;
                          }
                          case 1: {
                            child_hmat->block_type =
                              HMatrixSupport::upper_triangular_block;

                            break;
                          }
                          case 2: {
                            child_hmat->block_type =
                              HMatrixSupport::lower_triangular_block;

                            break;
                          }
                          case 3: {
                            child_hmat->block_type =
                              HMatrixSupport::diagonal_block;

                            break;
                          }
                          default: {
                            Assert(false, ExcNotImplemented());
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::upper_triangular_block: {
                    /**
                     * When the current \hmatrix is @p upper_triangular_block,
                     * all child \hmatrices are @p upper_triangular_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  case HMatrixSupport::lower_triangular_block: {
                    /**
                     * When the current \hmatrix is @p lower_triangular_block,
                     * all child \hmatrices are @p lower_triangular_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  default: {
                    Assert(false, ExcInvalidHMatrixBlockType(hmat->block_type));
                  }
              }

            /**
             * Set the property of the child \hmatrix, which depends on the
             * property of its parent.
             */
            switch (hmat->property)
              {
                  case HMatrixSupport::general: {
                    /**
                     * When the property of the current \hmatrix is @p general,
                     * all of its children have the same property @p general.
                     */
                    child_hmat->property = HMatrixSupport::general;

                    break;
                  }
                  case HMatrixSupport::symmetric: {
                    /**
                     * When the property of the current \hmatrix is @p symmetric,
                     * only those diagonal submatrices are @p symmetric, while
                     * the other submatrices are @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::symmetric;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  case HMatrixSupport::upper_triangular: {
                    /**
                     * When the property of the current \hmatrix is
                     * @p upper_triangular, only those diagonal submatrices are
                     * @p upper_triangular, while the other submatrices are
                     * @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::upper_triangular;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  case HMatrixSupport::lower_triangular: {
                    /**
                     * When the property of the current \hmatrix is
                     * @p lower_triangular, only those diagonal submatrices are
                     * @p lower_triangular, while the other submatrices are
                     * @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::lower_triangular;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  default: {
                    Assert(false, ExcInvalidHMatrixProperty(hmat->property));
                  }
              }

            InitAndCreateHMatrixChildren(child_hmat,
                                         bc_node->get_child_pointer(i),
                                         fixed_rank_k,
                                         M,
                                         M_row_index_range,
                                         M_col_index_range,
                                         top_hmat_node_property);

            /**
             * Append the initialized child to the list of submatrices of \p hmat.
             */
            hmat->submatrices.push_back(child_hmat);

            /**
             * Set the pointer to the parent \hmatnode of the current child
             * \hmatnode.
             */
            child_hmat->parent = hmat;

            child_hmat->submatrix_index = i;
          }
      }
    else
      {
        /**
         * Update the current matrix type according to the identity of the block
         * cluster node. When the block cluster belongs to the near field, \p hmat
         * should be represented as a \p LAPACKFullMatrixExt. When the block
         * cluster belongs to the far field, \p hmat should be represented as an
         * \p RkMatrix. Correspondingly, new matrices, either full matrix or
         * rank-k matrix will be created on the heap and assigned to the current
         * \hmatrix.
         */
        switch (top_hmat_node_property)
          {
              case HMatrixSupport::general: {
                /**
                 * When the top level \hmatnode has the @p general property, all
                 * \hmatnodes in the leaf set should be created with allocated
                 * memory.
                 */
                if (bc_node->get_data_reference().get_is_near_field())
                  {
                    hmat->type = FullMatrixType;
                    hmat->fullmatrix =
                      new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);

                    /**
                     * Assign matrix values from \p M to the current HMatrix.
                     */
                    for (unsigned int i = 0; i < hmat->m; i++)
                      {
                        for (unsigned int j = 0; j < hmat->n; j++)
                          {
                            (*hmat->fullmatrix)(i, j) =
                              M((*hmat->row_index_range)[0] -
                                  M_row_index_range[0] + i,
                                (*hmat->col_index_range)[0] -
                                  M_col_index_range[0] + j);
                          }
                      }
                  }
                else
                  {
                    hmat->type = RkMatrixType;
                    hmat->rkmatrix =
                      new RkMatrix<Number>(*(hmat->row_index_range),
                                           *(hmat->col_index_range),
                                           fixed_rank_k,
                                           M,
                                           M_row_index_range,
                                           M_col_index_range);
                  }

                break;
              }
              case HMatrixSupport::symmetric: {
                /**
                 * When the top level \hmatnode has the @p symmetric property,
                 * only those \hmatnodes in the leaf set that belong to the
                 * diagonal or lower triangular part of the original H-matrix
                 * will be created with allocated memory.
                 */
                switch (hmat->block_type)
                  {
                      case HMatrixSupport::diagonal_block: {
                        /**
                         * When the current \hmatnode in the leaf set is a
                         * diagonal block in the top level \hmatrix, it can only
                         * be a symmetric full matrix. Its memory will be
                         * allocated and its
                         * @p LAPACKFullMatrix type will be set to @p symmetric.
                         */

                        /**
                         * Here we make an assertion about the fact that a
                         * diagonal \hmatrix block in the leaf set should belong
                         * to the near field.
                         */
                        Assert(
                          bc_node->get_data_reference().get_is_near_field(),
                          ExcMessage(
                            "H-matrix node in the leaf set should belong to the near field if it is a diagonal block!"));
                        /**
                         * And we further make an assertion about the fact that
                         * the diagonal \hmatrix block should have the same
                         * property as the top level \hmatnode.
                         */
                        Assert(
                          hmat->property == top_hmat_node_property,
                          ExcMessage(
                            "A diagonal block should have the same property as that of the top level H-matrix node!"));

                        hmat->type = FullMatrixType;
                        hmat->fullmatrix =
                          new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::symmetric);

                        /**
                         * Assign matrix values from \p M to the current HMatrix.
                         */
                        for (unsigned int i = 0; i < hmat->m; i++)
                          {
                            for (unsigned int j = 0; j < hmat->n; j++)
                              {
                                (*hmat->fullmatrix)(i, j) =
                                  M((*hmat->row_index_range)[0] -
                                      M_row_index_range[0] + i,
                                    (*hmat->col_index_range)[0] -
                                      M_col_index_range[0] + j);
                              }
                          }

                        break;
                      }
                      case HMatrixSupport::lower_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the lower triangular part in the top level \hmatrix,
                         * it can be either a full matrix or a rank-k matrix.
                         * Its memory will be allocated because it contains
                         * effective data.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);

                            /**
                             * Assign matrix values from \p M to the current HMatrix.
                             */
                            for (unsigned int i = 0; i < hmat->m; i++)
                              {
                                for (unsigned int j = 0; j < hmat->n; j++)
                                  {
                                    (*hmat->fullmatrix)(i, j) =
                                      M((*hmat->row_index_range)[0] -
                                          M_row_index_range[0] + i,
                                        (*hmat->col_index_range)[0] -
                                          M_col_index_range[0] + j);
                                  }
                              }
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(*(hmat->row_index_range),
                                                   *(hmat->col_index_range),
                                                   fixed_rank_k,
                                                   M,
                                                   M_row_index_range,
                                                   M_col_index_range);
                          }

                        break;
                      }
                      case HMatrixSupport::upper_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the upper triangular part in the top level \hmatrix,
                         * only set its \hmatrix type without allocating memory
                         * because it is symmetric to the corresponding block in
                         * the lower triangular part.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>();
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(hmat->m, hmat->n, 0);
                          }

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcInvalidHMatrixBlockType(hmat->block_type));
                      }
                  }

                break;
              }
              case HMatrixSupport::lower_triangular: {
                /**
                 * When the top level \hmatnode has the @p lower_triangular
                 * property, only those \hmatnodes in the leaf set that belong
                 * to the diagonal or lower triangular part in the top level
                 * \hmatrix will be created with allocated memory.
                 */
                switch (hmat->block_type)
                  {
                      case HMatrixSupport::diagonal_block: {
                        /**
                         * When the current \hmatnode in the leaf set is a
                         * diagonal block in the top level \hmatrix, it can only
                         * be a lower triangular full matrix. Its memory will be
                         * allocated and its
                         * @p LAPACKFullMatrix type will be set to @p lower_triangular.
                         */

                        /**
                         * Here we make an assertion about the fact that a
                         * diagonal \hmatrix block in the leaf set should belong
                         * to the near field.
                         */
                        Assert(
                          bc_node->get_data_reference().get_is_near_field(),
                          ExcMessage(
                            "H-matrix node in the leaf set should belong to the near field if it is a diagonal block!"));
                        /**
                         * And we further make an assertion about the fact that
                         * the diagonal \hmatrix block should have the same
                         * property as the top level \hmatnode.
                         */
                        Assert(
                          hmat->property == top_hmat_node_property,
                          ExcMessage(
                            "A diagonal block should have the same property as that of the top level H-matrix node!"));

                        hmat->type = FullMatrixType;
                        hmat->fullmatrix =
                          new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::lower_triangular);

                        /**
                         * Assign matrix values from \p M to the current HMatrix.
                         */
                        for (unsigned int i = 0; i < hmat->m; i++)
                          {
                            for (unsigned int j = 0; j < hmat->n; j++)
                              {
                                (*hmat->fullmatrix)(i, j) =
                                  M((*hmat->row_index_range)[0] -
                                      M_row_index_range[0] + i,
                                    (*hmat->col_index_range)[0] -
                                      M_col_index_range[0] + j);
                              }
                          }

                        break;
                      }
                      case HMatrixSupport::lower_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the lower triangular part in the top level \hmatrix,
                         * it can be either a full matrix or a rank-k matrix.
                         * Its memory will be allocated because it contains
                         * effective data.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);

                            /**
                             * Assign matrix values from \p M to the current HMatrix.
                             */
                            for (unsigned int i = 0; i < hmat->m; i++)
                              {
                                for (unsigned int j = 0; j < hmat->n; j++)
                                  {
                                    (*hmat->fullmatrix)(i, j) =
                                      M((*hmat->row_index_range)[0] -
                                          M_row_index_range[0] + i,
                                        (*hmat->col_index_range)[0] -
                                          M_col_index_range[0] + j);
                                  }
                              }
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(*(hmat->row_index_range),
                                                   *(hmat->col_index_range),
                                                   fixed_rank_k,
                                                   M,
                                                   M_row_index_range,
                                                   M_col_index_range);
                          }

                        break;
                      }
                      case HMatrixSupport::upper_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the upper triangular part in the top level \hmatrix,
                         * only set its \hmatrix type without allocating memory
                         * because it is zero-valued.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>();
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(hmat->m, hmat->n, 0);
                          }

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcInvalidHMatrixBlockType(hmat->block_type));
                      }
                  }

                break;
              }
              case HMatrixSupport::upper_triangular: {
                /**
                 * When the top level \hmatnode has the @p upper_triangular
                 * property, only those \hmatnodes in the leaf set that belong
                 * to the diagonal or upper triangular part in the top level
                 * \hmatrix will be created with allocated memory.
                 */
                switch (hmat->block_type)
                  {
                      case HMatrixSupport::diagonal_block: {
                        /**
                         * When the current \hmatnode in the leaf set is a
                         * diagonal block in the top level \hmatrix, it can only
                         * be a upper triangular full matrix. Its memory will be
                         * allocated and its
                         * @p LAPACKFullMatrix type will be set to @p upper_triangular.
                         */

                        /**
                         * Here we make an assertion about the fact that a
                         * diagonal \hmatrix block in the leaf set should belong
                         * to the near field.
                         */
                        Assert(
                          bc_node->get_data_reference().get_is_near_field(),
                          ExcMessage(
                            "H-matrix node in the leaf set should belong to the near field if it is a diagonal block!"));
                        /**
                         * And we further make an assertion about the fact that
                         * the diagonal \hmatrix block should have the same
                         * property as the top level \hmatnode.
                         */
                        Assert(
                          hmat->property == top_hmat_node_property,
                          ExcMessage(
                            "A diagonal block should have the same property as that of the top level H-matrix node!"));

                        hmat->type = FullMatrixType;
                        hmat->fullmatrix =
                          new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::upper_triangular);

                        /**
                         * Assign matrix values from \p M to the current HMatrix.
                         */
                        for (unsigned int i = 0; i < hmat->m; i++)
                          {
                            for (unsigned int j = 0; j < hmat->n; j++)
                              {
                                (*hmat->fullmatrix)(i, j) =
                                  M((*hmat->row_index_range)[0] -
                                      M_row_index_range[0] + i,
                                    (*hmat->col_index_range)[0] -
                                      M_col_index_range[0] + j);
                              }
                          }

                        break;
                      }
                      case HMatrixSupport::upper_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the upper triangular part in the top level \hmatrix,
                         * it can be either a full matrix or a rank-k matrix.
                         * Its memory will be allocated because it contains
                         * effective data.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);

                            /**
                             * Assign matrix values from \p M to the current HMatrix.
                             */
                            for (unsigned int i = 0; i < hmat->m; i++)
                              {
                                for (unsigned int j = 0; j < hmat->n; j++)
                                  {
                                    (*hmat->fullmatrix)(i, j) =
                                      M((*hmat->row_index_range)[0] -
                                          M_row_index_range[0] + i,
                                        (*hmat->col_index_range)[0] -
                                          M_col_index_range[0] + j);
                                  }
                              }
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(*(hmat->row_index_range),
                                                   *(hmat->col_index_range),
                                                   fixed_rank_k,
                                                   M,
                                                   M_row_index_range,
                                                   M_col_index_range);
                          }

                        break;
                      }
                      case HMatrixSupport::lower_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the lower triangular part in the top level \hmatrix,
                         * only set its \hmatrix type without allocating memory
                         * because it is zero-valued.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>();
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(hmat->m, hmat->n, 0);
                          }

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcInvalidHMatrixBlockType(hmat->block_type));
                      }
                  }

                break;
              }
              default: {
                Assert(false,
                       ExcInvalidHMatrixProperty(top_hmat_node_property));
              }
          }
      }
  }


  /**
   * Recursively construct the children of an \hmatrix with
   * respect to a block cluster tree by starting from a tree node which is
   * associated with the current \hmatrix. There is no rank truncation to the
   * rank-k matrices.
   *
   * The matrices in the leaf set are initialized with the data in the given
   * full
   * matrix \p M, which is created on the block cluster index set \f$\tau \times
   * \sigma\f$ associated with the current \hmatrix. Hence, this
   * full matrix is just a block of the original global full matrix created on
   * the block cluster index set \f$I \times J\f$.
   *
   * During the recursive calling of this function, the source data matrix \p M is
   * kept intact, which will not be restricted to small matrix blocks.
   */
  template <int spacedim, typename Number = double>
  void
  InitAndCreateHMatrixChildren(
    HMatrix<spacedim, Number> *hmat,
    typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
                                                  bc_node,
    const LAPACKFullMatrixExt<Number>            &M,
    const std::array<types::global_dof_index, 2> &M_row_index_range,
    const std::array<types::global_dof_index, 2> &M_col_index_range,
    const HMatrixSupport::Property                top_hmat_node_property =
      HMatrixSupport::general)
  {
    /**
     * Link \p hmat with \p bc_node.
     */
    hmat->bc_node = const_cast<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type>(bc_node);

    /**
     * Link row and column indices.
     */
    hmat->row_index_range =
      const_cast<std::array<types::global_dof_index, 2> *>(
        &(hmat->bc_node->get_data_reference()
            .get_tau_node()
            ->get_data_reference()
            .get_index_range()));
    hmat->col_index_range =
      const_cast<std::array<types::global_dof_index, 2> *>(
        &(hmat->bc_node->get_data_reference()
            .get_sigma_node()
            ->get_data_reference()
            .get_index_range()));

    /**
     * Update the matrix dimension of \p hmat.
     */
    hmat->m = (*hmat->row_index_range)[1] - (*hmat->row_index_range)[0];
    hmat->n = (*hmat->col_index_range)[1] - (*hmat->col_index_range)[0];

    const unsigned int bc_node_child_num = bc_node->get_child_num();

    if (bc_node_child_num > 0)
      {
        /**
         * When the block cluster node \p bc_node has children, set the current \p
         * hmat type as \p HierarchicalMatrixType. Then we will
         * continue constructing hierarchical submatrices.
         */
        hmat->type = HierarchicalMatrixType;

        for (unsigned int i = 0; i < bc_node_child_num; i++)
          {
            /**
             * Create an empty HMatrix on the heap.
             */
            HMatrix<spacedim, Number> *child_hmat =
              new HMatrix<spacedim, Number>();

            /**
             * Set the state of the child \hmatrix, which is the same as its
             * parent.
             */
            child_hmat->state = hmat->state;

            /**
             * Set the block type of the child \hmatrix, which depends on the
             * block type of its parent.
             */
            switch (hmat->block_type)
              {
                  case HMatrixSupport::undefined_block: {
                    /**
                     * When the current \hmatrix block is @p undefined_block, all
                     * child \hmatrices are @p undefined_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  case HMatrixSupport::diagonal_block: {
                    /**
                     * When the current \hmatrix is @p diagonal_block, the first and
                     * fourth child \hmatrices are @p diagonal_block, while the second
                     * child \hmatrix is @p upper_triangular_block and the third child
                     * \hmatrix is @p lower_triangular_block.
                     */
                    switch (i)
                      {
                          case 0: {
                            child_hmat->block_type =
                              HMatrixSupport::diagonal_block;

                            break;
                          }
                          case 1: {
                            child_hmat->block_type =
                              HMatrixSupport::upper_triangular_block;

                            break;
                          }
                          case 2: {
                            child_hmat->block_type =
                              HMatrixSupport::lower_triangular_block;

                            break;
                          }
                          case 3: {
                            child_hmat->block_type =
                              HMatrixSupport::diagonal_block;

                            break;
                          }
                          default: {
                            Assert(false, ExcNotImplemented());
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::upper_triangular_block: {
                    /**
                     * When the current \hmatrix is @p upper_triangular_block,
                     * all child \hmatrices are @p upper_triangular_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  case HMatrixSupport::lower_triangular_block: {
                    /**
                     * When the current \hmatrix is @p lower_triangular_block,
                     * all child \hmatrices are @p lower_triangular_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  default: {
                    Assert(false, ExcInvalidHMatrixBlockType(hmat->block_type));
                  }
              }

            /**
             * Set the property of the child \hmatrix, which depends on the
             * property of its parent.
             */
            switch (hmat->property)
              {
                  case HMatrixSupport::general: {
                    /**
                     * When the property of the current \hmatrix is @p general,
                     * all of its children have the same property @p general.
                     */
                    child_hmat->property = HMatrixSupport::general;

                    break;
                  }
                  case HMatrixSupport::symmetric: {
                    /**
                     * When the property of the current \hmatrix is @p symmetric,
                     * only those diagonal submatrices are @p symmetric, while
                     * the other submatrices are @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::symmetric;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  case HMatrixSupport::upper_triangular: {
                    /**
                     * When the property of the current \hmatrix is
                     * @p upper_triangular, only those diagonal submatrices are
                     * @p upper_triangular, while the other submatrices are
                     * @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::upper_triangular;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  case HMatrixSupport::lower_triangular: {
                    /**
                     * When the property of the current \hmatrix is
                     * @p lower_triangular, only those diagonal submatrices are
                     * @p lower_triangular, while the other submatrices are
                     * @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::lower_triangular;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  default: {
                    Assert(false, ExcInvalidHMatrixProperty(hmat->property));
                  }
              }

            InitAndCreateHMatrixChildren(child_hmat,
                                         bc_node->get_child_pointer(i),
                                         M,
                                         M_row_index_range,
                                         M_col_index_range,
                                         top_hmat_node_property);

            /**
             * Append the initialized child to the list of submatrices of \p hmat.
             */
            hmat->submatrices.push_back(child_hmat);

            /**
             * Set the pointer to the parent \hmatnode of the current child
             * \hmatnode.
             */
            child_hmat->parent = hmat;

            child_hmat->submatrix_index = i;
          }
      }
    else
      {
        /**
         * Update the current matrix type according to the identity of the block
         * cluster node. When the block cluster belongs to the near field, \p hmat
         * should be represented as a \p LAPACKFullMatrixExt. When the block
         * cluster belongs to the far field, \p hmat should be represented as an
         * \p RkMatrix. Correspondingly, new matrices, either full matrix or
         * rank-k matrix will be created on the heap and assigned to the current
         * \hmatrix.
         */
        switch (top_hmat_node_property)
          {
              case HMatrixSupport::general: {
                /**
                 * When the top level \hmatnode has the @p general property, all
                 * \hmatnodes in the leaf set should be created with allocated
                 * memory.
                 */
                if (bc_node->get_data_reference().get_is_near_field())
                  {
                    hmat->type = FullMatrixType;
                    hmat->fullmatrix =
                      new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);

                    /**
                     * Assign matrix values from \p M to the current HMatrix.
                     */
                    for (unsigned int i = 0; i < hmat->m; i++)
                      {
                        for (unsigned int j = 0; j < hmat->n; j++)
                          {
                            (*hmat->fullmatrix)(i, j) =
                              M((*hmat->row_index_range)[0] -
                                  M_row_index_range[0] + i,
                                (*hmat->col_index_range)[0] -
                                  M_col_index_range[0] + j);
                          }
                      }
                  }
                else
                  {
                    hmat->type = RkMatrixType;
                    hmat->rkmatrix =
                      new RkMatrix<Number>(*(hmat->row_index_range),
                                           *(hmat->col_index_range),
                                           M,
                                           M_row_index_range,
                                           M_col_index_range);
                  }

                break;
              }
              case HMatrixSupport::symmetric: {
                /**
                 * When the top level \hmatnode has the @p symmetric property,
                 * only those \hmatnodes in the leaf set that belong to the
                 * diagonal or lower triangular part of the original H-matrix
                 * will be created with allocated memory.
                 */
                switch (hmat->block_type)
                  {
                      case HMatrixSupport::diagonal_block: {
                        /**
                         * When the current \hmatnode in the leaf set is a
                         * diagonal block in the top level \hmatrix, it can only
                         * be a symmetric full matrix. Its memory will be
                         * allocated and its
                         * @p LAPACKFullMatrix type will be set to @p symmetric.
                         */

                        /**
                         * Here we make an assertion about the fact that a
                         * diagonal \hmatrix block in the leaf set should belong
                         * to the near field.
                         */
                        Assert(
                          bc_node->get_data_reference().get_is_near_field(),
                          ExcMessage(
                            "H-matrix node in the leaf set should belong to the near field if it is a diagonal block!"));
                        /**
                         * And we further make an assertion about the fact that
                         * the diagonal \hmatrix block should have the same
                         * property as the top level \hmatnode.
                         */
                        Assert(
                          hmat->property == top_hmat_node_property,
                          ExcMessage(
                            "A diagonal block should have the same property as that of the top level H-matrix node!"));

                        hmat->type = FullMatrixType;
                        hmat->fullmatrix =
                          new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::symmetric);

                        /**
                         * Assign matrix values from \p M to the current HMatrix.
                         */
                        for (unsigned int i = 0; i < hmat->m; i++)
                          {
                            for (unsigned int j = 0; j < hmat->n; j++)
                              {
                                (*hmat->fullmatrix)(i, j) =
                                  M((*hmat->row_index_range)[0] -
                                      M_row_index_range[0] + i,
                                    (*hmat->col_index_range)[0] -
                                      M_col_index_range[0] + j);
                              }
                          }

                        break;
                      }
                      case HMatrixSupport::lower_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the lower triangular part in the top level \hmatrix,
                         * it can be either a full matrix or a rank-k matrix.
                         * Its memory will be allocated because it contains
                         * effective data.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);

                            /**
                             * Assign matrix values from \p M to the current HMatrix.
                             */
                            for (unsigned int i = 0; i < hmat->m; i++)
                              {
                                for (unsigned int j = 0; j < hmat->n; j++)
                                  {
                                    (*hmat->fullmatrix)(i, j) =
                                      M((*hmat->row_index_range)[0] -
                                          M_row_index_range[0] + i,
                                        (*hmat->col_index_range)[0] -
                                          M_col_index_range[0] + j);
                                  }
                              }
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(*(hmat->row_index_range),
                                                   *(hmat->col_index_range),
                                                   M,
                                                   M_row_index_range,
                                                   M_col_index_range);
                          }

                        break;
                      }
                      case HMatrixSupport::upper_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the upper triangular part in the top level \hmatrix,
                         * only set its \hmatrix type without allocating memory
                         * because it is symmetric to the corresponding block in
                         * the lower triangular part.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>();
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(hmat->m, hmat->n, 0);
                          }

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcInvalidHMatrixBlockType(hmat->block_type));
                      }
                  }

                break;
              }
              case HMatrixSupport::lower_triangular: {
                /**
                 * When the top level \hmatnode has the @p lower_triangular
                 * property, only those \hmatnodes in the leaf set that belong
                 * to the diagonal or lower triangular part in the top level
                 * \hmatrix will be created with allocated memory.
                 */
                switch (hmat->block_type)
                  {
                      case HMatrixSupport::diagonal_block: {
                        /**
                         * When the current \hmatnode in the leaf set is a
                         * diagonal block in the top level \hmatrix, it can only
                         * be a lower triangular full matrix. Its memory will be
                         * allocated and its
                         * @p LAPACKFullMatrix type will be set to @p lower_triangular.
                         */

                        /**
                         * Here we make an assertion about the fact that a
                         * diagonal \hmatrix block in the leaf set should belong
                         * to the near field.
                         */
                        Assert(
                          bc_node->get_data_reference().get_is_near_field(),
                          ExcMessage(
                            "H-matrix node in the leaf set should belong to the near field if it is a diagonal block!"));
                        /**
                         * And we further make an assertion about the fact that
                         * the diagonal \hmatrix block should have the same
                         * property as the top level \hmatnode.
                         */
                        Assert(
                          hmat->property == top_hmat_node_property,
                          ExcMessage(
                            "A diagonal block should have the same property as that of the top level H-matrix node!"));

                        hmat->type = FullMatrixType;
                        hmat->fullmatrix =
                          new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::lower_triangular);

                        /**
                         * Assign matrix values from \p M to the current HMatrix.
                         */
                        for (unsigned int i = 0; i < hmat->m; i++)
                          {
                            for (unsigned int j = 0; j < hmat->n; j++)
                              {
                                (*hmat->fullmatrix)(i, j) =
                                  M((*hmat->row_index_range)[0] -
                                      M_row_index_range[0] + i,
                                    (*hmat->col_index_range)[0] -
                                      M_col_index_range[0] + j);
                              }
                          }

                        break;
                      }
                      case HMatrixSupport::lower_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the lower triangular part in the top level \hmatrix,
                         * it can be either a full matrix or a rank-k matrix.
                         * Its memory will be allocated because it contains
                         * effective data.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);

                            /**
                             * Assign matrix values from \p M to the current HMatrix.
                             */
                            for (unsigned int i = 0; i < hmat->m; i++)
                              {
                                for (unsigned int j = 0; j < hmat->n; j++)
                                  {
                                    (*hmat->fullmatrix)(i, j) =
                                      M((*hmat->row_index_range)[0] -
                                          M_row_index_range[0] + i,
                                        (*hmat->col_index_range)[0] -
                                          M_col_index_range[0] + j);
                                  }
                              }
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(*(hmat->row_index_range),
                                                   *(hmat->col_index_range),
                                                   M,
                                                   M_row_index_range,
                                                   M_col_index_range);
                          }

                        break;
                      }
                      case HMatrixSupport::upper_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the upper triangular part in the top level \hmatrix,
                         * only set its \hmatrix type without allocating memory
                         * because it is zero-valued.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>();
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(hmat->m, hmat->n, 0);
                          }

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcInvalidHMatrixBlockType(hmat->block_type));
                      }
                  }

                break;
              }
              case HMatrixSupport::upper_triangular: {
                /**
                 * When the top level \hmatnode has the @p upper_triangular
                 * property, only those \hmatnodes in the leaf set that belong
                 * to the diagonal or upper triangular part in the top level
                 * \hmatrix will be created with allocated memory.
                 */
                switch (hmat->block_type)
                  {
                      case HMatrixSupport::diagonal_block: {
                        /**
                         * When the current \hmatnode in the leaf set is a
                         * diagonal block in the top level \hmatrix, it can only
                         * be a upper triangular full matrix. Its memory will be
                         * allocated and its
                         * @p LAPACKFullMatrix type will be set to @p upper_triangular.
                         */

                        /**
                         * Here we make an assertion about the fact that a
                         * diagonal \hmatrix block in the leaf set should belong
                         * to the near field.
                         */
                        Assert(
                          bc_node->get_data_reference().get_is_near_field(),
                          ExcMessage(
                            "H-matrix node in the leaf set should belong to the near field if it is a diagonal block!"));
                        /**
                         * And we further make an assertion about the fact that
                         * the diagonal \hmatrix block should have the same
                         * property as the top level \hmatnode.
                         */
                        Assert(
                          hmat->property == top_hmat_node_property,
                          ExcMessage(
                            "A diagonal block should have the same property as that of the top level H-matrix node!"));

                        hmat->type = FullMatrixType;
                        hmat->fullmatrix =
                          new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);
                        hmat->fullmatrix->set_property(
                          LAPACKSupport::upper_triangular);

                        /**
                         * Assign matrix values from \p M to the current HMatrix.
                         */
                        for (unsigned int i = 0; i < hmat->m; i++)
                          {
                            for (unsigned int j = 0; j < hmat->n; j++)
                              {
                                (*hmat->fullmatrix)(i, j) =
                                  M((*hmat->row_index_range)[0] -
                                      M_row_index_range[0] + i,
                                    (*hmat->col_index_range)[0] -
                                      M_col_index_range[0] + j);
                              }
                          }

                        break;
                      }
                      case HMatrixSupport::upper_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the upper triangular part in the top level \hmatrix,
                         * it can be either a full matrix or a rank-k matrix.
                         * Its memory will be allocated because it contains
                         * effective data.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>(hmat->m, hmat->n);

                            /**
                             * Assign matrix values from \p M to the current HMatrix.
                             */
                            for (unsigned int i = 0; i < hmat->m; i++)
                              {
                                for (unsigned int j = 0; j < hmat->n; j++)
                                  {
                                    (*hmat->fullmatrix)(i, j) =
                                      M((*hmat->row_index_range)[0] -
                                          M_row_index_range[0] + i,
                                        (*hmat->col_index_range)[0] -
                                          M_col_index_range[0] + j);
                                  }
                              }
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(*(hmat->row_index_range),
                                                   *(hmat->col_index_range),
                                                   M,
                                                   M_row_index_range,
                                                   M_col_index_range);
                          }

                        break;
                      }
                      case HMatrixSupport::lower_triangular_block: {
                        /**
                         * When the current \hmatnode in the leaf set belongs to
                         * the lower triangular part in the top level \hmatrix,
                         * only set its \hmatrix type without allocating memory
                         * because it is zero-valued.
                         */
                        if (bc_node->get_data_reference().get_is_near_field())
                          {
                            hmat->type = FullMatrixType;
                            hmat->fullmatrix =
                              new LAPACKFullMatrixExt<Number>();
                          }
                        else
                          {
                            hmat->type = RkMatrixType;
                            hmat->rkmatrix =
                              new RkMatrix<Number>(hmat->m, hmat->n, 0);
                          }

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcInvalidHMatrixBlockType(hmat->block_type));
                      }
                  }

                break;
              }
              default: {
                Assert(false,
                       ExcInvalidHMatrixProperty(top_hmat_node_property));
              }
          }
      }
  }


  /**
   * Recursively construct the children of an \hmatnode with
   * respect to a block cluster tree by starting from a tree node which is
   * associated with the current \hmatnode.
   *
   * The matrices in the leaf set take the data **migrated** from the leaf set
   * of
   * the given \hmatrix \p H.
   *
   * @param hmat The \hmatnode to be associated with the \bcn @p bc_node.
   * @param bc_node The \bcn to be associated with the \hmatnode @p hmat
   * @param H
   */
  template <int spacedim, typename Number = double>
  void
  InitAndCreateHMatrixChildren(
    HMatrix<spacedim, Number> *hmat,
    typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
                                bc_node,
    HMatrix<spacedim, Number> &&H)
  {
    /**
     * Link \p hmat with \p bc_node and remove the @p const feature @p bc_node by
     * using @p const_cast.
     */
    hmat->bc_node = const_cast<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type>(bc_node);

    /**
     * Link row and column indices stored in the clusters \f$\tau\f$ and
     * \f$\sigma\f$ respectively..
     */
    hmat->row_index_range =
      const_cast<std::array<types::global_dof_index, 2> *>(
        &(hmat->bc_node->get_data_reference()
            .get_tau_node()
            ->get_data_reference()
            .get_index_range()));
    hmat->col_index_range =
      const_cast<std::array<types::global_dof_index, 2> *>(
        &(hmat->bc_node->get_data_reference()
            .get_sigma_node()
            ->get_data_reference()
            .get_index_range()));

    /**
     * Update the matrix dimension of \p hmat.
     */
    hmat->m = (*hmat->row_index_range)[1] - (*hmat->row_index_range)[0];
    hmat->n = (*hmat->col_index_range)[1] - (*hmat->col_index_range)[0];

    const unsigned int bc_node_child_num = bc_node->get_child_num();

    if (bc_node_child_num > 0)
      {
        /**
         * When the block cluster node \p bc_node has children, set the current \p
         * hmat type as \p HierarchicalMatrixType.
         */
        hmat->type = HierarchicalMatrixType;

        /**
         * Then we will continue constructing its hierarchical submatrices.
         */
        for (unsigned int i = 0; i < bc_node_child_num; i++)
          {
            /**
             * Create an empty HMatrix on the heap.
             */
            HMatrix<spacedim, Number> *child_hmat =
              new HMatrix<spacedim, Number>();

            /**
             * Set the state of the child \hmatrix, which is the same as its
             * parent.
             */
            child_hmat->state = hmat->state;

            /**
             * Set the block type of the child \hmatrix, which depends on the
             * block type of its parent.
             */
            switch (hmat->block_type)
              {
                  case HMatrixSupport::undefined_block: {
                    /**
                     * When the current \hmatrix block is @p undefined_block, all
                     * child \hmatrices are @p undefined_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  case HMatrixSupport::diagonal_block: {
                    /**
                     * When the current \hmatrix is @p diagonal_block, the first and
                     * fourth child \hmatrices are @p diagonal_block, while the second
                     * child \hmatrix is @p upper_triangular_block and the third child
                     * \hmatrix is @p lower_triangular_block.
                     */
                    switch (i)
                      {
                          case 0: {
                            child_hmat->block_type =
                              HMatrixSupport::diagonal_block;

                            break;
                          }
                          case 1: {
                            child_hmat->block_type =
                              HMatrixSupport::upper_triangular_block;

                            break;
                          }
                          case 2: {
                            child_hmat->block_type =
                              HMatrixSupport::lower_triangular_block;

                            break;
                          }
                          case 3: {
                            child_hmat->block_type =
                              HMatrixSupport::diagonal_block;

                            break;
                          }
                          default: {
                            Assert(false, ExcNotImplemented());
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::upper_triangular_block: {
                    /**
                     * When the current \hmatrix is @p upper_triangular_block,
                     * all child \hmatrices are @p upper_triangular_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  case HMatrixSupport::lower_triangular_block: {
                    /**
                     * When the current \hmatrix is @p lower_triangular_block,
                     * all child \hmatrices are @p lower_triangular_block.
                     */
                    child_hmat->block_type = hmat->block_type;

                    break;
                  }
                  default: {
                    Assert(false, ExcInvalidHMatrixBlockType(hmat->block_type));
                  }
              }

            /**
             * Set the property of the child \hmatrix, which depends on the
             * property of its parent.
             */
            switch (hmat->property)
              {
                  case HMatrixSupport::general: {
                    /**
                     * When the property of the current \hmatrix is @p general,
                     * all of its children have the same property @p general.
                     */
                    child_hmat->property = HMatrixSupport::general;

                    break;
                  }
                  case HMatrixSupport::symmetric: {
                    /**
                     * When the property of the current \hmatrix is @p symmetric,
                     * only those diagonal submatrices are @p symmetric, while
                     * the other submatrices are @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::symmetric;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  case HMatrixSupport::upper_triangular: {
                    /**
                     * When the property of the current \hmatrix is
                     * @p upper_triangular, only those diagonal submatrices are
                     * @p upper_triangular, while the other submatrices are
                     * @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::upper_triangular;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  case HMatrixSupport::lower_triangular: {
                    /**
                     * When the property of the current \hmatrix is
                     * @p lower_triangular, only those diagonal submatrices are
                     * @p lower_triangular, while the other submatrices are
                     * @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::lower_triangular;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  default: {
                    Assert(false, ExcInvalidHMatrixProperty(hmat->property));
                  }
              }

            InitAndCreateHMatrixChildren(child_hmat,
                                         bc_node->get_child_pointer(i),
                                         std::move(H));

            /**
             * Append the initialized child to the list of submatrices of \p hmat.
             */
            hmat->submatrices.push_back(child_hmat);

            /**
             * Set the pointer to the parent \hmatnode of the current child
             * \hmatnode.
             */
            child_hmat->parent = hmat;

            child_hmat->submatrix_index = i;
          }
      }
    else
      {
        /**
         * When the current \hmatnode is a leaf, migrate the
         * data from the leaf set of \p H to it.
         */
        HMatrix<spacedim, Number> *matched_source_hmat =
          *(H.find_block_cluster_in_leaf_set(
            hmat->bc_node->get_data_reference()));
        /**
         * Shallow copy the found \hmatnode in the leaf set to
         * the current \hmatnode.
         */
        (*hmat) = std::move(*matched_source_hmat);
      }
  }


  /**
   * Refine an \hmatnode with respect to its associated block
   * cluster tree which has already been extended to be finer than the original
   * tree. The \hmatnode should be of either \p FullMatrixType
   * or \p RkMatrixType, i.e. it belongs to the leaf set of the block cluster tree
   * before extension.
   *
   * @param starting_hmat The pointer to the initial \hmatrix
   * node from which this recursive function is called for the first time, i.e.
   * the \hmatnode from which the refinement begins.
   * @param current_hmat The pointer to the current \hmatnode
   * being handled during the recursion. For the first time of calling this
   * function, \p current_hmat is the same as \p starting_hmat.
   */
  template <int spacedim, typename Number>
  void
  RefineHMatrixWrtExtendedBlockClusterTree(
    HMatrix<spacedim, Number> *starting_hmat,
    HMatrix<spacedim, Number> *current_hmat)
  {
    /**
     * <dl class="section">
     *   <dt>Work flow</dt>
     *   <dd>Because the \hmatnode from which the refinement
     * begins belongs to the leaf set of the original block cluster tree, its
     * \hmatrix type can only be \p FullMatrixType or \p
     * RkMatrixType. Therefore, we make an assertion here.
     */
    Assert((starting_hmat->type == FullMatrixType) ||
             (starting_hmat->type == RkMatrixType),
           ExcInvalidHMatrixType(starting_hmat->type));

    /**
     * Determine the total number of children of the current \hmatnode by
     * querying its associated block cluster node. We do it like this is because
     * the block cluster tree has already been extended which contains a set of
     * child node, while the hierarchy of H-matrices has still not been extended
     * yet.
     */
    const unsigned int bc_node_child_num =
      current_hmat->bc_node->get_child_num();

    if (bc_node_child_num > 0)
      {
        /**
         * If the associated block cluster node of the current \hmatnode has
         * children, we firstly update the \hmatrix type for the current
         * \hmatrix
         * node as \p HierarchicalMatrix and this is only performed when the
         * current \hmatnode is <strong>not</strong> the starting \hmatnode,
         * because the original matrix type of the starting \hmatnode will be
         * used later during restriction operations to the current block
         * cluster. When the whole recursive call of this function
         * @p RefineHMatrixWrtExtendedBlockClusterTree is complete, the \hmatrix
         * type of @p starting_hmat will be corrected if this \hmatnode has
         * literally been refined. And this operation should be performed in the
         * caller function of @p RefineHMatrixWrtExtendedBlockClusterTree, such
         * as @p HMatrix<spacedim, Number>::refine_to_supertree.
         */
        if (current_hmat != starting_hmat)
          {
            current_hmat->type = HierarchicalMatrixType;
          }

        for (unsigned int i = 0; i < bc_node_child_num; i++)
          {
            /**
             * For each of the children, create an empty \hmatrix
             * node on the heap and append it to the list of submatrices of the
             * current \hmatrix.
             */
            HMatrix<spacedim, Number> *child_hmat =
              new HMatrix<spacedim, Number>();

            /**
             * Set the state of the child \hmatrix, which is the same as its
             * parent.
             */
            child_hmat->state = current_hmat->state;

            /**
             * Set the block type of the child \hmatrix, which depends on the
             * block type of its parent.
             */
            switch (current_hmat->block_type)
              {
                  case HMatrixSupport::undefined_block: {
                    /**
                     * When the current \hmatrix block is @p undefined_block, all
                     * child \hmatrices are @p undefined_block.
                     */
                    child_hmat->block_type = current_hmat->block_type;

                    break;
                  }
                  case HMatrixSupport::diagonal_block: {
                    /**
                     * When the current \hmatrix is @p diagonal_block, the first and
                     * fourth child \hmatrices are @p diagonal_block, while the second
                     * child \hmatrix is @p upper_triangular_block and the third child
                     * \hmatrix is @p lower_triangular_block.
                     */
                    switch (i)
                      {
                          case 0: {
                            child_hmat->block_type =
                              HMatrixSupport::diagonal_block;

                            break;
                          }
                          case 1: {
                            child_hmat->block_type =
                              HMatrixSupport::upper_triangular_block;

                            break;
                          }
                          case 2: {
                            child_hmat->block_type =
                              HMatrixSupport::lower_triangular_block;

                            break;
                          }
                          case 3: {
                            child_hmat->block_type =
                              HMatrixSupport::diagonal_block;

                            break;
                          }
                          default: {
                            Assert(false, ExcNotImplemented());
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::upper_triangular_block: {
                    /**
                     * When the current \hmatrix is @p upper_triangular_block,
                     * all child \hmatrices are @p upper_triangular_block.
                     */
                    child_hmat->block_type = current_hmat->block_type;

                    break;
                  }
                  case HMatrixSupport::lower_triangular_block: {
                    /**
                     * When the current \hmatrix is @p lower_triangular_block,
                     * all child \hmatrices are @p lower_triangular_block.
                     */
                    child_hmat->block_type = current_hmat->block_type;

                    break;
                  }
                  default: {
                    Assert(false,
                           ExcMessage(
                             "Invalid H-matrix block type: " +
                             std::to_string(current_hmat->block_type)));
                  }
              }

            /**
             * Set the property of the child \hmatrix, which depends on the
             * property of its parent.
             */
            switch (current_hmat->property)
              {
                  case HMatrixSupport::general: {
                    /**
                     * When the property of the current \hmatrix is @p general,
                     * all of its children have the same property @p general.
                     */
                    child_hmat->property = HMatrixSupport::general;

                    break;
                  }
                  case HMatrixSupport::symmetric: {
                    /**
                     * When the property of the current \hmatrix is @p symmetric,
                     * only those diagonal submatrices are @p symmetric, while
                     * the other submatrices are @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::symmetric;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  case HMatrixSupport::upper_triangular: {
                    /**
                     * When the property of the current \hmatrix is
                     * @p upper_triangular, only those diagonal submatrices are
                     * @p upper_triangular, while the other submatrices are
                     * @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::upper_triangular;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  case HMatrixSupport::lower_triangular: {
                    /**
                     * When the property of the current \hmatrix is
                     * @p lower_triangular, only those diagonal submatrices are
                     * @p lower_triangular, while the other submatrices are
                     * @p general.
                     */
                    if (child_hmat->block_type ==
                        HMatrixSupport::diagonal_block)
                      {
                        child_hmat->property = HMatrixSupport::lower_triangular;
                      }
                    else
                      {
                        child_hmat->property = HMatrixSupport::general;
                      }

                    break;
                  }
                  default: {
                    Assert(false,
                           ExcMessage("Invalid H-matrix property: " +
                                      std::to_string(current_hmat->property)));
                  }
              }

            current_hmat->submatrices.push_back(child_hmat);

            /**
             * Link the child \hmatnode with the corresponding
             * block cluster node.
             */
            child_hmat->bc_node = const_cast<
              typename BlockClusterTree<spacedim, Number>::node_pointer_type>(
              current_hmat->bc_node->get_child_pointer(i));

            /**
             * Link row and column indices of the child \hmatrix
             * node to those index sets stored in clusters.
             */
            child_hmat->row_index_range =
              const_cast<std::array<types::global_dof_index, 2> *>(
                &(child_hmat->bc_node->get_data_reference()
                    .get_tau_node()
                    ->get_data_reference()
                    .get_index_range()));
            child_hmat->col_index_range =
              const_cast<std::array<types::global_dof_index, 2> *>(
                &(child_hmat->bc_node->get_data_reference()
                    .get_sigma_node()
                    ->get_data_reference()
                    .get_index_range()));

            /**
             * Update the matrix dimension of the child \hmatrix
             * node.
             */
            child_hmat->m = (*child_hmat->row_index_range)[1] -
                            (*child_hmat->row_index_range)[0];
            child_hmat->n = (*child_hmat->col_index_range)[1] -
                            (*child_hmat->col_index_range)[0];

            /**
             * Set the pointer to the parent \hmatnode of the current child
             * \hmatnode.
             */
            child_hmat->parent = current_hmat;

            child_hmat->submatrix_index = i;

            /**
             * Recursively call the function.
             */
            RefineHMatrixWrtExtendedBlockClusterTree(starting_hmat, child_hmat);
          }
      }
    else
      {
        /**
         * When the current \hmatnode has no children, i.e. it
         * belongs to the leaf set of the extended block cluster tree.
         */
        if (current_hmat == starting_hmat)
          {
            /**
             * If the current \hmatnode is still the same as
             * the starting \hmatnode, there is no actual
             * refinement work to be done.
             */
          }
        else
          {
            /**
             * Update the current \hmatnode type according to
             * the identity of the block cluster node: when the block cluster
             * belongs to the near field, \p current_hmat should be represented as
             * a full matrix \p LAPACKFullMatrixExt; when the block cluster
             * belongs to the far field, \p current_hmat should be represented as
             * a rank-k matrix \p RkMatrix. Correspondingly, new matrices, either
             * full matrix or rank-k matrix will be created on the heap and
             * assigned to the corresponding field of the current
             * \hmatrix.
             */
            if (current_hmat->bc_node->get_data_reference().get_is_near_field())
              {
                current_hmat->type = FullMatrixType;

                /**
                 * Fill the current full matrix with the data extracted from the
                 * starting \hmatnode. This is actually a restriction of the
                 * starting \hmatnode to the current \hmatnode.
                 */
                switch (starting_hmat->type)
                  {
                      case FullMatrixType: {
                        /**
                         * Restrict full matrix to full matrix.
                         */
                        current_hmat->fullmatrix =
                          new LAPACKFullMatrixExt<Number>(
                            *(current_hmat->row_index_range),
                            *(current_hmat->col_index_range),
                            *(starting_hmat->fullmatrix),
                            *starting_hmat->row_index_range,
                            *starting_hmat->col_index_range);

                        break;
                      }
                      case RkMatrixType: {
                        /**
                         * Restrict rank-k matrix to full matrix.
                         */
                        current_hmat->fullmatrix =
                          new LAPACKFullMatrixExt<Number>();
                        starting_hmat->rkmatrix->restrictToFullMatrix(
                          *starting_hmat->row_index_range,
                          *starting_hmat->col_index_range,
                          *(current_hmat->fullmatrix),
                          *(current_hmat->row_index_range),
                          *(current_hmat->col_index_range));

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcInvalidHMatrixType(starting_hmat->type));

                        break;
                      }
                  }

                /**
                 * Set the full matrix's property according to the current
                 * \hmatnode property only when the current \hmatnode is a
                 * diagonal block.
                 *
                 * \mynote{The @p state of the full matrix will be taken care of by
                 * itself, i.e. its state will change accordingly when some
                 * specific operation is applied to it.}
                 */
                if (current_hmat->block_type == HMatrixSupport::diagonal_block)
                  {
                    switch (current_hmat->property)
                      {
                          case HMatrixSupport::general: {
                            current_hmat->fullmatrix->set_property(
                              LAPACKSupport::general);

                            break;
                          }
                          case HMatrixSupport::symmetric: {
                            current_hmat->fullmatrix->set_property(
                              LAPACKSupport::symmetric);

                            break;
                          }
                          case HMatrixSupport::upper_triangular: {
                            current_hmat->fullmatrix->set_property(
                              LAPACKSupport::upper_triangular);

                            break;
                          }
                          case HMatrixSupport::lower_triangular: {
                            current_hmat->fullmatrix->set_property(
                              LAPACKSupport::lower_triangular);

                            break;
                          }
                          default: {
                            Assert(false,
                                   ExcMessage(
                                     "Invalid H-matrix property: " +
                                     std::to_string(current_hmat->property)));
                          }
                      }
                  }
              }
            else
              {
                current_hmat->type = RkMatrixType;

                /**
                 * Fill the current rank-k matrix with the data extracted
                 * from the starting \hmatnode.
                 */
                switch (starting_hmat->type)
                  {
                      case FullMatrixType: {
                        /**
                         * Restrict full matrix to rank-k matrix.
                         */
                        current_hmat->rkmatrix =
                          new RkMatrix<Number>(*(current_hmat->row_index_range),
                                               *(current_hmat->col_index_range),
                                               *(starting_hmat->fullmatrix),
                                               *starting_hmat->row_index_range,
                                               *starting_hmat->col_index_range);

                        break;
                      }
                      case RkMatrixType: {
                        /**
                         * Restrict rank-k matrix to rank-k matrix.
                         */
                        current_hmat->rkmatrix =
                          new RkMatrix<Number>(*(current_hmat->row_index_range),
                                               *(current_hmat->col_index_range),
                                               *(starting_hmat->rkmatrix),
                                               *starting_hmat->row_index_range,
                                               *starting_hmat->col_index_range);

                        break;
                      }
                      default: {
                        Assert(false,
                               ExcInvalidHMatrixType(starting_hmat->type));

                        break;
                      }
                  }
              }
          }
      }

    /**
     *   </dd>
     * </dl>
     */
  }


  /**
   * Convert an \hmatrix block \p hmat_block recursively into a
   * rank-k matrix or a full matrix, which depends on whether the block cluster
   * associated with \p hmat_block is large or not.
   *
   * Generally speaking, this method can be considered as the agglomeration of
   * all
   * descendants of \p hmat_block.
   *
   * <dl class="section note">
   *   <dt>Note</dt>
   *   <dd>This method implements the operator \f$\mathcal{T}_r^{\mathcal{R}
   * \leftarrow \mathcal{H}}\f$, i.e. the algorithm \f$Convert\_H\f$ in (7.8) in
   * Hackbusch's \hmatrix book.</dd>
   * </dl>
   *
   * This \hmatrix block is implemented as a node in a whole
   * \hmatrix hierarchy. This conversion algorithm will
   * recursively descend in the hierarchical matrices for processing:
   *
   * 1. when the current matrix block belongs to the near field set
   * \f$P^-\f$, it is represented as a full matrix and no operations will be
   * applied to it;
   *
   * 2. when it belongs to the far field set \f$P^+\f$, it is already
   * a rank-k matrix, which will then be truncated to the given \p fixed_rank_k;
   *
   * 3. when it is not a leaf, i.e. it is a hierarchical matrix, this
   * function will be called recursively for each of its children. After that,
   *
   *   a. if the block cluster related to the current matrix is large, pairwise
   * agglomeration for rank-k matrices will be performed and a rank-k matrix
   * will
   * be obtained with the given rank \p fixed_rank_k;
   *
   *   b. if the block cluster related to the current matrix is small,
   * agglomeration of full matrices will be performed and a full matrix will be
   * obtained.
   *
   * @param hmat_block the pointer to the current matrix block from which the
   * recursion will start.
   * @param fixed_rank_k the fixed rank to which the rank-k matrices in the far
   * field set will be truncated.
   * @param hmat_root_block the pointer to the root \hmatrix
   * block, which is only used for exporting matrix partition structure for
   * further visualization.
   * @param calling_counter the pointer to the counter which records the current
   * total number of calling times of this function. Its value will be used to
   * construct the name of the output file, which stores the matrix partition
   * structure.
   * @param output_file_base_name the based name of the output file which stores
   * the matrix partition structure.
   */
  template <int spacedim, typename Number = double>
  void
  convertHMatBlockToRkMatrix(
    HMatrix<spacedim, Number>       *hmat_block,
    const unsigned int               fixed_rank_k,
    const HMatrix<spacedim, Number> *hmat_root_block = nullptr,
    size_t                          *calling_counter = nullptr,
    const std::string &output_file_base_name         = std::string("hmat-bct"))
  {
    /**
     * <dl class="section">
     *   <dt>Work flow</dt>
     *   <dd>
     */
    using size_type = typename HMatrix<spacedim, Number>::size_type;

    Assert(hmat_block->type != UndefinedMatrixType,
           ExcInvalidHMatrixType(hmat_block->type));

    if (hmat_block->bc_node->is_leaf())
      {
        /**
         * When the current \hmatrix block belongs to the leaf
         * set.
         */
        if (hmat_block->bc_node->get_data_reference().get_is_near_field())
          {
            /**
             * When the current \hmatrix belongs to the near field
             * set, it should be of a full matrix type. Therefore, we make an
             * assertion here. After that we do nothing, since a near field node
             * should always be represented as a full matrix, thus the rank
             * truncation should not be applied.
             */
            Assert(hmat_block->type == FullMatrixType,
                   ExcInvalidHMatrixType(hmat_block->type));
          }
        else
          {
            /**
             * When the current \hmatrix belongs to the far field
             * set, it should be of a rank-k matrix type. Therefore, we make an
             * assertion here. After that the rank-k matrix block is truncated
             * to the specified rank.
             */
            Assert(hmat_block->type == RkMatrixType,
                   ExcInvalidHMatrixType(hmat_block->type));

            hmat_block->rkmatrix->truncate_to_rank(fixed_rank_k);
          }
      }
    else
      {
        /**
         * When the current \hmatrix block does not belong to the
         * leaf set, recursively convert each child of it to rank-k matrix if
         * possible.
         */
        for (auto submatrix : hmat_block->submatrices)
          {
            convertHMatBlockToRkMatrix(submatrix,
                                       fixed_rank_k,
                                       hmat_root_block,
                                       calling_counter,
                                       output_file_base_name);
          }

        if (hmat_block->bc_node->get_data_reference().get_is_near_field())
          {
            /**
             * When the current \hmatrix block belongs to the near
             * field set, we perform the operation of full matrix agglomeration.
             *
             * <dl class="section note">
             *   <dt>Note</dt>
             *   <dd>Normally, this case cannot happen because when an
             * \hmatrix block belongs to the near field, it is
             * represented as a full matrix and belongs to the leaf set.
             * However, this contradicts the precondition that the current
             * \hmatrix block does not belong to the leaf
             * set.
             *
             * But still this situation may happen during the conversion of an
             * \hmatrix to a different block cluster tree.</dd>
             * </dl>
             *
             * <strong>The general work flow for the agglomeration of a set of
             * full matrix blocks is as below.</strong>
             *
             * 1. Create a large full matrix on the heap and assemble all
             * submatrices into it which depends on the split mode of the block
             * cluster.
             *
             *   a. When it is \p CrossSplitMode, apply agglomeration of four full
             * submatrices.
             *
             *   b. When the split mode is \p HorizontalSplitMode, apply
             * agglomeration of two full submatrices via vertical stacking.
             *
             *   c. When the split mode is \p VerticalSplitMode, apply
             * agglomeration of two full submatrices via horizontal stacking.
             *
             * 2. Delete all submatrices associated with the current
             * \hmatrix and clear the \p std::vector storing
             * submatrix pointers.
             *
             * 3. Associate the new large full matrix with the current
             * \hmatrix.
             *
             * 4. Update the \hmatrix type as \p FullMatrix.
             *
             * <strong>About matrix assembly for \p CrossSplitMode</strong>
             *
             * Let the block cluster associated with the current
             * \hmatrix is \f$\tau \times \sigma\f$. Assume the
             * clusters are partitioned as \f$\tau = [\tau_1, \tau_2]\f$ and
             * \f$\sigma =
             * [\sigma_1, \sigma_2]\f$. Then the ordering of the child block
             * clusters are \f$\tau_1 \times \sigma_1, \tau_1 \times \sigma_2,
             * \tau_2 \times \sigma_1, \tau_2 \times \sigma_2\f$.
             */
            for (const HMatrix<spacedim, Number> *submatrix :
                 hmat_block->submatrices)
              {
                Assert(submatrix->type == FullMatrixType,
                       ExcInvalidHMatrixType(submatrix->type));
              }

            LAPACKFullMatrixExt<Number> *fullmatrix;

            switch (hmat_block->bc_node->get_split_mode())
              {
                  case CrossSplitMode: {
                    AssertDimension(hmat_block->submatrices.size(), 4);

                    fullmatrix = new LAPACKFullMatrixExt<Number>(
                      *(hmat_block->submatrices[0]->fullmatrix),
                      *(hmat_block->submatrices[1]->fullmatrix),
                      *(hmat_block->submatrices[2]->fullmatrix),
                      *(hmat_block->submatrices[3]->fullmatrix));

                    break;
                  }
                  case HorizontalSplitMode: {
                    AssertDimension(hmat_block->submatrices.size(), 2);

                    fullmatrix = new LAPACKFullMatrixExt<Number>(
                      *(hmat_block->submatrices[0]->fullmatrix),
                      *(hmat_block->submatrices[1]->fullmatrix),
                      true);

                    break;
                  }
                  case VerticalSplitMode: {
                    AssertDimension(hmat_block->submatrices.size(), 2);

                    fullmatrix = new LAPACKFullMatrixExt<Number>(
                      *(hmat_block->submatrices[0]->fullmatrix),
                      *(hmat_block->submatrices[1]->fullmatrix),
                      false);

                    break;
                  }
                  default: {
                    Assert(
                      false,
                      ExcMessage(
                        std::string("Invalid block cluster splitting mode: ") +
                        std::to_string(hmat_block->bc_node->get_split_mode())));
                  }
              }

            for (HMatrix<spacedim, Number> *submatrix : hmat_block->submatrices)
              {
                if (submatrix != nullptr)
                  {
                    delete submatrix;
                  }
              }
            hmat_block->submatrices.clear();

            hmat_block->fullmatrix = fullmatrix;
            hmat_block->type       = FullMatrixType;
          }
        else
          {
            /**
             * When the current \hmatrix block belongs to the far
             * field set, perform the pairwise matrix agglomeration of rank-k
             * submatrices or full submatrices, which has been implemented into
             * the constructor of \p RkMatrix.
             */
            RkMatrix<Number> *rkmatrix;

            switch (hmat_block->bc_node->get_split_mode())
              {
                  case CrossSplitMode: {
                    AssertDimension(hmat_block->submatrices.size(), 4);

                    if (hmat_block->submatrices[0]->type == RkMatrixType &&
                        hmat_block->submatrices[1]->type == RkMatrixType &&
                        hmat_block->submatrices[2]->type == RkMatrixType &&
                        hmat_block->submatrices[3]->type == RkMatrixType)
                      {
                        /**
                         * If the children of the current \hmatrix
                         * block are rank-k matrices, perform the pairwise
                         * rank-k matrix agglomeration directly.
                         */
                        rkmatrix = new RkMatrix<Number>(
                          fixed_rank_k,
                          *(hmat_block->submatrices[0]->rkmatrix),
                          *(hmat_block->submatrices[1]->rkmatrix),
                          *(hmat_block->submatrices[2]->rkmatrix),
                          *(hmat_block->submatrices[3]->rkmatrix));
                      }
                    else if (hmat_block->submatrices[0]->type ==
                               FullMatrixType &&
                             hmat_block->submatrices[1]->type ==
                               FullMatrixType &&
                             hmat_block->submatrices[2]->type ==
                               FullMatrixType &&
                             hmat_block->submatrices[3]->type == FullMatrixType)
                      {
                        /**
                         * If the children of the current \hmatrix
                         * block are full matrices, firstly convert all of them
                         * into rank-k matrices, then perform the pairwise
                         * rank-k matrix agglomeration.
                         */
                        RkMatrix<Number> rkmatrix11(
                          fixed_rank_k,
                          *(hmat_block->submatrices[0]->fullmatrix));
                        RkMatrix<Number> rkmatrix12(
                          fixed_rank_k,
                          *(hmat_block->submatrices[1]->fullmatrix));
                        RkMatrix<Number> rkmatrix21(
                          fixed_rank_k,
                          *(hmat_block->submatrices[2]->fullmatrix));
                        RkMatrix<Number> rkmatrix22(
                          fixed_rank_k,
                          *(hmat_block->submatrices[3]->fullmatrix));

                        rkmatrix = new RkMatrix<Number>(fixed_rank_k,
                                                        rkmatrix11,
                                                        rkmatrix12,
                                                        rkmatrix21,
                                                        rkmatrix22);
                      }
                    else
                      {
                        /**
                         * Other cases are invalid.
                         */
                        Assert(false, ExcInternalError());
                      }

                    break;
                  }
                  case HorizontalSplitMode: {
                    AssertDimension(hmat_block->submatrices.size(), 2);

                    if (hmat_block->submatrices[0]->type == RkMatrixType &&
                        hmat_block->submatrices[1]->type == RkMatrixType)
                      {
                        /**
                         * If the children of the current \hmatrix
                         * block are rank-k matrices, perform the pairwise
                         * rank-k matrix agglomeration directly.
                         */
                        rkmatrix = new RkMatrix<Number>(
                          fixed_rank_k,
                          *(hmat_block->submatrices[0]->rkmatrix),
                          *(hmat_block->submatrices[1]->rkmatrix),
                          true);
                      }
                    else if (hmat_block->submatrices[0]->type ==
                               FullMatrixType &&
                             hmat_block->submatrices[1]->type == FullMatrixType)
                      {
                        /**
                         * If the children of the current \hmatrix
                         * block are full matrices, firstly convert all of them
                         * into rank-k matrices, then perform the pairwise
                         * rank-k matrix agglomeration.
                         */
                        RkMatrix<Number> rkmatrix1(
                          fixed_rank_k,
                          *(hmat_block->submatrices[0]->fullmatrix));
                        RkMatrix<Number> rkmatrix2(
                          fixed_rank_k,
                          *(hmat_block->submatrices[1]->fullmatrix));

                        rkmatrix = new RkMatrix<Number>(fixed_rank_k,
                                                        rkmatrix1,
                                                        rkmatrix2,
                                                        true);
                      }
                    else
                      {
                        /**
                         * Other cases are invalid.
                         */
                        Assert(false, ExcInternalError());
                      }

                    break;
                  }
                  case VerticalSplitMode: {
                    AssertDimension(hmat_block->submatrices.size(), 2);

                    if (hmat_block->submatrices[0]->type == RkMatrixType &&
                        hmat_block->submatrices[1]->type == RkMatrixType)
                      {
                        /**
                         * If the children of the current \hmatrix
                         * block are rank-k matrices, perform the pairwise
                         * rank-k matrix agglomeration directly.
                         */
                        rkmatrix = new RkMatrix<Number>(
                          fixed_rank_k,
                          *(hmat_block->submatrices[0]->rkmatrix),
                          *(hmat_block->submatrices[1]->rkmatrix),
                          false);
                      }
                    else if (hmat_block->submatrices[0]->type ==
                               FullMatrixType &&
                             hmat_block->submatrices[1]->type == FullMatrixType)
                      {
                        /**
                         * If the children of the current \hmatrix
                         * block are full matrices, firstly convert all of them
                         * into rank-k matrices, then perform the pairwise
                         * rank-k matrix agglomeration.
                         */
                        RkMatrix<Number> rkmatrix1(
                          fixed_rank_k,
                          *(hmat_block->submatrices[0]->fullmatrix));
                        RkMatrix<Number> rkmatrix2(
                          fixed_rank_k,
                          *(hmat_block->submatrices[1]->fullmatrix));

                        rkmatrix = new RkMatrix<Number>(fixed_rank_k,
                                                        rkmatrix1,
                                                        rkmatrix2,
                                                        false);
                      }
                    else
                      {
                        /**
                         * Other cases are invalid.
                         */
                        Assert(false, ExcInternalError());
                      }

                    break;
                  }
                  default: {
                    Assert(
                      false,
                      ExcMessage(
                        std::string("Invalid block cluster splitting mode: ") +
                        std::to_string(hmat_block->bc_node->get_split_mode())));
                  }
              }

            for (HMatrix<spacedim, Number> *submatrix : hmat_block->submatrices)
              {
                if (submatrix != nullptr)
                  {
                    delete submatrix;
                  }
              }
            hmat_block->submatrices.clear();

            hmat_block->rkmatrix = rkmatrix;
            hmat_block->type     = RkMatrixType;
          }

        /**
         * Visualize the partition structure if a not-null pointer to the root
         * \hmatnode and a a not-null pointer to a \p
         * calling_counter are provided.
         */
        if (hmat_root_block != nullptr && calling_counter != nullptr)
          {
            std::ofstream output_stream(output_file_base_name +
                                        std::to_string(*calling_counter) +
                                        ".dat");
            hmat_root_block->write_leaf_set(output_stream);
            output_stream.close();

            (*calling_counter) = (*calling_counter) + 1;
          }
      }
    /**
     *   </dd>
     * </dl>
     */
  }


  /**
   * Calculate the product of two \hmatnodes, where the second
   * one \p M2 has \p RkMatrixType and the result will also be a rank-k matrix.
   *
   * The arithmetic operation to be performed is
   * \f[
   * M = M_1 \cdot M_2 = M_1 (A B^T) = (M_1 A) B^T = A' B^T,
   * \f]
   * where \f$A' = M_1 A\f$ is calculated as a series of
   * \hmatrix-vector multiplications. For details,
   * \f[
   * M_1 A = M_1
   * \begin{bmatrix}
   * a_{\sigma,1} & \cdots & a_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * M_1 a_{\sigma,1} & \cdots & M_1 a_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * a'_{\tau,1} & \cdots & a'_{\tau,r}
   * \end{bmatrix}.
   * \f]
   * It can be seen that the formal rank \f$r\f$ of the result matrix \p M is the
   * same as that of \p M2.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_rk_mmult(HMatrix<spacedim, Number> &M1,
             const RkMatrix<Number>    &M2,
             RkMatrix<Number>          &M)
  {
    AssertDimension(M1.n, M2.m);

    if (M2.rank > 0 && M2.formal_rank > 0)
      {
        /**
         * Create a temporary \p Vector storing a column \f$a_{\sigma,j}\f$ in the \p
         * A component of \p M2 and another \p Vector \f$a'_{\tau,j}\f$ storing the
         * matrix-vector product \f$M_1 \cdot a_{\sigma,j}\f$.
         */
        Vector<Number> col_vect_in_A(M2.A.m());
        Vector<Number> result_vect(M1.m);

        /**
         * Initialize the result rank-k matrix \p M with the formal rank of \p M2.
         * Its \p B component matrix is the same as that of \p M2.
         */
        M.reinit(M1.m, M2.n, M2.formal_rank);
        M.B = M2.B;

        /**
         * Then we calculate the \p A component matrix of \p M, which is \p
         * M1*M2.A.
         */
        for (size_t j = 0; j < M2.formal_rank; j++)
          {
            M2.A.get_column(j, col_vect_in_A);
            result_vect = 0.;
            M1.vmult(result_vect, col_vect_in_A, M1, M1.get_property());

            /**
             * Fill the result vector into the \p A component matrix of \p M.
             */
            M.A.fill_col(j, result_vect);
          }
      }
    else
      {
        M.reinit(M1.m, M2.n, 0);
      }
  }


  /**
   * Calculate the product of two \hmatnodes and the result is scaled by a
   * factor, where the second one \p M2 has \p RkMatrixType and the result will
   * also be a rank-k matrix.
   *
   * The arithmetic operation to be performed is
   * \f[
   * M = \alpha \cdot M_1 \cdot M_2 = \alpha \cdot M_1 (A B^T) = \alpha \cdot
   * (M_1 A) B^T = \alpha \cdot A' B^T, \f] where \f$A' = M_1 A\f$ is calculated
   * as a series of \hmatrix-vector multiplications. For details, \f[ M_1 A =
   * M_1 \begin{bmatrix} a_{\sigma,1} & \cdots & a_{\sigma,r} \end{bmatrix} =
   * \begin{bmatrix}
   * M_1 a_{\sigma,1} & \cdots & M_1 a_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * a'_{\tau,1} & \cdots & a'_{\tau,r}
   * \end{bmatrix}.
   * \f]
   * It can be seen that the formal rank \f$r\f$ of the result matrix \p M is the
   * same as that of \p M2.
   *
   * @param alpha
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_rk_mmult(const Number               alpha,
             HMatrix<spacedim, Number> &M1,
             const RkMatrix<Number>    &M2,
             RkMatrix<Number>          &M)
  {
    AssertDimension(M1.n, M2.m);

    if (M2.rank > 0 && M2.formal_rank > 0)
      {
        /**
         * Create a temporary \p Vector storing a column \f$a_{\sigma,j}\f$ in the \p
         * A component of \p M2 and another \p Vector \f$a'_{\tau,j}\f$ storing the
         * matrix-vector product \f$M_1 \cdot a_{\sigma,j}\f$.
         */
        Vector<Number> col_vect_in_A(M2.A.m());
        Vector<Number> result_vect(M1.m);

        /**
         * Initialize the result rank-k matrix \p M with the formal rank of \p M2.
         * Its \p B component matrix is the same as that of \p M2.
         */
        M.reinit(M1.m, M2.n, M2.formal_rank);
        M.B = M2.B;

        /**
         * Then we calculate the \p A component matrix of \p M, which is \p
         * M1*M2.A.
         */
        for (size_t j = 0; j < M2.formal_rank; j++)
          {
            M2.A.get_column(j, col_vect_in_A);
            /**
             * \alert{Since the following \p vmult will compute \f$y = y + M x\f$,
             * \p result_vect should be reset to zero beforehand.}
             */
            result_vect = 0.;
            M1.vmult(result_vect, alpha, col_vect_in_A, M1, M1.get_property());

            /**
             * Fill the result vector into the \p A component matrix of \p M.
             */
            M.A.fill_col(j, result_vect);
          }
      }
    else
      {
        M.reinit(M1.m, M2.n, 0);
      }
  }


  /**
   * Calculate the product of two \hmatnodes with the second operand being
   * transposed, where the second
   * operand \p M2 has \p RkMatrixType and the result will also be a rank-k matrix.
   *
   * The arithmetic operation to be performed is
   * \f[
   * M = M_1 \cdot M_2^T = M_1 (A B^T)^T = (M_1 B) A^T = A' B'^T,
   * \f]
   * where \f$A' = M_1 B\f$ is calculated as a series of
   * \hmatrix-vector multiplications, and \f$B' = A\f$. For details,
   * \f[
   * M_1 B = M_1
   * \begin{bmatrix}
   * b_{\sigma,1} & \cdots & b_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * M_1 b_{\sigma,1} & \cdots & M_1 b_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * b'_{\tau,1} & \cdots & b'_{\tau,r}
   * \end{bmatrix}.
   * \f]
   * It can be seen that the formal rank \f$r\f$ of the result matrix \p M is the
   * same as that of \p M2.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_rk_mTmult(HMatrix<spacedim, Number> &M1,
              const RkMatrix<Number>    &M2,
              RkMatrix<Number>          &M)
  {
    AssertDimension(M1.n, M2.n);

    if (M2.rank > 0 && M2.formal_rank > 0)
      {
        /**
         * Create a temporary \p Vector storing a column \f$b_{\sigma,j}\f$ in the \p
         * B component of \p M2 and another \p Vector \f$b'_{\tau,j}\f$ storing the
         * matrix-vector product \f$M_1 \cdot b_{\sigma,j}\f$.
         */
        Vector<Number> col_vect_in_B(M2.B.m());
        Vector<Number> result_vect(M1.m);

        /**
         * Initialize the result rank-k matrix \p M with the formal rank of \p M2.
         * Its \p B component matrix is the same as that of \p M2.
         */
        M.reinit(M1.m, M2.m, M2.formal_rank);
        M.B = M2.A;

        /**
         * Then we calculate the \p A component matrix of \p M, which is \p
         * M1*M2.B.
         */
        for (size_t j = 0; j < M2.formal_rank; j++)
          {
            M2.B.get_column(j, col_vect_in_B);
            result_vect = 0.;
            M1.vmult(result_vect, col_vect_in_B, M1, M1.get_property());

            /**
             * Fill the result vector into the \p A component matrix of \p M.
             */
            M.A.fill_col(j, result_vect);
          }
      }
    else
      {
        M.reinit(M1.m, M2.m, 0);
      }
  }


  /**
   * Calculate the product of two \hmatnodes with the second operand being
   * transposed, where the second
   * operand \p M2 has \p RkMatrixType and the result will also be a rank-k
   * matrix. The result will be scaled by a factor.
   *
   * The arithmetic operation to be performed is
   * \f[
   * M = \alpha \cdot M_1 \cdot M_2^T = \alpha \cdot M_1 (A B^T)^T = \alpha
   * \cdot (M_1 B) A^T = \alpha \cdot A' B'^T, \f] where \f$A' = M_1 B\f$ is
   * calculated as a series of \hmatrix-vector multiplications, and \f$B' =
   * A\f$. For details, \f[ M_1 B = M_1 \begin{bmatrix} b_{\sigma,1} & \cdots &
   * b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} M_1 b_{\sigma,1} & \cdots &
   * M_1 b_{\sigma,r} \end{bmatrix} = \begin{bmatrix} b'_{\tau,1} & \cdots &
   * b'_{\tau,r} \end{bmatrix}. \f]
   * It can be seen that the formal rank \f$r\f$ of the result matrix \p M is the
   * same as that of \p M2.
   *
   * @param alpha
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_rk_mTmult(const Number               alpha,
              HMatrix<spacedim, Number> &M1,
              const RkMatrix<Number>    &M2,
              RkMatrix<Number>          &M)
  {
    AssertDimension(M1.n, M2.n);

    if (M2.rank > 0 && M2.formal_rank > 0)
      {
        /**
         * Create a temporary \p Vector storing a column \f$b_{\sigma,j}\f$ in the \p
         * B component of \p M2 and another \p Vector \f$b'_{\tau,j}\f$ storing the
         * matrix-vector product \f$M_1 \cdot b_{\sigma,j}\f$.
         */
        Vector<Number> col_vect_in_B(M2.B.m());
        Vector<Number> result_vect(M1.m);

        /**
         * Initialize the result rank-k matrix \p M with the formal rank of \p M2.
         * Its \p B component matrix is the same as that of \p M2.
         */
        M.reinit(M1.m, M2.m, M2.formal_rank);
        M.B = M2.A;

        /**
         * Then we calculate the \p A component matrix of \p M, which is \p
         * M1*M2.B.
         */
        for (size_t j = 0; j < M2.formal_rank; j++)
          {
            M2.B.get_column(j, col_vect_in_B);
            result_vect = 0.;
            M1.vmult(result_vect, alpha, col_vect_in_B, M1, M1.get_property());

            /**
             * Fill the result vector into the \p A component matrix of \p M.
             */
            M.A.fill_col(j, result_vect);
          }
      }
    else
      {
        M.reinit(M1.m, M2.m, 0);
      }
  }


  /**
   * Calculate the product of two \hmatnodes with the first operand being
   * transposed, where the second one \p M2 has \p RkMatrixType and the result
   * will also be a rank-k matrix.
   *
   * The arithmetic operation to be performed is
   * \f[
   * M = M_1^T \cdot M_2 = M_1^T (A B^T) = (M_1^T A) B^T = A' B^T,
   * \f]
   * where \f$A' = M_1^T A\f$ is calculated as a series of
   * transposed-\hmatrix-vector multiplications. For details,
   * \f[
   * M_1^T A = M_1^T
   * \begin{bmatrix}
   * a_{\sigma,1} & \cdots & a_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * M_1^T a_{\sigma,1} & \cdots & M_1^T a_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * a'_{\tau,1} & \cdots & a'_{\tau,r}
   * \end{bmatrix}.
   * \f]
   * It can be seen that the formal rank \f$r\f$ of the result matrix \p M is the
   * same as that of \p M2.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_rk_Tmmult(HMatrix<spacedim, Number> &M1,
              const RkMatrix<Number>    &M2,
              RkMatrix<Number>          &M)
  {
    AssertDimension(M1.m, M2.m);

    if (M2.rank > 0 && M2.formal_rank > 0)
      {
        /**
         * Create a temporary \p Vector storing a column \f$a_{\sigma,j}\f$ in the \p
         * A component of \p M2 and another \p Vector \f$a'_{\tau,j}\f$ storing the
         * transposed-matrix-vector product \f$M_1^T \cdot a_{\sigma,j}\f$.
         */
        Vector<Number> col_vect_in_A(M2.A.m());
        Vector<Number> result_vect(M1.n);

        /**
         * Initialize the result rank-k matrix \p M with the formal rank of \p M2.
         * Its \p B component matrix is the same as that of \p M2.
         */
        M.reinit(M1.n, M2.n, M2.formal_rank);
        M.B = M2.B;

        /**
         * Then we calculate the \p A component matrix of \p M, which is \p
         * M1^T*M2.A.
         */
        for (size_t j = 0; j < M2.formal_rank; j++)
          {
            M2.A.get_column(j, col_vect_in_A);
            result_vect = 0.;
            M1.Tvmult(result_vect, col_vect_in_A, M1, M1.get_property());

            /**
             * Fill the result vector into the \p A component matrix of \p M.
             */
            M.A.fill_col(j, result_vect);
          }
      }
    else
      {
        M.reinit(M1.n, M2.n, 0);
      }
  }


  /**
   * Calculate the scaled product of two \hmatnodes with the first operand being
   * transposed, where the second one \p M2 has \p RkMatrixType and the result
   * will also be a rank-k matrix.
   *
   * The arithmetic operation to be performed is
   *
   * \f[
   * M = \alpha M_1^T \cdot M_2 = \alpha M_1^T (A B^T) = \alpha (M_1^T A) B^T =
   * \alpha A' B^T, \f]
   *
   * where \f$A' = M_1^T A\f$ is calculated as a series of
   * transposed-\hmatrix-vector multiplications. For details,
   * \f[
   * M_1^T A = M_1^T
   * \begin{bmatrix}
   * a_{\sigma,1} & \cdots & a_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * M_1^T a_{\sigma,1} & \cdots & M_1^T a_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * a'_{\tau,1} & \cdots & a'_{\tau,r}
   * \end{bmatrix}.
   * \f]
   * It can be seen that the formal rank \f$r\f$ of the result matrix \p M is the
   * same as that of \p M2.
   *
   * @param alpha
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_rk_Tmmult(const Number               alpha,
              HMatrix<spacedim, Number> &M1,
              const RkMatrix<Number>    &M2,
              RkMatrix<Number>          &M)
  {
    AssertDimension(M1.m, M2.m);

    if (M2.rank > 0 && M2.formal_rank > 0)
      {
        /**
         * Create a temporary \p Vector storing a column \f$a_{\sigma,j}\f$ in the \p
         * A component of \p M2 and another \p Vector \f$a'_{\tau,j}\f$ storing the
         * transposed-matrix-vector product \f$M_1^T \cdot a_{\sigma,j}\f$.
         */
        Vector<Number> col_vect_in_A(M2.A.m());
        Vector<Number> result_vect(M1.n);

        /**
         * Initialize the result rank-k matrix \p M with the formal rank of \p M2.
         * Its \p B component matrix is the same as that of \p M2.
         */
        M.reinit(M1.n, M2.n, M2.formal_rank);
        M.B = M2.B;

        /**
         * Then we calculate the \p A component matrix of \p M, which is \p
         * M1^T*M2.A.
         */
        for (size_t j = 0; j < M2.formal_rank; j++)
          {
            M2.A.get_column(j, col_vect_in_A);
            result_vect = 0.;
            M1.Tvmult(result_vect, alpha, col_vect_in_A, M1, M1.get_property());

            /**
             * Fill the result vector into the \p A component matrix of \p M.
             */
            M.A.fill_col(j, result_vect);
          }
      }
    else
      {
        M.reinit(M1.n, M2.n, 0);
      }
  }


  /**
   * Calculate the product of two \hmatnodes, where the second
   * one \p M2 has \p RkMatrixType and the result will also be a rank-k matrix.
   * This function is to be called by the matrix-matrix multiplication function.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_rk_mmult_for_h_h_mmult(HMatrix<spacedim, Number>       *M1,
                           const HMatrix<spacedim, Number> *M2,
                           HMatrix<spacedim, Number>       *M,
                           bool is_M1M2_last_in_M_Sigma_P = true)
  {
    Assert(M2->type == RkMatrixType, ExcInvalidHMatrixType(M2->type));
    Assert(M2->rkmatrix, ExcInternalError());
    //  Assert(*(M1->col_index_range) == *(M2->row_index_range),
    //         ExcMessage("Incompatible index sets during matrix
    //         multiplication"));
    AssertDimension(M1->n, M2->m);

    // DEBUG
    //  print_h_h_submatrix_mmult_accessor(std::cout, "M1", *M1, "M2", *M2);

    if (is_M1M2_last_in_M_Sigma_P)
      {
        M->Sigma_P.pop_back();
      }
    else
      {
        M->remove_hmat_pair_from_mm_product_list(M1, M2);
      }

    RkMatrix<Number> *M_rk = new RkMatrix<Number>();
    h_rk_mmult(*M1, *(M2->rkmatrix), *M_rk);
    M->Sigma_R.push_back(M_rk);

    //  // DEBUG
    //  LAPACKFullMatrixExt<Number> M_rk_to_full;
    //  M_rk->convertToFullMatrix(M_rk_to_full);
    //  M_rk_to_full.print_formatted(std::cout, 8, false, 16, "0");

    AssertDimension(M->Sigma_F.size(), 0);
    M->type = RkMatrixType;
  }


  /**
   * Calculate the product of two \hmatnodes, where the first
   * one \p M1 has \p RkMatrixType and the result is also a rank-k matrix.
   *
   * The arithmetic operation to be performed is
   * \f[
   * M = M_1 \cdot M_2 = (A B^T) M_2 = A (B^T M_2) = A B'^T,
   * \f]
   * where \f$B' = M_2^T B\f$ is calculated as a series of
   * transposed \hmatrix-vector multiplications. For details,
   * \f[
   * M_2^T B = M_2^T
   * \begin{bmatrix}
   * b_{\sigma,1} & \cdots & b_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * M_2^T b_{\sigma,1} & \cdots & M_2^T b_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * b'_{\rho,1} & \cdots & b'_{\rho,r}
   * \end{bmatrix}.
   * \f]
   * It can be seen that the formal rank \f$r\f$ of the result matrix \p M is the
   * same as that of \p M1.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  rk_h_mmult(const RkMatrix<Number>    &M1,
             HMatrix<spacedim, Number> &M2,
             RkMatrix<Number>          &M)
  {
    AssertDimension(M1.n, M2.m);

    if (M1.rank > 0 && M1.formal_rank > 0)
      {
        /**
         * Create a temporary \p Vector storing a column \f$b_{\sigma,j}\f$ in the \p
         * B component of \p M1 and another \p Vector \f$b'_{\rho,j}\f$ storing the
         * matrix-vector product \f$M_2^T \cdot b_{\sigma,j}\f$.
         */
        Vector<Number> col_vect_in_B(M1.B.m());
        Vector<Number> result_vect(M2.n);

        /**
         * Initialize the result rank-k matrix \p M with the formal rank of \p M1_rk.
         * Its \p A component matrix is the same as that of \p M1_rk.
         */
        M.reinit(M1.m, M2.n, M1.formal_rank);
        M.A = M1.A;

        /**
         * Then we calculate the \p B component matrix of \p M, which is \p
         * M2^T*M1_rk.B.
         */
        for (size_t j = 0; j < M.formal_rank; j++)
          {
            M1.B.get_column(j, col_vect_in_B);
            result_vect = 0.;
            M2.Tvmult(result_vect, col_vect_in_B, M2, M2.get_property());

            /**
             * Fill the result vector into the \p B component matrix of \p M.
             */
            M.B.fill_col(j, result_vect);
          }
      }
    else
      {
        M.reinit(M1.m, M2.n, 0);
      }
  }


  /**
   * Calculate the product of two \hmatnodes and the result is scaled by a
   * factor, where the first one \p M1 has \p RkMatrixType and the result is also
   * a rank-k matrix.
   *
   * The arithmetic operation to be performed is
   * \f[
   * M = \alpha \cdot M_1 \cdot M_2 = \alpha \cdot  (A B^T) M_2 = \alpha \cdot A
   * (B^T M_2) = \alpha \cdot  A B'^T, \f]
   * where \f$B' = M_2^T B\f$ is calculated as a series of
   * transposed \hmatrix-vector multiplications. For details,
   * \f[
   * M_2^T B = M_2^T
   * \begin{bmatrix}
   * b_{\sigma,1} & \cdots & b_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * M_2^T b_{\sigma,1} & \cdots & M_2^T b_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * b'_{\rho,1} & \cdots & b'_{\rho,r}
   * \end{bmatrix}.
   * \f]
   * It can be seen that the formal rank \f$r\f$ of the result matrix \p M is the
   * same as that of \p M1.
   *
   * @param alpha
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  rk_h_mmult(const Number               alpha,
             const RkMatrix<Number>    &M1,
             HMatrix<spacedim, Number> &M2,
             RkMatrix<Number>          &M)
  {
    AssertDimension(M1.n, M2.m);

    if (M1.rank > 0 && M1.formal_rank > 0)
      {
        /**
         * Create a temporary \p Vector storing a column \f$b_{\sigma,j}\f$ in the \p
         * B component of \p M1 and another \p Vector \f$b'_{\rho,j}\f$ storing the
         * matrix-vector product \f$M_2^T \cdot b_{\sigma,j}\f$.
         */
        Vector<Number> col_vect_in_B(M1.B.m());
        Vector<Number> result_vect(M2.n);

        /**
         * Initialize the result rank-k matrix \p M with the formal rank of \p M1_rk.
         * Its \p A component matrix is the same as that of \p M1_rk.
         */
        M.reinit(M1.m, M2.n, M1.formal_rank);
        M.A = M1.A;

        /**
         * Then we calculate the \p B component matrix of \p M, which is \p
         * M2^T*M1_rk.B.
         */
        for (size_t j = 0; j < M.formal_rank; j++)
          {
            M1.B.get_column(j, col_vect_in_B);
            /**
             * \alert{Since the following \p Tvmult will compute \f$y = y + M^T x\f$,
             * \p result_vect should be reset to zero beforehand.}
             */
            result_vect = 0.;
            M2.Tvmult(result_vect, alpha, col_vect_in_B, M2, M2.get_property());

            /**
             * Fill the result vector into the \p B component matrix of \p M.
             */
            M.B.fill_col(j, result_vect);
          }
      }
    else
      {
        M.reinit(M1.m, M2.n, 0);
      }
  }


  /**
   * Calculate the product of two \hmatnodes with the second operand being
   * transposed, where the first operand \p M1 has \p RkMatrixType and the result
   * is also a rank-k matrix.
   *
   * The arithmetic operation to be performed is
   * \f[
   * M = M_1 \cdot M_2^T = (A B^T) M_2^T = A (B^T M_2^T) = A B'^T,
   * \f]
   * where \f$B' = M_2 B\f$ is calculated as a series of \hmatrix-vector
   * multiplications. For details,
   * \f[ M_2 B = M_2 \begin{bmatrix}
   * b_{\sigma,1} & \cdots & b_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * M_2 b_{\sigma,1} & \cdots & M_2 b_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * b'_{\rho,1} & \cdots & b'_{\rho,r}
   * \end{bmatrix}.
   * \f]
   * It can be seen that the formal rank \f$r\f$ of the result matrix \p M is the
   * same as that of \p M1.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  rk_h_mTmult(const RkMatrix<Number>    &M1,
              HMatrix<spacedim, Number> &M2,
              RkMatrix<Number>          &M)
  {
    AssertDimension(M1.n, M2.n);

    if (M1.rank > 0 && M1.formal_rank > 0)
      {
        /**
         * Create a temporary \p Vector storing a column \f$b_{\sigma,j}\f$ in the \p
         * B component of \p M1 and another \p Vector \f$b'_{\rho,j}\f$ storing the
         * matrix-vector product \f$M_2 \cdot b_{\sigma,j}\f$.
         */
        Vector<Number> col_vect_in_B(M1.B.m());
        Vector<Number> result_vect(M2.m);

        /**
         * Initialize the result rank-k matrix \p M with the formal rank of \p M1_rk.
         * Its \p A component matrix is the same as that of \p M1_rk.
         */
        M.reinit(M1.m, M2.m, M1.formal_rank);
        M.A = M1.A;

        /**
         * Then we calculate the \p B component matrix of \p M, which is \p
         * M2*M1_rk.B.
         */
        for (size_t j = 0; j < M.formal_rank; j++)
          {
            M1.B.get_column(j, col_vect_in_B);
            result_vect = 0.;
            M2.vmult(result_vect, col_vect_in_B, M2, M2.get_property());

            /**
             * Fill the result vector into the \p B component matrix of \p M.
             */
            M.B.fill_col(j, result_vect);
          }
      }
    else
      {
        M.reinit(M1.m, M2.m, 0);
      }
  }


  /**
   * Calculate the product of two \hmatnodes with the second operand being
   * transposed, where the first operand \p M1 has \p RkMatrixType and the result
   * is also a rank-k matrix. The result will be scaled by a factor.
   *
   * The arithmetic operation to be performed is
   * \f[
   * M = \alpha \cdot M_1 \cdot M_2^T = \alpha \cdot (A B^T) M_2^T = \alpha
   * \cdot A (B^T M_2^T) = \alpha \cdot A B'^T, \f] where \f$B' = M_2 B\f$ is
   * calculated as a series of \hmatrix-vector multiplications. For details, \f[
   * M_2 B = M_2 \begin{bmatrix} b_{\sigma,1} & \cdots & b_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * M_2 b_{\sigma,1} & \cdots & M_2 b_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * b'_{\rho,1} & \cdots & b'_{\rho,r}
   * \end{bmatrix}.
   * \f]
   * It can be seen that the formal rank \f$r\f$ of the result matrix \p M is the
   * same as that of \p M1.
   *
   * @param alpha
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  rk_h_mTmult(const Number               alpha,
              const RkMatrix<Number>    &M1,
              HMatrix<spacedim, Number> &M2,
              RkMatrix<Number>          &M)
  {
    AssertDimension(M1.n, M2.n);

    if (M1.rank > 0 && M1.formal_rank > 0)
      {
        /**
         * Create a temporary \p Vector storing a column \f$b_{\sigma,j}\f$ in the \p
         * B component of \p M1 and another \p Vector \f$b'_{\rho,j}\f$ storing the
         * matrix-vector product \f$M_2 \cdot b_{\sigma,j}\f$.
         */
        Vector<Number> col_vect_in_B(M1.B.m());
        Vector<Number> result_vect(M2.m);

        /**
         * Initialize the result rank-k matrix \p M with the formal rank of \p M1_rk.
         * Its \p A component matrix is the same as that of \p M1_rk.
         */
        M.reinit(M1.m, M2.m, M1.formal_rank);
        M.A = M1.A;

        /**
         * Then we calculate the \p B component matrix of \p M, which is \p
         * M2*M1_rk.B.
         */
        for (size_t j = 0; j < M.formal_rank; j++)
          {
            M1.B.get_column(j, col_vect_in_B);
            result_vect = 0.;
            M2.vmult(result_vect, alpha, col_vect_in_B, M2, M2.get_property());

            /**
             * Fill the result vector into the \p B component matrix of \p M.
             */
            M.B.fill_col(j, result_vect);
          }
      }
    else
      {
        M.reinit(M1.m, M2.m, 0);
      }
  }


  /**
   * Calculate the product of two \hmatnodes with the first operand being
   * transposed, where the first one \p M1 has \p RkMatrixType and the result is
   * also a rank-k matrix.
   *
   * The arithmetic operation to be performed is
   * \f[
   * M = M_1^T \cdot M_2 = (A B^T)^T M_2 = B (A^T M_2) = B A'^T,
   * \f]
   * where \f$A' = M_2^T A\f$ is calculated as a series of
   * transposed \hmatrix-vector multiplications. For details,
   * \f[
   * M_2^T A = M_2^T
   * \begin{bmatrix}
   * a_{\sigma,1} & \cdots & a_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * M_2^T a_{\sigma,1} & \cdots & M_2^T a_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * a'_{\rho,1} & \cdots & a'_{\rho,r}
   * \end{bmatrix}.
   * \f]
   * It can be seen that the formal rank \f$r\f$ of the result matrix \p M is the
   * same as that of \p M1.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  rk_h_Tmmult(const RkMatrix<Number>    &M1,
              HMatrix<spacedim, Number> &M2,
              RkMatrix<Number>          &M)
  {
    AssertDimension(M1.m, M2.m);

    if (M1.rank > 0 && M1.formal_rank > 0)
      {
        /**
         * Create a temporary \p Vector storing a column \f$a_{\sigma,j}\f$ in the \p
         * A component of \p M1 and another \p Vector \f$a'_{\rho,j}\f$ storing the
         * transposed matrix-vector product \f$M_2^T \cdot a_{\sigma,j}\f$.
         */
        Vector<Number> col_vect_in_A(M1.A.m());
        Vector<Number> result_vect(M2.n);

        /**
         * Initialize the result rank-k matrix \p M with the formal rank of \p M1_rk.
         * Its \p A component matrix is the same as the @p B component of \p M1_rk.
         */
        M.reinit(M1.n, M2.n, M1.formal_rank);
        M.A = M1.B;

        /**
         * Then we calculate the \p B component matrix of \p M, which is \p
         * M2^T*M1_rk.A.
         */
        for (size_t j = 0; j < M.formal_rank; j++)
          {
            M1.A.get_column(j, col_vect_in_A);
            result_vect = 0.;
            M2.Tvmult(result_vect, col_vect_in_A, M2, M2.get_property());

            /**
             * Fill the result vector into the \p B component matrix of \p M.
             */
            M.B.fill_col(j, result_vect);
          }
      }
    else
      {
        M.reinit(M1.n, M2.n, 0);
      }
  }


  /**
   * Calculate the scaled product of two \hmatnodes with the first operand being
   * transposed, where the first one \p M1 has \p RkMatrixType and the result is
   * also a rank-k matrix.
   *
   * The arithmetic operation to be performed is
   *
   * \f[
   * M = \alpha M_1^T \cdot M_2 = \alpha (A B^T)^T M_2 = \alpha B (A^T M_2) =
   * \alpha B A'^T, \f]
   *
   * where \f$A' = M_2^T A\f$ is calculated as a series of
   * transposed \hmatrix-vector multiplications. For details,
   * \f[
   * M_2^T A = M_2^T
   * \begin{bmatrix}
   * a_{\sigma,1} & \cdots & a_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * M_2^T a_{\sigma,1} & \cdots & M_2^T a_{\sigma,r}
   * \end{bmatrix} =
   * \begin{bmatrix}
   * a'_{\rho,1} & \cdots & a'_{\rho,r}
   * \end{bmatrix}.
   * \f]
   * It can be seen that the formal rank \f$r\f$ of the result matrix \p M is the
   * same as that of \p M1.
   *
   * @param alpha
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  rk_h_Tmmult(const Number               alpha,
              const RkMatrix<Number>    &M1,
              HMatrix<spacedim, Number> &M2,
              RkMatrix<Number>          &M)
  {
    AssertDimension(M1.m, M2.m);

    if (M1.rank > 0 && M1.formal_rank > 0)
      {
        /**
         * Create a temporary \p Vector storing a column \f$a_{\sigma,j}\f$ in the \p
         * A component of \p M1 and another \p Vector \f$a'_{\rho,j}\f$ storing the
         * transposed matrix-vector product \f$M_2^T \cdot a_{\sigma,j}\f$.
         */
        Vector<Number> col_vect_in_A(M1.A.m());
        Vector<Number> result_vect(M2.n);

        /**
         * Initialize the result rank-k matrix \p M with the formal rank of \p M1_rk.
         * Its \p A component matrix is the same as the @p B component of \p M1_rk.
         */
        M.reinit(M1.n, M2.n, M1.formal_rank);
        M.A = M1.B;

        /**
         * Then we calculate the \p B component matrix of \p M, which is \p
         * M2^T*M1_rk.A.
         */
        for (size_t j = 0; j < M.formal_rank; j++)
          {
            M1.A.get_column(j, col_vect_in_A);
            result_vect = 0.;
            M2.Tvmult(result_vect, alpha, col_vect_in_A, M2, M2.get_property());

            /**
             * Fill the result vector into the \p B component matrix of \p M.
             */
            M.B.fill_col(j, result_vect);
          }
      }
    else
      {
        M.reinit(M1.n, M2.n, 0);
      }
  }


  /**
   * Calculate the product of two \hmatnodes, where the first
   * one \p M1 has \p RkMatrixType and the result will also be a rank-k matrix.
   * This function is to be called by the matrix-matrix multiplication function.
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  rk_h_mmult_for_h_h_mmult(const HMatrix<spacedim, Number> *M1,
                           HMatrix<spacedim, Number>       *M2,
                           HMatrix<spacedim, Number>       *M,
                           bool is_M1M2_last_in_M_Sigma_P = true)
  {
    Assert(M1->type == RkMatrixType, ExcInvalidHMatrixType(M1->type));
    Assert(M1->rkmatrix, ExcInternalError());
    //  Assert(*(M1->col_index_range) == *(M2->row_index_range),
    //         ExcMessage("Incompatible index sets during matrix
    //         multiplication"));
    AssertDimension(M1->n, M2->m);

    //  // DEBUG
    //  print_h_h_submatrix_mmult_accessor(std::cout, "M1", *M1, "M2", *M2);

    if (is_M1M2_last_in_M_Sigma_P)
      {
        M->Sigma_P.pop_back();
      }
    else
      {
        M->remove_hmat_pair_from_mm_product_list(M1, M2);
      }

    RkMatrix<Number> *M_rk = new RkMatrix<Number>();
    rk_h_mmult(*(M1->rkmatrix), *M2, *M_rk);
    M->Sigma_R.push_back(M_rk);

    //  // DEBUG
    //  LAPACKFullMatrixExt<Number> M_rk_to_full;
    //  M_rk->convertToFullMatrix(M_rk_to_full);
    //  M_rk_to_full.print_formatted(std::cout, 8, false, 16, "0");

    AssertDimension(M->Sigma_F.size(), 0);
    M->type = RkMatrixType;
  }


  /**
   * Calculate the product of two \hmatnodes, where the second
   * one is a full matrix and the result is also represented as a full matrix
   * because the associated block cluster node \f$\tau\times\rho\f$ is small.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_f_mmult(HMatrix<spacedim, Number>         &M1,
            const LAPACKFullMatrixExt<Number> &M2,
            LAPACKFullMatrixExt<Number>       &M)
  {
    AssertDimension(M1.n, M2.m());

    Vector<Number> col_vect_in_M2(M2.m());
    Vector<Number> result_vect(M1.m);

    const typename LAPACKFullMatrixExt<Number>::size_type n_rows = M1.m;
    const typename LAPACKFullMatrixExt<Number>::size_type n_cols = M2.n();

    M.reinit(n_rows, n_cols);
    for (typename LAPACKFullMatrixExt<Number>::size_type j = 0; j < n_cols; j++)
      {
        M2.get_column(j, col_vect_in_M2);
        result_vect = 0.;
        M1.vmult(result_vect, col_vect_in_M2, M1, M1.get_property());
        M.fill_col(j, result_vect);
      }
  }


  /**
   * Calculate the product of two \hmatnodes with the result scaled by a
   * factor. The second operand is a full matrix and the result is also
   * represented as a full matrix because the associated block cluster node
   * \f$\tau\times\rho\f$ is small.
   *
   * @param alpha
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_f_mmult(const Number                       alpha,
            HMatrix<spacedim, Number>         &M1,
            const LAPACKFullMatrixExt<Number> &M2,
            LAPACKFullMatrixExt<Number>       &M)
  {
    AssertDimension(M1.n, M2.m());

    Vector<Number> col_vect_in_M2(M2.m());
    Vector<Number> result_vect(M1.m);

    const typename LAPACKFullMatrixExt<Number>::size_type n_rows = M1.m;
    const typename LAPACKFullMatrixExt<Number>::size_type n_cols = M2.n();

    M.reinit(n_rows, n_cols);
    for (typename LAPACKFullMatrixExt<Number>::size_type j = 0; j < n_cols; j++)
      {
        M2.get_column(j, col_vect_in_M2);
        result_vect = 0.;
        M1.vmult(result_vect, alpha, col_vect_in_M2, M1, M1.get_property());
        M.fill_col(j, result_vect);
      }
  }


  /**
   * Calculate the product of two \hmatnodes with the second operand being
   * transposed, where the second one is a full matrix and the result is also
   * represented as a full matrix because the associated block cluster node
   * \f$\tau\times\rho\f$ is small.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_f_mTmult(HMatrix<spacedim, Number>         &M1,
             const LAPACKFullMatrixExt<Number> &M2,
             LAPACKFullMatrixExt<Number>       &M)
  {
    AssertDimension(M1.n, M2.n());

    Vector<Number> row_vect_in_M2(M2.n());
    Vector<Number> result_vect(M1.m);

    const typename LAPACKFullMatrixExt<Number>::size_type n_rows = M1.m;
    const typename LAPACKFullMatrixExt<Number>::size_type n_cols = M2.m();

    M.reinit(n_rows, n_cols);
    for (typename LAPACKFullMatrixExt<Number>::size_type j = 0; j < n_cols; j++)
      {
        M2.get_row(j, row_vect_in_M2);
        result_vect = 0.;
        M1.vmult(result_vect, row_vect_in_M2, M1, M1.get_property());
        M.fill_col(j, result_vect);
      }
  }


  /**
   * Calculate the product of two \hmatnodes with the second operand being
   * transposed, where the second one is a full matrix and the result is also
   * represented as a full matrix because the associated block cluster node
   * \f$\tau\times\rho\f$ is small. The result will be scaled by a factor.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_f_mTmult(const Number                       alpha,
             HMatrix<spacedim, Number>         &M1,
             const LAPACKFullMatrixExt<Number> &M2,
             LAPACKFullMatrixExt<Number>       &M)
  {
    AssertDimension(M1.n, M2.n());

    Vector<Number> row_vect_in_M2(M2.n());
    Vector<Number> result_vect(M1.m);

    const typename LAPACKFullMatrixExt<Number>::size_type n_rows = M1.m;
    const typename LAPACKFullMatrixExt<Number>::size_type n_cols = M2.m();

    M.reinit(n_rows, n_cols);
    for (typename LAPACKFullMatrixExt<Number>::size_type j = 0; j < n_cols; j++)
      {
        M2.get_row(j, row_vect_in_M2);
        result_vect = 0.;
        M1.vmult(result_vect, alpha, row_vect_in_M2, M1, M1.get_property());
        M.fill_col(j, result_vect);
      }
  }


  /**
   * Calculate the product of two \hmatnodes with the first operand being
   * transposed, where the second one is a full matrix and the result is also
   * represented as a full matrix because the associated block cluster node
   * \f$\tau\times\rho\f$ is small.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_f_Tmmult(HMatrix<spacedim, Number>         &M1,
             const LAPACKFullMatrixExt<Number> &M2,
             LAPACKFullMatrixExt<Number>       &M)
  {
    AssertDimension(M1.m, M2.m());

    Vector<Number> col_vect_in_M2(M2.m());
    Vector<Number> result_vect(M1.n);

    const typename LAPACKFullMatrixExt<Number>::size_type n_rows = M1.n;
    const typename LAPACKFullMatrixExt<Number>::size_type n_cols = M2.n();

    M.reinit(n_rows, n_cols);
    for (typename LAPACKFullMatrixExt<Number>::size_type j = 0; j < n_cols; j++)
      {
        M2.get_column(j, col_vect_in_M2);
        result_vect = 0.;
        M1.Tvmult(result_vect, col_vect_in_M2, M1, M1.get_property());
        M.fill_col(j, result_vect);
      }
  }


  template <int spacedim, typename Number = double>
  void
  h_f_Tmmult(const Number                       alpha,
             HMatrix<spacedim, Number>         &M1,
             const LAPACKFullMatrixExt<Number> &M2,
             LAPACKFullMatrixExt<Number>       &M)
  {
    AssertDimension(M1.m, M2.m());

    Vector<Number> col_vect_in_M2(M2.m());
    Vector<Number> result_vect(M1.n);

    const typename LAPACKFullMatrixExt<Number>::size_type n_rows = M1.n;
    const typename LAPACKFullMatrixExt<Number>::size_type n_cols = M2.n();

    M.reinit(n_rows, n_cols);
    for (typename LAPACKFullMatrixExt<Number>::size_type j = 0; j < n_cols; j++)
      {
        M2.get_column(j, col_vect_in_M2);
        result_vect = 0.;
        M1.Tvmult(result_vect, alpha, col_vect_in_M2, M1, M1.get_property());
        M.fill_col(j, result_vect);
      }
  }


  /**
   * Calculate the product of two \hmatnodes, where the second
   * one is a full matrix and the result is represented as a rank-k matrix
   * because the associated block cluster is large.
   *
   * The second matrix \p M2 will be firstly converted to a rank-k matrix. Then
   * its multiplication with \p M1 will be carried by calling \p h_rk_mmult. Since
   * the conversion from a full matrix to a rank-k matrix will modify the
   * original
   * data, a copy of \p M2 will be created.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_f_mmult(HMatrix<spacedim, Number>         &M1,
            const LAPACKFullMatrixExt<Number> &M2,
            RkMatrix<Number>                  &M)
  {
    AssertDimension(M1.n, M2.m());

    /**
     * Create a local copy of the full matrix \p M2.
     */
    LAPACKFullMatrixExt<Number> M2_copy(M2);

    /**
     * Convert the full matrix \p M2 to a rank-k matrix.
     */
    RkMatrix<Number> M2_rk(M2_copy);

    h_rk_mmult(M1, M2_rk, M);
  }


  /**
   * Calculate the product of two \hmatnodes with the result scaled by a
   * factor. The second operand is a full matrix and the result is represented
   * as a rank-k matrix because the associated block cluster is large.
   *
   * The second matrix \p M2 will be firstly converted to a rank-k matrix. Then
   * its multiplication with \p M1 will be carried by calling \p h_rk_mmult. Since
   * the conversion from a full matrix to a rank-k matrix will modify the
   * original
   * data, a copy of \p M2 will be created.
   *
   * @param alpha
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_f_mmult(const Number                       alpha,
            HMatrix<spacedim, Number>         &M1,
            const LAPACKFullMatrixExt<Number> &M2,
            RkMatrix<Number>                  &M)
  {
    AssertDimension(M1.n, M2.m());

    /**
     * Create a local copy of the full matrix \p M2.
     */
    LAPACKFullMatrixExt<Number> M2_copy(M2);

    /**
     * Convert the full matrix \p M2 to a rank-k matrix.
     */
    RkMatrix<Number> M2_rk(M2_copy);

    h_rk_mmult(alpha, M1, M2_rk, M);
  }


  /**
   * Calculate the product of two \hmatnodes with the second operand being
   * transposed, where the second one is a full matrix and the result is
   * represented as a rank-k matrix because the associated block cluster is
   * large.
   *
   * The second matrix \p M2 will be firstly converted to a rank-k matrix. Then
   * its multiplication with \p M1 will be carried by calling \p h_rk_mTmult. Since
   * the conversion from a full matrix to a rank-k matrix will modify the
   * original
   * data, a copy of \p M2 will be created.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_f_mTmult(HMatrix<spacedim, Number>         &M1,
             const LAPACKFullMatrixExt<Number> &M2,
             RkMatrix<Number>                  &M)
  {
    AssertDimension(M1.n, M2.n());

    /**
     * Create a local copy of the full matrix \p M2.
     */
    LAPACKFullMatrixExt<Number> M2_copy(M2);

    /**
     * Convert the full matrix \p M2 to a rank-k matrix.
     */
    RkMatrix<Number> M2_rk(M2_copy);

    h_rk_mTmult(M1, M2_rk, M);
  }


  /**
   * Calculate the product of two \hmatnodes with the second operand being
   * transposed, where the second one is a full matrix and the result is
   * represented as a rank-k matrix because the associated block cluster is
   * large. The result will be scaled by a factor.
   *
   * The second matrix \p M2 will be firstly converted to a rank-k matrix. Then
   * its multiplication with \p M1 will be carried by calling \p h_rk_mTmult. Since
   * the conversion from a full matrix to a rank-k matrix will modify the
   * original
   * data, a copy of \p M2 will be created.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_f_mTmult(const Number                       alpha,
             HMatrix<spacedim, Number>         &M1,
             const LAPACKFullMatrixExt<Number> &M2,
             RkMatrix<Number>                  &M)
  {
    AssertDimension(M1.n, M2.n());

    /**
     * Create a local copy of the full matrix \p M2.
     */
    LAPACKFullMatrixExt<Number> M2_copy(M2);

    /**
     * Convert the full matrix \p M2 to a rank-k matrix.
     */
    RkMatrix<Number> M2_rk(M2_copy);

    h_rk_mTmult(alpha, M1, M2_rk, M);
  }


  /**
   * Calculate the product of two \hmatnodes with the first operand being
   * transposed, where the second one is a full matrix and the result is
   * represented as a rank-k matrix because the associated block cluster is
   * large.
   *
   * The second matrix \p M2 will be firstly converted to a rank-k matrix. Then
   * its multiplication with \p M1^T will be carried by calling \p h_rk_Tmmult. Since
   * the conversion from a full matrix to a rank-k matrix will modify the
   * original
   * data, a copy of \p M2 will be created.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_f_Tmmult(HMatrix<spacedim, Number>         &M1,
             const LAPACKFullMatrixExt<Number> &M2,
             RkMatrix<Number>                  &M)
  {
    AssertDimension(M1.m, M2.m());

    /**
     * Create a local copy of the full matrix \p M2.
     */
    LAPACKFullMatrixExt<Number> M2_copy(M2);

    /**
     * Convert the full matrix \p M2 to a rank-k matrix.
     */
    RkMatrix<Number> M2_rk(M2_copy);

    h_rk_Tmmult(M1, M2_rk, M);
  }


  /**
   * Calculate the scaled product of two \hmatnodes with the first operand being
   * transposed, where the second one is a full matrix and the result is
   * represented as a rank-k matrix because the associated block cluster is
   * large.
   *
   * The second matrix \p M2 will be firstly converted to a rank-k matrix. Then
   * its multiplication with \p M1^T will be carried by calling \p h_rk_Tmmult. Since
   * the conversion from a full matrix to a rank-k matrix will modify the
   * original
   * data, a copy of \p M2 will be created.
   *
   * @param alpha
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  h_f_Tmmult(const Number                       alpha,
             HMatrix<spacedim, Number>         &M1,
             const LAPACKFullMatrixExt<Number> &M2,
             RkMatrix<Number>                  &M)
  {
    AssertDimension(M1.m, M2.m());

    /**
     * Create a local copy of the full matrix \p M2.
     */
    LAPACKFullMatrixExt<Number> M2_copy(M2);

    /**
     * Convert the full matrix \p M2 to a rank-k matrix.
     */
    RkMatrix<Number> M2_rk(M2_copy);

    h_rk_Tmmult(alpha, M1, M2_rk, M);
  }


  /**
   * Multiplication of two \hmatrices, where the second one is of \p
   * FullMatrixType. An \hmatrix is returned in \p M, which is either of \p
   * FullMatrixType or \p RkMatrixType.
   * @param M1
   * @param M2
   * @param M
   * @param is_M1M2_last_in_M_Sigma_P
   */
  template <int spacedim, typename Number = double>
  void
  h_f_mmult_for_h_h_mmult(HMatrix<spacedim, Number>       *M1,
                          const HMatrix<spacedim, Number> *M2,
                          HMatrix<spacedim, Number>       *M,
                          bool is_M1M2_last_in_M_Sigma_P = true)
  {
    Assert(M2->type == FullMatrixType, ExcInvalidHMatrixType(M2->type));
    Assert(M2->fullmatrix, ExcInternalError());
    //  Assert(*(M1->col_index_range) == *(M2->row_index_range),
    //         ExcMessage("Incompatible index sets during matrix
    //         multiplication"));
    AssertDimension(M1->n, M2->m);

    //  // DEBUG
    //  print_h_h_submatrix_mmult_accessor(std::cout, "M1", *M1, "M2", *M2);

    if (is_M1M2_last_in_M_Sigma_P)
      {
        M->Sigma_P.pop_back();
      }
    else
      {
        M->remove_hmat_pair_from_mm_product_list(M1, M2);
      }

    if (M->bc_node->get_data_reference().get_is_near_field())
      {
        /**
         * Full matrix is returned.
         */
        LAPACKFullMatrixExt<Number> *M_full = new LAPACKFullMatrixExt<Number>();
        h_f_mmult(*M1, *(M2->fullmatrix), *M_full);
        M->Sigma_F.push_back(M_full);

        //      // DEBUG
        //      M_full->print_formatted(std::cout, 8, false, 16, "0");

        AssertDimension(M->Sigma_R.size(), 0);
        M->type = FullMatrixType;
      }
    else
      {
        /**
         * Rank-k matrix is returned.
         */
        RkMatrix<Number> *M_rk = new RkMatrix<Number>();
        h_f_mmult(*M1, *(M2->fullmatrix), *M_rk);
        M->Sigma_R.push_back(M_rk);

        //      // DEBUG
        //      LAPACKFullMatrixExt<Number> M_rk_to_full;
        //      M_rk->convertToFullMatrix(M_rk_to_full);
        //      M_rk_to_full.print_formatted(std::cout, 8, false, 16, "0");

        AssertDimension(M->Sigma_F.size(), 0);
        M->type = RkMatrixType;
      }
  }


  /**
   * Multiplication of a full matrix and a \hmatrix. A full matrix is returned
   * in
   * \p M.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  f_h_mmult(const LAPACKFullMatrixExt<Number> &M1,
            HMatrix<spacedim, Number>         &M2,
            LAPACKFullMatrixExt<Number>       &M)
  {
    AssertDimension(M1.n(), M2.m);

    Vector<Number> row_vect_in_M1(M1.n());
    Vector<Number> result_vect(M2.n);

    const typename LAPACKFullMatrixExt<Number>::size_type n_rows = M1.m();
    const typename LAPACKFullMatrixExt<Number>::size_type n_cols = M2.n;

    M.reinit(n_rows, n_cols);
    for (typename LAPACKFullMatrixExt<Number>::size_type i = 0; i < n_rows; i++)
      {
        M1.get_row(i, row_vect_in_M1);
        result_vect = 0.;
        M2.Tvmult(result_vect, row_vect_in_M1, M2, M2.get_property());
        M.fill_row(i, result_vect);
      }
  }


  /**
   * Multiplication of a full matrix and a \hmatrix and the result is scaled by
   * a
   * factor. A full matrix is returned in \p M.
   *
   * @param alpha
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  f_h_mmult(const Number                       alpha,
            const LAPACKFullMatrixExt<Number> &M1,
            HMatrix<spacedim, Number>         &M2,
            LAPACKFullMatrixExt<Number>       &M)
  {
    AssertDimension(M1.n(), M2.m);

    Vector<Number> row_vect_in_M1(M1.n());
    Vector<Number> result_vect(M2.n);

    const typename LAPACKFullMatrixExt<Number>::size_type n_rows = M1.m();
    const typename LAPACKFullMatrixExt<Number>::size_type n_cols = M2.n;

    M.reinit(n_rows, n_cols);
    for (typename LAPACKFullMatrixExt<Number>::size_type i = 0; i < n_rows; i++)
      {
        M1.get_row(i, row_vect_in_M1);
        /**
         * \alert{Since the following \p Tvmult will compute \f$y = y + M^T x\f$,
         * \p result_vect should be reset to zero beforehand.}
         */
        result_vect = 0.;
        M2.Tvmult(result_vect, alpha, row_vect_in_M1, M2, M2.get_property());
        M.fill_row(i, result_vect);
      }
  }


  /**
   * Multiplication of a full matrix and a \hmatrix with the second operand
   * being
   * transposed. A full matrix is returned in \p M.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  f_h_mTmult(const LAPACKFullMatrixExt<Number> &M1,
             HMatrix<spacedim, Number>         &M2,
             LAPACKFullMatrixExt<Number>       &M)
  {
    AssertDimension(M1.n(), M2.n);

    Vector<Number> row_vect_in_M1(M1.n());
    Vector<Number> result_vect(M2.m);

    const typename LAPACKFullMatrixExt<Number>::size_type n_rows = M1.m();
    const typename LAPACKFullMatrixExt<Number>::size_type n_cols = M2.m;

    M.reinit(n_rows, n_cols);
    for (typename LAPACKFullMatrixExt<Number>::size_type i = 0; i < n_rows; i++)
      {
        M1.get_row(i, row_vect_in_M1);
        result_vect = 0.;
        M2.vmult(result_vect, row_vect_in_M1, M2, M2.get_property());
        M.fill_row(i, result_vect);
      }
  }


  /**
   * Multiplication of a full matrix and a \hmatrix with the second operand
   * being
   * transposed, the result of which will be scaled by a factor. A full matrix is returned in \p M.
   *
   * @param alpha
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  f_h_mTmult(const Number                       alpha,
             const LAPACKFullMatrixExt<Number> &M1,
             HMatrix<spacedim, Number>         &M2,
             LAPACKFullMatrixExt<Number>       &M)
  {
    AssertDimension(M1.n(), M2.n);

    Vector<Number> row_vect_in_M1(M1.n());
    Vector<Number> result_vect(M2.m);

    const typename LAPACKFullMatrixExt<Number>::size_type n_rows = M1.m();
    const typename LAPACKFullMatrixExt<Number>::size_type n_cols = M2.m;

    M.reinit(n_rows, n_cols);
    for (typename LAPACKFullMatrixExt<Number>::size_type i = 0; i < n_rows; i++)
      {
        M1.get_row(i, row_vect_in_M1);
        result_vect = 0.;
        M2.vmult(result_vect, alpha, row_vect_in_M1, M2, M2.get_property());
        M.fill_row(i, result_vect);
      }
  }


  /**
   * Multiplication of a transposed full matrix and a \hmatrix. A full matrix is
   * returned in \p M.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  f_h_Tmmult(const LAPACKFullMatrixExt<Number> &M1,
             HMatrix<spacedim, Number>         &M2,
             LAPACKFullMatrixExt<Number>       &M)
  {
    AssertDimension(M1.m(), M2.m);

    Vector<Number> col_vect_in_M1(M1.m());
    Vector<Number> result_vect(M2.n);

    const typename LAPACKFullMatrixExt<Number>::size_type n_rows = M1.n();
    const typename LAPACKFullMatrixExt<Number>::size_type n_cols = M2.n;

    M.reinit(n_rows, n_cols);
    for (typename LAPACKFullMatrixExt<Number>::size_type i = 0; i < n_rows; i++)
      {
        M1.get_column(i, col_vect_in_M1);
        result_vect = 0.;
        M2.Tvmult(result_vect, col_vect_in_M1, M2, M2.get_property());
        M.fill_row(i, result_vect);
      }
  }


  /**
   * Scaled multiplication of a transposed full matrix and a \hmatrix. A full
   * matrix is returned in \p M.
   *
   * @param alpha
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  f_h_Tmmult(const Number                       alpha,
             const LAPACKFullMatrixExt<Number> &M1,
             HMatrix<spacedim, Number>         &M2,
             LAPACKFullMatrixExt<Number>       &M)
  {
    AssertDimension(M1.m(), M2.m);

    Vector<Number> col_vect_in_M1(M1.m());
    Vector<Number> result_vect(M2.n);

    const typename LAPACKFullMatrixExt<Number>::size_type n_rows = M1.n();
    const typename LAPACKFullMatrixExt<Number>::size_type n_cols = M2.n;

    M.reinit(n_rows, n_cols);
    for (typename LAPACKFullMatrixExt<Number>::size_type i = 0; i < n_rows; i++)
      {
        M1.get_column(i, col_vect_in_M1);
        result_vect = 0.;
        M2.Tvmult(result_vect, alpha, col_vect_in_M1, M2, M2.get_property());
        M.fill_row(i, result_vect);
      }
  }


  /**
   * Multiplication of a full matrix and a \hmatrix. A rank-k matrix is returned
   * in \p M.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  f_h_mmult(const LAPACKFullMatrixExt<Number> &M1,
            HMatrix<spacedim, Number>         &M2,
            RkMatrix<Number>                  &M)
  {
    AssertDimension(M1.n(), M2.m);

    /**
     * \alert{The creation of the rank-k matrix \p M1_rk from \p M1 will modify \p
     * M1 internally. Hence, we make a copy of \p M1 here.}
     */
    LAPACKFullMatrixExt<Number> M1_copy(M1);
    RkMatrix<Number>            M1_rk(M1_copy);
    rk_h_mmult(M1_rk, M2, M);
  }


  /**
   * Multiplication of a full matrix and a \hmatrix and the result is scaled by
   * a
   * factor. A rank-k matrix is returned in \p M.
   *
   * @param alpha
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  f_h_mmult(const Number                       alpha,
            const LAPACKFullMatrixExt<Number> &M1,
            HMatrix<spacedim, Number>         &M2,
            RkMatrix<Number>                  &M)
  {
    AssertDimension(M1.n(), M2.m);

    /**
     * \alert{The creation of the rank-k matrix \p M1_rk from \p M1 will modify \p
     * M1 internally. Hence, we make a copy of \p M1 here.}
     */
    LAPACKFullMatrixExt<Number> M1_copy(M1);
    RkMatrix<Number>            M1_rk(M1_copy);
    rk_h_mmult(alpha, M1_rk, M2, M);
  }


  /**
   * Multiplication of a full matrix and a \hmatrix with the second operand
   * being
   * transposed. A rank-k matrix is returned in \p M.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  f_h_mTmult(const LAPACKFullMatrixExt<Number> &M1,
             HMatrix<spacedim, Number>         &M2,
             RkMatrix<Number>                  &M)
  {
    AssertDimension(M1.n(), M2.n);

    /**
     * \alert{The creation of the rank-k matrix \p M1_rk from \p M1 will modify \p
     * M1 internally. Hence, we make a copy of \p M1 here.}
     */
    LAPACKFullMatrixExt<Number> M1_copy(M1);
    RkMatrix<Number>            M1_rk(M1_copy);
    rk_h_mTmult(M1_rk, M2, M);
  }


  /**
   * Multiplication of a full matrix and a \hmatrix with the second operand
   * being
   * transposed. The result will be scaled by a factor. A rank-k matrix is returned in \p M.
   *
   * @param alpha
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  f_h_mTmult(const Number                       alpha,
             const LAPACKFullMatrixExt<Number> &M1,
             HMatrix<spacedim, Number>         &M2,
             RkMatrix<Number>                  &M)
  {
    AssertDimension(M1.n(), M2.n);

    /**
     * \alert{The creation of the rank-k matrix \p M1_rk from \p M1 will modify \p
     * M1 internally. Hence, we make a copy of \p M1 here.}
     */
    LAPACKFullMatrixExt<Number> M1_copy(M1);
    RkMatrix<Number>            M1_rk(M1_copy);
    rk_h_mTmult(alpha, M1_rk, M2, M);
  }


  /**
   * Multiplication of a transposed full matrix and a \hmatrix. A rank-k matrix
   * is
   * returned in \p M.
   *
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  f_h_Tmmult(const LAPACKFullMatrixExt<Number> &M1,
             HMatrix<spacedim, Number>         &M2,
             RkMatrix<Number>                  &M)
  {
    AssertDimension(M1.m(), M2.m);

    /**
     * \alert{The creation of the rank-k matrix \p M1_rk from \p M1 will modify \p
     * M1 internally. Hence, we make a copy of \p M1 here.}
     */
    LAPACKFullMatrixExt<Number> M1_copy(M1);
    RkMatrix<Number>            M1_rk(M1_copy);
    rk_h_Tmmult(M1_rk, M2, M);
  }


  /**
   * Scaled multiplication of a transposed full matrix and a \hmatrix. A rank-k
   * matrix is returned in \p M.
   *
   * @param alpha
   * @param M1
   * @param M2
   * @param M
   */
  template <int spacedim, typename Number = double>
  void
  f_h_Tmmult(const Number                       alpha,
             const LAPACKFullMatrixExt<Number> &M1,
             HMatrix<spacedim, Number>         &M2,
             RkMatrix<Number>                  &M)
  {
    AssertDimension(M1.m(), M2.m);

    /**
     * \alert{The creation of the rank-k matrix \p M1_rk from \p M1 will modify \p
     * M1 internally. Hence, we make a copy of \p M1 here.}
     */
    LAPACKFullMatrixExt<Number> M1_copy(M1);
    RkMatrix<Number>            M1_rk(M1_copy);
    rk_h_Tmmult(alpha, M1_rk, M2, M);
  }


  /**
   * Multiplication of two \hmatrices, where the first one is of \p
   * FullMatrixType. An \hmatrix is returned in \p M, which is either of \p
   * FullMatrixType or \p RkMatrixType.
   * @param M1
   * @param M2
   * @param M
   * @param is_M1M2_last_in_M_Sigma_P
   */
  template <int spacedim, typename Number = double>
  void
  f_h_mmult_for_h_h_mmult(const HMatrix<spacedim, Number> *M1,
                          HMatrix<spacedim, Number>       *M2,
                          HMatrix<spacedim, Number>       *M,
                          bool is_M1M2_last_in_M_Sigma_P = true)
  {
    Assert(M1->type == FullMatrixType, ExcInvalidHMatrixType(M1->type));
    Assert(M1->fullmatrix, ExcInternalError());
    //  Assert(*(M1->col_index_range) == *(M2->row_index_range),
    //         ExcMessage("Incompatible index sets during matrix
    //         multiplication"));
    AssertDimension(M1->n, M2->m);

    // DEBUG
    // print_h_h_submatrix_mmult_accessor(std::cout, "M1", *M1, "M2", *M2);

    if (is_M1M2_last_in_M_Sigma_P)
      {
        M->Sigma_P.pop_back();
      }
    else
      {
        M->remove_hmat_pair_from_mm_product_list(M1, M2);
      }

    if (M->bc_node->get_data_reference().get_is_near_field())
      {
        /**
         * Full matrix is returned.
         */
        LAPACKFullMatrixExt<Number> *M_full = new LAPACKFullMatrixExt<Number>();
        f_h_mmult(*(M1->fullmatrix), *M2, *M_full);
        M->Sigma_F.push_back(M_full);

        //      // DEBUG
        //      M_full->print_formatted(std::cout, 8, false, 16, "0");

        AssertDimension(M->Sigma_R.size(), 0);
        M->type = FullMatrixType;
      }
    else
      {
        /**
         * Rank-k matrix is returned.
         */
        RkMatrix<Number> *M_rk = new RkMatrix<Number>();
        f_h_mmult(*(M1->fullmatrix), *M2, *M_rk);
        M->Sigma_R.push_back(M_rk);

        //      // DEBUG
        //      LAPACKFullMatrixExt<Number> M_rk_to_full;
        //      M_rk->convertToFullMatrix(M_rk_to_full);
        //      M_rk_to_full.print_formatted(std::cout, 8, false, 16, "0");

        AssertDimension(M->Sigma_F.size(), 0);
        M->type = RkMatrixType;
      }
  }


  template <int spacedim, typename Number = double>
  void
  h_h_mmult_phase1_recursion(HMatrix<spacedim, Number>          *M,
                             BlockClusterTree<spacedim, Number> &Tind)
  {
    M->h_h_mmult_reduction();

    if (M->Sigma_P.size() > 0)
      {
        /**
         * There are still multiplication subtasks stored in \p Sigma_P to be
         * handled recursively.
         */
        TreeNodeSplitMode split_mode_of_mm =
          M->determine_mm_split_mode_from_Sigma_P();

        switch (split_mode_of_mm)
          {
              case HorizontalSplitMode: {
                M->h_h_mmult_horizontal_split(Tind);

                Assert(
                  false,
                  ExcMessage(
                    "For level conserving H-matrix multiplication, HorizontalSplitMode should not appear!"));

                break;
              }
              case VerticalSplitMode: {
                M->h_h_mmult_vertical_split(Tind);

                Assert(
                  false,
                  ExcMessage(
                    "For level conserving H-matrix multiplication, VerticalSplitMode should not appear!"));

                break;
              }
              case CrossSplitMode: {
                M->h_h_mmult_cross_split(Tind);

                break;
              }
              default: {
                Assert(
                  false,
                  ExcMessage(
                    "Inconsistent case met during H-matrix MM multiplication"));

                break;
              }
          }

        /**
         * After previous reduction and splitting, the matrix multiplication for
         * the current \hmatnode should be replaced by the
         * multiplication subtasks for submatrices. These subtasks are recorded
         * as \hmatnode pairs which are stored in \f$\Sigma_b^P\f$ of the
         * submatrices.
         */
        AssertDimension(M->Sigma_P.size(), 0);
        for (HMatrix<spacedim, Number> *submatrix : M->submatrices)
          {
            h_h_mmult_phase1_recursion(submatrix, Tind);
          }
      }
  }


  template <int spacedim, typename Number = double>
  void
  h_h_mmult_phase2(HMatrix<spacedim, Number>          &M,
                   BlockClusterTree<spacedim, Number> &target_bc_tree,
                   const unsigned int                  fixed_rank)
  {
    /**
     * Collect terms in \p Sigma_R and \p Sigma_F for the leaf nodes.
     */
    for (HMatrix<spacedim, Number> *hmat : M.leaf_set)
      {
        /**
         * Here we make sure that \hmatrix pairs in the list
         * \f$\Sigma_b^P\f$ have all been processed and erased, hence the list
         * should be empty.
         */
        AssertDimension(hmat->Sigma_P.size(), 0);

        if (hmat->Sigma_R.size() > 0 && hmat->Sigma_F.size() == 0)
          {
            Assert(hmat->type == RkMatrixType,
                   ExcInvalidHMatrixType(hmat->type));

            /**
             * Perform pairwise formatted addition for the list of rank-k
             * matrices stored in the list \f$\Sigma_b^R\f$, the result of which
             * will be assigned to the \p rkmatrix field of the current \hmatrix
             * leaf node.
             */
            Assert(
              hmat->rkmatrix == nullptr,
              ExcMessage(
                "The pointer hmat->rkmatrix should be nullptr before the following assignment:\n\nhmat->rkmatrix = hmat->Sigma_R[0];\n"));
            hmat->rkmatrix = hmat->Sigma_R[0];
            for (size_t i = 1; i < hmat->Sigma_R.size(); i++)
              {
                hmat->rkmatrix->add(*(hmat->Sigma_R[i]), fixed_rank);
                delete hmat->Sigma_R[i];
                hmat->Sigma_R[i] = nullptr;
              }

            /**
             * Clear the list \f$\Sigma_b^R\f$ after adding all of its rank-k
             * matrices.
             */
            hmat->Sigma_R.clear();
          }
        else if (hmat->Sigma_R.size() == 0 && hmat->Sigma_F.size() > 0)
          {
            Assert(hmat->type == FullMatrixType,
                   ExcInvalidHMatrixType(hmat->type));

            Assert(
              hmat->fullmatrix == nullptr,
              ExcMessage(
                "The pointer hmat->fullmatrix should be nullptr before the following assignment:\n\nhmat->fullmatrix = hmat->Sigma_F[0];\n"));
            hmat->fullmatrix = hmat->Sigma_F[0];
            for (size_t i = 1; i < hmat->Sigma_F.size(); i++)
              {
                hmat->fullmatrix->add(*(hmat->Sigma_F[i]));
                delete hmat->Sigma_F[i];
                hmat->Sigma_F[i] = nullptr;
              }

            /**
             * Clear the list \f$\Sigma_b^F\f$ after adding all of its full
             * matrices.
             */
            hmat->Sigma_F.clear();
          }
        else
          {
            Assert(false, ExcInternalError());
          }
      }

    /**
     * \alert{Important}: Distribute matrices stored in \f$\Sigma_b^R\f$ and
     * \f$\Sigma_b^F\f$ of each \alert{non-leaf node} to the leaf nodes which
     * are its descendants.
     */
    M.distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves(fixed_rank);

    /**
     * Convert the calculated product matrix to the specified matrix structure.
     */
    M.convert_between_different_block_cluster_trees(M.Tind,
                                                    target_bc_tree,
                                                    fixed_rank);
  }


  /**
   * \hmatrix-\hmatrix multiplication when the product matrix belongs to the
   * leaf set of the target \bct.
   *
   * This function implements the recursive \p MMR algorithm in (7.26) in
   * Hackbusch's \hmatrix book.
   *
   * @param M0 The initial product matrix on the \bcn \f$\tau_0\times\rho_0\f$,
   * which is a leaf node in the product \bct.
   *
   * @param M The current product matrix \f$M\f$ on the \bcn \f$\tau\times\rho\f$,
   * which will assembles the contribution from \f$M_1 \cdot M_2\f$ (N.B. This
   * description is only valid for the first call of this function. During
   * recursive calls of this function, @p M may not be on a same level as the
   * product of @p M1 and @p M2, when both @p M1 and @p M2 have substructures and
   * the multiplication needs to collect results from the multiplications of
   * submatrices). For the first call of this function, \p M is the same as
   * \p M0.
   * @param M1 The first operand of the multiplication, which is built upon the
   * \bcn \f$\tau\times\sigma\f$.
   * @param M2 The second operand of the multiplication, which is built upon the
   * \bcn \f$\sigma\times\rho\f$.
   * @param fixed_rank
   */
  template <int spacedim, typename Number>
  void
  h_h_mmult_from_leaf_node(
    HMatrix<spacedim, Number>      &M0,
    HMatrix<spacedim, Number>      &M,
    HMatrix<spacedim, Number>      &M1,
    HMatrix<spacedim, Number>      &M2,
    const HMatrixSupport::BlockType block_type_for_local_Z,
    const unsigned int              fixed_rank,
    const bool                      is_result_matrix_store_tril_only = false)
  {
    /**
     * Here we make an assertion that the top level result \hmatrix @p M0 should
     * be a leaf node.
     */
    Assert(M0.bc_node->is_leaf(), ExcMessage("M0 should be a leaf node!"));

    if (is_result_matrix_store_tril_only)
      {
        Assert(M0.get_property() == HMatrixSupport::symmetric ||
                 M0.get_property() == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(M0.get_property()));
        Assert(M0.get_block_type() == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(M0.get_block_type()));
        Assert(M.get_property() == HMatrixSupport::symmetric ||
                 M.get_property() == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(M.get_property()));
        Assert(M.get_block_type() == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(M.get_block_type()));
      }

    // Array of empty child pointers used for initializing a block
    // cluster tree node.
    const std::array<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type,
      BlockClusterTree<spacedim, Number>::child_num>
      empty_child_pointers{{nullptr, nullptr, nullptr, nullptr}};

    /**
     * Create a \bcn \f$\tau\times\rho\f$ for the current local product matrix
     * \p Z. Since this \bcn will not be connected with other \bcns in a \bct,
     * it has neither parent nor children and its level is set to zero.
     */
    typename BlockClusterTree<spacedim, Number>::node_value_type
      current_product_bc_node(
        BlockCluster<spacedim, Number>(
          M1.bc_node->get_data_reference().get_tau_node(),
          M2.bc_node->get_data_reference().get_sigma_node()),
        0,
        empty_child_pointers,
        nullptr,
        UnsplitMode);

    /**
     * Set the \p is_near_field flag of the \bcn for the current local product
     * matrix \p Z according to the matrix type of the initial leaf node \hmatrix
     * \p M0, i.e. it inherits the \p is_near_field flag of the \bcn for \p M0.
     */
    if (M0.bc_node->get_data_reference().get_is_near_field())
      {
        Assert(M0.type == FullMatrixType, ExcInvalidHMatrixType(M0.type));

        current_product_bc_node.get_data_reference().set_is_near_field(true);
      }
    else
      {
        Assert(M0.type == RkMatrixType, ExcInvalidHMatrixType(M0.type));

        current_product_bc_node.get_data_reference().set_is_near_field(false);
      }

    /**
     * When the flag @p is_result_matrix_store_tril_only is true, determine if
     * the \hmatrix property of the local product \hmatrix @p Z should be the
     * same as that of @p M by checking if the index ranges of its \f$\tau\f$
     * node and \f$\sigma\f$ are the same, since only when they are the same,
     * @p Z or @p M's property can be symmetric or lower triangular.
     */
    HMatrixSupport::Property Z_property = HMatrixSupport::general;
    bool                     is_result_matrix_Z_store_tril_only = false;

    if (is_result_matrix_store_tril_only &&
        (*M1.get_row_index_range() == *M2.get_col_index_range()))
      {
        /**
         * The local product \hmatrix @p Z inherits the property of @p M, which
         * can be either symmetric or lower triangular.
         */
        Z_property                         = M.property;
        is_result_matrix_Z_store_tril_only = true;

        /**
         * If the local \hmatrix @p Z is symmetric or lower triangular, its block
         * type should be @p diagonal_block and an assertion is made about this
         * fact.
         */
        Assert(block_type_for_local_Z == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(block_type_for_local_Z));
      }

    /**
     * Create the local product \hmatrix \p Z associated with the current \bcn.
     * During its initialization, memory will be allocated depending on its
     * \hmatrix property and block type.
     */
    HMatrix<spacedim, Number> Z(&current_product_bc_node,
                                fixed_rank,
                                Z_property,
                                block_type_for_local_Z);
    // Local variable storing the rank-k matrix obtained from multiplication
    // involving leaf node.
    RkMatrix<Number> ZR;
    // Local variable storing the full matrix obtained from multiplication
    // involving leaf node.
    LAPACKFullMatrixExt<Number> ZF;
    // The result matrix type for the multiplication involving leaf node.
    HMatrixType result_matrix_type;

    if (M1.bc_node->is_leaf() || M2.bc_node->is_leaf())
      {
        /**
         * When either operand \p M1 or \p M2 is a leaf node, directly evaluation
         * of their multiplication can be performed.
         */
        if (M1.type == RkMatrixType)
          {
            rk_h_mmult(*(M1.rkmatrix), M2, ZR);
            result_matrix_type = RkMatrixType;
          }
        else if (M2.type == RkMatrixType)
          {
            h_rk_mmult(M1, *(M2.rkmatrix), ZR);
            result_matrix_type = RkMatrixType;
          }
        else if (M1.type == FullMatrixType)
          {
            f_h_mmult(*(M1.fullmatrix), M2, ZF);
            result_matrix_type = FullMatrixType;
          }
        else if (M2.type == FullMatrixType)
          {
            h_f_mmult(M1, *(M2.fullmatrix), ZF);
            result_matrix_type = FullMatrixType;
          }
        else
          {
            Assert(false, ExcInternalError());
            result_matrix_type = UndefinedMatrixType;
          }

        if (Z.type == RkMatrixType)
          {
            // The desired result should be a rank-k matrix.
            if (result_matrix_type == RkMatrixType)
              {
                *(Z.rkmatrix) = ZR;
              }
            else if (result_matrix_type == FullMatrixType)
              {
                // Convert the full matrix to rank-k matrix.
                *(Z.rkmatrix) = RkMatrix<Number>(fixed_rank, ZF);
              }
            else
              {
                Assert(false, ExcInvalidHMatrixType(result_matrix_type));
              }
          }
        else if (Z.type == FullMatrixType)
          {
            // The desired result should be a full matrix.
            if (result_matrix_type == RkMatrixType)
              {
                // Convert the rank-k matrix to full matrix.
                ZR.convertToFullMatrix(*(Z.fullmatrix));
              }
            else if (result_matrix_type == FullMatrixType)
              {
                *(Z.fullmatrix) = ZF;
              }
            else
              {
                Assert(false, ExcInvalidHMatrixType(result_matrix_type));
              }

            /**
             * If the local product \hmatrix @p Z is expected to be symmetric or
             * lower triangular, also set the property of the associated full
             * matrix correspondingly. This operation is mandatory because the
             * property of the local full matrix @p ZF is @p general, which has
             * overwritten the property of @p Z.
             */
            if (is_result_matrix_Z_store_tril_only)
              {
                switch (Z.property)
                  {
                      case HMatrixSupport::symmetric: {
                        Z.fullmatrix->set_property(LAPACKSupport::symmetric);

                        break;
                      }
                      case HMatrixSupport::lower_triangular: {
                        Z.fullmatrix->set_property(
                          LAPACKSupport::lower_triangular);

                        break;
                      }
                      default: {
                        Assert(false, ExcInvalidHMatrixProperty(Z.property));

                        break;
                      }
                  }
              }
          }
        else
          {
            Assert(false, ExcInvalidHMatrixType(Z.type));
          }
      }
    else
      {
        /**
         * In this case, both @p M1 and @p M2 have child submatrices.
         *
         * \alert{When we perform submatrix multiplication, we use a higher
         * specified rank, since the results will be assembled into the larger
         * matrix \p Z via pairwise formatted addition, during which the actual
         * matrix rank may increase.}
         */
        const unsigned int local_fixed_rank =
          std::min(fixed_rank * 2, std::min(Z.m, Z.n));

        std::array<HMatrixSupport::BlockType,
                   BlockClusterTree<spacedim, Number>::child_num>
          block_types_for_submatrices_of_local_Z;
        HMatrixSupport::infer_submatrix_block_types_from_parent_hmat(
          block_type_for_local_Z, block_types_for_submatrices_of_local_Z);

        h_h_mmult_from_leaf_node(M0,
                                 Z,
                                 *(M1.submatrices[0]),
                                 *(M2.submatrices[0]),
                                 block_types_for_submatrices_of_local_Z[0],
                                 local_fixed_rank,
                                 is_result_matrix_Z_store_tril_only);
        h_h_mmult_from_leaf_node(M0,
                                 Z,
                                 *(M1.submatrices[1]),
                                 *(M2.submatrices[2]),
                                 block_types_for_submatrices_of_local_Z[0],
                                 local_fixed_rank,
                                 is_result_matrix_Z_store_tril_only);

        if ((!is_result_matrix_Z_store_tril_only) ||
            (is_result_matrix_Z_store_tril_only &&
             Z.property != HMatrixSupport::symmetric &&
             Z.property != HMatrixSupport::lower_triangular))
          {
            /**
             * The submatrix block @p Z.submatrices[1], which is obtained
             * from the cross type multiplication of @p M1 and @p M2, will be
             * evaluated in two scenarios:
             * 1. when the \hmatrix @p M is not expected to be symmetric or lower
             * triangular;
             * 2. when the \hmatrix @p M is required to be symmetric or lower
             * triangular a priori, and the product matrix @p Z should not be
             * symmetric or lower triangular.
             */
            h_h_mmult_from_leaf_node(M0,
                                     Z,
                                     *(M1.submatrices[0]),
                                     *(M2.submatrices[1]),
                                     block_types_for_submatrices_of_local_Z[1],
                                     local_fixed_rank,
                                     is_result_matrix_Z_store_tril_only);
            h_h_mmult_from_leaf_node(M0,
                                     Z,
                                     *(M1.submatrices[1]),
                                     *(M2.submatrices[3]),
                                     block_types_for_submatrices_of_local_Z[1],
                                     local_fixed_rank,
                                     is_result_matrix_Z_store_tril_only);
          }

        h_h_mmult_from_leaf_node(M0,
                                 Z,
                                 *(M1.submatrices[2]),
                                 *(M2.submatrices[0]),
                                 block_types_for_submatrices_of_local_Z[2],
                                 local_fixed_rank,
                                 is_result_matrix_Z_store_tril_only);
        h_h_mmult_from_leaf_node(M0,
                                 Z,
                                 *(M1.submatrices[3]),
                                 *(M2.submatrices[2]),
                                 block_types_for_submatrices_of_local_Z[2],
                                 local_fixed_rank,
                                 is_result_matrix_Z_store_tril_only);

        h_h_mmult_from_leaf_node(M0,
                                 Z,
                                 *(M1.submatrices[2]),
                                 *(M2.submatrices[1]),
                                 block_types_for_submatrices_of_local_Z[3],
                                 local_fixed_rank,
                                 is_result_matrix_Z_store_tril_only);
        h_h_mmult_from_leaf_node(M0,
                                 Z,
                                 *(M1.submatrices[3]),
                                 *(M2.submatrices[3]),
                                 block_types_for_submatrices_of_local_Z[3],
                                 local_fixed_rank,
                                 is_result_matrix_Z_store_tril_only);
      }

    /**
     * Assemble the local matrix \p Z to the product matrix \p M.
     */
    if (M0.bc_node->get_data_reference().get_is_near_field())
      {
        /**
         * When the original matrix \p M0 belongs to the near field, assemble the
         * full matrix stored in \p Z directly into \p M.
         */
        Assert(M.fullmatrix, ExcInternalError());

        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.block_type != HMatrixSupport::upper_triangular_block &&
             Z.block_type != HMatrixSupport::upper_triangular_block))
          {
            M.fullmatrix->fill(*(Z.fullmatrix),
                               (*Z.row_index_range)[0] -
                                 (*M.row_index_range)[0],
                               (*Z.col_index_range)[0] -
                                 (*M.col_index_range)[0],
                               0,
                               0,
                               1.0,
                               false,
                               true);
          }
      }
    else
      {
        /**
         * When the original matrix \p M0 does not belong to the near field,
         * assemble the rank-k matrix stored in \p Z into \p M by first embedding
         * then formatted addition, which has been implemented in the member
         * function \p assemble_from_rkmatrix.
         */
        Assert(M.rkmatrix, ExcInternalError());

        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.block_type != HMatrixSupport::upper_triangular_block &&
             Z.block_type != HMatrixSupport::upper_triangular_block))
          {
            M.rkmatrix->assemble_from_rkmatrix(*M.row_index_range,
                                               *M.col_index_range,
                                               *(Z.rkmatrix),
                                               *(Z.row_index_range),
                                               *(Z.col_index_range),
                                               fixed_rank);
          }
      }
  }


  /**
   * \hmatrix-\hmatrix multiplication with the result scaled by a factor, when
   * the product matrix belongs to the leaf set of the target \bct.
   *
   * This function implements the recursive \p MMR algorithm in (7.26) in
   * Hackbusch's \hmatrix book.
   *
   * @param M0 The initial product matrix on the \bcn \f$\tau_0\times\rho_0\f$.
   *
   * @param M The current product matrix \f$M\f$ on the \bcn \f$\tau\times\rho\f$,
   * which will assembles the contribution from \f$M_1 \cdot M_2\f$ (N.B. This
   * description is only valid for the first call of this function. During
   * recursive calls of this function, @p M may not be on a same level as the
   * product of @p M1 and @p M2, when both @p M1 and @p M2 have substructures and
   * the multiplication needs to collect results from the multiplications of
   * submatrices). For the first call of this function, \p M is the same as
   * \p M0.
   * @param M1 The first operand of the multiplication, which is built upon the
   * \bcn \f$\tau\times\sigma\f$.
   * @param M2 The second operand of the multiplication, which is built upon the
   * \bcn \f$\sigma\times\rho\f$.
   * @param block_type_for_local_Z Block type for the local \hmatrix @p Z, which
   * is the product of @p M1 and @p M2.
   * @param fixed_rank
   * @param is_result_matrix_store_tril_only Flag indicating whether only the
   * lower triangular part and the diagonal part of the \hmatrix @p M are stored.
   * The naming of this variable follows the convention adopted by GNU Octave,
   * where a lower triangular matrix has nonzero entries only on the main
   * diagonal
   * and below. See @p tril and @p istril function in GNU Octave.
   */
  template <int spacedim, typename Number>
  void
  h_h_mmult_from_leaf_node(
    HMatrix<spacedim, Number>      &M0,
    HMatrix<spacedim, Number>      &M,
    const Number                    alpha,
    HMatrix<spacedim, Number>      &M1,
    HMatrix<spacedim, Number>      &M2,
    const HMatrixSupport::BlockType block_type_for_local_Z,
    const unsigned int              fixed_rank,
    const bool                      is_result_matrix_store_tril_only = false)
  {
    /**
     * Here we make an assertion that the top level result \hmatrix @p M0 should
     * be a leaf node.
     */
    Assert(M0.bc_node->is_leaf(), ExcMessage("M0 should be a leaf node!"));

    if (is_result_matrix_store_tril_only)
      {
        Assert(M0.get_property() == HMatrixSupport::symmetric ||
                 M0.get_property() == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(M0.get_property()));
        Assert(M0.get_block_type() == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(M0.get_block_type()));
        Assert(M.get_property() == HMatrixSupport::symmetric ||
                 M.get_property() == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(M.get_property()));
        Assert(M.get_block_type() == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(M.get_block_type()));
      }

    // Array of empty child pointers used for initializing a block
    // cluster tree node.
    const std::array<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type,
      BlockClusterTree<spacedim, Number>::child_num>
      empty_child_pointers{{nullptr, nullptr, nullptr, nullptr}};

    /**
     * Create a \bcn \f$\tau\times\rho\f$ for the current local product matrix
     * \p Z. Since this \bcn will not be connected with other \bcns in a \bct,
     * it has neither parent nor children and its level is set to zero.
     */
    typename BlockClusterTree<spacedim, Number>::node_value_type
      current_product_bc_node(
        BlockCluster<spacedim, Number>(
          M1.bc_node->get_data_reference().get_tau_node(),
          M2.bc_node->get_data_reference().get_sigma_node()),
        0,
        empty_child_pointers,
        nullptr,
        UnsplitMode);

    /**
     * Set the \p is_near_field flag of the \bcn for the current local product
     * matrix \p Z according to the matrix type of the initial leaf node \hmatrix
     * \p M0, i.e. it inherits the \p is_near_field flag of the \bcn for \p M0.
     */
    if (M0.bc_node->get_data_reference().get_is_near_field())
      {
        Assert(M0.type == FullMatrixType, ExcInvalidHMatrixType(M0.type));

        current_product_bc_node.get_data_reference().set_is_near_field(true);
      }
    else
      {
        Assert(M0.type == RkMatrixType, ExcInvalidHMatrixType(M0.type));

        current_product_bc_node.get_data_reference().set_is_near_field(false);
      }

    /**
     * When the flag @p is_result_matrix_store_tril_only is true, determine if
     * the \hmatrix property of the local product \hmatrix @p Z should be the
     * same as that of @p M by checking if the index ranges of its \f$\tau\f$
     * node and \f$\sigma\f$ are the same, since only when they are the same,
     * @p Z or @p M's property can be symmetric or lower triangular.
     */
    HMatrixSupport::Property Z_property = HMatrixSupport::general;
    bool                     is_result_matrix_Z_store_tril_only = false;

    if (is_result_matrix_store_tril_only &&
        (*M1.get_row_index_range() == *M2.get_col_index_range()))
      {
        /**
         * The local product \hmatrix @p Z inherits the property of @p M, which
         * can be either symmetric or lower triangular.
         */
        Z_property                         = M.property;
        is_result_matrix_Z_store_tril_only = true;

        /**
         * If the local \hmatrix @p Z is symmetric or lower triangular, its block
         * type should be @p diagonal_block and an assertion is made about this
         * fact.
         */
        Assert(block_type_for_local_Z == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(block_type_for_local_Z));
      }


    /**
     * Create the local product \hmatrix \p Z associated with the current \bcn.
     * During its initialization, memory will be allocated depending on its
     * \hmatrix property and block type.
     */
    HMatrix<spacedim, Number> Z(&current_product_bc_node,
                                fixed_rank,
                                Z_property,
                                block_type_for_local_Z);
    // Local variable storing the rank-k matrix obtained from multiplication
    // involving leaf node.
    RkMatrix<Number> ZR;
    // Local variable storing the full matrix obtained from multiplication
    // involving leaf node.
    LAPACKFullMatrixExt<Number> ZF;
    // The result matrix type for the multiplication involving leaf node.
    HMatrixType result_matrix_type = UndefinedMatrixType;

    if (M1.bc_node->is_leaf() || M2.bc_node->is_leaf())
      {
        /**
         * When either operand \p M1 or \p M2 is a leaf node, directly evaluation
         * of their multiplication can be performed.
         */
        if (M1.type == RkMatrixType)
          {
            rk_h_mmult(alpha, *(M1.rkmatrix), M2, ZR);
            result_matrix_type = RkMatrixType;
          }
        else if (M2.type == RkMatrixType)
          {
            h_rk_mmult(alpha, M1, *(M2.rkmatrix), ZR);
            result_matrix_type = RkMatrixType;
          }
        else if (M1.type == FullMatrixType)
          {
            f_h_mmult(alpha, *(M1.fullmatrix), M2, ZF);
            result_matrix_type = FullMatrixType;
          }
        else if (M2.type == FullMatrixType)
          {
            h_f_mmult(alpha, M1, *(M2.fullmatrix), ZF);
            result_matrix_type = FullMatrixType;
          }
        else
          {
            Assert(false, ExcInternalError());
            result_matrix_type = UndefinedMatrixType;
          }

        if (Z.type == RkMatrixType)
          {
            // The desired result should be a rank-k matrix.
            if (result_matrix_type == RkMatrixType)
              {
                *(Z.rkmatrix) = ZR;
              }
            else if (result_matrix_type == FullMatrixType)
              {
                // Convert the full matrix to rank-k matrix.
                *(Z.rkmatrix) = RkMatrix<Number>(fixed_rank, ZF);
              }
            else
              {
                Assert(false, ExcInvalidHMatrixType(result_matrix_type));
              }
          }
        else if (Z.type == FullMatrixType)
          {
            // The desired result should be a full matrix.
            if (result_matrix_type == RkMatrixType)
              {
                // Convert the rank-k matrix to full matrix.
                ZR.convertToFullMatrix(*(Z.fullmatrix));
              }
            else if (result_matrix_type == FullMatrixType)
              {
                *(Z.fullmatrix) = ZF;
              }
            else
              {
                Assert(false, ExcInvalidHMatrixType(result_matrix_type));
              }

            /**
             * If the local product \hmatrix @p Z is expected to be symmetric or
             * lower triangular, also set the property of the associated full
             * matrix correspondingly. This operation is mandatory because the
             * property of the local full matrix @p ZF is @p general, which has
             * overwritten the property of @p Z.
             */
            if (is_result_matrix_Z_store_tril_only)
              {
                switch (Z.property)
                  {
                      case HMatrixSupport::symmetric: {
                        Z.fullmatrix->set_property(LAPACKSupport::symmetric);

                        break;
                      }
                      case HMatrixSupport::lower_triangular: {
                        Z.fullmatrix->set_property(
                          LAPACKSupport::lower_triangular);

                        break;
                      }
                      default: {
                        Assert(false, ExcInvalidHMatrixProperty(Z.property));

                        break;
                      }
                  }
              }
          }
        else
          {
            Assert(false, ExcInvalidHMatrixType(Z.type));
          }
      }
    else
      {
        /**
         * In this case, both @p M1 and @p M2 have child submatrices.
         *
         * \alert{When we perform submatrix multiplication, we use a higher
         * specified rank, since the results will be assembled into the larger
         * matrix \p Z via pairwise formatted addition, during which the actual
         * matrix rank may increase.}
         */
        const unsigned int local_fixed_rank =
          std::min(fixed_rank * 2, std::min(Z.m, Z.n));

        std::array<HMatrixSupport::BlockType,
                   BlockClusterTree<spacedim, Number>::child_num>
          block_types_for_submatrices_of_local_Z;
        HMatrixSupport::infer_submatrix_block_types_from_parent_hmat(
          block_type_for_local_Z, block_types_for_submatrices_of_local_Z);

        h_h_mmult_from_leaf_node(M0,
                                 Z,
                                 alpha,
                                 *(M1.submatrices[0]),
                                 *(M2.submatrices[0]),
                                 block_types_for_submatrices_of_local_Z[0],
                                 local_fixed_rank,
                                 is_result_matrix_Z_store_tril_only);
        h_h_mmult_from_leaf_node(M0,
                                 Z,
                                 alpha,
                                 *(M1.submatrices[1]),
                                 *(M2.submatrices[2]),
                                 block_types_for_submatrices_of_local_Z[0],
                                 local_fixed_rank,
                                 is_result_matrix_Z_store_tril_only);

        if ((!is_result_matrix_Z_store_tril_only) ||
            (is_result_matrix_Z_store_tril_only &&
             Z.property != HMatrixSupport::symmetric &&
             Z.property != HMatrixSupport::lower_triangular))
          {
            /**
             * The virtual submatrix block @p Z.submatrices[1], which is obtained
             * from the cross type multiplication of @p M1 and @p M2, will be
             * evaluated in two scenarios:
             * 1. when the result matrix is not expected to be symmetric;
             * 2. when the result matrix is required to be symmetric a priori,
             * then if the product matrix @p M is not symmetric.
             *
             * Here the "virtual" above means even though @p Z is actually not
             * further divided and have no submatrices, the cross type
             * multiplication will generate submatrix blocks virtually.
             */
            h_h_mmult_from_leaf_node(M0,
                                     Z,
                                     alpha,
                                     *(M1.submatrices[0]),
                                     *(M2.submatrices[1]),
                                     block_types_for_submatrices_of_local_Z[1],
                                     local_fixed_rank,
                                     is_result_matrix_Z_store_tril_only);
            h_h_mmult_from_leaf_node(M0,
                                     Z,
                                     alpha,
                                     *(M1.submatrices[1]),
                                     *(M2.submatrices[3]),
                                     block_types_for_submatrices_of_local_Z[1],
                                     local_fixed_rank,
                                     is_result_matrix_Z_store_tril_only);
          }

        h_h_mmult_from_leaf_node(M0,
                                 Z,
                                 alpha,
                                 *(M1.submatrices[2]),
                                 *(M2.submatrices[0]),
                                 block_types_for_submatrices_of_local_Z[2],
                                 local_fixed_rank,
                                 is_result_matrix_Z_store_tril_only);
        h_h_mmult_from_leaf_node(M0,
                                 Z,
                                 alpha,
                                 *(M1.submatrices[3]),
                                 *(M2.submatrices[2]),
                                 block_types_for_submatrices_of_local_Z[2],
                                 local_fixed_rank,
                                 is_result_matrix_Z_store_tril_only);

        h_h_mmult_from_leaf_node(M0,
                                 Z,
                                 alpha,
                                 *(M1.submatrices[2]),
                                 *(M2.submatrices[1]),
                                 block_types_for_submatrices_of_local_Z[3],
                                 local_fixed_rank,
                                 is_result_matrix_Z_store_tril_only);
        h_h_mmult_from_leaf_node(M0,
                                 Z,
                                 alpha,
                                 *(M1.submatrices[3]),
                                 *(M2.submatrices[3]),
                                 block_types_for_submatrices_of_local_Z[3],
                                 local_fixed_rank,
                                 is_result_matrix_Z_store_tril_only);
      }

    /**
     * Assemble the local matrix \p Z to the product matrix \p M.
     */
    if (M0.bc_node->get_data_reference().get_is_near_field())
      {
        /**
         * When the original matrix \p M0 belongs to the near field, assemble the
         * full matrix stored in \p Z directly into \p M.
         */
        Assert(M.fullmatrix, ExcInternalError());

        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.block_type != HMatrixSupport::upper_triangular_block &&
             Z.block_type != HMatrixSupport::upper_triangular_block))
          {
            M.fullmatrix->fill(*(Z.fullmatrix),
                               (*Z.row_index_range)[0] -
                                 (*M.row_index_range)[0],
                               (*Z.col_index_range)[0] -
                                 (*M.col_index_range)[0],
                               0,
                               0,
                               1.0,
                               false,
                               true);
          }
      }
    else
      {
        /**
         * When the original matrix \p M0 does not belong to the near field,
         * assemble the rank-k matrix stored in \p Z into \p M by first embedding
         * then formatted addition, which has been implemented in the member
         * function \p assemble_from_rkmatrix.
         */
        Assert(M.rkmatrix, ExcInternalError());

        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.block_type != HMatrixSupport::upper_triangular_block &&
             Z.block_type != HMatrixSupport::upper_triangular_block))
          {
            M.rkmatrix->assemble_from_rkmatrix(*M.row_index_range,
                                               *M.col_index_range,
                                               *(Z.rkmatrix),
                                               *(Z.row_index_range),
                                               *(Z.col_index_range),
                                               fixed_rank);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  h_h_mmult_from_leaf_node_for_parallel_lu(
    HMatrix<spacedim, Number>      &M0,
    HMatrix<spacedim, Number>      &M,
    const Number                    alpha,
    HMatrix<spacedim, Number>      &M1,
    HMatrix<spacedim, Number>      &M2,
    const HMatrixSupport::BlockType block_type_for_local_Z,
    const unsigned int              fixed_rank,
    const bool                      is_result_matrix_store_tril_only = false)
  {
    /**
     * Here we make an assertion that the top level result \hmatrix @p M0 should
     * be a leaf node.
     */
    Assert(M0.bc_node->is_leaf(), ExcMessage("M0 should be a leaf node!"));

    if (is_result_matrix_store_tril_only)
      {
        Assert(M0.get_property() == HMatrixSupport::symmetric ||
                 M0.get_property() == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(M0.get_property()));
        Assert(M0.get_block_type() == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(M0.get_block_type()));
        Assert(M.get_property() == HMatrixSupport::symmetric ||
                 M.get_property() == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(M.get_property()));
        Assert(M.get_block_type() == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(M.get_block_type()));
      }

    // Array of empty child pointers used for initializing a block
    // cluster tree node.
    const std::array<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type,
      BlockClusterTree<spacedim, Number>::child_num>
      empty_child_pointers{{nullptr, nullptr, nullptr, nullptr}};

    /**
     * Create a \bcn \f$\tau\times\rho\f$ for the current local product matrix
     * \p Z. Since this \bcn will not be connected with other \bcns in a \bct,
     * it has neither parent nor children and its level is set to zero.
     */
    typename BlockClusterTree<spacedim, Number>::node_value_type
      current_product_bc_node(
        BlockCluster<spacedim, Number>(
          M1.bc_node->get_data_reference().get_tau_node(),
          M2.bc_node->get_data_reference().get_sigma_node()),
        0,
        empty_child_pointers,
        nullptr,
        UnsplitMode);

    /**
     * Set the \p is_near_field flag of the \bcn for the current local product
     * matrix \p Z according to the matrix type of the initial leaf node \hmatrix
     * \p M0, i.e. it inherits the \p is_near_field flag of the \bcn for \p M0.
     */
    if (M0.bc_node->get_data_reference().get_is_near_field())
      {
        Assert(M0.type == FullMatrixType, ExcInvalidHMatrixType(M0.type));

        current_product_bc_node.get_data_reference().set_is_near_field(true);
      }
    else
      {
        Assert(M0.type == RkMatrixType, ExcInvalidHMatrixType(M0.type));

        current_product_bc_node.get_data_reference().set_is_near_field(false);
      }

    /**
     * When the flag @p is_result_matrix_store_tril_only is true, determine if
     * the \hmatrix property of the local product \hmatrix @p Z should be the
     * same as that of @p M by checking if the index ranges of its \f$\tau\f$
     * node and \f$\sigma\f$ are the same, since only when they are the same,
     * @p Z or @p M's property can be symmetric or lower triangular.
     */
    HMatrixSupport::Property Z_property = HMatrixSupport::general;
    bool                     is_result_matrix_Z_store_tril_only = false;

    if (is_result_matrix_store_tril_only &&
        (*M1.get_row_index_range() == *M2.get_col_index_range()))
      {
        /**
         * The local product \hmatrix @p Z inherits the property of @p M, which
         * can be either symmetric or lower triangular.
         */
        Z_property                         = M.property;
        is_result_matrix_Z_store_tril_only = true;

        /**
         * If the local \hmatrix @p Z is symmetric or lower triangular, its block
         * type should be @p diagonal_block and an assertion is made about this
         * fact.
         */
        Assert(block_type_for_local_Z == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(block_type_for_local_Z));
      }


    /**
     * Create the local product \hmatrix \p Z associated with the current \bcn.
     * During its initialization, memory will be allocated depending on its
     * \hmatrix property and block type.
     */
    HMatrix<spacedim, Number> Z(&current_product_bc_node,
                                fixed_rank,
                                Z_property,
                                block_type_for_local_Z);
    // Local variable storing the rank-k matrix obtained from multiplication
    // involving leaf node.
    RkMatrix<Number> ZR;
    // Local variable storing the full matrix obtained from multiplication
    // involving leaf node.
    LAPACKFullMatrixExt<Number> ZF;
    // The result matrix type for the multiplication involving leaf node.
    HMatrixType result_matrix_type = UndefinedMatrixType;

    if (M1.bc_node->is_leaf() || M2.bc_node->is_leaf())
      {
        /**
         * When either operand \p M1 or \p M2 is a leaf node, directly evaluation
         * of their multiplication can be performed.
         */
        if (M1.type == RkMatrixType)
          {
            rk_h_mmult(alpha, *(M1.rkmatrix), M2, ZR);
            result_matrix_type = RkMatrixType;
          }
        else if (M2.type == RkMatrixType)
          {
            h_rk_mmult(alpha, M1, *(M2.rkmatrix), ZR);
            result_matrix_type = RkMatrixType;
          }
        else if (M1.type == FullMatrixType)
          {
            f_h_mmult(alpha, *(M1.fullmatrix), M2, ZF);
            result_matrix_type = FullMatrixType;
          }
        else if (M2.type == FullMatrixType)
          {
            h_f_mmult(alpha, M1, *(M2.fullmatrix), ZF);
            result_matrix_type = FullMatrixType;
          }
        else
          {
            Assert(false, ExcInternalError());
            result_matrix_type = UndefinedMatrixType;
          }

        if (Z.type == RkMatrixType)
          {
            // The desired result should be a rank-k matrix.
            if (result_matrix_type == RkMatrixType)
              {
                *(Z.rkmatrix) = ZR;
              }
            else if (result_matrix_type == FullMatrixType)
              {
                // Convert the full matrix to rank-k matrix.
                *(Z.rkmatrix) = RkMatrix<Number>(fixed_rank, ZF);
              }
            else
              {
                Assert(false, ExcInvalidHMatrixType(result_matrix_type));
              }
          }
        else if (Z.type == FullMatrixType)
          {
            // The desired result should be a full matrix.
            if (result_matrix_type == RkMatrixType)
              {
                // Convert the rank-k matrix to full matrix.
                ZR.convertToFullMatrix(*(Z.fullmatrix));
              }
            else if (result_matrix_type == FullMatrixType)
              {
                *(Z.fullmatrix) = ZF;
              }
            else
              {
                Assert(false, ExcInvalidHMatrixType(result_matrix_type));
              }

            /**
             * If the local product \hmatrix @p Z is expected to be symmetric or
             * lower triangular, also set the property of the associated full
             * matrix correspondingly. This operation is mandatory because the
             * property of the local full matrix @p ZF is @p general, which has
             * overwritten the property of @p Z.
             */
            if (is_result_matrix_Z_store_tril_only)
              {
                switch (Z.property)
                  {
                      case HMatrixSupport::symmetric: {
                        Z.fullmatrix->set_property(LAPACKSupport::symmetric);

                        break;
                      }
                      case HMatrixSupport::lower_triangular: {
                        Z.fullmatrix->set_property(
                          LAPACKSupport::lower_triangular);

                        break;
                      }
                      default: {
                        Assert(false, ExcInvalidHMatrixProperty(Z.property));

                        break;
                      }
                  }
              }
          }
        else
          {
            Assert(false, ExcInvalidHMatrixType(Z.type));
          }
      }
    else
      {
        /**
         * In this case, both @p M1 and @p M2 have child submatrices.
         *
         * \alert{When we perform submatrix multiplication, we use a higher
         * specified rank, since the results will be assembled into the larger
         * matrix \p Z via pairwise formatted addition, during which the actual
         * matrix rank may increase.}
         */
        const unsigned int local_fixed_rank =
          std::min(fixed_rank * 2, std::min(Z.m, Z.n));

        std::array<HMatrixSupport::BlockType,
                   BlockClusterTree<spacedim, Number>::child_num>
          block_types_for_submatrices_of_local_Z;
        HMatrixSupport::infer_submatrix_block_types_from_parent_hmat(
          block_type_for_local_Z, block_types_for_submatrices_of_local_Z);

        h_h_mmult_from_leaf_node_for_parallel_lu(
          M0,
          Z,
          alpha,
          *(M1.submatrices[0]),
          *(M2.submatrices[0]),
          block_types_for_submatrices_of_local_Z[0],
          local_fixed_rank,
          is_result_matrix_Z_store_tril_only);
        h_h_mmult_from_leaf_node_for_parallel_lu(
          M0,
          Z,
          alpha,
          *(M1.submatrices[1]),
          *(M2.submatrices[2]),
          block_types_for_submatrices_of_local_Z[0],
          local_fixed_rank,
          is_result_matrix_Z_store_tril_only);

        if ((!is_result_matrix_Z_store_tril_only) ||
            (is_result_matrix_Z_store_tril_only &&
             Z.property != HMatrixSupport::symmetric &&
             Z.property != HMatrixSupport::lower_triangular))
          {
            /**
             * The virtual submatrix block @p Z.submatrices[1], which is obtained
             * from the cross type multiplication of @p M1 and @p M2, will be
             * evaluated in two scenarios:
             * 1. when the result matrix is not expected to be symmetric;
             * 2. when the result matrix is required to be symmetric a priori,
             * then if the product matrix @p M is not symmetric.
             *
             * Here the "virtual" above means even though @p Z is actually not
             * further divided and have no submatrices, the cross type
             * multiplication will generate submatrix blocks virtually.
             */
            h_h_mmult_from_leaf_node_for_parallel_lu(
              M0,
              Z,
              alpha,
              *(M1.submatrices[0]),
              *(M2.submatrices[1]),
              block_types_for_submatrices_of_local_Z[1],
              local_fixed_rank,
              is_result_matrix_Z_store_tril_only);
            h_h_mmult_from_leaf_node_for_parallel_lu(
              M0,
              Z,
              alpha,
              *(M1.submatrices[1]),
              *(M2.submatrices[3]),
              block_types_for_submatrices_of_local_Z[1],
              local_fixed_rank,
              is_result_matrix_Z_store_tril_only);
          }

        h_h_mmult_from_leaf_node_for_parallel_lu(
          M0,
          Z,
          alpha,
          *(M1.submatrices[2]),
          *(M2.submatrices[0]),
          block_types_for_submatrices_of_local_Z[2],
          local_fixed_rank,
          is_result_matrix_Z_store_tril_only);
        h_h_mmult_from_leaf_node_for_parallel_lu(
          M0,
          Z,
          alpha,
          *(M1.submatrices[3]),
          *(M2.submatrices[2]),
          block_types_for_submatrices_of_local_Z[2],
          local_fixed_rank,
          is_result_matrix_Z_store_tril_only);

        h_h_mmult_from_leaf_node_for_parallel_lu(
          M0,
          Z,
          alpha,
          *(M1.submatrices[2]),
          *(M2.submatrices[1]),
          block_types_for_submatrices_of_local_Z[3],
          local_fixed_rank,
          is_result_matrix_Z_store_tril_only);
        h_h_mmult_from_leaf_node_for_parallel_lu(
          M0,
          Z,
          alpha,
          *(M1.submatrices[3]),
          *(M2.submatrices[3]),
          block_types_for_submatrices_of_local_Z[3],
          local_fixed_rank,
          is_result_matrix_Z_store_tril_only);
      }

    /**
     * Assemble the local matrix \p Z to the product matrix \p M.
     */
    if (M0.bc_node->get_data_reference().get_is_near_field())
      {
        /**
         * When the original matrix \p M0 belongs to the near field, assemble the
         * full matrix stored in \p Z directly into \p M.
         */
        Assert(M.fullmatrix, ExcInternalError());

        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.block_type != HMatrixSupport::upper_triangular_block &&
             Z.block_type != HMatrixSupport::upper_triangular_block))
          {
            /**
             * Only when the result matrix @p M is the top level result matrix
             * @p M0, the mutex will be locked. Otherwise, the result matrix
             * @p M is only a temporary object, which needs not be locked.
             */
            std::unique_lock<std::mutex> ul(M0.update_lock, std::defer_lock);
            if (&M0 == &M)
              {
                ul.lock();
              }

            M.fullmatrix->fill(*(Z.fullmatrix),
                               (*Z.row_index_range)[0] -
                                 (*M.row_index_range)[0],
                               (*Z.col_index_range)[0] -
                                 (*M.col_index_range)[0],
                               0,
                               0,
                               1.0,
                               false,
                               true);
          }
      }
    else
      {
        /**
         * When the original matrix \p M0 does not belong to the near field,
         * assemble the rank-k matrix stored in \p Z into \p M by first embedding
         * then formatted addition, which has been implemented in the member
         * function \p assemble_from_rkmatrix.
         */
        Assert(M.rkmatrix, ExcInternalError());

        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.block_type != HMatrixSupport::upper_triangular_block &&
             Z.block_type != HMatrixSupport::upper_triangular_block))
          {
            /**
             * Only when the result matrix @p M is the top level result matrix
             * @p M0, the mutex will be locked. Otherwise, the result matrix
             * @p M is only a temporary object, which needs not be locked.
             */
            std::unique_lock<std::mutex> ul(M0.update_lock, std::defer_lock);
            if (&M0 == &M)
              {
                ul.lock();

#if ARENA_OR_ISOLATE_IN_LU_AND_CHOL == 3
                M.rkmatrix->assemble_from_rkmatrix(*M.row_index_range,
                                                   *M.col_index_range,
                                                   *(Z.rkmatrix),
                                                   *(Z.row_index_range),
                                                   *(Z.col_index_range),
                                                   fixed_rank);
#endif

#if ARENA_OR_ISOLATE_IN_LU_AND_CHOL == 1
                tbb::task_arena ta{ARENA_MAX_CONCURRENCY_IN_LU_AND_CHOL};
                ta.execute([&M, &Z, fixed_rank] {
                  M.rkmatrix->assemble_from_rkmatrix(*M.row_index_range,
                                                     *M.col_index_range,
                                                     *(Z.rkmatrix),
                                                     *(Z.row_index_range),
                                                     *(Z.col_index_range),
                                                     fixed_rank);
                });
#endif

#if ARENA_OR_ISOLATE_IN_LU_AND_CHOL == 2
                /**
                 * There will be nested parallelism from deal.ii library in the
                 * following function call. Hence, it should be isolated.
                 */
                tbb::this_task_arena::isolate([&M, &Z, fixed_rank] {
                  M.rkmatrix->assemble_from_rkmatrix(*M.row_index_range,
                                                     *M.col_index_range,
                                                     *(Z.rkmatrix),
                                                     *(Z.row_index_range),
                                                     *(Z.col_index_range),
                                                     fixed_rank);
                });
#endif
              }
            else
              {
                M.rkmatrix->assemble_from_rkmatrix(*M.row_index_range,
                                                   *M.col_index_range,
                                                   *(Z.rkmatrix),
                                                   *(Z.row_index_range),
                                                   *(Z.col_index_range),
                                                   fixed_rank);
              }
          }
      }
  }


  /**
   * \hmatrix-\hmatrix multiplication with the second operand transposed,
   * when the product matrix belongs to the leaf set of the target \bct.
   *
   * This function implements the recursive \p MMR algorithm in (7.26) in
   * Hackbusch's \hmatrix book.
   *
   * @param M0 The initial product matrix on the \bcn \f$\tau_0\times\rho_0\f$.
   * @param M The current product matrix \f$M\f$ on the \bcn \f$\tau\times\rho\f$,
   * which will assembles the contribution from \f$M_1 \cdot M_2^T\f$ (N.B. This
   * description is only valid for the first call of this function. During
   * recursive calls of this function, @p M may not be on a same level as the
   * product of @p M1 and @p M2, when both @p M1 and @p M2 have substructures and
   * the multiplication needs to collect results from the multiplications of
   * submatrices). For the first call of this function, \p M is the same as
   * \p M0.
   * @param M1 The first operand of the multiplication, which is built upon the
   * \bcn \f$\tau\times\sigma\f$.
   * @param M2 The second operand of the multiplication, which is built upon the
   * \bcn \f$\rho\times\sigma\f$.
   * @param block_type_for_local_Z Block type for the local \hmatrix @p Z, which
   * is the product of @p M1 and @p M2.
   * @param fixed_rank
   * @param is_result_matrix_store_tril_only Flag indicating whether only the
   * lower triangular part and the diagonal part of the \hmatrix @p M are stored.
   * The naming of this variable follows the convention adopted by GNU Octave,
   * where a lower triangular matrix has nonzero entries only on the main
   * diagonal
   * and below. See @p tril and @p istril function in GNU Octave.
   */
  template <int spacedim, typename Number>
  void
  h_h_mTmult_from_leaf_node(
    HMatrix<spacedim, Number>      &M0,
    HMatrix<spacedim, Number>      &M,
    HMatrix<spacedim, Number>      &M1,
    HMatrix<spacedim, Number>      &M2,
    const HMatrixSupport::BlockType block_type_for_local_Z,
    const unsigned int              fixed_rank,
    const bool                      is_result_matrix_store_tril_only = false)
  {
    /**
     * Here we make an assertion that the top level result \hmatrix @p M0 should
     * be a leaf node.
     */
    Assert(M0.bc_node->is_leaf(), ExcMessage("M0 should be a leaf node!"));

    if (is_result_matrix_store_tril_only)
      {
        Assert(M0.get_property() == HMatrixSupport::symmetric ||
                 M0.get_property() == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(M0.get_property()));
        Assert(M0.get_block_type() == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(M0.get_block_type()));
        Assert(M.get_property() == HMatrixSupport::symmetric ||
                 M.get_property() == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(M.get_property()));
        Assert(M.get_block_type() == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(M.get_block_type()));
      }

    // Array of empty child pointers used for initializing a block
    // cluster tree node.
    const std::array<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type,
      BlockClusterTree<spacedim, Number>::child_num>
      empty_child_pointers{{nullptr, nullptr, nullptr, nullptr}};

    /**
     * Create a \bcn \f$\tau\times\rho\f$ for the current local product matrix
     * \p Z. Since this \bcn will not be connected with other \bcns in a \bct,
     * it has neither parent nor children and its level is set to zero.
     *
     * \alert{Because the current multiplication is \f$M_1\cdot M_2^T\f$, the
     * product \bctnode is built from \f$\tau\f$ of \f$M_1\f$ and \f$\tau\f$ of
     * \f$M_2\f$.}
     */
    typename BlockClusterTree<spacedim, Number>::node_value_type
      current_product_bc_node(
        BlockCluster<spacedim, Number>(
          M1.bc_node->get_data_reference().get_tau_node(),
          M2.bc_node->get_data_reference().get_tau_node()),
        0,
        empty_child_pointers,
        nullptr,
        UnsplitMode);

    /**
     * Set the \p is_near_field flag of the \bcn for the current local product
     * matrix \p Z according to the matrix type of the initial leaf node \hmatrix
     * \p M0, i.e. it inherits the \p is_near_field flag of the \bcn for \p M0.
     */
    if (M0.bc_node->get_data_reference().get_is_near_field())
      {
        Assert(M0.type == FullMatrixType, ExcInvalidHMatrixType(M0.type));

        current_product_bc_node.get_data_reference().set_is_near_field(true);
      }
    else
      {
        Assert(M0.type == RkMatrixType, ExcInvalidHMatrixType(M0.type));

        current_product_bc_node.get_data_reference().set_is_near_field(false);
      }

    /**
     * When the flag @p is_result_matrix_store_tril_only is true, determine if
     * the \hmatrix property of the local product \hmatrix @p Z should be the
     * same as that of @p M by checking if the index ranges of its \f$\tau\f$
     * node and \f$\sigma\f$ are the same, since only when they are the same,
     * @p Z or @p M's property can be symmetric or lower triangular.
     */
    HMatrixSupport::Property Z_property = HMatrixSupport::general;
    bool                     is_result_matrix_Z_store_tril_only = false;

    if (is_result_matrix_store_tril_only &&
        (*M1.get_row_index_range() == *M2.get_row_index_range()))
      {
        /**
         * The local product \hmatrix @p Z inherits the property of @p M, which
         * can be either symmetric or lower triangular.
         */
        Z_property                         = M.property;
        is_result_matrix_Z_store_tril_only = true;

        /**
         * If the local \hmatrix @p Z is symmetric or lower triangular, its block
         * type should be @p diagonal_block and an assertion is made about this
         * fact.
         */
        Assert(block_type_for_local_Z == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(block_type_for_local_Z));
      }

    /**
     * Create the local product \hmatrix \p Z associated with the current \bcn.
     * During its initialization, memory will be allocated depending on its
     * \hmatrix property and block type.
     */
    HMatrix<spacedim, Number> Z(&current_product_bc_node,
                                fixed_rank,
                                Z_property,
                                block_type_for_local_Z);
    // Local variable storing the rank-k matrix obtained from multiplication
    // involving leaf node.
    RkMatrix<Number> ZR;
    // Local variable storing the full matrix obtained from multiplication
    // involving leaf node.
    LAPACKFullMatrixExt<Number> ZF;
    // The result matrix type for the multiplication involving leaf node.
    HMatrixType result_matrix_type = UndefinedMatrixType;

    if (M1.bc_node->is_leaf() || M2.bc_node->is_leaf())
      {
        /**
         * When either operand \p M1 or \p M2 is a leaf node, directly evaluation
         * of their multiplication can be performed.
         */
        if (M1.type == RkMatrixType)
          {
            rk_h_mTmult(*(M1.rkmatrix), M2, ZR);
            result_matrix_type = RkMatrixType;
          }
        else if (M2.type == RkMatrixType)
          {
            h_rk_mTmult(M1, *(M2.rkmatrix), ZR);
            result_matrix_type = RkMatrixType;
          }
        else if (M1.type == FullMatrixType)
          {
            f_h_mTmult(*(M1.fullmatrix), M2, ZF);
            result_matrix_type = FullMatrixType;
          }
        else if (M2.type == FullMatrixType)
          {
            h_f_mTmult(M1, *(M2.fullmatrix), ZF);
            result_matrix_type = FullMatrixType;
          }
        else
          {
            Assert(false, ExcInternalError());
            result_matrix_type = UndefinedMatrixType;
          }

        if (Z.type == RkMatrixType)
          {
            // The desired result should be a rank-k matrix.
            if (result_matrix_type == RkMatrixType)
              {
                *(Z.rkmatrix) = ZR;
              }
            else if (result_matrix_type == FullMatrixType)
              {
                // Convert the full matrix to rank-k matrix.
                *(Z.rkmatrix) = RkMatrix<Number>(fixed_rank, ZF);
              }
            else
              {
                Assert(false, ExcInvalidHMatrixType(result_matrix_type));
              }
          }
        else if (Z.type == FullMatrixType)
          {
            // The desired result should be a full matrix.
            if (result_matrix_type == RkMatrixType)
              {
                // Convert the rank-k matrix to full matrix.
                ZR.convertToFullMatrix(*(Z.fullmatrix));
              }
            else if (result_matrix_type == FullMatrixType)
              {
                *(Z.fullmatrix) = ZF;
              }
            else
              {
                Assert(false, ExcInvalidHMatrixType(result_matrix_type));
              }

            /**
             * If the local product \hmatrix @p Z is expected to be symmetric or
             * lower triangular, also set the property of the associated full
             * matrix correspondingly. This operation is mandatory because the
             * property of the local full matrix @p ZF is @p general, which has
             * overwritten the property of @p Z.
             */
            if (is_result_matrix_Z_store_tril_only)
              {
                switch (Z.property)
                  {
                      case HMatrixSupport::symmetric: {
                        Z.fullmatrix->set_property(LAPACKSupport::symmetric);

                        break;
                      }
                      case HMatrixSupport::lower_triangular: {
                        Z.fullmatrix->set_property(
                          LAPACKSupport::lower_triangular);

                        break;
                      }
                      default: {
                        Assert(false, ExcInvalidHMatrixProperty(Z.property));

                        break;
                      }
                  }
              }
          }
        else
          {
            Assert(false, ExcInvalidHMatrixType(Z.type));
          }
      }
    else
      {
        /**
         * In this case, both @p M1 and @p M2 have child submatrices.
         *
         * \alert{When we perform submatrix multiplication, we use a higher
         * specified rank, since the results will be assembled into the larger
         * matrix \p Z via pairwise formatted addition, during which the actual
         * matrix rank may increase.}
         */
        const unsigned int local_fixed_rank =
          std::min(fixed_rank * 2, std::min(Z.m, Z.n));

        std::array<HMatrixSupport::BlockType,
                   BlockClusterTree<spacedim, Number>::child_num>
          block_types_for_submatrices_of_local_Z;
        HMatrixSupport::infer_submatrix_block_types_from_parent_hmat(
          block_type_for_local_Z, block_types_for_submatrices_of_local_Z);

        h_h_mTmult_from_leaf_node(M0,
                                  Z,
                                  *(M1.submatrices[0]),
                                  *(M2.submatrices[0]),
                                  block_types_for_submatrices_of_local_Z[0],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);
        h_h_mTmult_from_leaf_node(M0,
                                  Z,
                                  *(M1.submatrices[1]),
                                  *(M2.submatrices[1]),
                                  block_types_for_submatrices_of_local_Z[0],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);

        if ((!is_result_matrix_Z_store_tril_only) ||
            (is_result_matrix_Z_store_tril_only &&
             Z.property != HMatrixSupport::symmetric &&
             Z.property != HMatrixSupport::lower_triangular))
          {
            /**
             * The submatrix block @p Z.submatrices[1], which is obtained
             * from the cross type multiplication of @p M1 and @p M2, will be
             * evaluated in two scenarios:
             * 1. when the \hmatrix @p M is not expected to be symmetric or lower
             * triangular;
             * 2. when the \hmatrix @p M is required to be symmetric or lower
             * triangular a priori, and the product matrix @p Z should not be
             * symmetric or lower triangular.
             */
            h_h_mTmult_from_leaf_node(M0,
                                      Z,
                                      *(M1.submatrices[0]),
                                      *(M2.submatrices[2]),
                                      block_types_for_submatrices_of_local_Z[1],
                                      local_fixed_rank,
                                      is_result_matrix_Z_store_tril_only);
            h_h_mTmult_from_leaf_node(M0,
                                      Z,
                                      *(M1.submatrices[1]),
                                      *(M2.submatrices[3]),
                                      block_types_for_submatrices_of_local_Z[1],
                                      local_fixed_rank,
                                      is_result_matrix_Z_store_tril_only);
          }

        h_h_mTmult_from_leaf_node(M0,
                                  Z,
                                  *(M1.submatrices[2]),
                                  *(M2.submatrices[0]),
                                  block_types_for_submatrices_of_local_Z[2],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);
        h_h_mTmult_from_leaf_node(M0,
                                  Z,
                                  *(M1.submatrices[3]),
                                  *(M2.submatrices[1]),
                                  block_types_for_submatrices_of_local_Z[2],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);

        h_h_mTmult_from_leaf_node(M0,
                                  Z,
                                  *(M1.submatrices[2]),
                                  *(M2.submatrices[2]),
                                  block_types_for_submatrices_of_local_Z[3],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);
        h_h_mTmult_from_leaf_node(M0,
                                  Z,
                                  *(M1.submatrices[3]),
                                  *(M2.submatrices[3]),
                                  block_types_for_submatrices_of_local_Z[3],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);
      }

    /**
     * Assemble the local matrix \p Z to the product matrix \p M.
     */
    if (M0.bc_node->get_data_reference().get_is_near_field())
      {
        /**
         * When the original matrix \p M0 belongs to the near field, assemble the
         * full matrix stored in \p Z directly into \p M.
         */
        Assert(M.fullmatrix, ExcInternalError());

        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.block_type != HMatrixSupport::upper_triangular_block &&
             Z.block_type != HMatrixSupport::upper_triangular_block))
          {
            M.fullmatrix->fill(*(Z.fullmatrix),
                               (*Z.row_index_range)[0] -
                                 (*M.row_index_range)[0],
                               (*Z.col_index_range)[0] -
                                 (*M.col_index_range)[0],
                               0,
                               0,
                               1.0,
                               false,
                               true);
          }
      }
    else
      {
        /**
         * When the original matrix \p M0 does not belong to the near field,
         * assemble the rank-k matrix stored in \p Z into \p M by first embedding
         * then formatted addition, which has been implemented in the member
         * function \p assemble_from_rkmatrix.
         */
        Assert(M.rkmatrix, ExcInternalError());

        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.block_type != HMatrixSupport::upper_triangular_block &&
             Z.block_type != HMatrixSupport::upper_triangular_block))
          {
            M.rkmatrix->assemble_from_rkmatrix(*M.row_index_range,
                                               *M.col_index_range,
                                               *(Z.rkmatrix),
                                               *(Z.row_index_range),
                                               *(Z.col_index_range),
                                               fixed_rank);
          }
      }
  }


  /**
   * \hmatrix-\hmatrix multiplication with the second operand transposed,
   * when the product matrix belongs to the leaf set of the target \bct.
   *
   * This function implements the recursive \p MMR algorithm in (7.26) in
   * Hackbusch's \hmatrix book.
   *
   * @param M0 The initial product matrix on the \bcn \f$\tau_0\times\rho_0\f$.
   * @param M The current product matrix \f$M\f$ on the \bcn \f$\tau\times\rho\f$,
   * which will assembles the contribution from \f$M_1 \cdot M_2^T\f$ (N.B. This
   * description is only valid for the first call of this function. During
   * recursive calls of this function, @p M may not be on a same level as the
   * product of @p M1 and @p M2, when both @p M1 and @p M2 have substructures and
   * the multiplication needs to collect results from the multiplications of
   * submatrices). For the first call of this function, \p M is the same as
   * \p M0.
   * @param alpha
   * @param M1 The first operand of the multiplication, which is built upon the
   * \bcn \f$\tau\times\sigma\f$.
   * @param M2 The second operand of the multiplication, which is built upon the
   * \bcn \f$\rho\times\sigma\f$.
   * @param block_type_for_local_Z Block type for the local \hmatrix @p Z, which
   * is the product of @p M1 and @p M2.
   * @param fixed_rank
   * @param is_result_matrix_store_tril_only Flag indicating whether only the
   * lower triangular part and the diagonal part of the \hmatrix @p M are stored.
   * The naming of this variable follows the convention adopted by GNU Octave,
   * where a lower triangular matrix has nonzero entries only on the main
   * diagonal
   * and below. See @p tril and @p istril function in GNU Octave.
   */
  template <int spacedim, typename Number>
  void
  h_h_mTmult_from_leaf_node(
    HMatrix<spacedim, Number>      &M0,
    HMatrix<spacedim, Number>      &M,
    const Number                    alpha,
    HMatrix<spacedim, Number>      &M1,
    HMatrix<spacedim, Number>      &M2,
    const HMatrixSupport::BlockType block_type_for_local_Z,
    const unsigned int              fixed_rank,
    const bool                      is_result_matrix_store_tril_only = false)
  {
    /**
     * Here we make an assertion that the top level result \hmatrix @p M0 should
     * be a leaf node.
     */
    Assert(M0.bc_node->is_leaf(), ExcMessage("M0 should be a leaf node!"));

    if (is_result_matrix_store_tril_only)
      {
        Assert(M0.get_property() == HMatrixSupport::symmetric ||
                 M0.get_property() == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(M0.get_property()));
        Assert(M0.get_block_type() == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(M0.get_block_type()));
        Assert(M.get_property() == HMatrixSupport::symmetric ||
                 M.get_property() == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(M.get_property()));
        Assert(M.get_block_type() == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(M.get_block_type()));
      }

    // Array of empty child pointers used for initializing a block
    // cluster tree node.
    const std::array<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type,
      BlockClusterTree<spacedim, Number>::child_num>
      empty_child_pointers{{nullptr, nullptr, nullptr, nullptr}};

    /**
     * Create a \bcn \f$\tau\times\rho\f$ for the current local product matrix
     * \p Z. Since this \bcn will not be connected with other \bcns in a \bct,
     * it has neither parent nor children and its level is set to zero.
     *
     * \alert{Because the current multiplication is \f$M_1\cdot M_2^T\f$, the
     * product \bctnode is built from \f$\tau\f$ of \f$M_1\f$ and \f$\tau\f$ of
     * \f$M_2\f$.}
     */
    typename BlockClusterTree<spacedim, Number>::node_value_type
      current_product_bc_node(
        BlockCluster<spacedim, Number>(
          M1.bc_node->get_data_reference().get_tau_node(),
          M2.bc_node->get_data_reference().get_tau_node()),
        0,
        empty_child_pointers,
        nullptr,
        UnsplitMode);

    /**
     * Set the \p is_near_field flag of the \bcn for the current local product
     * matrix \p Z according to the matrix type of the initial leaf node \hmatrix
     * \p M0, i.e. it inherits the \p is_near_field flag of the \bcn for \p M0.
     */
    if (M0.bc_node->get_data_reference().get_is_near_field())
      {
        Assert(M0.type == FullMatrixType, ExcInvalidHMatrixType(M0.type));

        current_product_bc_node.get_data_reference().set_is_near_field(true);
      }
    else
      {
        Assert(M0.type == RkMatrixType, ExcInvalidHMatrixType(M0.type));

        current_product_bc_node.get_data_reference().set_is_near_field(false);
      }

    /**
     * When the flag @p is_result_matrix_store_tril_only is true, determine if
     * the \hmatrix property of the local product \hmatrix @p Z should be the
     * same as that of @p M by checking if the index ranges of its \f$\tau\f$
     * node and \f$\sigma\f$ are the same, since only when they are the same,
     * @p Z or @p M's property can be symmetric or lower triangular.
     */
    HMatrixSupport::Property Z_property = HMatrixSupport::general;
    bool                     is_result_matrix_Z_store_tril_only = false;

    if (is_result_matrix_store_tril_only &&
        (*M1.get_row_index_range() == *M2.get_row_index_range()))
      {
        /**
         * The local product \hmatrix @p Z inherits the property of @p M, which
         * can be either symmetric or lower triangular.
         */
        Z_property                         = M.property;
        is_result_matrix_Z_store_tril_only = true;

        /**
         * If the local \hmatrix @p Z is symmetric or lower triangular, its block
         * type should be @p diagonal_block and an assertion is made about this
         * fact.
         */
        Assert(block_type_for_local_Z == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(block_type_for_local_Z));
      }

    /**
     * Create the local product \hmatrix \p Z associated with the current \bcn.
     * During its initialization, memory will be allocated depending on its
     * \hmatrix property and block type.
     */
    HMatrix<spacedim, Number> Z(&current_product_bc_node,
                                fixed_rank,
                                Z_property,
                                block_type_for_local_Z);

    // Local variable storing the rank-k matrix obtained from multiplication
    // involving leaf node.
    RkMatrix<Number> ZR;
    // Local variable storing the full matrix obtained from multiplication
    // involving leaf node.
    LAPACKFullMatrixExt<Number> ZF;
    // The result matrix type for the multiplication involving leaf node.
    HMatrixType result_matrix_type = UndefinedMatrixType;

    if (M1.bc_node->is_leaf() || M2.bc_node->is_leaf())
      {
        /**
         * When either operand \p M1 or \p M2 is a leaf node, directly evaluation
         * of their multiplication can be performed.
         */
        if (M1.type == RkMatrixType)
          {
            rk_h_mTmult(alpha, *(M1.rkmatrix), M2, ZR);
            result_matrix_type = RkMatrixType;
          }
        else if (M2.type == RkMatrixType)
          {
            h_rk_mTmult(alpha, M1, *(M2.rkmatrix), ZR);
            result_matrix_type = RkMatrixType;
          }
        else if (M1.type == FullMatrixType)
          {
            f_h_mTmult(alpha, *(M1.fullmatrix), M2, ZF);
            result_matrix_type = FullMatrixType;
          }
        else if (M2.type == FullMatrixType)
          {
            h_f_mTmult(alpha, M1, *(M2.fullmatrix), ZF);
            result_matrix_type = FullMatrixType;
          }
        else
          {
            Assert(false, ExcInternalError());
            result_matrix_type = UndefinedMatrixType;
          }

        if (Z.type == RkMatrixType)
          {
            // The desired result should be a rank-k matrix.
            if (result_matrix_type == RkMatrixType)
              {
                *(Z.rkmatrix) = ZR;
              }
            else if (result_matrix_type == FullMatrixType)
              {
                // Convert the full matrix to rank-k matrix.
                *(Z.rkmatrix) = RkMatrix<Number>(fixed_rank, ZF);
              }
            else
              {
                Assert(false, ExcInvalidHMatrixType(result_matrix_type));
              }
          }
        else if (Z.type == FullMatrixType)
          {
            // The desired result should be a full matrix.
            if (result_matrix_type == RkMatrixType)
              {
                // Convert the rank-k matrix to full matrix.
                ZR.convertToFullMatrix(*(Z.fullmatrix));
              }
            else if (result_matrix_type == FullMatrixType)
              {
                *(Z.fullmatrix) = ZF;
              }
            else
              {
                Assert(false, ExcInvalidHMatrixType(result_matrix_type));
              }

            /**
             * If the local product \hmatrix @p Z is expected to be symmetric or
             * lower triangular, also set the property of the associated full
             * matrix correspondingly. This operation is mandatory because the
             * property of the local full matrix @p ZF is @p general, which has
             * overwritten the property of @p Z.
             */
            if (is_result_matrix_Z_store_tril_only)
              {
                switch (Z.property)
                  {
                      case HMatrixSupport::symmetric: {
                        Z.fullmatrix->set_property(LAPACKSupport::symmetric);

                        break;
                      }
                      case HMatrixSupport::lower_triangular: {
                        Z.fullmatrix->set_property(
                          LAPACKSupport::lower_triangular);

                        break;
                      }
                      default: {
                        Assert(false, ExcInvalidHMatrixProperty(Z.property));

                        break;
                      }
                  }
              }
          }
        else
          {
            Assert(false, ExcInvalidHMatrixType(Z.type));
          }
      }
    else
      {
        /**
         * In this case, both @p M1 and @p M2 have child submatrices.
         *
         * \alert{When we perform submatrix multiplication, we use a higher
         * specified rank, since the results will be assembled into the larger
         * matrix \p Z via pairwise formatted addition, during which the actual
         * matrix rank may increase.}
         */
        const unsigned int local_fixed_rank =
          std::min(fixed_rank * 2, std::min(Z.m, Z.n));

        std::array<HMatrixSupport::BlockType,
                   BlockClusterTree<spacedim, Number>::child_num>
          block_types_for_submatrices_of_local_Z;
        HMatrixSupport::infer_submatrix_block_types_from_parent_hmat(
          block_type_for_local_Z, block_types_for_submatrices_of_local_Z);

        h_h_mTmult_from_leaf_node(M0,
                                  Z,
                                  alpha,
                                  *(M1.submatrices[0]),
                                  *(M2.submatrices[0]),
                                  block_types_for_submatrices_of_local_Z[0],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);
        h_h_mTmult_from_leaf_node(M0,
                                  Z,
                                  alpha,
                                  *(M1.submatrices[1]),
                                  *(M2.submatrices[1]),
                                  block_types_for_submatrices_of_local_Z[0],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);

        if ((!is_result_matrix_Z_store_tril_only) ||
            (is_result_matrix_Z_store_tril_only &&
             Z.property != HMatrixSupport::symmetric &&
             Z.property != HMatrixSupport::lower_triangular))
          {
            /**
             * The submatrix block @p Z.submatrices[1], which is obtained
             * from the cross type multiplication of @p M1 and @p M2, will be
             * evaluated in two scenarios:
             * 1. when the \hmatrix @p M is not expected to be symmetric or lower
             * triangular;
             * 2. when the \hmatrix @p M is required to be symmetric or lower
             * triangular a priori, and the product matrix @p Z should not be
             * symmetric or lower triangular.
             */
            h_h_mTmult_from_leaf_node(M0,
                                      Z,
                                      alpha,
                                      *(M1.submatrices[0]),
                                      *(M2.submatrices[2]),
                                      block_types_for_submatrices_of_local_Z[1],
                                      local_fixed_rank,
                                      is_result_matrix_Z_store_tril_only);
            h_h_mTmult_from_leaf_node(M0,
                                      Z,
                                      alpha,
                                      *(M1.submatrices[1]),
                                      *(M2.submatrices[3]),
                                      block_types_for_submatrices_of_local_Z[1],
                                      local_fixed_rank,
                                      is_result_matrix_Z_store_tril_only);
          }

        h_h_mTmult_from_leaf_node(M0,
                                  Z,
                                  alpha,
                                  *(M1.submatrices[2]),
                                  *(M2.submatrices[0]),
                                  block_types_for_submatrices_of_local_Z[2],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);
        h_h_mTmult_from_leaf_node(M0,
                                  Z,
                                  alpha,
                                  *(M1.submatrices[3]),
                                  *(M2.submatrices[1]),
                                  block_types_for_submatrices_of_local_Z[2],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);

        h_h_mTmult_from_leaf_node(M0,
                                  Z,
                                  alpha,
                                  *(M1.submatrices[2]),
                                  *(M2.submatrices[2]),
                                  block_types_for_submatrices_of_local_Z[3],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);
        h_h_mTmult_from_leaf_node(M0,
                                  Z,
                                  alpha,
                                  *(M1.submatrices[3]),
                                  *(M2.submatrices[3]),
                                  block_types_for_submatrices_of_local_Z[3],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);
      }

    /**
     * Assemble the product \hmatrix \p Z to the \hmatrix \p M.
     */
    if (M0.bc_node->get_data_reference().get_is_near_field())
      {
        /**
         * When the original matrix \p M0 belongs to the near field, assemble the
         * full matrix stored in \p Z directly into \p M.
         */
        Assert(M.fullmatrix, ExcInternalError());

        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.block_type != HMatrixSupport::upper_triangular_block &&
             Z.block_type != HMatrixSupport::upper_triangular_block))
          {
            M.fullmatrix->fill(*(Z.fullmatrix),
                               (*Z.row_index_range)[0] -
                                 (*M.row_index_range)[0],
                               (*Z.col_index_range)[0] -
                                 (*M.col_index_range)[0],
                               0,
                               0,
                               1.0,
                               false,
                               true);
          }
      }
    else
      {
        /**
         * When the original matrix \p M0 does not belong to the near field,
         * assemble the rank-k matrix stored in \p Z into \p M by first embedding
         * then formatted addition, which has been implemented in the member
         * function \p assemble_from_rkmatrix.
         */
        Assert(M.rkmatrix, ExcInternalError());

        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.block_type != HMatrixSupport::upper_triangular_block &&
             Z.block_type != HMatrixSupport::upper_triangular_block))
          {
            M.rkmatrix->assemble_from_rkmatrix(*M.row_index_range,
                                               *M.col_index_range,
                                               *(Z.rkmatrix),
                                               *(Z.row_index_range),
                                               *(Z.col_index_range),
                                               fixed_rank);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  h_h_mTmult_from_leaf_node_for_parallel_cholesky(
    HMatrix<spacedim, Number>      &M0,
    HMatrix<spacedim, Number>      &M,
    const Number                    alpha,
    HMatrix<spacedim, Number>      &M1,
    HMatrix<spacedim, Number>      &M2,
    const HMatrixSupport::BlockType block_type_for_local_Z,
    const unsigned int              fixed_rank,
    const bool                      is_result_matrix_store_tril_only = false)
  {
    /**
     * Here we make an assertion that the top level result \hmatrix @p M0 should
     * be a leaf node.
     */
    Assert(M0.bc_node->is_leaf(), ExcMessage("M0 should be a leaf node!"));

    if (is_result_matrix_store_tril_only)
      {
        Assert(M0.get_property() == HMatrixSupport::symmetric ||
                 M0.get_property() == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(M0.get_property()));
        Assert(M0.get_block_type() == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(M0.get_block_type()));
        Assert(M.get_property() == HMatrixSupport::symmetric ||
                 M.get_property() == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(M.get_property()));
        Assert(M.get_block_type() == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(M.get_block_type()));
      }

    // Array of empty child pointers used for initializing a block
    // cluster tree node.
    const std::array<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type,
      BlockClusterTree<spacedim, Number>::child_num>
      empty_child_pointers{{nullptr, nullptr, nullptr, nullptr}};

    /**
     * Create a \bcn \f$\tau\times\rho\f$ for the current local product matrix
     * \p Z. Since this \bcn will not be connected with other \bcns in a \bct,
     * it has neither parent nor children and its level is set to zero.
     *
     * \alert{Because the current multiplication is \f$M_1\cdot M_2^T\f$, the
     * product \bctnode is built from \f$\tau\f$ of \f$M_1\f$ and \f$\tau\f$ of
     * \f$M_2\f$.}
     */
    typename BlockClusterTree<spacedim, Number>::node_value_type
      current_product_bc_node(
        BlockCluster<spacedim, Number>(
          M1.bc_node->get_data_reference().get_tau_node(),
          M2.bc_node->get_data_reference().get_tau_node()),
        0,
        empty_child_pointers,
        nullptr,
        UnsplitMode);

    /**
     * Set the \p is_near_field flag of the \bcn for the current local product
     * matrix \p Z according to the matrix type of the initial leaf node \hmatrix
     * \p M0, i.e. it inherits the \p is_near_field flag of the \bcn for \p M0.
     */
    if (M0.bc_node->get_data_reference().get_is_near_field())
      {
        Assert(M0.type == FullMatrixType, ExcInvalidHMatrixType(M0.type));

        current_product_bc_node.get_data_reference().set_is_near_field(true);
      }
    else
      {
        Assert(M0.type == RkMatrixType, ExcInvalidHMatrixType(M0.type));

        current_product_bc_node.get_data_reference().set_is_near_field(false);
      }

    /**
     * When the flag @p is_result_matrix_store_tril_only is true, determine if
     * the \hmatrix property of the local product \hmatrix @p Z should be the
     * same as that of @p M by checking if the index ranges of its \f$\tau\f$
     * node and \f$\sigma\f$ are the same, since only when they are the same,
     * @p Z or @p M's property can be symmetric or lower triangular.
     */
    HMatrixSupport::Property Z_property = HMatrixSupport::general;
    bool                     is_result_matrix_Z_store_tril_only = false;

    if (is_result_matrix_store_tril_only &&
        (*M1.get_row_index_range() == *M2.get_row_index_range()))
      {
        /**
         * The local product \hmatrix @p Z inherits the property of @p M, which
         * can be either symmetric or lower triangular.
         */
        Z_property                         = M.property;
        is_result_matrix_Z_store_tril_only = true;

        /**
         * If the local \hmatrix @p Z is symmetric or lower triangular, its block
         * type should be @p diagonal_block and an assertion is made about this
         * fact.
         */
        Assert(block_type_for_local_Z == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(block_type_for_local_Z));
      }

    /**
     * Create the local product \hmatrix \p Z associated with the current \bcn.
     * During its initialization, memory will be allocated depending on its
     * \hmatrix property and block type.
     */
    HMatrix<spacedim, Number> Z(&current_product_bc_node,
                                fixed_rank,
                                Z_property,
                                block_type_for_local_Z);

    // Local variable storing the rank-k matrix obtained from multiplication
    // involving leaf node.
    RkMatrix<Number> ZR;
    // Local variable storing the full matrix obtained from multiplication
    // involving leaf node.
    LAPACKFullMatrixExt<Number> ZF;
    // The result matrix type for the multiplication involving leaf node.
    HMatrixType result_matrix_type = UndefinedMatrixType;

    if (M1.bc_node->is_leaf() || M2.bc_node->is_leaf())
      {
        /**
         * When either operand \p M1 or \p M2 is a leaf node, directly evaluation
         * of their multiplication can be performed.
         */
        if (M1.type == RkMatrixType)
          {
            rk_h_mTmult(alpha, *(M1.rkmatrix), M2, ZR);
            result_matrix_type = RkMatrixType;
          }
        else if (M2.type == RkMatrixType)
          {
            h_rk_mTmult(alpha, M1, *(M2.rkmatrix), ZR);
            result_matrix_type = RkMatrixType;
          }
        else if (M1.type == FullMatrixType)
          {
            f_h_mTmult(alpha, *(M1.fullmatrix), M2, ZF);
            result_matrix_type = FullMatrixType;
          }
        else if (M2.type == FullMatrixType)
          {
            h_f_mTmult(alpha, M1, *(M2.fullmatrix), ZF);
            result_matrix_type = FullMatrixType;
          }
        else
          {
            Assert(false, ExcInternalError());
            result_matrix_type = UndefinedMatrixType;
          }

        if (Z.type == RkMatrixType)
          {
            // The desired result should be a rank-k matrix.
            if (result_matrix_type == RkMatrixType)
              {
                *(Z.rkmatrix) = ZR;
              }
            else if (result_matrix_type == FullMatrixType)
              {
                // Convert the full matrix to rank-k matrix.
                *(Z.rkmatrix) = RkMatrix<Number>(fixed_rank, ZF);
              }
            else
              {
                Assert(false, ExcInvalidHMatrixType(result_matrix_type));
              }
          }
        else if (Z.type == FullMatrixType)
          {
            // The desired result should be a full matrix.
            if (result_matrix_type == RkMatrixType)
              {
                // Convert the rank-k matrix to full matrix.
                ZR.convertToFullMatrix(*(Z.fullmatrix));
              }
            else if (result_matrix_type == FullMatrixType)
              {
                *(Z.fullmatrix) = ZF;
              }
            else
              {
                Assert(false, ExcInvalidHMatrixType(result_matrix_type));
              }

            /**
             * If the local product \hmatrix @p Z is expected to be symmetric or
             * lower triangular, also set the property of the associated full
             * matrix correspondingly. This operation is mandatory because the
             * property of the local full matrix @p ZF is @p general, which has
             * overwritten the property of @p Z.
             */
            if (is_result_matrix_Z_store_tril_only)
              {
                switch (Z.property)
                  {
                      case HMatrixSupport::symmetric: {
                        Z.fullmatrix->set_property(LAPACKSupport::symmetric);

                        break;
                      }
                      case HMatrixSupport::lower_triangular: {
                        Z.fullmatrix->set_property(
                          LAPACKSupport::lower_triangular);

                        break;
                      }
                      default: {
                        Assert(false, ExcInvalidHMatrixProperty(Z.property));

                        break;
                      }
                  }
              }
          }
        else
          {
            Assert(false, ExcInvalidHMatrixType(Z.type));
          }
      }
    else
      {
        /**
         * In this case, both @p M1 and @p M2 have child submatrices.
         *
         * \alert{When we perform submatrix multiplication, we use a higher
         * specified rank, since the results will be assembled into the larger
         * matrix \p Z via pairwise formatted addition, during which the actual
         * matrix rank may increase.}
         */
        const unsigned int local_fixed_rank =
          std::min(fixed_rank * 2, std::min(Z.m, Z.n));

        std::array<HMatrixSupport::BlockType,
                   BlockClusterTree<spacedim, Number>::child_num>
          block_types_for_submatrices_of_local_Z;
        HMatrixSupport::infer_submatrix_block_types_from_parent_hmat(
          block_type_for_local_Z, block_types_for_submatrices_of_local_Z);

        h_h_mTmult_from_leaf_node_for_parallel_cholesky(
          M0,
          Z,
          alpha,
          *(M1.submatrices[0]),
          *(M2.submatrices[0]),
          block_types_for_submatrices_of_local_Z[0],
          local_fixed_rank,
          is_result_matrix_Z_store_tril_only);
        h_h_mTmult_from_leaf_node_for_parallel_cholesky(
          M0,
          Z,
          alpha,
          *(M1.submatrices[1]),
          *(M2.submatrices[1]),
          block_types_for_submatrices_of_local_Z[0],
          local_fixed_rank,
          is_result_matrix_Z_store_tril_only);

        if ((!is_result_matrix_Z_store_tril_only) ||
            (is_result_matrix_Z_store_tril_only &&
             Z.property != HMatrixSupport::symmetric &&
             Z.property != HMatrixSupport::lower_triangular))
          {
            /**
             * The submatrix block @p Z.submatrices[1], which is obtained
             * from the cross type multiplication of @p M1 and @p M2, will be
             * evaluated in two scenarios:
             * 1. when the \hmatrix @p M is not expected to be symmetric or lower
             * triangular;
             * 2. when the \hmatrix @p M is required to be symmetric or lower
             * triangular a priori, and the product matrix @p Z should not be
             * symmetric or lower triangular.
             */
            h_h_mTmult_from_leaf_node_for_parallel_cholesky(
              M0,
              Z,
              alpha,
              *(M1.submatrices[0]),
              *(M2.submatrices[2]),
              block_types_for_submatrices_of_local_Z[1],
              local_fixed_rank,
              is_result_matrix_Z_store_tril_only);
            h_h_mTmult_from_leaf_node_for_parallel_cholesky(
              M0,
              Z,
              alpha,
              *(M1.submatrices[1]),
              *(M2.submatrices[3]),
              block_types_for_submatrices_of_local_Z[1],
              local_fixed_rank,
              is_result_matrix_Z_store_tril_only);
          }

        h_h_mTmult_from_leaf_node_for_parallel_cholesky(
          M0,
          Z,
          alpha,
          *(M1.submatrices[2]),
          *(M2.submatrices[0]),
          block_types_for_submatrices_of_local_Z[2],
          local_fixed_rank,
          is_result_matrix_Z_store_tril_only);
        h_h_mTmult_from_leaf_node_for_parallel_cholesky(
          M0,
          Z,
          alpha,
          *(M1.submatrices[3]),
          *(M2.submatrices[1]),
          block_types_for_submatrices_of_local_Z[2],
          local_fixed_rank,
          is_result_matrix_Z_store_tril_only);

        h_h_mTmult_from_leaf_node_for_parallel_cholesky(
          M0,
          Z,
          alpha,
          *(M1.submatrices[2]),
          *(M2.submatrices[2]),
          block_types_for_submatrices_of_local_Z[3],
          local_fixed_rank,
          is_result_matrix_Z_store_tril_only);
        h_h_mTmult_from_leaf_node_for_parallel_cholesky(
          M0,
          Z,
          alpha,
          *(M1.submatrices[3]),
          *(M2.submatrices[3]),
          block_types_for_submatrices_of_local_Z[3],
          local_fixed_rank,
          is_result_matrix_Z_store_tril_only);
      }

    /**
     * Assemble the product \hmatrix \p Z to the \hmatrix \p M.
     */
    if (M0.bc_node->get_data_reference().get_is_near_field())
      {
        /**
         * When the original matrix \p M0 belongs to the near field, assemble the
         * full matrix stored in \p Z directly into \p M.
         */
        Assert(M.fullmatrix, ExcInternalError());

        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.block_type != HMatrixSupport::upper_triangular_block &&
             Z.block_type != HMatrixSupport::upper_triangular_block))
          {
            /**
             * Only when the result matrix @p M is the top level result matrix
             * @p M0, the mutex will be locked. Otherwise, the result matrix
             * @p M is only a temporary object, which needs not be locked.
             */
            std::unique_lock<std::mutex> ul(M0.update_lock, std::defer_lock);
            if (&M0 == &M)
              {
                ul.lock();
              }

            M.fullmatrix->fill(*(Z.fullmatrix),
                               (*Z.row_index_range)[0] -
                                 (*M.row_index_range)[0],
                               (*Z.col_index_range)[0] -
                                 (*M.col_index_range)[0],
                               0,
                               0,
                               1.0,
                               false,
                               true);
          }
      }
    else
      {
        /**
         * When the original matrix \p M0 does not belong to the near field,
         * assemble the rank-k matrix stored in \p Z into \p M by first embedding
         * then formatted addition, which has been implemented in the member
         * function \p assemble_from_rkmatrix.
         */
        Assert(M.rkmatrix, ExcInternalError());

        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.block_type != HMatrixSupport::upper_triangular_block &&
             Z.block_type != HMatrixSupport::upper_triangular_block))
          {
            /**
             * Only when the result matrix @p M is the top level result matrix
             * @p M0, the mutex will be locked. Otherwise, the result matrix
             * @p M is only a temporary object, which needs not be locked.
             */
            std::unique_lock<std::mutex> ul(M0.update_lock, std::defer_lock);
            if (&M0 == &M)
              {
                ul.lock();

#if ARENA_OR_ISOLATE_IN_LU_AND_CHOL == 3
                M.rkmatrix->assemble_from_rkmatrix(*M.row_index_range,
                                                   *M.col_index_range,
                                                   *(Z.rkmatrix),
                                                   *(Z.row_index_range),
                                                   *(Z.col_index_range),
                                                   fixed_rank);
#endif

#if ARENA_OR_ISOLATE_IN_LU_AND_CHOL == 1
                tbb::task_arena ta{ARENA_MAX_CONCURRENCY_IN_LU_AND_CHOL};
                ta.execute([&M, &Z, fixed_rank] {
                  M.rkmatrix->assemble_from_rkmatrix(*M.row_index_range,
                                                     *M.col_index_range,
                                                     *(Z.rkmatrix),
                                                     *(Z.row_index_range),
                                                     *(Z.col_index_range),
                                                     fixed_rank);
                });
#endif

#if ARENA_OR_ISOLATE_IN_LU_AND_CHOL == 2
                /**
                 * There will be nested parallelism from deal.ii library in the
                 * following function call. Hence, it should be isolated.
                 */
                tbb::this_task_arena::isolate([&M, &Z, fixed_rank] {
                  M.rkmatrix->assemble_from_rkmatrix(*M.row_index_range,
                                                     *M.col_index_range,
                                                     *(Z.rkmatrix),
                                                     *(Z.row_index_range),
                                                     *(Z.col_index_range),
                                                     fixed_rank);
                });
#endif
              }
            else
              {
                M.rkmatrix->assemble_from_rkmatrix(*M.row_index_range,
                                                   *M.col_index_range,
                                                   *(Z.rkmatrix),
                                                   *(Z.row_index_range),
                                                   *(Z.col_index_range),
                                                   fixed_rank);
              }
          }
      }
  }


  /**
   * \hmatrix-\hmatrix multiplication with the first operand transposed,
   * when the product matrix belongs to the leaf set of the target \bct.
   *
   * This function implements the recursive \p MMR algorithm in (7.26) in
   * Hackbusch's \hmatrix book.
   *
   * @param M0
   * @param M
   * @param M1
   * @param M2
   * @param block_type_for_local_Z
   * @param fixed_rank
   * @param is_result_matrix_store_tril_only
   */
  template <int spacedim, typename Number>
  void
  h_h_Tmmult_from_leaf_node(
    HMatrix<spacedim, Number>      &M0,
    HMatrix<spacedim, Number>      &M,
    HMatrix<spacedim, Number>      &M1,
    HMatrix<spacedim, Number>      &M2,
    const HMatrixSupport::BlockType block_type_for_local_Z,
    const unsigned int              fixed_rank,
    const bool                      is_result_matrix_store_tril_only = false)
  {
    /**
     * Here we make an assertion that the top level result \hmatrix @p M0 should
     * be a leaf node.
     */
    Assert(M0.bc_node->is_leaf(), ExcMessage("M0 should be a leaf node!"));

    if (is_result_matrix_store_tril_only)
      {
        Assert(M0.get_property() == HMatrixSupport::symmetric ||
                 M0.get_property() == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(M0.get_property()));
        Assert(M0.get_block_type() == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(M0.get_block_type()));
        Assert(M.get_property() == HMatrixSupport::symmetric ||
                 M.get_property() == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(M.get_property()));
        Assert(M.get_block_type() == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(M.get_block_type()));
      }

    // Array of empty child pointers used for initializing a block
    // cluster tree node.
    const std::array<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type,
      BlockClusterTree<spacedim, Number>::child_num>
      empty_child_pointers{{nullptr, nullptr, nullptr, nullptr}};

    /**
     * Create a \bcn \f$\tau\times\rho\f$ for the current local product matrix
     * \p Z. Since this \bcn will not be connected with other \bcns in a \bct,
     * it has neither parent nor children and its level is set to zero.
     *
     * \alert{Because the current multiplication is \f$M_1^T\cdot M_2\f$, the
     * product \bctnode is built from \f$\sigma\f$ of \f$M_1\f$ and \f$\sigma\f$
     * of \f$M_2\f$.}
     */
    typename BlockClusterTree<spacedim, Number>::node_value_type
      current_product_bc_node(
        BlockCluster<spacedim, Number>(
          M1.bc_node->get_data_reference().get_sigma_node(),
          M2.bc_node->get_data_reference().get_sigma_node()),
        0,
        empty_child_pointers,
        nullptr,
        UnsplitMode);

    /**
     * Set the \p is_near_field flag of the \bcn for the current local product
     * matrix \p Z according to the matrix type of the initial leaf node \hmatrix
     * \p M0, i.e. it inherits the \p is_near_field flag of the \bcn for \p M0.
     */
    if (M0.bc_node->get_data_reference().get_is_near_field())
      {
        Assert(M0.type == FullMatrixType, ExcInvalidHMatrixType(M0.type));

        current_product_bc_node.get_data_reference().set_is_near_field(true);
      }
    else
      {
        Assert(M0.type == RkMatrixType, ExcInvalidHMatrixType(M0.type));

        current_product_bc_node.get_data_reference().set_is_near_field(false);
      }

    /**
     * When the flag @p is_result_matrix_store_tril_only is true, determine if
     * the \hmatrix property of the local product \hmatrix @p Z should be the
     * same as that of @p M by checking if the index ranges of its \f$\tau\f$
     * node and \f$\sigma\f$ are the same, since only when they are the same,
     * @p Z or @p M's property can be symmetric or lower triangular.
     */
    HMatrixSupport::Property Z_property = HMatrixSupport::general;
    bool                     is_result_matrix_Z_store_tril_only = false;

    if (is_result_matrix_store_tril_only &&
        (*M1.get_col_index_range() == *M2.get_col_index_range()))
      {
        /**
         * The local product \hmatrix @p Z inherits the property of @p M, which
         * can be either symmetric or lower triangular.
         */
        Z_property                         = M.property;
        is_result_matrix_Z_store_tril_only = true;

        /**
         * If the local \hmatrix @p Z is symmetric or lower triangular, its block
         * type should be @p diagonal_block and an assertion is made about this
         * fact.
         */
        Assert(block_type_for_local_Z == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(block_type_for_local_Z));
      }

    /**
     * Create the local product \hmatrix \p Z associated with the current \bcn.
     * During its initialization, memory will be allocated depending on its
     * \hmatrix property and block type.
     */
    HMatrix<spacedim, Number> Z(&current_product_bc_node,
                                fixed_rank,
                                Z_property,
                                block_type_for_local_Z);
    // Local variable storing the rank-k matrix obtained from multiplication
    // involving leaf node.
    RkMatrix<Number> ZR;
    // Local variable storing the full matrix obtained from multiplication
    // involving leaf node.
    LAPACKFullMatrixExt<Number> ZF;
    // The result matrix type for the multiplication involving leaf node.
    HMatrixType result_matrix_type = UndefinedMatrixType;

    if (M1.bc_node->is_leaf() || M2.bc_node->is_leaf())
      {
        /**
         * When either operand \p M1 or \p M2 is a leaf node, directly evaluation
         * of their multiplication can be performed.
         */
        if (M1.type == RkMatrixType)
          {
            rk_h_Tmmult(*(M1.rkmatrix), M2, ZR);
            result_matrix_type = RkMatrixType;
          }
        else if (M2.type == RkMatrixType)
          {
            h_rk_Tmmult(M1, *(M2.rkmatrix), ZR);
            result_matrix_type = RkMatrixType;
          }
        else if (M1.type == FullMatrixType)
          {
            f_h_Tmmult(*(M1.fullmatrix), M2, ZF);
            result_matrix_type = FullMatrixType;
          }
        else if (M2.type == FullMatrixType)
          {
            h_f_Tmmult(M1, *(M2.fullmatrix), ZF);
            result_matrix_type = FullMatrixType;
          }
        else
          {
            Assert(false, ExcInternalError());
            result_matrix_type = UndefinedMatrixType;
          }

        if (Z.type == RkMatrixType)
          {
            // The desired result should be a rank-k matrix.
            if (result_matrix_type == RkMatrixType)
              {
                *(Z.rkmatrix) = ZR;
              }
            else if (result_matrix_type == FullMatrixType)
              {
                // Convert the full matrix to rank-k matrix.
                *(Z.rkmatrix) = RkMatrix<Number>(fixed_rank, ZF);
              }
            else
              {
                Assert(false, ExcInvalidHMatrixType(result_matrix_type));
              }
          }
        else if (Z.type == FullMatrixType)
          {
            // The desired result should be a full matrix.
            if (result_matrix_type == RkMatrixType)
              {
                // Convert the rank-k matrix to full matrix.
                ZR.convertToFullMatrix(*(Z.fullmatrix));
              }
            else if (result_matrix_type == FullMatrixType)
              {
                *(Z.fullmatrix) = ZF;
              }
            else
              {
                Assert(false, ExcInvalidHMatrixType(result_matrix_type));
              }

            /**
             * If the local product \hmatrix @p Z is expected to be symmetric or
             * lower triangular, also set the property of the associated full
             * matrix correspondingly. This operation is mandatory because the
             * property of the local full matrix @p ZF is @p general, which has
             * overwritten the property of @p Z.
             */
            if (is_result_matrix_Z_store_tril_only)
              {
                switch (Z.property)
                  {
                      case HMatrixSupport::symmetric: {
                        Z.fullmatrix->set_property(LAPACKSupport::symmetric);

                        break;
                      }
                      case HMatrixSupport::lower_triangular: {
                        Z.fullmatrix->set_property(
                          LAPACKSupport::lower_triangular);

                        break;
                      }
                      default: {
                        Assert(false, ExcInvalidHMatrixProperty(Z.property));

                        break;
                      }
                  }
              }
          }
        else
          {
            Assert(false, ExcInvalidHMatrixType(Z.type));
          }
      }
    else
      {
        /**
         * In this case, both @p M1 and @p M2 have child submatrices.
         *
         * \alert{When we perform submatrix multiplication, we use a higher
         * specified rank, since the results will be assembled into the larger
         * matrix \p Z via pairwise formatted addition, during which the actual
         * matrix rank may increase.}
         */
        const unsigned int local_fixed_rank =
          std::min(fixed_rank * 2, std::min(Z.m, Z.n));

        std::array<HMatrixSupport::BlockType,
                   BlockClusterTree<spacedim, Number>::child_num>
          block_types_for_submatrices_of_local_Z;
        HMatrixSupport::infer_submatrix_block_types_from_parent_hmat(
          block_type_for_local_Z, block_types_for_submatrices_of_local_Z);

        h_h_Tmmult_from_leaf_node(M0,
                                  Z,
                                  *(M1.submatrices[0]),
                                  *(M2.submatrices[0]),
                                  block_types_for_submatrices_of_local_Z[0],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);
        h_h_Tmmult_from_leaf_node(M0,
                                  Z,
                                  *(M1.submatrices[2]),
                                  *(M2.submatrices[2]),
                                  block_types_for_submatrices_of_local_Z[0],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);

        if ((!is_result_matrix_Z_store_tril_only) ||
            (is_result_matrix_Z_store_tril_only &&
             Z.property != HMatrixSupport::symmetric &&
             Z.property != HMatrixSupport::lower_triangular))
          {
            /**
             * The submatrix block @p Z.submatrices[1], which is obtained
             * from the cross type multiplication of @p M1 and @p M2, will be
             * evaluated in two scenarios:
             * 1. when the \hmatrix @p M is not expected to be symmetric or lower
             * triangular;
             * 2. when the \hmatrix @p M is required to be symmetric or lower
             * triangular a priori, and the product matrix @p Z should not be
             * symmetric or lower triangular.
             */
            h_h_Tmmult_from_leaf_node(M0,
                                      Z,
                                      *(M1.submatrices[0]),
                                      *(M2.submatrices[1]),
                                      block_types_for_submatrices_of_local_Z[1],
                                      local_fixed_rank,
                                      is_result_matrix_Z_store_tril_only);
            h_h_Tmmult_from_leaf_node(M0,
                                      Z,
                                      *(M1.submatrices[2]),
                                      *(M2.submatrices[3]),
                                      block_types_for_submatrices_of_local_Z[1],
                                      local_fixed_rank,
                                      is_result_matrix_Z_store_tril_only);
          }

        h_h_Tmmult_from_leaf_node(M0,
                                  Z,
                                  *(M1.submatrices[1]),
                                  *(M2.submatrices[0]),
                                  block_types_for_submatrices_of_local_Z[2],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);
        h_h_Tmmult_from_leaf_node(M0,
                                  Z,
                                  *(M1.submatrices[3]),
                                  *(M2.submatrices[2]),
                                  block_types_for_submatrices_of_local_Z[2],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);

        h_h_Tmmult_from_leaf_node(M0,
                                  Z,
                                  *(M1.submatrices[1]),
                                  *(M2.submatrices[1]),
                                  block_types_for_submatrices_of_local_Z[3],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);
        h_h_Tmmult_from_leaf_node(M0,
                                  Z,
                                  *(M1.submatrices[3]),
                                  *(M2.submatrices[3]),
                                  block_types_for_submatrices_of_local_Z[3],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);
      }

    /**
     * Assemble the local matrix \p Z to the product matrix \p M.
     */
    if (M0.bc_node->get_data_reference().get_is_near_field())
      {
        /**
         * When the original matrix \p M0 belongs to the near field, assemble the
         * full matrix stored in \p Z directly into \p M.
         */
        Assert(M.fullmatrix, ExcInternalError());

        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.block_type != HMatrixSupport::upper_triangular_block &&
             Z.block_type != HMatrixSupport::upper_triangular_block))
          {
            M.fullmatrix->fill(*(Z.fullmatrix),
                               (*Z.row_index_range)[0] -
                                 (*M.row_index_range)[0],
                               (*Z.col_index_range)[0] -
                                 (*M.col_index_range)[0],
                               0,
                               0,
                               1.0,
                               false,
                               true);
          }
      }
    else
      {
        /**
         * When the original matrix \p M0 does not belong to the near field,
         * assemble the rank-k matrix stored in \p Z into \p M by first embedding
         * then formatted addition, which has been implemented in the member
         * function \p assemble_from_rkmatrix.
         */
        Assert(M.rkmatrix, ExcInternalError());

        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.block_type != HMatrixSupport::upper_triangular_block &&
             Z.block_type != HMatrixSupport::upper_triangular_block))
          {
            M.rkmatrix->assemble_from_rkmatrix(*M.row_index_range,
                                               *M.col_index_range,
                                               *(Z.rkmatrix),
                                               *(Z.row_index_range),
                                               *(Z.col_index_range),
                                               fixed_rank);
          }
      }
  }


  /**
   * Scaled \hmatrix-\hmatrix multiplication with the first operand transposed,
   * when the product matrix belongs to the leaf set of the target \bct.
   *
   * This function implements the recursive \p MMR algorithm in (7.26) in
   * Hackbusch's \hmatrix book.
   *
   * @param M0
   * @param M
   * @param alpha
   * @param M1
   * @param M2
   * @param block_type_for_local_Z
   * @param fixed_rank
   * @param is_result_matrix_store_tril_only
   */
  template <int spacedim, typename Number>
  void
  h_h_Tmmult_from_leaf_node(
    HMatrix<spacedim, Number>      &M0,
    HMatrix<spacedim, Number>      &M,
    const Number                    alpha,
    HMatrix<spacedim, Number>      &M1,
    HMatrix<spacedim, Number>      &M2,
    const HMatrixSupport::BlockType block_type_for_local_Z,
    const unsigned int              fixed_rank,
    const bool                      is_result_matrix_store_tril_only = false)
  {
    /**
     * Here we make an assertion that the top level result \hmatrix @p M0 should
     * be a leaf node.
     */
    Assert(M0.bc_node->is_leaf(), ExcMessage("M0 should be a leaf node!"));

    if (is_result_matrix_store_tril_only)
      {
        Assert(M0.get_property() == HMatrixSupport::symmetric ||
                 M0.get_property() == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(M0.get_property()));
        Assert(M0.get_block_type() == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(M0.get_block_type()));
        Assert(M.get_property() == HMatrixSupport::symmetric ||
                 M.get_property() == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(M.get_property()));
        Assert(M.get_block_type() == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(M.get_block_type()));
      }

    // Array of empty child pointers used for initializing a block
    // cluster tree node.
    const std::array<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type,
      BlockClusterTree<spacedim, Number>::child_num>
      empty_child_pointers{{nullptr, nullptr, nullptr, nullptr}};

    /**
     * Create a \bcn \f$\tau\times\rho\f$ for the current local product matrix
     * \p Z. Since this \bcn will not be connected with other \bcns in a \bct,
     * it has neither parent nor children and its level is set to zero.
     *
     * \alert{Because the current multiplication is \f$M_1^T\cdot M_2\f$, the
     * product \bctnode is built from \f$\sigma\f$ of \f$M_1\f$ and \f$\sigma\f$
     * of \f$M_2\f$.}
     */
    typename BlockClusterTree<spacedim, Number>::node_value_type
      current_product_bc_node(
        BlockCluster<spacedim, Number>(
          M1.bc_node->get_data_reference().get_sigma_node(),
          M2.bc_node->get_data_reference().get_sigma_node()),
        0,
        empty_child_pointers,
        nullptr,
        UnsplitMode);

    /**
     * Set the \p is_near_field flag of the \bcn for the current local product
     * matrix \p Z according to the matrix type of the initial leaf node \hmatrix
     * \p M0, i.e. it inherits the \p is_near_field flag of the \bcn for \p M0.
     */
    if (M0.bc_node->get_data_reference().get_is_near_field())
      {
        Assert(M0.type == FullMatrixType, ExcInvalidHMatrixType(M0.type));

        current_product_bc_node.get_data_reference().set_is_near_field(true);
      }
    else
      {
        Assert(M0.type == RkMatrixType, ExcInvalidHMatrixType(M0.type));

        current_product_bc_node.get_data_reference().set_is_near_field(false);
      }

    /**
     * When the flag @p is_result_matrix_store_tril_only is true, determine if
     * the \hmatrix property of the local product \hmatrix @p Z should be the
     * same as that of @p M by checking if the index ranges of its \f$\tau\f$
     * node and \f$\sigma\f$ are the same, since only when they are the same,
     * @p Z or @p M's property can be symmetric or lower triangular.
     */
    HMatrixSupport::Property Z_property = HMatrixSupport::general;
    bool                     is_result_matrix_Z_store_tril_only = false;

    if (is_result_matrix_store_tril_only &&
        (*M1.get_col_index_range() == *M2.get_col_index_range()))
      {
        /**
         * The local product \hmatrix @p Z inherits the property of @p M, which
         * can be either symmetric or lower triangular.
         */
        Z_property                         = M.property;
        is_result_matrix_Z_store_tril_only = true;

        /**
         * If the local \hmatrix @p Z is symmetric or lower triangular, its block
         * type should be @p diagonal_block and an assertion is made about this
         * fact.
         */
        Assert(block_type_for_local_Z == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(block_type_for_local_Z));
      }

    /**
     * Create the local product \hmatrix \p Z associated with the current \bcn.
     * During its initialization, memory will be allocated depending on its
     * \hmatrix property and block type.
     */
    HMatrix<spacedim, Number> Z(&current_product_bc_node,
                                fixed_rank,
                                Z_property,
                                block_type_for_local_Z);
    // Local variable storing the rank-k matrix obtained from multiplication
    // involving leaf node.
    RkMatrix<Number> ZR;
    // Local variable storing the full matrix obtained from multiplication
    // involving leaf node.
    LAPACKFullMatrixExt<Number> ZF;
    // The result matrix type for the multiplication involving leaf node.
    HMatrixType result_matrix_type = UndefinedMatrixType;

    if (M1.bc_node->is_leaf() || M2.bc_node->is_leaf())
      {
        /**
         * When either operand \p M1 or \p M2 is a leaf node, directly evaluation
         * of their multiplication can be performed.
         */
        if (M1.type == RkMatrixType)
          {
            rk_h_Tmmult(alpha, *(M1.rkmatrix), M2, ZR);
            result_matrix_type = RkMatrixType;
          }
        else if (M2.type == RkMatrixType)
          {
            h_rk_Tmmult(alpha, M1, *(M2.rkmatrix), ZR);
            result_matrix_type = RkMatrixType;
          }
        else if (M1.type == FullMatrixType)
          {
            f_h_Tmmult(alpha, *(M1.fullmatrix), M2, ZF);
            result_matrix_type = FullMatrixType;
          }
        else if (M2.type == FullMatrixType)
          {
            h_f_Tmmult(alpha, M1, *(M2.fullmatrix), ZF);
            result_matrix_type = FullMatrixType;
          }
        else
          {
            Assert(false, ExcInternalError());
            result_matrix_type = UndefinedMatrixType;
          }

        if (Z.type == RkMatrixType)
          {
            // The desired result should be a rank-k matrix.
            if (result_matrix_type == RkMatrixType)
              {
                *(Z.rkmatrix) = ZR;
              }
            else if (result_matrix_type == FullMatrixType)
              {
                // Convert the full matrix to rank-k matrix.
                *(Z.rkmatrix) = RkMatrix<Number>(fixed_rank, ZF);
              }
            else
              {
                Assert(false, ExcInvalidHMatrixType(result_matrix_type));
              }
          }
        else if (Z.type == FullMatrixType)
          {
            // The desired result should be a full matrix.
            if (result_matrix_type == RkMatrixType)
              {
                // Convert the rank-k matrix to full matrix.
                ZR.convertToFullMatrix(*(Z.fullmatrix));
              }
            else if (result_matrix_type == FullMatrixType)
              {
                *(Z.fullmatrix) = ZF;
              }
            else
              {
                Assert(false, ExcInvalidHMatrixType(result_matrix_type));
              }

            /**
             * If the local product \hmatrix @p Z is expected to be symmetric or
             * lower triangular, also set the property of the associated full
             * matrix correspondingly. This operation is mandatory because the
             * property of the local full matrix @p ZF is @p general, which has
             * overwritten the property of @p Z.
             */
            if (is_result_matrix_Z_store_tril_only)
              {
                switch (Z.property)
                  {
                      case HMatrixSupport::symmetric: {
                        Z.fullmatrix->set_property(LAPACKSupport::symmetric);

                        break;
                      }
                      case HMatrixSupport::lower_triangular: {
                        Z.fullmatrix->set_property(
                          LAPACKSupport::lower_triangular);

                        break;
                      }
                      default: {
                        Assert(false, ExcInvalidHMatrixProperty(Z.property));

                        break;
                      }
                  }
              }
          }
        else
          {
            Assert(false, ExcInvalidHMatrixType(Z.type));
          }
      }
    else
      {
        /**
         * In this case, both @p M1 and @p M2 have child submatrices.
         *
         * \alert{When we perform submatrix multiplication, we use a higher
         * specified rank, since the results will be assembled into the larger
         * matrix \p Z via pairwise formatted addition, during which the actual
         * matrix rank may increase.}
         */
        const unsigned int local_fixed_rank =
          std::min(fixed_rank * 2, std::min(Z.m, Z.n));

        std::array<HMatrixSupport::BlockType,
                   BlockClusterTree<spacedim, Number>::child_num>
          block_types_for_submatrices_of_local_Z;
        HMatrixSupport::infer_submatrix_block_types_from_parent_hmat(
          block_type_for_local_Z, block_types_for_submatrices_of_local_Z);

        h_h_Tmmult_from_leaf_node(M0,
                                  Z,
                                  alpha,
                                  *(M1.submatrices[0]),
                                  *(M2.submatrices[0]),
                                  block_types_for_submatrices_of_local_Z[0],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);
        h_h_Tmmult_from_leaf_node(M0,
                                  Z,
                                  alpha,
                                  *(M1.submatrices[2]),
                                  *(M2.submatrices[2]),
                                  block_types_for_submatrices_of_local_Z[0],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);

        if ((!is_result_matrix_Z_store_tril_only) ||
            (is_result_matrix_Z_store_tril_only &&
             Z.property != HMatrixSupport::symmetric &&
             Z.property != HMatrixSupport::lower_triangular))
          {
            /**
             * The submatrix block @p Z.submatrices[1], which is obtained
             * from the cross type multiplication of @p M1 and @p M2, will be
             * evaluated in two scenarios:
             * 1. when the \hmatrix @p M is not expected to be symmetric or lower
             * triangular;
             * 2. when the \hmatrix @p M is required to be symmetric or lower
             * triangular a priori, and the product matrix @p Z should not be
             * symmetric or lower triangular.
             */
            h_h_Tmmult_from_leaf_node(M0,
                                      Z,
                                      alpha,
                                      *(M1.submatrices[0]),
                                      *(M2.submatrices[1]),
                                      block_types_for_submatrices_of_local_Z[1],
                                      local_fixed_rank,
                                      is_result_matrix_Z_store_tril_only);
            h_h_Tmmult_from_leaf_node(M0,
                                      Z,
                                      alpha,
                                      *(M1.submatrices[2]),
                                      *(M2.submatrices[3]),
                                      block_types_for_submatrices_of_local_Z[1],
                                      local_fixed_rank,
                                      is_result_matrix_Z_store_tril_only);
          }

        h_h_Tmmult_from_leaf_node(M0,
                                  Z,
                                  alpha,
                                  *(M1.submatrices[1]),
                                  *(M2.submatrices[0]),
                                  block_types_for_submatrices_of_local_Z[2],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);
        h_h_Tmmult_from_leaf_node(M0,
                                  Z,
                                  alpha,
                                  *(M1.submatrices[3]),
                                  *(M2.submatrices[2]),
                                  block_types_for_submatrices_of_local_Z[2],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);

        h_h_Tmmult_from_leaf_node(M0,
                                  Z,
                                  alpha,
                                  *(M1.submatrices[1]),
                                  *(M2.submatrices[1]),
                                  block_types_for_submatrices_of_local_Z[3],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);
        h_h_Tmmult_from_leaf_node(M0,
                                  Z,
                                  alpha,
                                  *(M1.submatrices[3]),
                                  *(M2.submatrices[3]),
                                  block_types_for_submatrices_of_local_Z[3],
                                  local_fixed_rank,
                                  is_result_matrix_Z_store_tril_only);
      }

    /**
     * Assemble the local matrix \p Z to the product matrix \p M.
     */
    if (M0.bc_node->get_data_reference().get_is_near_field())
      {
        /**
         * When the original matrix \p M0 belongs to the near field, assemble the
         * full matrix stored in \p Z directly into \p M.
         */
        Assert(M.fullmatrix, ExcInternalError());

        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.block_type != HMatrixSupport::upper_triangular_block &&
             Z.block_type != HMatrixSupport::upper_triangular_block))
          {
            M.fullmatrix->fill(*(Z.fullmatrix),
                               (*Z.row_index_range)[0] -
                                 (*M.row_index_range)[0],
                               (*Z.col_index_range)[0] -
                                 (*M.col_index_range)[0],
                               0,
                               0,
                               1.0,
                               false,
                               true);
          }
      }
    else
      {
        /**
         * When the original matrix \p M0 does not belong to the near field,
         * assemble the rank-k matrix stored in \p Z into \p M by first embedding
         * then formatted addition, which has been implemented in the member
         * function \p assemble_from_rkmatrix.
         */
        Assert(M.rkmatrix, ExcInternalError());

        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.block_type != HMatrixSupport::upper_triangular_block &&
             Z.block_type != HMatrixSupport::upper_triangular_block))
          {
            M.rkmatrix->assemble_from_rkmatrix(*M.row_index_range,
                                               *M.col_index_range,
                                               *(Z.rkmatrix),
                                               *(Z.row_index_range),
                                               *(Z.col_index_range),
                                               fixed_rank);
          }
      }
  }


  /**
   * Multiplication of two level-conserving \hmatrices and the result will be
   * added to the target matrix \p M, i.e. \f$M = M + M_1 M_2\f$.
   *
   * \mynote{It is required that an empty result matrix \p M should be created
   * first with respect to a \bct.}
   *
   * @param M
   * @param M1
   * @param M2
   * @param fixed_rank
   * @param is_result_matrix_store_tril_only
   */
  template <int spacedim, typename Number>
  void
  h_h_mmult_level_conserving(
    HMatrix<spacedim, Number> &M,
    HMatrix<spacedim, Number> &M1,
    HMatrix<spacedim, Number> &M2,
    const unsigned int         fixed_rank,
    const bool                 is_result_matrix_store_tril_only = false)
  {
    if (!(M1.bc_node->is_leaf()) && !(M2.bc_node->is_leaf()) &&
        !(M.bc_node->is_leaf()))
      {
        /**
         * All matrices (including the two operands and the product result) have
         * substructure. Hence the \hmatrix multiplication type is cross.
         */
        h_h_mmult_level_conserving(*(M.submatrices[0]),
                                   *(M1.submatrices[0]),
                                   *(M2.submatrices[0]),
                                   fixed_rank,
                                   is_result_matrix_store_tril_only);
        h_h_mmult_level_conserving(*(M.submatrices[0]),
                                   *(M1.submatrices[1]),
                                   *(M2.submatrices[2]),
                                   fixed_rank,
                                   is_result_matrix_store_tril_only);

        /**
         * N.B. When the \hmatrix is symmetric or lower triangular, it stores
         * the lower triangular data only (including diagonal elements).
         */
        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.property != HMatrixSupport::symmetric &&
             M.property != HMatrixSupport::lower_triangular))
          {
            /**
             * The submatrix block @p M.submatrices[1] will be evaluated in two
             * scenarios:
             * 1. when the result matrix is not expected to be symmetric;
             * 2. when the result matrix is required to be symmetric a priori,
             * then if the product matrix @p M is not symmetric.
             */
            h_h_mmult_level_conserving(*(M.submatrices[1]),
                                       *(M1.submatrices[0]),
                                       *(M2.submatrices[1]),
                                       fixed_rank,
                                       false);
            h_h_mmult_level_conserving(*(M.submatrices[1]),
                                       *(M1.submatrices[1]),
                                       *(M2.submatrices[3]),
                                       fixed_rank,
                                       false);
          }

        h_h_mmult_level_conserving(*(M.submatrices[2]),
                                   *(M1.submatrices[2]),
                                   *(M2.submatrices[0]),
                                   fixed_rank,
                                   false);
        h_h_mmult_level_conserving(*(M.submatrices[2]),
                                   *(M1.submatrices[3]),
                                   *(M2.submatrices[2]),
                                   fixed_rank,
                                   false);

        h_h_mmult_level_conserving(*(M.submatrices[3]),
                                   *(M1.submatrices[2]),
                                   *(M2.submatrices[1]),
                                   fixed_rank,
                                   is_result_matrix_store_tril_only);
        h_h_mmult_level_conserving(*(M.submatrices[3]),
                                   *(M1.submatrices[3]),
                                   *(M2.submatrices[3]),
                                   fixed_rank,
                                   is_result_matrix_store_tril_only);
      }
    else if (!(M.bc_node->is_leaf()))
      {
        /**
         * This is the case when the product matrix @p M is further divided,
         * while at least one of the two operands is a leaf. Hence the
         * multiplication on this level can be directly evaluated.
         *
         * 1. When one of the operand matrix is a rank-k matrix, the product
         * result is also a rank-k matrix.
         * 2. When one of the operand matrix is a full matrix, the immediate
         * product result is for sure a full matrix. However, because the block
         * cluster associated with @p M is not a leaf, @p M should be represented
         * as a rank-k matrix, which is converted from the full matrix. In the
         * current implementation, this conversion has no accuracy loss.
         */

        RkMatrix<Number> Z;
        if (M1.type == RkMatrixType)
          {
            rk_h_mmult(*(M1.rkmatrix), M2, Z);
          }
        else if (M2.type == RkMatrixType)
          {
            h_rk_mmult(M1, *(M2.rkmatrix), Z);
          }
        else if (M1.type == FullMatrixType)
          {
            f_h_mmult(*(M1.fullmatrix), M2, Z);
          }
        else if (M2.type == FullMatrixType)
          {
            h_f_mmult(M1, *(M2.fullmatrix), Z);
          }
        else
          {
            Assert(false, ExcInternalError());
          }

        /**
         * Add the result matrix @p Z into @p M and note that @p Z and @p M are
         * associated with a same block cluster.
         *
         * This addition is implemented by restricting @p Z to each leaf node of
         * @p M first, then the addition operation will be performed on each leaf
         * node respectively.
         *
         * \alert{The matrix @p Z should only be added into @p M but not simply
         * overwrite @p M. This is because the result matrix @p M on the block
         * cluster \f$\tau\times\rho\f$ may be contributed from several
         * multiplications with respect to a collection of \f$\{\sigma_i\}\f$,
         * which forms a partition of the index set \f$J\f$.}
         */
        M.add(Z, fixed_rank, is_result_matrix_store_tril_only);
      }
    else
      {
        /**
         * This is the first time of calling @p h_h_mmult_from_leaf_node, where
         * the second argument @p M is the product of @p M1 and @p M2. If there
         * are further recursive calls of this function, the second argument
         * will
         * be one level higher than the product of @p M1 and @p M2.
         */
        h_h_mmult_from_leaf_node(M,
                                 M,
                                 M1,
                                 M2,
                                 M.block_type,
                                 fixed_rank,
                                 is_result_matrix_store_tril_only);
      }
  }


  /**
   * Multiplication of two level-conserving \hmatrices with a factor multiplied
   * to
   * the matrix product and the result will be added to the target matrix \p M,
   * i.e. \f$M = M + \alpha \cdot M_1 M_2\f$.
   *
   * \mynote{It is required that an empty result matrix \p M should be created
   * first with respect to a \bct.}
   *
   * @param M0
   * @param M
   * @param alpha
   * @param M1
   * @param M2
   * @param fixed_rank
   * @param
   */
  template <int spacedim, typename Number>
  void
  h_h_mmult_level_conserving(
    HMatrix<spacedim, Number> &M,
    const Number               alpha,
    HMatrix<spacedim, Number> &M1,
    HMatrix<spacedim, Number> &M2,
    const unsigned int         fixed_rank,
    const bool                 is_result_matrix_store_tril_only = false)
  {
    if (!(M1.bc_node->is_leaf()) && !(M2.bc_node->is_leaf()) &&
        !(M.bc_node->is_leaf()))
      {
        /**
         * All matrices (including the two operands and the product result) have
         * substructure. Hence the \hmatrix multiplication type is cross.
         */
        h_h_mmult_level_conserving(*(M.submatrices[0]),
                                   alpha,
                                   *(M1.submatrices[0]),
                                   *(M2.submatrices[0]),
                                   fixed_rank,
                                   is_result_matrix_store_tril_only);
        h_h_mmult_level_conserving(*(M.submatrices[0]),
                                   alpha,
                                   *(M1.submatrices[1]),
                                   *(M2.submatrices[2]),
                                   fixed_rank,
                                   is_result_matrix_store_tril_only);

        /**
         * N.B. When the \hmatrix is symmetric or lower triangular, it stores
         * the lower triangular data only (including diagonal elements).
         */
        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.property != HMatrixSupport::symmetric &&
             M.property != HMatrixSupport::lower_triangular))
          {
            /**
             * The submatrix block @p M.submatrices[1] will be evaluated in two
             * scenarios:
             * 1. when the result matrix is not expected to be symmetric;
             * 2. when the result matrix is required to be symmetric a priori,
             * then if the product matrix @p M is not symmetric.
             */
            h_h_mmult_level_conserving(*(M.submatrices[1]),
                                       alpha,
                                       *(M1.submatrices[0]),
                                       *(M2.submatrices[1]),
                                       fixed_rank,
                                       false);
            h_h_mmult_level_conserving(*(M.submatrices[1]),
                                       alpha,
                                       *(M1.submatrices[1]),
                                       *(M2.submatrices[3]),
                                       fixed_rank,
                                       false);
          }

        h_h_mmult_level_conserving(*(M.submatrices[2]),
                                   alpha,
                                   *(M1.submatrices[2]),
                                   *(M2.submatrices[0]),
                                   fixed_rank,
                                   false);
        h_h_mmult_level_conserving(*(M.submatrices[2]),
                                   alpha,
                                   *(M1.submatrices[3]),
                                   *(M2.submatrices[2]),
                                   fixed_rank,
                                   false);

        h_h_mmult_level_conserving(*(M.submatrices[3]),
                                   alpha,
                                   *(M1.submatrices[2]),
                                   *(M2.submatrices[1]),
                                   fixed_rank,
                                   is_result_matrix_store_tril_only);
        h_h_mmult_level_conserving(*(M.submatrices[3]),
                                   alpha,
                                   *(M1.submatrices[3]),
                                   *(M2.submatrices[3]),
                                   fixed_rank,
                                   is_result_matrix_store_tril_only);
      }
    else if (!(M.bc_node->is_leaf()))
      {
        /**
         * This is the case when the product matrix @p M is further divided,
         * while at least one of the two operands is a leaf. Hence the
         * multiplication on this level can be directly evaluated.
         *
         * 1. When one of the operand matrix is a rank-k matrix, the product
         * result is also a rank-k matrix.
         * 2. When one of the operand matrix is a full matrix, the immediate
         * product result is for sure a full matrix. However, because the block
         * cluster associated with @p M is not a leaf, @p M should be represented
         * as a rank-k matrix, which is converted from the full matrix. In the
         * current implementation, this conversion has no accuracy loss.
         */

        RkMatrix<Number> Z;
        if (M1.type == RkMatrixType)
          {
            rk_h_mmult(alpha, *(M1.rkmatrix), M2, Z);
          }
        else if (M2.type == RkMatrixType)
          {
            h_rk_mmult(alpha, M1, *(M2.rkmatrix), Z);
          }
        else if (M1.type == FullMatrixType)
          {
            f_h_mmult(alpha, *(M1.fullmatrix), M2, Z);
          }
        else if (M2.type == FullMatrixType)
          {
            h_f_mmult(alpha, M1, *(M2.fullmatrix), Z);
          }
        else
          {
            Assert(false, ExcInternalError());
          }

        /**
         * Add the result matrix @p Z into @p M and note that @p Z and @p M are
         * associated with a same block cluster.
         *
         * This addition is implemented by restricting @p Z to each leaf node of
         * @p M first, then the addition operation will be performed on each leaf
         * node respectively.
         *
         * \alert{The matrix @p Z should only be added into @p M but not simply
         * overwrite @p M. This is because the result matrix @p M on the block
         * cluster \f$\tau\times\rho\f$ may be contributed from several
         * multiplications with respect to a collection of \f$\{\sigma_i\}\f$,
         * which forms a partition of the index set \f$J\f$.}
         */
        M.add(Z, fixed_rank, is_result_matrix_store_tril_only);
      }
    else
      {
        /**
         * This is the first time of calling @p h_h_mmult_from_leaf_node, where
         * the second argument @p M is the product of @p M1 and @p M2. If there
         * are further recursive calls of this function, the second argument
         * will
         * be one level higher than the product of @p M1 and @p M2.
         */
        h_h_mmult_from_leaf_node(M,
                                 M,
                                 alpha,
                                 M1,
                                 M2,
                                 M.block_type,
                                 fixed_rank,
                                 is_result_matrix_store_tril_only);
      }
  }


  template <int spacedim, typename Number>
  void
  h_h_mmult_level_conserving_for_parallel_lu(
    HMatrix<spacedim, Number> &M,
    const Number               alpha,
    HMatrix<spacedim, Number> &M1,
    HMatrix<spacedim, Number> &M2,
    const unsigned int         fixed_rank,
    const bool                 is_result_matrix_store_tril_only = false)
  {
    if (!(M1.bc_node->is_leaf()) && !(M2.bc_node->is_leaf()) &&
        !(M.bc_node->is_leaf()))
      {
        /**
         * All matrices (including the two operands and the product result) have
         * substructure. Hence the \hmatrix multiplication type is cross.
         */
        h_h_mmult_level_conserving_for_parallel_lu(
          *(M.submatrices[0]),
          alpha,
          *(M1.submatrices[0]),
          *(M2.submatrices[0]),
          fixed_rank,
          is_result_matrix_store_tril_only);
        h_h_mmult_level_conserving_for_parallel_lu(
          *(M.submatrices[0]),
          alpha,
          *(M1.submatrices[1]),
          *(M2.submatrices[2]),
          fixed_rank,
          is_result_matrix_store_tril_only);

        /**
         * N.B. When the \hmatrix is symmetric or lower triangular, it stores
         * the lower triangular data only (including diagonal elements).
         */
        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.property != HMatrixSupport::symmetric &&
             M.property != HMatrixSupport::lower_triangular))
          {
            /**
             * The submatrix block @p M.submatrices[1] will be evaluated in two
             * scenarios:
             * 1. when the result matrix is not expected to be symmetric;
             * 2. when the result matrix is required to be symmetric a priori,
             * then if the product matrix @p M is not symmetric.
             */
            h_h_mmult_level_conserving_for_parallel_lu(*(M.submatrices[1]),
                                                       alpha,
                                                       *(M1.submatrices[0]),
                                                       *(M2.submatrices[1]),
                                                       fixed_rank,
                                                       false);
            h_h_mmult_level_conserving_for_parallel_lu(*(M.submatrices[1]),
                                                       alpha,
                                                       *(M1.submatrices[1]),
                                                       *(M2.submatrices[3]),
                                                       fixed_rank,
                                                       false);
          }

        h_h_mmult_level_conserving_for_parallel_lu(*(M.submatrices[2]),
                                                   alpha,
                                                   *(M1.submatrices[2]),
                                                   *(M2.submatrices[0]),
                                                   fixed_rank,
                                                   false);
        h_h_mmult_level_conserving_for_parallel_lu(*(M.submatrices[2]),
                                                   alpha,
                                                   *(M1.submatrices[3]),
                                                   *(M2.submatrices[2]),
                                                   fixed_rank,
                                                   false);

        h_h_mmult_level_conserving_for_parallel_lu(
          *(M.submatrices[3]),
          alpha,
          *(M1.submatrices[2]),
          *(M2.submatrices[1]),
          fixed_rank,
          is_result_matrix_store_tril_only);
        h_h_mmult_level_conserving_for_parallel_lu(
          *(M.submatrices[3]),
          alpha,
          *(M1.submatrices[3]),
          *(M2.submatrices[3]),
          fixed_rank,
          is_result_matrix_store_tril_only);
      }
    else if (!(M.bc_node->is_leaf()))
      {
        /**
         * This is the case when the product matrix @p M is further divided,
         * while at least one of the two operands is a leaf. Hence the
         * multiplication on this level can be directly evaluated.
         *
         * 1. When one of the operand matrix is a rank-k matrix, the product
         * result is also a rank-k matrix.
         * 2. When one of the operand matrix is a full matrix, the immediate
         * product result is for sure a full matrix. However, because the block
         * cluster associated with @p M is not a leaf, @p M should be represented
         * as a rank-k matrix, which is converted from the full matrix. In the
         * current implementation, this conversion has no accuracy loss.
         */

        RkMatrix<Number> Z;
        if (M1.type == RkMatrixType)
          {
            rk_h_mmult(alpha, *(M1.rkmatrix), M2, Z);
          }
        else if (M2.type == RkMatrixType)
          {
            h_rk_mmult(alpha, M1, *(M2.rkmatrix), Z);
          }
        else if (M1.type == FullMatrixType)
          {
            f_h_mmult(alpha, *(M1.fullmatrix), M2, Z);
          }
        else if (M2.type == FullMatrixType)
          {
            h_f_mmult(alpha, M1, *(M2.fullmatrix), Z);
          }
        else
          {
            Assert(false, ExcInternalError());
          }

        /**
         * Add the result matrix @p Z into @p M and note that @p Z and @p M are
         * associated with a same block cluster.
         *
         * This addition is implemented by restricting @p Z to each leaf node of
         * @p M first, then the addition operation will be performed on each leaf
         * node respectively.
         *
         * \alert{The matrix @p Z should only be added into @p M but not simply
         * overwrite @p M. This is because the result matrix @p M on the block
         * cluster \f$\tau\times\rho\f$ may be contributed from several
         * multiplications with respect to a collection of \f$\{\sigma_i\}\f$,
         * which forms a partition of the index set \f$J\f$.}
         */
        M.add_for_parallel_lu_or_cholesky(Z,
                                          fixed_rank,
                                          is_result_matrix_store_tril_only);
      }
    else
      {
        /**
         * This is the first time of calling @p h_h_mmult_from_leaf_node, where
         * the second argument @p M is the product of @p M1 and @p M2. If there
         * are further recursive calls of this function, the second argument
         * will
         * be one level higher than the product of @p M1 and @p M2.
         */
        h_h_mmult_from_leaf_node_for_parallel_lu(
          M,
          M,
          alpha,
          M1,
          M2,
          M.block_type,
          fixed_rank,
          is_result_matrix_store_tril_only);
      }
  }


  /**
   * Multiplication of two level-conserving \hmatrices with the second operand
   * transposed. The result will be added to the target matrix \p M, i.e.
   * \f$M = M + M_1 M_2^T\f$.
   *
   * \mynote{It is required that an empty result matrix \p M should be created
   * first with respect to a \bct.}
   *
   * @param M
   * @param M1
   * @param M2
   * @param fixed_rank
   * @param is_result_matrix_store_tril_only
   */
  template <int spacedim, typename Number>
  void
  h_h_mTmult_level_conserving(
    HMatrix<spacedim, Number> &M,
    HMatrix<spacedim, Number> &M1,
    HMatrix<spacedim, Number> &M2,
    const unsigned int         fixed_rank,
    const bool                 is_result_matrix_store_tril_only = false)
  {
    if (!(M1.bc_node->is_leaf()) && !(M2.bc_node->is_leaf()) &&
        !(M.bc_node->is_leaf()))
      {
        /**
         * All matrices (including the two operands and the product result) have
         * substructure. Hence the \hmatrix multiplication type is cross.
         */
        h_h_mTmult_level_conserving(*(M.submatrices[0]),
                                    *(M1.submatrices[0]),
                                    *(M2.submatrices[0]),
                                    fixed_rank,
                                    is_result_matrix_store_tril_only);
        h_h_mTmult_level_conserving(*(M.submatrices[0]),
                                    *(M1.submatrices[1]),
                                    *(M2.submatrices[1]),
                                    fixed_rank,
                                    is_result_matrix_store_tril_only);

        /**
         * N.B. When the \hmatrix is symmetric or lower triangular, it stores
         * the lower triangular data only (including diagonal elements).
         */
        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.property != HMatrixSupport::symmetric &&
             M.property != HMatrixSupport::lower_triangular))
          {
            /**
             * The submatrix block @p M.submatrices[1] will be evaluated in two
             * scenarios:
             * 1. when the result matrix is not expected to be symmetric;
             * 2. when the result matrix is required to be symmetric a priori,
             * then if the product matrix @p M is not symmetric.
             */
            h_h_mTmult_level_conserving(*(M.submatrices[1]),
                                        *(M1.submatrices[0]),
                                        *(M2.submatrices[2]),
                                        fixed_rank,
                                        false);
            h_h_mTmult_level_conserving(*(M.submatrices[1]),
                                        *(M1.submatrices[1]),
                                        *(M2.submatrices[3]),
                                        fixed_rank,
                                        false);
          }

        h_h_mTmult_level_conserving(*(M.submatrices[2]),
                                    *(M1.submatrices[2]),
                                    *(M2.submatrices[0]),
                                    fixed_rank,
                                    false);
        h_h_mTmult_level_conserving(*(M.submatrices[2]),
                                    *(M1.submatrices[3]),
                                    *(M2.submatrices[1]),
                                    fixed_rank,
                                    false);

        h_h_mTmult_level_conserving(*(M.submatrices[3]),
                                    *(M1.submatrices[2]),
                                    *(M2.submatrices[2]),
                                    fixed_rank,
                                    is_result_matrix_store_tril_only);
        h_h_mTmult_level_conserving(*(M.submatrices[3]),
                                    *(M1.submatrices[3]),
                                    *(M2.submatrices[3]),
                                    fixed_rank,
                                    is_result_matrix_store_tril_only);
      }
    else if (!(M.bc_node->is_leaf()))
      {
        /**
         * This is the case when the product matrix @p M is further divided,
         * while some of the two operands is a leaf. Hence the multiplication on
         * this level can be directly evaluated.
         *
         * 1. When one of the operand matrix is a rank-k matrix, the product
         * result is also a rank-k matrix.
         * 2. When one of the operand matrix is a full matrix, the immediate
         * product result is for sure a full matrix. However, because the block
         * cluster associated with @p M is not a leaf, @p M should be represented
         * as a rank-k matrix, which is converted from the full matrix. In the
         * current implementation, this conversion has no accuracy loss.
         */
        RkMatrix<Number> Z;
        if (M1.type == RkMatrixType)
          {
            rk_h_mTmult(*(M1.rkmatrix), M2, Z);
          }
        else if (M2.type == RkMatrixType)
          {
            h_rk_mTmult(M1, *(M2.rkmatrix), Z);
          }
        else if (M1.type == FullMatrixType)
          {
            f_h_mTmult(*(M1.fullmatrix), M2, Z);
          }
        else if (M2.type == FullMatrixType)
          {
            h_f_mTmult(M1, *(M2.fullmatrix), Z);
          }
        else
          {
            Assert(false, ExcInternalError());
          }

        /**
         * Add the result matrix @p Z into @p M and note that @p Z and @p M are
         * associated with a same block cluster.
         *
         * This addition is implemented by restricting @p Z to each leaf node of
         * @p M first, then the addition operation will be performed on each leaf
         * node respectively.
         *
         * \alert{The matrix @p Z should only be added into @p M but not simply
         * overwrite @p M. This is because the result matrix @p M on the block
         * cluster \f$\tau\times\rho\f$ may be contributed from several
         * multiplications with respect to a collection of \f$\{\sigma_i\}\f$,
         * which forms a partition of the index set \f$J\f$.}
         */
        M.add(Z, fixed_rank, is_result_matrix_store_tril_only);
      }
    else
      {
        /**
         * This is the first time of calling @p h_h_mTmult_from_leaf_node, where
         * the second argument @p M is the product of @p M1 and @p M2. If there
         * are further recursive calls of this function, the second argument
         * will
         * be one level higher than the product of @p M1 and @p M2.
         */
        h_h_mTmult_from_leaf_node(M,
                                  M,
                                  M1,
                                  M2,
                                  M.block_type,
                                  fixed_rank,
                                  is_result_matrix_store_tril_only);
      }
  }


  /**
   * Multiplication of two level-conserving \hmatrices with the second operand
   * transposed. The result will multiplied by a factor and then added to
   * the target matrix \p M, i.e. \f$M = M + \alpha \cdot M_1 M_2^T\f$.
   *
   * \mynote{It is required that an empty result matrix \p M should be created
   * first with respect to a \bct.}
   *
   * @param M
   * @param alpha
   * @param M1
   * @param M2
   * @param fixed_rank
   * @param is_result_matrix_store_tril_only
   */
  template <int spacedim, typename Number>
  void
  h_h_mTmult_level_conserving(
    HMatrix<spacedim, Number> &M,
    const Number               alpha,
    HMatrix<spacedim, Number> &M1,
    HMatrix<spacedim, Number> &M2,
    const unsigned int         fixed_rank,
    const bool                 is_result_matrix_store_tril_only = false)
  {
    if (!(M1.bc_node->is_leaf()) && !(M2.bc_node->is_leaf()) &&
        !(M.bc_node->is_leaf()))
      {
        /**
         * All matrices (including the two operands and the product result) have
         * substructure. Hence the \hmatrix multiplication type is cross.
         */
        h_h_mTmult_level_conserving(*(M.submatrices[0]),
                                    alpha,
                                    *(M1.submatrices[0]),
                                    *(M2.submatrices[0]),
                                    fixed_rank,
                                    is_result_matrix_store_tril_only);
        h_h_mTmult_level_conserving(*(M.submatrices[0]),
                                    alpha,
                                    *(M1.submatrices[1]),
                                    *(M2.submatrices[1]),
                                    fixed_rank,
                                    is_result_matrix_store_tril_only);

        /**
         * N.B. When the \hmatrix is symmetric or lower triangular, it stores
         * the lower triangular data only (including diagonal elements).
         */
        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.property != HMatrixSupport::symmetric &&
             M.property != HMatrixSupport::lower_triangular))
          {
            /**
             * The submatrix block @p M.submatrices[1] will be evaluated in two
             * scenarios:
             * 1. when the result matrix is not expected to be symmetric;
             * 2. when the result matrix is required to be symmetric a priori,
             * then if the product matrix @p M is not symmetric.
             */
            h_h_mTmult_level_conserving(*(M.submatrices[1]),
                                        alpha,
                                        *(M1.submatrices[0]),
                                        *(M2.submatrices[2]),
                                        fixed_rank,
                                        false);
            h_h_mTmult_level_conserving(*(M.submatrices[1]),
                                        alpha,
                                        *(M1.submatrices[1]),
                                        *(M2.submatrices[3]),
                                        fixed_rank,
                                        false);
          }

        h_h_mTmult_level_conserving(*(M.submatrices[2]),
                                    alpha,
                                    *(M1.submatrices[2]),
                                    *(M2.submatrices[0]),
                                    fixed_rank,
                                    false);
        h_h_mTmult_level_conserving(*(M.submatrices[2]),
                                    alpha,
                                    *(M1.submatrices[3]),
                                    *(M2.submatrices[1]),
                                    fixed_rank,
                                    false);

        h_h_mTmult_level_conserving(*(M.submatrices[3]),
                                    alpha,
                                    *(M1.submatrices[2]),
                                    *(M2.submatrices[2]),
                                    fixed_rank,
                                    is_result_matrix_store_tril_only);
        h_h_mTmult_level_conserving(*(M.submatrices[3]),
                                    alpha,
                                    *(M1.submatrices[3]),
                                    *(M2.submatrices[3]),
                                    fixed_rank,
                                    is_result_matrix_store_tril_only);
      }
    else if (!(M.bc_node->is_leaf()))
      {
        /**
         * This is the case when the product matrix @p M is further divided,
         * while some of the two operands is a leaf. Hence the multiplication on
         * this level can be directly evaluated.
         *
         * 1. When one of the operand matrix is a rank-k matrix, the product
         * result is also a rank-k matrix.
         * 2. When one of the operand matrix is a full matrix, the immediate
         * product result is for sure a full matrix. However, because the block
         * cluster associated with @p M is not a leaf, @p M should be represented
         * as a rank-k matrix, which is converted from the full matrix. In the
         * current implementation, this conversion has no accuracy loss.
         */
        RkMatrix<Number> Z;
        if (M1.type == RkMatrixType)
          {
            rk_h_mTmult(alpha, *(M1.rkmatrix), M2, Z);
          }
        else if (M2.type == RkMatrixType)
          {
            h_rk_mTmult(alpha, M1, *(M2.rkmatrix), Z);
          }
        else if (M1.type == FullMatrixType)
          {
            f_h_mTmult(alpha, *(M1.fullmatrix), M2, Z);
          }
        else if (M2.type == FullMatrixType)
          {
            h_f_mTmult(alpha, M1, *(M2.fullmatrix), Z);
          }
        else
          {
            Assert(false, ExcInternalError());
          }

        /**
         * Add the result matrix @p Z into @p M and note that @p Z and @p M are
         * associated with a same block cluster.
         *
         * This addition is implemented by restricting @p Z to each leaf node of
         * @p M first, then the addition operation will be performed on each leaf
         * node respectively.
         *
         * \alert{The matrix @p Z should only be added into @p M but not simply
         * overwrite @p M. This is because the result matrix @p M on the block
         * cluster \f$\tau\times\rho\f$ may be contributed from several
         * multiplications with respect to a collection of \f$\{\sigma_i\}\f$,
         * which forms a partition of the index set \f$J\f$.}
         */
        M.add(Z, fixed_rank, is_result_matrix_store_tril_only);
      }
    else
      {
        /**
         * This is the first time of calling @p h_h_mTmult_from_leaf_node, where
         * the second argument @p M is the product of @p M1 and @p M2. If there
         * are further recursive calls of this function, the second argument
         * will
         * be one level higher than the product of @p M1 and @p M2.
         */
        h_h_mTmult_from_leaf_node(M,
                                  M,
                                  alpha,
                                  M1,
                                  M2,
                                  M.block_type,
                                  fixed_rank,
                                  is_result_matrix_store_tril_only);
      }
  }


  template <int spacedim, typename Number>
  void
  h_h_mTmult_level_conserving_for_parallel_cholesky(
    HMatrix<spacedim, Number> &M,
    const Number               alpha,
    HMatrix<spacedim, Number> &M1,
    HMatrix<spacedim, Number> &M2,
    const unsigned int         fixed_rank,
    const bool                 is_result_matrix_store_tril_only = false)
  {
    if (!(M1.bc_node->is_leaf()) && !(M2.bc_node->is_leaf()) &&
        !(M.bc_node->is_leaf()))
      {
        /**
         * All matrices (including the two operands and the product result) have
         * substructure. Hence the \hmatrix multiplication type is cross.
         */
        h_h_mTmult_level_conserving_for_parallel_cholesky(
          *(M.submatrices[0]),
          alpha,
          *(M1.submatrices[0]),
          *(M2.submatrices[0]),
          fixed_rank,
          is_result_matrix_store_tril_only);
        h_h_mTmult_level_conserving_for_parallel_cholesky(
          *(M.submatrices[0]),
          alpha,
          *(M1.submatrices[1]),
          *(M2.submatrices[1]),
          fixed_rank,
          is_result_matrix_store_tril_only);

        /**
         * N.B. When the \hmatrix is symmetric or lower triangular, it stores
         * the lower triangular data only (including diagonal elements).
         */
        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.property != HMatrixSupport::symmetric &&
             M.property != HMatrixSupport::lower_triangular))
          {
            /**
             * The submatrix block @p M.submatrices[1] will be evaluated in two
             * scenarios:
             * 1. when the result matrix is not expected to be symmetric;
             * 2. when the result matrix is required to be symmetric a priori,
             * then if the product matrix @p M is not symmetric.
             */
            h_h_mTmult_level_conserving_for_parallel_cholesky(
              *(M.submatrices[1]),
              alpha,
              *(M1.submatrices[0]),
              *(M2.submatrices[2]),
              fixed_rank,
              false);
            h_h_mTmult_level_conserving_for_parallel_cholesky(
              *(M.submatrices[1]),
              alpha,
              *(M1.submatrices[1]),
              *(M2.submatrices[3]),
              fixed_rank,
              false);
          }

        h_h_mTmult_level_conserving_for_parallel_cholesky(*(M.submatrices[2]),
                                                          alpha,
                                                          *(M1.submatrices[2]),
                                                          *(M2.submatrices[0]),
                                                          fixed_rank,
                                                          false);
        h_h_mTmult_level_conserving_for_parallel_cholesky(*(M.submatrices[2]),
                                                          alpha,
                                                          *(M1.submatrices[3]),
                                                          *(M2.submatrices[1]),
                                                          fixed_rank,
                                                          false);

        h_h_mTmult_level_conserving_for_parallel_cholesky(
          *(M.submatrices[3]),
          alpha,
          *(M1.submatrices[2]),
          *(M2.submatrices[2]),
          fixed_rank,
          is_result_matrix_store_tril_only);
        h_h_mTmult_level_conserving_for_parallel_cholesky(
          *(M.submatrices[3]),
          alpha,
          *(M1.submatrices[3]),
          *(M2.submatrices[3]),
          fixed_rank,
          is_result_matrix_store_tril_only);
      }
    else if (!(M.bc_node->is_leaf()))
      {
        /**
         * This is the case when the product matrix @p M is further divided,
         * while some of the two operands is a leaf. Hence the multiplication on
         * this level can be directly evaluated.
         *
         * 1. When one of the operand matrix is a rank-k matrix, the product
         * result is also a rank-k matrix.
         * 2. When one of the operand matrix is a full matrix, the immediate
         * product result is for sure a full matrix. However, because the block
         * cluster associated with @p M is not a leaf, @p M should be represented
         * as a rank-k matrix, which is converted from the full matrix. In the
         * current implementation, this conversion has no accuracy loss.
         */
        RkMatrix<Number> Z;
        if (M1.type == RkMatrixType)
          {
            rk_h_mTmult(alpha, *(M1.rkmatrix), M2, Z);
          }
        else if (M2.type == RkMatrixType)
          {
            h_rk_mTmult(alpha, M1, *(M2.rkmatrix), Z);
          }
        else if (M1.type == FullMatrixType)
          {
            f_h_mTmult(alpha, *(M1.fullmatrix), M2, Z);
          }
        else if (M2.type == FullMatrixType)
          {
            h_f_mTmult(alpha, M1, *(M2.fullmatrix), Z);
          }
        else
          {
            Assert(false, ExcInternalError());
          }

        /**
         * Add the result matrix @p Z into @p M and note that @p Z and @p M are
         * associated with a same block cluster.
         *
         * This addition is implemented by restricting @p Z to each leaf node of
         * @p M first, then the addition operation will be performed on each leaf
         * node respectively.
         *
         * \alert{The matrix @p Z should only be added into @p M but not simply
         * overwrite @p M. This is because the result matrix @p M on the block
         * cluster \f$\tau\times\rho\f$ may be contributed from several
         * multiplications with respect to a collection of \f$\{\sigma_i\}\f$,
         * which forms a partition of the index set \f$J\f$.}
         */
        M.add_for_parallel_lu_or_cholesky(Z,
                                          fixed_rank,
                                          is_result_matrix_store_tril_only);
      }
    else
      {
        /**
         * This is the first time of calling @p h_h_mTmult_from_leaf_node, where
         * the second argument @p M is the product of @p M1 and @p M2. If there
         * are further recursive calls of this function, the second argument
         * will
         * be one level higher than the product of @p M1 and @p M2.
         */
        h_h_mTmult_from_leaf_node_for_parallel_cholesky(
          M,
          M,
          alpha,
          M1,
          M2,
          M.block_type,
          fixed_rank,
          is_result_matrix_store_tril_only);
      }
  }


  /**
   * Multiplication of two level-conserving \hmatrices with the first operand
   * transposed. The result will be added to the target matrix \p M, i.e.
   * \f$M = M + M_1^T M_2\f$.
   *
   * \mynote{It is required that an empty result matrix \p M should be created
   * first with respect to a \bct.}
   *
   * @param M
   * @param M1
   * @param M2
   * @param fixed_rank
   * @param is_result_matrix_store_tril_only
   */
  template <int spacedim, typename Number>
  void
  h_h_Tmmult_level_conserving(
    HMatrix<spacedim, Number> &M,
    HMatrix<spacedim, Number> &M1,
    HMatrix<spacedim, Number> &M2,
    const unsigned int         fixed_rank,
    const bool                 is_result_matrix_store_tril_only = false)
  {
    if (!(M1.bc_node->is_leaf()) && !(M2.bc_node->is_leaf()) &&
        !(M.bc_node->is_leaf()))
      {
        /**
         * All matrices (including the two operands and the product result) have
         * substructure. Hence the \hmatrix multiplication type is cross.
         */
        h_h_Tmmult_level_conserving(*(M.submatrices[0]),
                                    *(M1.submatrices[0]),
                                    *(M2.submatrices[0]),
                                    fixed_rank,
                                    is_result_matrix_store_tril_only);
        h_h_Tmmult_level_conserving(*(M.submatrices[0]),
                                    *(M1.submatrices[2]),
                                    *(M2.submatrices[2]),
                                    fixed_rank,
                                    is_result_matrix_store_tril_only);

        /**
         * N.B. When the \hmatrix is symmetric or lower triangular, it stores
         * the lower triangular data only (including diagonal elements).
         */
        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.property != HMatrixSupport::symmetric &&
             M.property != HMatrixSupport::lower_triangular))
          {
            /**
             * The submatrix block @p M.submatrices[1] will be evaluated in two
             * scenarios:
             * 1. when the result matrix is not expected to be symmetric;
             * 2. when the result matrix is required to be symmetric a priori,
             * then if the product matrix @p M is not symmetric.
             */
            h_h_Tmmult_level_conserving(*(M.submatrices[1]),
                                        *(M1.submatrices[0]),
                                        *(M2.submatrices[1]),
                                        fixed_rank,
                                        false);
            h_h_Tmmult_level_conserving(*(M.submatrices[1]),
                                        *(M1.submatrices[2]),
                                        *(M2.submatrices[3]),
                                        fixed_rank,
                                        false);
          }

        h_h_Tmmult_level_conserving(*(M.submatrices[2]),
                                    *(M1.submatrices[1]),
                                    *(M2.submatrices[0]),
                                    fixed_rank,
                                    false);
        h_h_Tmmult_level_conserving(*(M.submatrices[2]),
                                    *(M1.submatrices[3]),
                                    *(M2.submatrices[2]),
                                    fixed_rank,
                                    false);

        h_h_Tmmult_level_conserving(*(M.submatrices[3]),
                                    *(M1.submatrices[1]),
                                    *(M2.submatrices[1]),
                                    fixed_rank,
                                    is_result_matrix_store_tril_only);
        h_h_Tmmult_level_conserving(*(M.submatrices[3]),
                                    *(M1.submatrices[3]),
                                    *(M2.submatrices[3]),
                                    fixed_rank,
                                    is_result_matrix_store_tril_only);
      }
    else if (!(M.bc_node->is_leaf()))
      {
        /**
         * This is the case when the product matrix @p M is further divided,
         * while at least one of the two operands is a leaf. Hence the
         * multiplication on this level can be directly evaluated.
         *
         * 1. When one of the operand matrix is a rank-k matrix, the product
         * result is also a rank-k matrix.
         * 2. When one of the operand matrix is a full matrix, the immediate
         * product result is for sure a full matrix. However, because the block
         * cluster associated with @p M is not a leaf, @p M should be represented
         * as a rank-k matrix, which is converted from the full matrix. In the
         * current implementation, this conversion has no accuracy loss.
         */

        RkMatrix<Number> Z;
        if (M1.type == RkMatrixType)
          {
            rk_h_Tmmult(*(M1.rkmatrix), M2, Z);
          }
        else if (M2.type == RkMatrixType)
          {
            h_rk_Tmmult(M1, *(M2.rkmatrix), Z);
          }
        else if (M1.type == FullMatrixType)
          {
            f_h_Tmmult(*(M1.fullmatrix), M2, Z);
          }
        else if (M2.type == FullMatrixType)
          {
            h_f_Tmmult(M1, *(M2.fullmatrix), Z);
          }
        else
          {
            Assert(false, ExcInternalError());
          }

        /**
         * Add the result matrix @p Z into @p M and note that @p Z and @p M are
         * associated with a same block cluster.
         *
         * This addition is implemented by restricting @p Z to each leaf node of
         * @p M first, then the addition operation will be performed on each leaf
         * node respectively.
         *
         * \alert{The matrix @p Z should only be added into @p M but not simply
         * overwrite @p M. This is because the result matrix @p M on the block
         * cluster \f$\tau\times\rho\f$ may be contributed from several
         * multiplications with respect to a collection of \f$\{\sigma_i\}\f$,
         * which forms a partition of the index set \f$J\f$.}
         */
        M.add(Z, fixed_rank, is_result_matrix_store_tril_only);
      }
    else
      {
        /**
         * This is the first time of calling @p h_h_mmult_from_leaf_node, where
         * the second argument @p M is the product of @p M1 and @p M2. If there
         * are further recursive calls of this function, the second argument
         * will
         * be one level higher than the product of @p M1 and @p M2.
         */
        h_h_Tmmult_from_leaf_node(M,
                                  M,
                                  M1,
                                  M2,
                                  M.block_type,
                                  fixed_rank,
                                  is_result_matrix_store_tril_only);
      }
  }


  /**
   * Scaled multiplication of two level-conserving \hmatrices with the first
   * operand transposed. The result will be added to the target matrix \p M, i.e.
   * \f$M = M + \alpha M_1^T M_2\f$.
   *
   * \mynote{It is required that an empty result matrix \p M should be created
   * first with respect to a \bct.}
   *
   * @param M
   * @param alpha
   * @param M1
   * @param M2
   * @param fixed_rank
   * @param is_result_matrix_store_tril_only
   */
  template <int spacedim, typename Number>
  void
  h_h_Tmmult_level_conserving(
    HMatrix<spacedim, Number> &M,
    const Number               alpha,
    HMatrix<spacedim, Number> &M1,
    HMatrix<spacedim, Number> &M2,
    const unsigned int         fixed_rank,
    const bool                 is_result_matrix_store_tril_only = false)
  {
    if (!(M1.bc_node->is_leaf()) && !(M2.bc_node->is_leaf()) &&
        !(M.bc_node->is_leaf()))
      {
        /**
         * All matrices (including the two operands and the product result) have
         * substructure. Hence the \hmatrix multiplication type is cross.
         */
        h_h_Tmmult_level_conserving(*(M.submatrices[0]),
                                    alpha,
                                    *(M1.submatrices[0]),
                                    *(M2.submatrices[0]),
                                    fixed_rank,
                                    is_result_matrix_store_tril_only);
        h_h_Tmmult_level_conserving(*(M.submatrices[0]),
                                    alpha,
                                    *(M1.submatrices[2]),
                                    *(M2.submatrices[2]),
                                    fixed_rank,
                                    is_result_matrix_store_tril_only);

        /**
         * N.B. When the \hmatrix is symmetric or lower triangular, it stores
         * the lower triangular data only (including diagonal elements).
         */
        if ((!is_result_matrix_store_tril_only) ||
            (is_result_matrix_store_tril_only &&
             M.property != HMatrixSupport::symmetric &&
             M.property != HMatrixSupport::lower_triangular))
          {
            /**
             * The submatrix block @p M.submatrices[1] will be evaluated in two
             * scenarios:
             * 1. when the result matrix is not expected to be symmetric;
             * 2. when the result matrix is required to be symmetric a priori,
             * then if the product matrix @p M is not symmetric.
             */
            h_h_Tmmult_level_conserving(*(M.submatrices[1]),
                                        alpha,
                                        *(M1.submatrices[0]),
                                        *(M2.submatrices[1]),
                                        fixed_rank,
                                        false);
            h_h_Tmmult_level_conserving(*(M.submatrices[1]),
                                        alpha,
                                        *(M1.submatrices[2]),
                                        *(M2.submatrices[3]),
                                        fixed_rank,
                                        false);
          }

        h_h_Tmmult_level_conserving(*(M.submatrices[2]),
                                    alpha,
                                    *(M1.submatrices[1]),
                                    *(M2.submatrices[0]),
                                    fixed_rank,
                                    false);
        h_h_Tmmult_level_conserving(*(M.submatrices[2]),
                                    alpha,
                                    *(M1.submatrices[3]),
                                    *(M2.submatrices[2]),
                                    fixed_rank,
                                    false);

        h_h_Tmmult_level_conserving(*(M.submatrices[3]),
                                    alpha,
                                    *(M1.submatrices[1]),
                                    *(M2.submatrices[1]),
                                    fixed_rank,
                                    is_result_matrix_store_tril_only);
        h_h_Tmmult_level_conserving(*(M.submatrices[3]),
                                    alpha,
                                    *(M1.submatrices[3]),
                                    *(M2.submatrices[3]),
                                    fixed_rank,
                                    is_result_matrix_store_tril_only);
      }
    else if (!(M.bc_node->is_leaf()))
      {
        /**
         * This is the case when the product matrix @p M is further divided,
         * while at least one of the two operands is a leaf. Hence the
         * multiplication on this level can be directly evaluated.
         *
         * 1. When one of the operand matrix is a rank-k matrix, the product
         * result is also a rank-k matrix.
         * 2. When one of the operand matrix is a full matrix, the immediate
         * product result is for sure a full matrix. However, because the block
         * cluster associated with @p M is not a leaf, @p M should be represented
         * as a rank-k matrix, which is converted from the full matrix. In the
         * current implementation, this conversion has no accuracy loss.
         */

        RkMatrix<Number> Z;
        if (M1.type == RkMatrixType)
          {
            rk_h_Tmmult(alpha, *(M1.rkmatrix), M2, Z);
          }
        else if (M2.type == RkMatrixType)
          {
            h_rk_Tmmult(alpha, M1, *(M2.rkmatrix), Z);
          }
        else if (M1.type == FullMatrixType)
          {
            f_h_Tmmult(alpha, *(M1.fullmatrix), M2, Z);
          }
        else if (M2.type == FullMatrixType)
          {
            h_f_Tmmult(alpha, M1, *(M2.fullmatrix), Z);
          }
        else
          {
            Assert(false, ExcInternalError());
          }

        /**
         * Add the result matrix @p Z into @p M and note that @p Z and @p M are
         * associated with a same block cluster.
         *
         * This addition is implemented by restricting @p Z to each leaf node of
         * @p M first, then the addition operation will be performed on each leaf
         * node respectively.
         *
         * \alert{The matrix @p Z should only be added into @p M but not simply
         * overwrite @p M. This is because the result matrix @p M on the block
         * cluster \f$\tau\times\rho\f$ may be contributed from several
         * multiplications with respect to a collection of \f$\{\sigma_i\}\f$,
         * which forms a partition of the index set \f$J\f$.}
         */
        M.add(Z, fixed_rank, is_result_matrix_store_tril_only);
      }
    else
      {
        /**
         * This is the first time of calling @p h_h_mmult_from_leaf_node, where
         * the second argument @p M is the product of @p M1 and @p M2. If there
         * are further recursive calls of this function, the second argument
         * will
         * be one level higher than the product of @p M1 and @p M2.
         */
        h_h_Tmmult_from_leaf_node(M,
                                  M,
                                  alpha,
                                  M1,
                                  M2,
                                  M.block_type,
                                  fixed_rank,
                                  is_result_matrix_store_tril_only);
      }
  }


  /**
   * Deep copy an \hmatnode into the target node, i.e. the
   * copy is limited within the current node without recursion into its
   * descendants. This function will be called by \p copy_hmatrix.
   *
   * \mynote{1. Do not copy the list \p submatrices from the source submatrix,
   * because newly created child matrices will be pushed back into this list.
   * 2. Do not copy the list \p leaf_set. After the whole \hmatrix hierarchy has
   * been constructed, the leaf set will be built in the constructor.
   * 3. Do not copy the working data: \p Sigma_P, \p Sigma_F, \p Sigma_R and
   * \p Tind.
   * 4. Do not copy @p parent and it will be set during the recursive deep copy
   * of the \hmatrix.}
   *
   * @param hmat_dst
   * @param hmat_src
   */
  template <int spacedim, typename Number = double>
  void
  copy_hmatrix_node(HMatrix<spacedim, Number>       &hmat_dst,
                    const HMatrix<spacedim, Number> &hmat_src)
  {
    hmat_dst.type            = hmat_src.type;
    hmat_dst.state           = hmat_src.state;
    hmat_dst.property        = hmat_src.property;
    hmat_dst.block_type      = hmat_src.block_type;
    hmat_dst.submatrix_index = hmat_src.submatrix_index;

    /**
     * Copy the rank-k matrix in the source submatrix if it is not \p NULL.
     */
    if (hmat_src.rkmatrix != nullptr)
      {
        hmat_dst.rkmatrix = new RkMatrix<Number>(*(hmat_src.rkmatrix));
      }
    else
      {
        hmat_dst.rkmatrix = nullptr;
      }

    /**
     * Copy the full matrix in the source submatrix if it is not \p NULL.
     */
    if (hmat_src.fullmatrix != nullptr)
      {
        hmat_dst.fullmatrix =
          new LAPACKFullMatrixExt<Number>(*(hmat_src.fullmatrix));
      }
    else
      {
        hmat_dst.fullmatrix = nullptr;
      }

    hmat_dst.bc_node         = hmat_src.bc_node;
    hmat_dst.row_index_range = hmat_src.row_index_range;
    hmat_dst.col_index_range = hmat_src.col_index_range;
    hmat_dst.m               = hmat_src.m;
    hmat_dst.n               = hmat_src.n;
  }


  /**
   * Shallow copy an \hmatnode into the target node, i.e. the copy is limited
   * within the current node without recursion into its descendants. Or rather,
   * we can say the destination \hmatrix takes over the data from the source
   * \hmatrix.
   *
   * @param hmat_dst
   * @param hmat_src
   */
  template <int spacedim, typename Number = double>
  void
  copy_hmatrix_node(HMatrix<spacedim, Number>  &hmat_dst,
                    HMatrix<spacedim, Number> &&hmat_src)
  {
    hmat_dst.type                      = hmat_src.type;
    hmat_dst.state                     = hmat_src.state;
    hmat_dst.property                  = hmat_src.property;
    hmat_dst.block_type                = hmat_src.block_type;
    hmat_dst.dot_node_id               = hmat_src.dot_node_id;
    hmat_dst.submatrices               = hmat_src.submatrices;
    hmat_dst.submatrix_index           = hmat_src.submatrix_index;
    hmat_dst.parent                    = hmat_src.parent;
    hmat_dst.next_same_level_hmat_node = hmat_src.next_same_level_hmat_node;
    hmat_dst.next_same_level_same_row_hmat_node =
      hmat_src.next_same_level_same_row_hmat_node;
    hmat_dst.next_same_level_same_column_hmat_node =
      hmat_src.next_same_level_same_column_hmat_node;
    hmat_dst.previous_same_level_same_row_hmat_node =
      hmat_src.previous_same_level_same_row_hmat_node;
    hmat_dst.previous_same_level_same_column_hmat_node =
      hmat_src.previous_same_level_same_column_hmat_node;
    hmat_dst.leaf_set            = hmat_src.leaf_set;
    hmat_dst.near_field_leaf_set = hmat_src.near_field_leaf_set;
    hmat_dst.far_field_leaf_set  = hmat_src.far_field_leaf_set;
    hmat_dst.rkmatrix            = hmat_src.rkmatrix;
    hmat_dst.fullmatrix          = hmat_src.fullmatrix;
    hmat_dst.bc_node             = hmat_src.bc_node;
    hmat_dst.row_index_range     = hmat_src.row_index_range;
    hmat_dst.col_index_range     = hmat_src.col_index_range;
    hmat_dst.m                   = hmat_src.m;
    hmat_dst.n                   = hmat_src.n;
    hmat_dst.Sigma_P             = hmat_src.Sigma_P;
    hmat_dst.Sigma_R             = hmat_src.Sigma_R;
    hmat_dst.Sigma_F             = hmat_src.Sigma_F;
    hmat_dst.Tind                = std::move(hmat_src.Tind);
  }


  /**
   * Recursively copy an \hmatrix into the target matrix.
   * @param M_dst
   * @param M_src
   */
  template <int spacedim, typename Number = double>
  void
  copy_hmatrix(HMatrix<spacedim, Number>       &hmat_dst,
               const HMatrix<spacedim, Number> &hmat_src)
  {
    /**
     * Copy the current \hmatnode.
     */
    copy_hmatrix_node(hmat_dst, hmat_src);

    /**
     * Recursively copy child \hmatnodes.
     */
    for (HMatrix<spacedim, Number> *submatrix : hmat_src.submatrices)
      {
        Assert(submatrix, ExcInternalError());

        /**
         * Create a corresponding child \hmatnode on the heap
         * and push it back into the \p submatrices list of the current
         * \hmatnode.
         */
        HMatrix<spacedim, Number> *child_hmat = new HMatrix<spacedim, Number>();
        copy_hmatrix(*child_hmat, *submatrix);
        hmat_dst.submatrices.push_back(child_hmat);
        child_hmat->parent = &hmat_dst;
      }
  }


  template <int spacedim, typename Number = double>
  void
  print_h_submatrix_accessor(std::ostream                    &out,
                             const std::string               &name,
                             const HMatrix<spacedim, Number> &M)
  {
    out << name + std::string("([") << std::flush;
    print_vector_values(out, *(M.row_index_range), ",", false);
    out << "],[" << std::flush;
    print_vector_values(out, *(M.col_index_range), ",", false);
    out << "])";
  }


  template <int spacedim, typename Number = double>
  void
  print_h_h_submatrix_mmult_accessor(std::ostream                    &out,
                                     const std::string               &name1,
                                     const HMatrix<spacedim, Number> &M1,
                                     const std::string               &name2,
                                     const HMatrix<spacedim, Number> &M2)
  {
    print_h_submatrix_accessor(out, name1, M1);
    out << " * ";
    print_h_submatrix_accessor(out, name2, M2);
  }


  template <int spacedim, typename Number>
  void
  hmatrix_solve_lu(const HMatrix<spacedim, Number> &L,
                   const HMatrix<spacedim, Number> &U,
                   Vector<Number>                  &x,
                   const Vector<Number>            &b)
  {
    x = b;
    L.solve_by_forward_substitution(x, true);
    U.solve_by_backward_substitution(x, false);
  }


  template <int spacedim, typename Number>
  void
  hmatrix_solve_cholesky(const HMatrix<spacedim, Number> &L,
                         Vector<Number>                  &x,
                         const Vector<Number>            &b)
  {
    x = b;
    L.solve_cholesky_by_forward_substitution(x);
    L.solve_cholesky_by_backward_substitution(x);
  }


  template <int spacedim, typename Number>
  HMatrix<spacedim, Number>::HMatrix()
    : type(UndefinedMatrixType)
    , state(HMatrixSupport::matrix)
    , property(HMatrixSupport::general)
    , block_type(HMatrixSupport::undefined_block)
    , dot_node_id(0)
    , submatrices(0)
    , parent(nullptr)
    , next_same_level_hmat_node(nullptr)
    , next_same_level_same_row_hmat_node(nullptr)
    , next_same_level_same_column_hmat_node(nullptr)
    , previous_same_level_same_row_hmat_node(nullptr)
    , previous_same_level_same_column_hmat_node(nullptr)
    , submatrix_index(submatrix_index_invalid)
    , leaf_set(0)
    , near_field_leaf_set(0)
    , far_field_leaf_set(0)
    , rkmatrix(nullptr)
    , fullmatrix(nullptr)
    , bc_node(nullptr)
    , row_index_range(nullptr)
    , col_index_range(nullptr)
    , m(0)
    , n(0)
    , Tind()
    , Sigma_P(0)
    , Sigma_R(0)
    , Sigma_F(0)
  {}


  template <int spacedim, typename Number>
  HMatrix<spacedim, Number>::HMatrix(
    const BlockClusterTree<spacedim, Number> &bct,
    const unsigned int                        fixed_rank_k,
    const HMatrixSupport::Property            property,
    const HMatrixSupport::BlockType           block_type)
    : type(UndefinedMatrixType)
    , state(HMatrixSupport::matrix)
    , property(property)
    , block_type(block_type)
    , dot_node_id(0)
    , submatrices(0)
    , parent(nullptr)
    , next_same_level_hmat_node(nullptr)
    , next_same_level_same_row_hmat_node(nullptr)
    , next_same_level_same_column_hmat_node(nullptr)
    , previous_same_level_same_row_hmat_node(nullptr)
    , previous_same_level_same_column_hmat_node(nullptr)
    , submatrix_index(submatrix_index_invalid)
    , leaf_set(0)
    , near_field_leaf_set(0)
    , far_field_leaf_set(0)
    , rkmatrix(nullptr)
    , fullmatrix(nullptr)
    , bc_node(nullptr)
    , row_index_range(nullptr)
    , col_index_range(nullptr)
    , m(0)
    , n(0)
    , Tind()
    , Sigma_P(0)
    , Sigma_R(0)
    , Sigma_F(0)
  {
    InitAndCreateHMatrixChildren(this, bct.get_root(), fixed_rank_k, property);
    build_leaf_set();
    link_hmat_nodes_on_same_levels();
  }


  template <int spacedim, typename Number>
  HMatrix<spacedim, Number>::HMatrix(
    typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
                                    bc_node,
    const unsigned int              fixed_rank_k,
    const HMatrixSupport::Property  property,
    const HMatrixSupport::BlockType block_type)
    : type(UndefinedMatrixType)
    , state(HMatrixSupport::matrix)
    , property(property)
    , block_type(block_type)
    , dot_node_id(0)
    , submatrices(0)
    , parent(nullptr)
    , next_same_level_hmat_node(nullptr)
    , next_same_level_same_row_hmat_node(nullptr)
    , next_same_level_same_column_hmat_node(nullptr)
    , previous_same_level_same_row_hmat_node(nullptr)
    , previous_same_level_same_column_hmat_node(nullptr)
    , submatrix_index(submatrix_index_invalid)
    , leaf_set(0)
    , near_field_leaf_set(0)
    , far_field_leaf_set(0)
    , rkmatrix(nullptr)
    , fullmatrix(nullptr)
    , bc_node(nullptr)
    , row_index_range(nullptr)
    , col_index_range(nullptr)
    , m(0)
    , n(0)
    , Tind()
    , Sigma_P(0)
    , Sigma_R(0)
    , Sigma_F(0)
  {
    InitAndCreateHMatrixChildren(this, bc_node, fixed_rank_k, property);
    build_leaf_set();
    link_hmat_nodes_on_same_levels();
  }


  template <int spacedim, typename Number>
  HMatrix<spacedim, Number>::HMatrix(
    const BlockClusterTree<spacedim, Number> &bct,
    const LAPACKFullMatrixExt<Number>        &M,
    const unsigned int                        fixed_rank_k,
    const HMatrixSupport::BlockType           block_type)
    : type(UndefinedMatrixType)
    , state(HMatrixSupport::matrix)
    , property(HMatrixSupport::general)
    , block_type(block_type)
    , dot_node_id(0)
    , submatrices(0)
    , parent(nullptr)
    , next_same_level_hmat_node(nullptr)
    , next_same_level_same_row_hmat_node(nullptr)
    , next_same_level_same_column_hmat_node(nullptr)
    , previous_same_level_same_row_hmat_node(nullptr)
    , previous_same_level_same_column_hmat_node(nullptr)
    , submatrix_index(submatrix_index_invalid)
    , leaf_set(0)
    , near_field_leaf_set(0)
    , far_field_leaf_set(0)
    , rkmatrix(nullptr)
    , fullmatrix(nullptr)
    , bc_node(nullptr)
    , row_index_range(nullptr)
    , col_index_range(nullptr)
    , m(0)
    , n(0)
    , Tind()
    , Sigma_P(0)
    , Sigma_R(0)
    , Sigma_F(0)
  {
    /**
     * Determine the property of the \hmatrix from the global full matrix.
     */
    set_current_matrix_property(M);

    InitAndCreateHMatrixChildren(
      this, bct.get_root(), fixed_rank_k, M, property);
    build_leaf_set();
    link_hmat_nodes_on_same_levels();
  }


  template <int spacedim, typename Number>
  HMatrix<spacedim, Number>::HMatrix(
    const BlockClusterTree<spacedim, Number> &bct,
    const LAPACKFullMatrixExt<Number>        &M,
    const HMatrixSupport::BlockType           block_type)
    : type(UndefinedMatrixType)
    , state(HMatrixSupport::matrix)
    , property(HMatrixSupport::general)
    , block_type(block_type)
    , dot_node_id(0)
    , submatrices(0)
    , parent(nullptr)
    , next_same_level_hmat_node(nullptr)
    , next_same_level_same_row_hmat_node(nullptr)
    , next_same_level_same_column_hmat_node(nullptr)
    , previous_same_level_same_row_hmat_node(nullptr)
    , previous_same_level_same_column_hmat_node(nullptr)
    , submatrix_index(submatrix_index_invalid)
    , leaf_set(0)
    , near_field_leaf_set(0)
    , far_field_leaf_set(0)
    , rkmatrix(nullptr)
    , fullmatrix(nullptr)
    , bc_node(nullptr)
    , row_index_range(nullptr)
    , col_index_range(nullptr)
    , m(0)
    , n(0)
    , Tind()
    , Sigma_P(0)
    , Sigma_R(0)
    , Sigma_F(0)
  {
    /**
     * Determine the property of the \hmatrix from the global full matrix.
     */
    set_current_matrix_property(M);

    InitAndCreateHMatrixChildren(this, bct.get_root(), M, property);
    build_leaf_set();
    link_hmat_nodes_on_same_levels();
  }


  template <int spacedim, typename Number>
  HMatrix<spacedim, Number>::HMatrix(
    typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
                                       bc_node,
    const LAPACKFullMatrixExt<Number> &M,
    const unsigned int                 fixed_rank_k,
    const HMatrixSupport::Property     property,
    const HMatrixSupport::BlockType    block_type)
    : type(UndefinedMatrixType)
    , state(HMatrixSupport::matrix)
    , property(property)
    , block_type(block_type)
    , dot_node_id(0)
    , submatrices(0)
    , parent(nullptr)
    , next_same_level_hmat_node(nullptr)
    , next_same_level_same_row_hmat_node(nullptr)
    , next_same_level_same_column_hmat_node(nullptr)
    , previous_same_level_same_row_hmat_node(nullptr)
    , previous_same_level_same_column_hmat_node(nullptr)
    , submatrix_index(submatrix_index_invalid)
    , leaf_set(0)
    , near_field_leaf_set(0)
    , far_field_leaf_set(0)
    , rkmatrix(nullptr)
    , fullmatrix(nullptr)
    , bc_node(nullptr)
    , row_index_range(nullptr)
    , col_index_range(nullptr)
    , m(0)
    , n(0)
    , Tind()
    , Sigma_P(0)
    , Sigma_R(0)
    , Sigma_F(0)
  {
    InitAndCreateHMatrixChildren(this, bc_node, fixed_rank_k, M, property);
    build_leaf_set();
    link_hmat_nodes_on_same_levels();
  }


  template <int spacedim, typename Number>
  HMatrix<spacedim, Number>::HMatrix(
    typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
                                       bc_node,
    const LAPACKFullMatrixExt<Number> &M,
    const HMatrixSupport::Property     property,
    const HMatrixSupport::BlockType    block_type)
    : type(UndefinedMatrixType)
    , state(HMatrixSupport::matrix)
    , property(property)
    , block_type(block_type)
    , dot_node_id(0)
    , submatrices(0)
    , parent(nullptr)
    , next_same_level_hmat_node(nullptr)
    , next_same_level_same_row_hmat_node(nullptr)
    , next_same_level_same_column_hmat_node(nullptr)
    , previous_same_level_same_row_hmat_node(nullptr)
    , previous_same_level_same_column_hmat_node(nullptr)
    , submatrix_index(submatrix_index_invalid)
    , leaf_set(0)
    , near_field_leaf_set(0)
    , far_field_leaf_set(0)
    , rkmatrix(nullptr)
    , fullmatrix(nullptr)
    , bc_node(nullptr)
    , row_index_range(nullptr)
    , col_index_range(nullptr)
    , m(0)
    , n(0)
    , Tind()
    , Sigma_P(0)
    , Sigma_R(0)
    , Sigma_F(0)
  {
    InitAndCreateHMatrixChildren(this, bc_node, M, property);
    build_leaf_set();
    link_hmat_nodes_on_same_levels();
  }


  template <int spacedim, typename Number>
  HMatrix<spacedim, Number>::HMatrix(
    typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
                                    bc_node,
    HMatrix<spacedim, Number>     &&H,
    const HMatrixSupport::Property  property,
    const HMatrixSupport::BlockType block_type)
    : type(UndefinedMatrixType)
    , state(HMatrixSupport::matrix)
    , property(property)
    , block_type(block_type)
    , dot_node_id(0)
    , submatrices(0)
    , parent(nullptr)
    , next_same_level_hmat_node(nullptr)
    , next_same_level_same_row_hmat_node(nullptr)
    , next_same_level_same_column_hmat_node(nullptr)
    , previous_same_level_same_row_hmat_node(nullptr)
    , previous_same_level_same_column_hmat_node(nullptr)
    , submatrix_index(submatrix_index_invalid)
    , leaf_set(0)
    , near_field_leaf_set(0)
    , far_field_leaf_set(0)
    , rkmatrix(nullptr)
    , fullmatrix(nullptr)
    , bc_node(nullptr)
    , row_index_range(nullptr)
    , col_index_range(nullptr)
    , m(0)
    , n(0)
    , Tind(std::move(H.Tind))
    , Sigma_P(0)
    , Sigma_R(0)
    , Sigma_F(0)
  {
    InitAndCreateHMatrixChildren(this, bc_node, std::move(H));
    build_leaf_set();
    link_hmat_nodes_on_same_levels();
  }


  template <int spacedim, typename Number>
  HMatrix<spacedim, Number>::HMatrix(
    const BlockClusterTree<spacedim, Number> &bct,
    HMatrix<spacedim, Number>               &&H,
    const HMatrixSupport::Property            property,
    const HMatrixSupport::BlockType           block_type)
    : type(UndefinedMatrixType)
    , state(HMatrixSupport::matrix)
    , property(property)
    , block_type(block_type)
    , dot_node_id(0)
    , submatrices(0)
    , parent(nullptr)
    , next_same_level_hmat_node(nullptr)
    , next_same_level_same_row_hmat_node(nullptr)
    , next_same_level_same_column_hmat_node(nullptr)
    , previous_same_level_same_row_hmat_node(nullptr)
    , previous_same_level_same_column_hmat_node(nullptr)
    , submatrix_index(submatrix_index_invalid)
    , leaf_set(0)
    , near_field_leaf_set(0)
    , far_field_leaf_set(0)
    , rkmatrix(nullptr)
    , fullmatrix(nullptr)
    , bc_node(nullptr)
    , row_index_range(nullptr)
    , col_index_range(nullptr)
    , m(0)
    , n(0)
    , Tind(std::move(H.Tind))
    , Sigma_P(0)
    , Sigma_R(0)
    , Sigma_F(0)
  {
    InitAndCreateHMatrixChildren(this, bct.get_root(), std::move(H));
    build_leaf_set();
    link_hmat_nodes_on_same_levels();
  }


  template <int spacedim, typename Number>
  HMatrix<spacedim, Number>::HMatrix(const HMatrix<spacedim, Number> &H)
    : type(UndefinedMatrixType)
    , state(HMatrixSupport::matrix)
    , property(HMatrixSupport::general)
    , block_type(HMatrixSupport::undefined_block)
    , dot_node_id(0)
    , submatrices(0)
    , parent(nullptr)
    , next_same_level_hmat_node(nullptr)
    , next_same_level_same_row_hmat_node(nullptr)
    , next_same_level_same_column_hmat_node(nullptr)
    , previous_same_level_same_row_hmat_node(nullptr)
    , previous_same_level_same_column_hmat_node(nullptr)
    , submatrix_index(submatrix_index_invalid)
    , leaf_set(0)
    , near_field_leaf_set(0)
    , far_field_leaf_set(0)
    , rkmatrix(nullptr)
    , fullmatrix(nullptr)
    , bc_node(nullptr)
    , row_index_range(nullptr)
    , col_index_range(nullptr)
    , m(0)
    , n(0)
    , Tind()
    , Sigma_P(0)
    , Sigma_R(0)
    , Sigma_F(0)
  {
    copy_hmatrix(*this, H);
    build_leaf_set();
    link_hmat_nodes_on_same_levels();
  }


  template <int spacedim, typename Number>
  HMatrix<spacedim, Number>::HMatrix(HMatrix<spacedim, Number> &&H) noexcept
    : type(H.type)
    , state(H.state)
    , property(H.property)
    , block_type(H.block_type)
    , dot_node_id(H.dot_node_id)
    , submatrices(H.submatrices)
    , parent(H.parent)
    , next_same_level_hmat_node(H.next_same_level_hmat_node)
    , next_same_level_same_row_hmat_node(H.next_same_level_same_row_hmat_node)
    , next_same_level_same_column_hmat_node(
        H.next_same_level_same_column_hmat_node)
    , previous_same_level_same_row_hmat_node(
        H.previous_same_level_same_row_hmat_node)
    , previous_same_level_same_column_hmat_node(
        H.previous_same_level_same_column_hmat_node)
    , submatrix_index(H.submatrix_index)
    , leaf_set(H.leaf_set)
    , near_field_leaf_set(H.near_field_leaf_set)
    , far_field_leaf_set(H.far_field_leaf_set)
    , rkmatrix(H.rkmatrix)
    , fullmatrix(H.fullmatrix)
    , bc_node(H.bc_node)
    , row_index_range(H.row_index_range)
    , col_index_range(H.col_index_range)
    , m(H.m)
    , n(H.n)
    , Tind(std::move(H.Tind))
    , Sigma_P(H.Sigma_P)
    , Sigma_R(H.Sigma_R)
    , Sigma_F(H.Sigma_F)
  {
    H.clear_hmat_node();
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::reinit(
    const BlockClusterTree<spacedim, Number> &bct,
    const unsigned int                        fixed_rank_k,
    const HMatrixSupport::Property            property,
    const HMatrixSupport::BlockType           block_type)
  {
    release();

    this->property   = property;
    this->block_type = block_type;

    InitAndCreateHMatrixChildren(this,
                                 bct.get_root(),
                                 fixed_rank_k,
                                 this->property);
    build_leaf_set();
    link_hmat_nodes_on_same_levels();
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::reinit(
    typename BlockClusterTree<spacedim, Number>::node_const_pointer_type
                                    bc_node,
    const unsigned int              fixed_rank_k,
    const HMatrixSupport::Property  property,
    const HMatrixSupport::BlockType block_type)
  {
    release();

    this->property   = property;
    this->block_type = block_type;

    InitAndCreateHMatrixChildren(this, bc_node, fixed_rank_k, this->property);
    build_leaf_set();
    link_hmat_nodes_on_same_levels();
  }


  template <int spacedim, typename Number>
  HMatrix<spacedim, Number> &
  HMatrix<spacedim, Number>::operator=(HMatrix<spacedim, Number> &&H) noexcept
  {
    /**
     * \alert{This test prevents self-assignment.}
     */
    if (this != &H)
      {
        release();
        copy_hmatrix_node((*this), std::move(H));
        H.clear_hmat_node();

        /**
         * \alert{When the block cluster node corresponding to the current \hmat
         * node is the root node and the \hmat has no children, the leaf set
         * should be rebuilt because it previously stored the \hmat node pointer
         * of @p H.
         *
         * N.B. In \hmat algebraic operations, there will be the case that an
         * \hmat node is created with respect to a non-root block cluster node.
         * Even though the \hmat node itself has no parent, its associated block
         * cluster node has parent. In this case, the leaf set will not be
         * rebuilt.}
         */
        if (bc_node->is_root() && submatrices.size() == 0)
          {
            // When there is only one root node in the \hmat hierarchy, the
            // \hmat type can only be @p FullMatrixType.
            Assert(type == HMatrixType::FullMatrixType,
                   ExcInvalidHMatrixType(type));
            build_leaf_set();
            /**
             * Since there is only one node in the \hmatrix hierarchy, there is
             * no need to link nodes on same levels.
             */
          }
      }

    return (*this);
  }


  template <int spacedim, typename Number>
  HMatrix<spacedim, Number> &
  HMatrix<spacedim, Number>::operator=(const HMatrix<spacedim, Number> &H)
  {
    release();
    copy_hmatrix(*this, H);
    build_leaf_set();
    link_hmat_nodes_on_same_levels();

    return (*this);
  }


  template <int spacedim, typename Number>
  template <typename MatrixType>
  void
  HMatrix<spacedim, Number>::convertToFullMatrix(MatrixType &M) const
  {
    M.reinit(m, n);
    _convertToFullMatrix(M, property);

    /**
     * Set the property of the full matrix according to the top level \hmat.
     */
    set_property_for_converted_fullmatrix(M);
  }


  template <int spacedim, typename Number>
  template <typename MatrixType>
  void
  HMatrix<spacedim, Number>::_convertToFullMatrix(
    MatrixType                    &M,
    const HMatrixSupport::Property top_hmat_property) const
  {
    LAPACKFullMatrixExt<Number> matrix_block;

    switch (type)
      {
        case FullMatrixType:
          Assert(fullmatrix, ExcInternalError());

          switch (top_hmat_property)
            {
                case HMatrixSupport::general: {
                  for (size_type i = 0; i < m; i++)
                    {
                      for (size_type j = 0; j < n; j++)
                        {
                          M((*row_index_range)[0] + i,
                            (*col_index_range)[0] + j) = (*fullmatrix)(i, j);
                        }
                    }

                  break;
                }
              case HMatrixSupport::symmetric:
                case HMatrixSupport::lower_triangular: {
                  /**
                   * In principle, we should make assertion here that the block
                   * type of the top level \hmatrix should be diagonal. However,
                   * this also requires to pass the block type of the top level
                   * \hmatrix into this function. To simplify the calling of
                   * this function, we do not make the assertion.
                   */

                  if (this->block_type == HMatrixSupport::diagonal_block)
                    {
                      for (size_type i = 0; i < m; i++)
                        {
                          for (size_type j = 0; j <= i; j++)
                            {
                              M((*row_index_range)[0] + i,
                                (*col_index_range)[0] + j) =
                                (*fullmatrix)(i, j);
                            }
                        }
                    }
                  else if (this->block_type ==
                           HMatrixSupport::lower_triangular_block)
                    {
                      for (size_type i = 0; i < m; i++)
                        {
                          for (size_type j = 0; j < n; j++)
                            {
                              M((*row_index_range)[0] + i,
                                (*col_index_range)[0] + j) =
                                (*fullmatrix)(i, j);
                            }
                        }
                    }

                  break;
                }
                case HMatrixSupport::upper_triangular: {
                  /**
                   * In principle, we should make assertion here that the block
                   * type of the top level \hmatrix should be diagonal. However,
                   * this also requires to pass the block type of the top level
                   * \hmatrix into this function. To simplify the calling of
                   * this function, we do not make the assertion.
                   */

                  if (this->block_type == HMatrixSupport::diagonal_block)
                    {
                      for (size_type i = 0; i < m; i++)
                        {
                          for (size_type j = i; j < n; j++)
                            {
                              M((*row_index_range)[0] + i,
                                (*col_index_range)[0] + j) =
                                (*fullmatrix)(i, j);
                            }
                        }
                    }
                  else if (this->block_type ==
                           HMatrixSupport::upper_triangular_block)
                    {
                      for (size_type i = 0; i < m; i++)
                        {
                          for (size_type j = 0; j < n; j++)
                            {
                              M((*row_index_range)[0] + i,
                                (*col_index_range)[0] + j) =
                                (*fullmatrix)(i, j);
                            }
                        }
                    }

                  break;
                }
                default: {
                  Assert(false, ExcInvalidHMatrixProperty(top_hmat_property));

                  break;
                }
            }

          break;
        case RkMatrixType:
          Assert(rkmatrix, ExcInternalError());

          switch (top_hmat_property)
            {
                case HMatrixSupport::general: {
                  if (rkmatrix->convertToFullMatrix(matrix_block))
                    {
                      /**
                       * Only when the converted full matrix is not zero-valued,
                       * the values will be copied to the full matrix.
                       */
                      for (size_type i = 0; i < m; i++)
                        {
                          for (size_type j = 0; j < n; j++)
                            {
                              M((*row_index_range)[0] + i,
                                (*col_index_range)[0] + j) = matrix_block(i, j);
                            }
                        }
                    }

                  break;
                }
              case HMatrixSupport::symmetric:
                case HMatrixSupport::lower_triangular: {
                  /**
                   * In principle, we should make assertion here that the block
                   * type of the top level \hmatrix should be diagonal. However,
                   * this also requires to pass the block type of the top level
                   * \hmatrix into this function. To simplify the calling of
                   * this function, we do not make the assertion.
                   */

                  if (this->block_type == HMatrixSupport::diagonal_block)
                    {
                      Assert(
                        false,
                        ExcMessage(
                          "Rank-k matrix cannot belong to the diagonal part!"));
                    }
                  else if (this->block_type ==
                           HMatrixSupport::lower_triangular_block)
                    {
                      if (rkmatrix->convertToFullMatrix(matrix_block))
                        {
                          /**
                           * Only when the converted full matrix is not
                           * zero-valued, the values will be copied to the full
                           * matrix.
                           */
                          for (size_type i = 0; i < m; i++)
                            {
                              for (size_type j = 0; j < n; j++)
                                {
                                  M((*row_index_range)[0] + i,
                                    (*col_index_range)[0] + j) =
                                    matrix_block(i, j);
                                }
                            }
                        }
                    }

                  break;
                }
                case HMatrixSupport::upper_triangular: {
                  /**
                   * In principle, we should make assertion here that the block
                   * type of the top level \hmatrix should be diagonal. However,
                   * this also requires to pass the block type of the top level
                   * \hmatrix into this function. To simplify the calling of
                   * this function, we do not make the assertion.
                   */

                  if (this->block_type == HMatrixSupport::diagonal_block)
                    {
                      Assert(
                        false,
                        ExcMessage(
                          "Rank-k matrix cannot belong to the diagonal part!"));
                    }
                  else if (this->block_type ==
                           HMatrixSupport::upper_triangular_block)
                    {
                      if (rkmatrix->convertToFullMatrix(matrix_block))
                        {
                          /**
                           * Only when the converted full matrix is not
                           * zero-valued, the values will be copied to the full
                           * matrix.
                           */
                          for (size_type i = 0; i < m; i++)
                            {
                              for (size_type j = 0; j < n; j++)
                                {
                                  M((*row_index_range)[0] + i,
                                    (*col_index_range)[0] + j) =
                                    matrix_block(i, j);
                                }
                            }
                        }
                    }

                  break;
                }
                default: {
                  Assert(false, ExcInvalidHMatrixProperty(top_hmat_property));

                  break;
                }
            }

          break;
        case HierarchicalMatrixType:
          for (HMatrix *submatrix : submatrices)
            {
              submatrix->_convertToFullMatrix(M, top_hmat_property);
            }

          break;
        default:
          Assert(false, ExcInvalidHMatrixType(type));
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::_build_leaf_set_z_traversal(
    std::vector<HMatrix *> &total_leaf_set,
    std::vector<HMatrix *> &total_near_field_leaf_set,
    std::vector<HMatrix *> &total_far_field_leaf_set) const
  {
    switch (type)
      {
          case FullMatrixType: {
            total_leaf_set.push_back(const_cast<HMatrix *>(this));
            total_near_field_leaf_set.push_back(const_cast<HMatrix *>(this));

            break;
          }
          case RkMatrixType: {
            total_leaf_set.push_back(const_cast<HMatrix *>(this));
            total_far_field_leaf_set.push_back(const_cast<HMatrix *>(this));

            break;
          }
          case HierarchicalMatrixType: {
            for (HMatrix *submatrix : submatrices)
              {
                submatrix->_build_leaf_set_z_traversal(
                  total_leaf_set,
                  total_near_field_leaf_set,
                  total_far_field_leaf_set);
              }

            break;
          }
          default: {
            Assert(false, ExcInvalidHMatrixType(type));

            break;
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::_build_leaf_set_hilbert_traversal(
    std::vector<HMatrix *> &total_leaf_set,
    std::vector<HMatrix *> &total_near_field_leaf_set,
    std::vector<HMatrix *> &total_far_field_leaf_set,
    HilbertBlockType        current_hilbert_block_type) const
  {
    switch (type)
      {
          case FullMatrixType: {
            total_leaf_set.push_back(const_cast<HMatrix *>(this));
            total_near_field_leaf_set.push_back(const_cast<HMatrix *>(this));

            break;
          }
          case RkMatrixType: {
            total_leaf_set.push_back(const_cast<HMatrix *>(this));
            total_far_field_leaf_set.push_back(const_cast<HMatrix *>(this));

            break;
          }
          case HierarchicalMatrixType: {
            /**
             * The H-matrix should be a quad-tree in this scenario.
             */
            AssertDimension(submatrices.size(), 4);

            switch (current_hilbert_block_type)
              {
                  case HilbertBlockType::A: {
                    submatrices[2]->_build_leaf_set_hilbert_traversal(
                      total_leaf_set,
                      total_near_field_leaf_set,
                      total_far_field_leaf_set,
                      HilbertBlockType::B);

                    submatrices[0]->_build_leaf_set_hilbert_traversal(
                      total_leaf_set,
                      total_near_field_leaf_set,
                      total_far_field_leaf_set,
                      HilbertBlockType::A);

                    submatrices[1]->_build_leaf_set_hilbert_traversal(
                      total_leaf_set,
                      total_near_field_leaf_set,
                      total_far_field_leaf_set,
                      HilbertBlockType::A);

                    submatrices[3]->_build_leaf_set_hilbert_traversal(
                      total_leaf_set,
                      total_near_field_leaf_set,
                      total_far_field_leaf_set,
                      HilbertBlockType::C);

                    break;
                  }
                  case HilbertBlockType::B: {
                    submatrices[2]->_build_leaf_set_hilbert_traversal(
                      total_leaf_set,
                      total_near_field_leaf_set,
                      total_far_field_leaf_set,
                      HilbertBlockType::A);

                    submatrices[3]->_build_leaf_set_hilbert_traversal(
                      total_leaf_set,
                      total_near_field_leaf_set,
                      total_far_field_leaf_set,
                      HilbertBlockType::B);

                    submatrices[1]->_build_leaf_set_hilbert_traversal(
                      total_leaf_set,
                      total_near_field_leaf_set,
                      total_far_field_leaf_set,
                      HilbertBlockType::B);

                    submatrices[0]->_build_leaf_set_hilbert_traversal(
                      total_leaf_set,
                      total_near_field_leaf_set,
                      total_far_field_leaf_set,
                      HilbertBlockType::D);

                    break;
                  }
                  case HilbertBlockType::C: {
                    submatrices[1]->_build_leaf_set_hilbert_traversal(
                      total_leaf_set,
                      total_near_field_leaf_set,
                      total_far_field_leaf_set,
                      HilbertBlockType::D);

                    submatrices[0]->_build_leaf_set_hilbert_traversal(
                      total_leaf_set,
                      total_near_field_leaf_set,
                      total_far_field_leaf_set,
                      HilbertBlockType::C);

                    submatrices[2]->_build_leaf_set_hilbert_traversal(
                      total_leaf_set,
                      total_near_field_leaf_set,
                      total_far_field_leaf_set,
                      HilbertBlockType::C);

                    submatrices[3]->_build_leaf_set_hilbert_traversal(
                      total_leaf_set,
                      total_near_field_leaf_set,
                      total_far_field_leaf_set,
                      HilbertBlockType::A);

                    break;
                  }
                  case HilbertBlockType::D: {
                    submatrices[1]->_build_leaf_set_hilbert_traversal(
                      total_leaf_set,
                      total_near_field_leaf_set,
                      total_far_field_leaf_set,
                      HilbertBlockType::C);

                    submatrices[3]->_build_leaf_set_hilbert_traversal(
                      total_leaf_set,
                      total_near_field_leaf_set,
                      total_far_field_leaf_set,
                      HilbertBlockType::D);

                    submatrices[2]->_build_leaf_set_hilbert_traversal(
                      total_leaf_set,
                      total_near_field_leaf_set,
                      total_far_field_leaf_set,
                      HilbertBlockType::D);

                    submatrices[0]->_build_leaf_set_hilbert_traversal(
                      total_leaf_set,
                      total_near_field_leaf_set,
                      total_far_field_leaf_set,
                      HilbertBlockType::B);

                    break;
                  }
              }

            break;
          }
          default: {
            Assert(false, ExcInvalidHMatrixType(type));

            break;
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::
    distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves(
      const unsigned int fixed_rank)
  {
    /**
     * Only non-leaf \hmatnodes need to be processed.
     */
    if (submatrices.size() > 0)
      {
        /**
         * Since the current \hmatnode has children, its type
         * should be \p HierarchicalMatrixType and we make an assertion on it.
         */
        Assert(type == HierarchicalMatrixType, ExcInvalidHMatrixType(type));

        /**
         * Distribute matrices in \f$\Sigma_b^R\f$ and \f$\Sigma_b^F\f$ of the
         * current \hmatnode to the leaf nodes which are its descendants.
         * This is a recursive function call.
         */
        distribute_sigma_r_and_f_to_leaves(fixed_rank);

        /**
         * Distribute matrices in \f$\Sigma_b^R\f$ and \f$\Sigma_b^F\f$ of each
         * child matrix of the current \hmatnode to the leaf nodes which are
         * its descendants.
         */
        for (HMatrix<spacedim, Number> *submatrix : submatrices)
          {
            Assert(submatrix, ExcInternalError());

            submatrix->distribute_all_non_leaf_nodes_sigma_r_and_f_to_leaves(
              fixed_rank);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::distribute_sigma_r_and_f_to_leaves(
    const unsigned int fixed_rank)
  {
    if (Sigma_R.size() > 0 || Sigma_F.size() > 0)
      {
        _distribute_sigma_r_and_f_to_leaves(*this, fixed_rank);

        for (auto &rkmatrix_in_starting_hmat : Sigma_R)
          {
            if (rkmatrix_in_starting_hmat != nullptr)
              {
                delete rkmatrix_in_starting_hmat;
                rkmatrix_in_starting_hmat = nullptr;
              }
          }

        Sigma_R.clear();

        for (auto &fullmatrix_in_starting_hmat : Sigma_F)
          {
            if (fullmatrix_in_starting_hmat != nullptr)
              {
                delete fullmatrix_in_starting_hmat;
                fullmatrix_in_starting_hmat = nullptr;
              }
          }

        Sigma_F.clear();
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::_distribute_sigma_r_and_f_to_leaves(
    HMatrix<spacedim, Number> &starting_hmat,
    const unsigned int         fixed_rank)
  {
    if (submatrices.size() > 0)
      {
        for (HMatrix<spacedim, Number> *submatrix : submatrices)
          {
            submatrix->_distribute_sigma_r_and_f_to_leaves(starting_hmat,
                                                           fixed_rank);
          }
      }
    else
      {
        switch (type)
          {
              case FullMatrixType: {
                /**
                 * Restrict each rank-k matrix in the list \p Sigma_R of \p
                 * starting_hmat to the block as a full matrix.
                 */
                for (RkMatrix<Number> *rkmatrix_in_starting_hmat :
                     starting_hmat.Sigma_R)
                  {
                    Assert(rkmatrix_in_starting_hmat, ExcInternalError());

                    LAPACKFullMatrixExt<Number> fullmatrix_restricted;

                    rkmatrix_in_starting_hmat->restrictToFullMatrix(
                      *starting_hmat.row_index_range,
                      *starting_hmat.col_index_range,
                      fullmatrix_restricted,
                      *row_index_range,
                      *col_index_range);

                    fullmatrix->add(fullmatrix_restricted);
                  }

                /**
                 * Restrict each full matrix in the list \p Sigma_F of \p
                 * starting_hmat to the block as a full matrix.
                 */
                for (LAPACKFullMatrixExt<Number> *fullmatrix_in_starting_hmat :
                     starting_hmat.Sigma_F)
                  {
                    Assert(fullmatrix_in_starting_hmat, ExcInternalError());

                    LAPACKFullMatrixExt<Number> fullmatrix_restricted(
                      *row_index_range,
                      *col_index_range,
                      *fullmatrix_in_starting_hmat,
                      *starting_hmat.row_index_range,
                      *starting_hmat.col_index_range);

                    fullmatrix->add(fullmatrix_restricted);
                  }

                break;
              }
              case RkMatrixType: {
                /**
                 * Restrict each rank-k matrix in the list \p Sigma_R of \p
                 * starting_hmat to the block as a rank-k matrix.
                 */
                for (RkMatrix<Number> *rkmatrix_in_starting_hmat :
                     starting_hmat.Sigma_R)
                  {
                    Assert(rkmatrix_in_starting_hmat, ExcInternalError());

                    RkMatrix<Number> rkmatrix_restricted(
                      *row_index_range,
                      *col_index_range,
                      *rkmatrix_in_starting_hmat,
                      *starting_hmat.row_index_range,
                      *starting_hmat.col_index_range);

                    if (fixed_rank == 0)
                      {
                        rkmatrix->add(rkmatrix_restricted);
                      }
                    else
                      {
                        rkmatrix->add(rkmatrix_restricted, fixed_rank);
                      }
                  }

                /**
                 * Restrict each full matrix in the list \p Sigma_F of \p
                 * starting_hmat to the block as a rank-k matrix.
                 */
                for (LAPACKFullMatrixExt<Number> *fullmatrix_in_starting_hmat :
                     starting_hmat.Sigma_F)
                  {
                    Assert(fullmatrix_in_starting_hmat, ExcInternalError());

                    RkMatrix<Number> rkmatrix_restricted(
                      *row_index_range,
                      *col_index_range,
                      *fullmatrix_in_starting_hmat,
                      *starting_hmat.row_index_range,
                      *starting_hmat.col_index_range);

                    if (fixed_rank == 0)
                      {
                        rkmatrix->add(rkmatrix_restricted);
                      }
                    else
                      {
                        rkmatrix->add(rkmatrix_restricted, fixed_rank);
                      }
                  }

                break;
              }
              default: {
                Assert(false, ExcInvalidHMatrixType(type));
                break;
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::release()
  {
    if (rkmatrix != nullptr)
      {
        delete rkmatrix;
        rkmatrix = nullptr;
      }

    if (fullmatrix != nullptr)
      {
        delete fullmatrix;
        fullmatrix = nullptr;
      }

    for (auto submatrix : submatrices)
      {
        /**
         * The deletion of \p submatrix will call the destructor of this
         * sub-HMatrix, which will further recursively call the destructor of
         * the submatrices of this sub-HMatrix. Hence, this destructor is
         * intrinsically recursive.
         */
        if (submatrix != nullptr)
          {
            delete submatrix;
          }
      }

    submatrices.clear();
    leaf_set.clear();
    near_field_leaf_set.clear();
    far_field_leaf_set.clear();

    type                                      = UndefinedMatrixType;
    state                                     = HMatrixSupport::matrix;
    property                                  = HMatrixSupport::general,
    block_type                                = HMatrixSupport::undefined_block;
    dot_node_id                               = 0;
    bc_node                                   = nullptr;
    parent                                    = nullptr;
    next_same_level_hmat_node                 = nullptr;
    next_same_level_same_row_hmat_node        = nullptr;
    next_same_level_same_column_hmat_node     = nullptr;
    previous_same_level_same_row_hmat_node    = nullptr;
    previous_same_level_same_column_hmat_node = nullptr;
    submatrix_index                           = submatrix_index_invalid;
    row_index_range                           = nullptr;
    col_index_range                           = nullptr;
    m                                         = 0;
    n                                         = 0;

    Sigma_P.clear();

    for (auto &r : Sigma_R)
      {
        if (r != nullptr)
          {
            delete r;
            r = nullptr;
          }
      }
    Sigma_R.clear();

    for (auto &f : Sigma_F)
      {
        if (f != nullptr)
          {
            delete f;
            f = nullptr;
          }
      }
    Sigma_F.clear();

    Tind.release();
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::clear()
  {
    /**
     * Recursively clear submatrices.
     */
    if (submatrices.size() > 0)
      {
        Assert(type == HierarchicalMatrixType, ExcInvalidHMatrixType(type));

        for (HMatrix *submatrix : submatrices)
          {
            submatrix->clear();
          }
      }

    /**
     * Clear the current matrix node.
     */
    clear_hmat_node();
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::clear_hmat_node()
  {
    type        = UndefinedMatrixType;
    state       = HMatrixSupport::matrix;
    property    = HMatrixSupport::general;
    block_type  = HMatrixSupport::undefined_block;
    dot_node_id = 0;
    submatrices.clear();
    parent                                    = nullptr;
    next_same_level_hmat_node                 = nullptr;
    next_same_level_same_row_hmat_node        = nullptr;
    next_same_level_same_column_hmat_node     = nullptr;
    previous_same_level_same_row_hmat_node    = nullptr;
    previous_same_level_same_column_hmat_node = nullptr;
    submatrix_index                           = submatrix_index_invalid;
    leaf_set.clear();
    near_field_leaf_set.clear();
    far_field_leaf_set.clear();
    rkmatrix        = nullptr;
    fullmatrix      = nullptr;
    bc_node         = nullptr;
    row_index_range = nullptr;
    col_index_range = nullptr;
    m               = 0;
    n               = 0;
    Sigma_P.clear();
    Sigma_R.clear();
    Sigma_F.clear();
    Tind.clear();
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::clear_lu_or_cholesky_task_nodes()
  {
    for (auto submatrix : submatrices)
      {
        submatrix->clear_lu_or_cholesky_task_nodes();
      }

    clear_lu_or_cholesky_task_nodes_in_hmat();
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::clear_lu_or_cholesky_task_nodes_in_hmat()
  {
    factorize_lu_or_cholesky_graph_node.reset();
    update_lu_or_cholesky_graph_nodes.clear();
    solve_upper_or_lower_lu_or_cholesky_graph_node.reset();
  }


  template <int spacedim, typename Number>
  HMatrix<spacedim, Number>::~HMatrix()
  {
    release();
  }


  template <int spacedim, typename Number>
  inline HMatrixType
  HMatrix<spacedim, Number>::get_type() const
  {
    return type;
  }


  template <int spacedim, typename Number>
  inline bool
  HMatrix<spacedim, Number>::is_near_field() const
  {
    return (type == HMatrixType::FullMatrixType);
  }


  template <int spacedim, typename Number>
  inline bool
  HMatrix<spacedim, Number>::is_far_field() const
  {
    return (type == HMatrixType::RkMatrixType);
  }


  template <int spacedim, typename Number>
  inline bool
  HMatrix<spacedim, Number>::is_leaf() const
  {
    return (type == HMatrixType::FullMatrixType ||
            type == HMatrixType::RkMatrixType);
  }


  template <int spacedim, typename Number>
  inline typename HMatrix<spacedim, Number>::size_type
  HMatrix<spacedim, Number>::get_m() const
  {
    return m;
  }


  template <int spacedim, typename Number>
  inline unsigned int
  HMatrix<spacedim, Number>::get_n_row_blocks() const
  {
    return type == HMatrixType::HierarchicalMatrixType ?
             bc_node->get_data_reference().get_tau_node()->get_child_num() :
             0;
  }


  template <int spacedim, typename Number>
  inline unsigned int
  HMatrix<spacedim, Number>::get_n_col_blocks() const
  {
    return type == HMatrixType::HierarchicalMatrixType ?
             bc_node->get_data_reference().get_sigma_node()->get_child_num() :
             0;
  }


  template <int spacedim, typename Number>
  inline HMatrixSupport::Property
  HMatrix<spacedim, Number>::get_property() const
  {
    return property;
  }


  template <int spacedim, typename Number>
  inline void
  HMatrix<spacedim, Number>::set_current_matrix_property(
    const HMatrixSupport::Property property)
  {
    this->property = property;
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::set_current_matrix_property(
    const LAPACKFullMatrixExt<Number> &M)
  {
    switch (M.get_property())
      {
          case LAPACKSupport::general: {
            property = HMatrixSupport::general;

            break;
          }
          case LAPACKSupport::symmetric: {
            property = HMatrixSupport::symmetric;

            break;
          }
          case LAPACKSupport::upper_triangular: {
            property = HMatrixSupport::upper_triangular;

            break;
          }
          case LAPACKSupport::lower_triangular: {
            property = HMatrixSupport::lower_triangular;

            break;
          }
          default: {
            Assert(false, ExcNotImplemented());
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::set_property(
    const HMatrixSupport::Property property)
  {
    switch (property)
      {
          case HMatrixSupport::general: {
            /**
             * When a \hmatnode's property is @p general, all of its descendants
             * have this same property.
             */

            /**
             * Set the current \hmatnode property to be @p general.
             */
            this->set_current_matrix_property(property);

            /**
             * Set the same property for each submatrix, if there are any.
             */
            for (HMatrix<spacedim, Number> *hmat : submatrices)
              {
                hmat->set_property(property);
              }

            break;
          }
          case HMatrixSupport::symmetric: {
            /**
             * If the current \hmatnode is symmetric, it should belong to the
             * diagonal part. Hence we make an assertion.
             */
            Assert(
              block_type == HMatrixSupport::diagonal_block,
              ExcMessage(
                "A symmetric H-matrix node should belong to the diagonal part!"));

            this->set_current_matrix_property(property);

            if (submatrices.size() > 0)
              {
                /**
                 * When the current \hmatnode is not a leaf node, we currently
                 * only handle the situation where there are four child
                 * matrices.
                 *
                 * \mynote{Because @p AssertDimension is a macro, the second
                 * argument @p BlockClusterTree<spacedim, Number>::child_num
                 * should be protected by a pair of brackets.}
                 */
                Assert(submatrices.size() ==
                         (BlockClusterTree<spacedim, Number>::child_num),
                       ExcDimensionMismatch(
                         submatrices.size(),
                         (BlockClusterTree<spacedim, Number>::child_num)));

                /**
                 * In my implementation of \bct and \hmatrix construction, the
                 * first and the fourth child matrices belong to the diagonal
                 * part, the second child matrix belongs to the upper triangular
                 * part and the third child matrix belongs to the lower
                 * triangular part.
                 *
                 * <code>
                 *  -----
                 * |0 | 1|
                 *  -----
                 * |2 | 3|
                 *  -----
                 * </code>
                 */
                Assert(
                  submatrices[0]->block_type == HMatrixSupport::diagonal_block,
                  ExcMessage(
                    "The first child matrix should belong to the diagonal part!"));
                Assert(
                  submatrices[1]->block_type ==
                    HMatrixSupport::upper_triangular_block,
                  ExcMessage(
                    "The second child matrix should belong to the upper triangular part!"));
                Assert(
                  submatrices[2]->block_type ==
                    HMatrixSupport::lower_triangular_block,
                  ExcMessage(
                    "The third child matrix should belong to the lower triangular part!"));
                Assert(
                  submatrices[3]->block_type == HMatrixSupport::diagonal_block,
                  ExcMessage(
                    "The fourth child matrix should belong to the diagonal part!"));

                /**
                 * After the assertion about block type has been made, set the
                 * property of each submatrix recursively.
                 */
                submatrices[0]->set_property(this->property);
                submatrices[1]->set_property(HMatrixSupport::general);
                submatrices[2]->set_property(HMatrixSupport::general);
                submatrices[3]->set_property(this->property);
              }
            else
              {
                /**
                 * When the current \hmatnode is a leaf node, because it must be
                 * a diagonal block, it should be a full matrix.
                 */
                Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));

                this->fullmatrix->set_property(LAPACKSupport::symmetric);
              }

            break;
          }
          case HMatrixSupport::upper_triangular: {
            /**
             * If the current \hmatnode is upper triangular, it should belong to
             * the diagonal part. Hence we make an assertion.
             */
            Assert(
              block_type == HMatrixSupport::diagonal_block,
              ExcMessage(
                "An upper triangular H-matrix node should belong to the diagonal part!"));

            this->set_current_matrix_property(property);

            if (submatrices.size() > 0)
              {
                /**
                 * When the current \hmatnode is not a leaf node, we currently
                 * only handle the situation where there are four child
                 * matrices.
                 *
                 * \mynote{Because @p AssertDimension is a macro, the second
                 * argument @p BlockClusterTree<spacedim, Number>::child_num
                 * should be protected by a pair of brackets.}
                 */
                Assert(submatrices.size() ==
                         (BlockClusterTree<spacedim, Number>::child_num),
                       ExcDimensionMismatch(
                         submatrices.size(),
                         (BlockClusterTree<spacedim, Number>::child_num)));

                /**
                 * In my implementation of \bct and \hmatrix construction, the
                 * first and the fourth child matrices belong to the diagonal
                 * part, the second child matrix belongs to the upper triangular
                 * part and the third child matrix belongs to the lower
                 * triangular part.
                 */
                Assert(
                  submatrices[0]->block_type == HMatrixSupport::diagonal_block,
                  ExcMessage(
                    "The first child matrix should belong to the diagonal part!"));
                Assert(
                  submatrices[1]->block_type ==
                    HMatrixSupport::upper_triangular_block,
                  ExcMessage(
                    "The second child matrix should belong to the upper triangular part!"));
                Assert(
                  submatrices[2]->block_type ==
                    HMatrixSupport::lower_triangular_block,
                  ExcMessage(
                    "The third child matrix should belong to the lower triangular part!"));
                Assert(
                  submatrices[3]->block_type == HMatrixSupport::diagonal_block,
                  ExcMessage(
                    "The fourth child matrix should belong to the diagonal part!"));

                /**
                 * After the assertion about block type has been made, set the
                 * property of each submatrix recursively.
                 */
                submatrices[0]->set_property(this->property);
                submatrices[1]->set_property(HMatrixSupport::general);
                submatrices[2]->set_property(HMatrixSupport::general);
                submatrices[3]->set_property(this->property);
              }
            else
              {
                /**
                 * When the current \hmatnode is a leaf node, because it is a
                 * diagonal block, it should be a full matrix.
                 */
                Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));

                this->fullmatrix->set_property(LAPACKSupport::upper_triangular);
              }

            break;
          }
          case HMatrixSupport::lower_triangular: {
            /**
             * If the current \hmatnode is lower triangular, it should belong to
             * the diagonal part. Hence we make an assertion.
             */
            Assert(
              block_type == HMatrixSupport::diagonal_block,
              ExcMessage(
                "A lower triangular H-matrix node should belong to the diagonal part!"));

            this->set_current_matrix_property(property);

            if (submatrices.size() > 0)
              {
                /**
                 * When the current \hmatnode is not a leaf node, we currently
                 * only handle the situation where there are four child
                 * matrices.
                 *
                 * \mynote{Because @p AssertDimension is a macro, the second
                 * argument @p BlockClusterTree<spacedim, Number>::child_num
                 * should be protected by a pair of brackets.}
                 */
                Assert(submatrices.size() ==
                         (BlockClusterTree<spacedim, Number>::child_num),
                       ExcDimensionMismatch(
                         submatrices.size(),
                         (BlockClusterTree<spacedim, Number>::child_num)));

                /**
                 * In my implementation of \bct and \hmatrix construction, the
                 * first and the fourth child matrices belong to the diagonal
                 * part, the second child matrix belongs to the upper triangular
                 * part and the third child matrix belongs to the lower
                 * triangular part.
                 */
                Assert(
                  submatrices[0]->block_type == HMatrixSupport::diagonal_block,
                  ExcMessage(
                    "The first child matrix should belong to the diagonal part!"));
                Assert(
                  submatrices[1]->block_type ==
                    HMatrixSupport::upper_triangular_block,
                  ExcMessage(
                    "The second child matrix should belong to the upper triangular part!"));
                Assert(
                  submatrices[2]->block_type ==
                    HMatrixSupport::lower_triangular_block,
                  ExcMessage(
                    "The third child matrix should belong to the lower triangular part!"));
                Assert(
                  submatrices[3]->block_type == HMatrixSupport::diagonal_block,
                  ExcMessage(
                    "The fourth child matrix should belong to the diagonal part!"));

                /**
                 * After the assertion about block type has been made, set the
                 * property of each submatrix recursively.
                 */
                submatrices[0]->set_property(this->property);
                submatrices[1]->set_property(HMatrixSupport::general);
                submatrices[2]->set_property(HMatrixSupport::general);
                submatrices[3]->set_property(this->property);
              }
            else
              {
                /**
                 * When the current \hmatnode is a leaf node, because it is a
                 * diagonal block, it should be a full matrix.
                 */
                Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));

                this->fullmatrix->set_property(LAPACKSupport::lower_triangular);
              }

            break;
          }
          default: {
            Assert(false,
                   ExcMessage(
                     std::string("Invalid H-matrix property: ") +
                     std::string(HMatrixSupport::property_name(property))));
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::set_property(const LAPACKFullMatrixExt<Number> &M)
  {
    /**
     * Determine the current \hmatnode property from the given full matrix.
     */
    this->set_current_matrix_property(M);

    this->set_property(this->property);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::set_current_matrix_state(
    const HMatrixSupport::State state)
  {
    this->state = state;

    if (type == FullMatrixType)
      {
        /**
         * Set the state of the associated full matrix.
         */
        switch (this->state)
          {
              case HMatrixSupport::matrix: {
                fullmatrix->set_state(LAPACKSupport::matrix);

                break;
              }
              case HMatrixSupport::inverse_matrix: {
                fullmatrix->set_state(LAPACKSupport::inverse_matrix);

                break;
              }
              case HMatrixSupport::lu: {
                fullmatrix->set_state(LAPACKSupport::lu);

                break;
              }
              case HMatrixSupport::cholesky: {
                fullmatrix->set_state(LAPACKSupport::cholesky);

                break;
              }
              case HMatrixSupport::eigenvalues: {
                fullmatrix->set_state(LAPACKSupport::eigenvalues);

                break;
              }
              case HMatrixSupport::svd: {
                fullmatrix->set_state(LAPACKSupport::svd);

                break;
              }
              case HMatrixSupport::inverse_svd: {
                fullmatrix->set_state(LAPACKSupport::inverse_svd);

                break;
              }
              case HMatrixSupport::unusable: {
                fullmatrix->set_state(LAPACKSupport::unusable);

                break;
              }
              default: {
                Assert(false,
                       ExcMessage(
                         std::string("Invalid H-matrix state ") +
                         std::string(HMatrixSupport::state_name(this->state))));

                break;
              }
          }
      }
  }


  template <int spacedim, typename Number>
  inline HMatrixSupport::State
  HMatrix<spacedim, Number>::get_state() const
  {
    return state;
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::set_state(const HMatrixSupport::State state)
  {
    this->set_current_matrix_state(state);

    /**
     * All submatrices inherit the same state from their parent.
     */
    for (auto hmat : submatrices)
      {
        hmat->set_state(this->state);
      }
  }


  template <int spacedim, typename Number>
  inline HMatrixSupport::BlockType
  HMatrix<spacedim, Number>::get_block_type() const
  {
    return block_type;
  }


  template <int spacedim, typename Number>
  inline void
  HMatrix<spacedim, Number>::set_current_matrix_block_type(
    const HMatrixSupport::BlockType block_type)
  {
    this->block_type = block_type;
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::set_block_type(
    const HMatrixSupport::BlockType block_type)
  {
    this->set_current_matrix_block_type(block_type);

    for (unsigned int i = 0; i < submatrices.size(); i++)
      {
        switch (block_type)
          {
              case HMatrixSupport::undefined_block: {
                /**
                 * When the current \hmatrix block is @p undefined_block, all
                 * child \hmatrices are @p undefined_block.
                 */
                submatrices[i]->set_block_type(block_type);

                break;
              }
              case HMatrixSupport::diagonal_block: {
                /**
                 * When the current \hmatrix is @p diagonal_block, the first and
                 * fourth child \hmatrices are @p diagonal_block, while the second
                 * child \hmatrix is @p upper_triangular_block and the third child
                 * \hmatrix is @p lower_triangular_block.
                 */
                switch (i)
                  {
                      case 0: {
                        submatrices[i]->set_block_type(
                          HMatrixSupport::diagonal_block);

                        break;
                      }
                      case 1: {
                        submatrices[i]->set_block_type(
                          HMatrixSupport::upper_triangular_block);

                        break;
                      }
                      case 2: {
                        submatrices[i]->set_block_type(
                          HMatrixSupport::lower_triangular_block);

                        break;
                      }
                      case 3: {
                        submatrices[i]->set_block_type(
                          HMatrixSupport::diagonal_block);

                        break;
                      }
                      default: {
                        Assert(false, ExcNotImplemented());
                      }
                  }

                break;
              }
              case HMatrixSupport::upper_triangular_block: {
                /**
                 * When the current \hmatrix is @p upper_triangular_block,
                 * all child \hmatrices are @p upper_triangular_block.
                 */
                submatrices[i]->set_block_type(block_type);

                break;
              }
              case HMatrixSupport::lower_triangular_block: {
                /**
                 * When the current \hmatrix is @p lower_triangular_block,
                 * all child \hmatrices are @p lower_triangular_block.
                 */
                submatrices[i]->set_block_type(block_type);

                break;
              }
              default: {
                Assert(false,
                       ExcMessage(std::string("Invalid block type ") +
                                  std::string(HMatrixSupport::block_type_name(
                                    block_type))));
              }
          }
      }
  }


  template <int spacedim, typename Number>
  inline typename HMatrix<spacedim, Number>::size_type
  HMatrix<spacedim, Number>::get_n() const
  {
    return n;
  }


  template <int spacedim, typename Number>
  inline RkMatrix<Number> *
  HMatrix<spacedim, Number>::get_rkmatrix()
  {
    return rkmatrix;
  }


  template <int spacedim, typename Number>
  inline const RkMatrix<Number> *
  HMatrix<spacedim, Number>::get_rkmatrix() const
  {
    return rkmatrix;
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::calc_rank_upper_bound_for_rkmatrices() const
  {
    switch (type)
      {
          case HierarchicalMatrixType: {
            for (HMatrix *submatrix : submatrices)
              {
                submatrix->calc_rank_upper_bound_for_rkmatrices();
              }
          }

          break;
          case RkMatrixType: {
            this->rkmatrix->calc_rank_upper_bound();
          }

          break;
          default: // Do nothing.
          {
            break;
          }
      }
  }


  template <int spacedim, typename Number>
  inline LAPACKFullMatrixExt<Number> *
  HMatrix<spacedim, Number>::get_fullmatrix()
  {
    return fullmatrix;
  }


  template <int spacedim, typename Number>
  inline const LAPACKFullMatrixExt<Number> *
  HMatrix<spacedim, Number>::get_fullmatrix() const
  {
    return fullmatrix;
  }


  template <int spacedim, typename Number>
  inline std::vector<HMatrix<spacedim, Number> *> &
  HMatrix<spacedim, Number>::get_submatrices()
  {
    return submatrices;
  }


  template <int spacedim, typename Number>
  inline const std::vector<HMatrix<spacedim, Number> *> &
  HMatrix<spacedim, Number>::get_submatrices() const
  {
    return submatrices;
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::print_formatted(std::ostream      &out,
                                             const unsigned int precision,
                                             const bool         scientific,
                                             const unsigned int width,
                                             const char        *zero_string,
                                             const double       denominator,
                                             const double       threshold) const
  {
    switch (type)
      {
        case FullMatrixType:
          fullmatrix->print_formatted(out,
                                      precision,
                                      scientific,
                                      width,
                                      zero_string,
                                      denominator,
                                      threshold);

          break;
        case RkMatrixType:
          rkmatrix->print_formatted(out,
                                    precision,
                                    scientific,
                                    width,
                                    zero_string,
                                    denominator,
                                    threshold);

          break;
        case HierarchicalMatrixType:
          for (HMatrix *submatrix : submatrices)
            {
              submatrix->print_formatted(out,
                                         precision,
                                         scientific,
                                         width,
                                         zero_string,
                                         denominator,
                                         threshold);
            }

          break;
        case UndefinedMatrixType:
        default:
          Assert(false, ExcInvalidHMatrixType(type));
          break;
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::print_matrix_info(std::ostream &out) const
  {
    print_current_matrix_info(out);

    for (const HMatrix<spacedim, Number> *submatrix : submatrices)
      {
        submatrix->print_matrix_info(out);
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::print_current_matrix_info(std::ostream &out) const
  {
    out << "H-matrix address: " << std::hex << this << "\n";
    out << "Parent H-matrix address: " << std::hex << this->parent << "\n";
    out << "Submatrix addresses: (";
    for (unsigned int i = 0; i < submatrices.size(); i++)
      {
        out << std::hex << submatrices[i];

        if (i < submatrices.size() - 1)
          {
            out << ",";
          }
      }
    out << ")\n";
    out << "Submatrix index wrt. the parent H-matrix: " << std::dec
        << this->submatrix_index << "\n";
    out << "H-matrix state: " << HMatrixSupport::state_name(this->state) << "\n"
        << "H-matrix property: "
        << HMatrixSupport::property_name(this->property) << "\n"
        << "H-matrix block type: "
        << HMatrixSupport::block_type_name(this->block_type) << std::endl;

    /**
     * Print the size of \f$\Sigma_b^P\f$, \f$\Sigma_b^R\f$ and
     * \f$\Sigma_b^F\f$.
     */
    print_h_submatrix_accessor(out, "M", *this);
    out << std::endl;
    out << "(#level, #Sigma_b^P, #Sigma_b^R, #Sigma_b^F)=("
        << bc_node->get_level() << "," << Sigma_P.size() << ","
        << Sigma_R.size() << "," << Sigma_F.size() << ")" << std::endl;

    for (std::pair<HMatrix<spacedim, Number> *, HMatrix<spacedim, Number> *>
           hmat_pair : Sigma_P)
      {
        out << "  Sigma_P products: ";
        print_h_h_submatrix_mmult_accessor(
          out, "M1", *(hmat_pair.first), "M2", *(hmat_pair.second));
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::print_matrix_info_as_dot(std::ostream &out)
  {
    assign_node_ids_for_dot();

    /**
     * Write the header of the Graphviz dot file.
     */
    out << "#@startdot\n";
    out << "digraph hmatrix {\n";

    /**
     * Define the node style.
     */
    out << "node [style=filled, shape=box]\n";

    /**
     * Add comment nodes.
     */
    out << "\"Non-leaf block\" [fillcolor=white]\n";
    out << "\"Near field block\" [fillcolor=red]\n";
    out << "\"Far field block\" [fillcolor=green]\n";

    _print_matrix_info_as_dot_node(out);

    /**
     * Finalize the Graphviz dot file.
     */
    out << "}\n";
    out << "#@enddot" << std::endl;
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::print_as_formatted_full_matrix(
    std::ostream      &out,
    const std::string &name,
    const unsigned int precision,
    const bool         scientific,
    const unsigned int width,
    const char        *zero_string,
    const double       denominator,
    const double       threshold) const
  {
    LAPACKFullMatrixExt<Number> fullmat;
    this->convertToFullMatrix(fullmat);
    fullmat.print_formatted_to_mat(out,
                                   name,
                                   precision,
                                   scientific,
                                   width,
                                   zero_string,
                                   denominator,
                                   threshold);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::print_leaf_set_info(std::ostream &out) const
  {
    /**
     * @internal Calculate the total number of matrix entries in the near field
     * set.
     */
    types::global_dof_index near_field_matrix_entries_num = 0;
    for (auto mat : near_field_leaf_set)
      {
        Assert(mat->fullmatrix != nullptr, ExcInternalError());

        near_field_matrix_entries_num +=
          mat->fullmatrix->m() * mat->fullmatrix->n();
      }

    /**
     * @internal Calculate the maximum total number of matrix entries in the far
     * field set.
     */
    types::global_dof_index far_field_matrix_entries_num = 0;
    for (auto mat : far_field_leaf_set)
      {
        Assert(mat->rkmatrix != nullptr, ExcInternalError());

        far_field_matrix_entries_num +=
          (mat->rkmatrix->get_m() + mat->rkmatrix->get_n()) *
          mat->rkmatrix->get_formal_rank();
      }

    out << "Number of H-matrix nodes in the leaf set: " << leaf_set.size()
        << "\n"
        << "Number of H-matrix nodes in the near field set: "
        << near_field_leaf_set.size() << "\n"
        << "Number of H-matrix nodes in the far field set: "
        << far_field_leaf_set.size() << "\n"
        << "Number of matrix entries in the near field set: "
        << near_field_matrix_entries_num << "\n"
        << "Maximum number of matrix entries in the far field set: "
        << far_field_matrix_entries_num << std::endl;
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::assign_node_ids_for_dot()
  {
    size_type current_node_id = 0;

    std::queue<HMatrix<spacedim, Number> *> work_queue;
    work_queue.push(this);

    while (!work_queue.empty())
      {
        HMatrix<spacedim, Number> *current_hmat_node = work_queue.front();
        work_queue.pop();

        current_hmat_node->dot_node_id = current_node_id;
        current_node_id++;

        /**
         * Push all submatrix nodes of the current \hmatrix node into the
         * queue, if there is any.
         */
        for (auto hmat : current_hmat_node->submatrices)
          {
            work_queue.push(hmat);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::_print_matrix_info_as_dot_node(
    std::ostream &out) const
  {
    /**
     * Create the graph node for the current \hmatnode. When the current
     * \hmatnode is a full matrix, use red background. When it is a rank-k
     * matrix, use green background.
     */
    out << "\"" << dot_node_id << "\""
        << "[label=<<b>ID: " << dot_node_id << "</b><br/>"
        << "tau: [" << (*row_index_range)[0] << "," << (*row_index_range)[1]
        << ")<br/>";
    out << "sigma: [" << (*col_index_range)[0] << "," << (*col_index_range)[1]
        << ")<br/>";
    out << "Level: " << bc_node->get_level() << "<br/>";
    out << "Parent: " << ((parent == nullptr) ? 0 : parent->dot_node_id)
        << "<br/>";
    out << "Submatrix index: " << submatrix_index << "<br/>";
    out << "H-matrix state: " << HMatrixSupport::state_name(state) << "<br/>"
        << "H-matrix property: " << HMatrixSupport::property_name(property)
        << "<br/>"
        << "H-matrix block type: "
        << HMatrixSupport::block_type_name(block_type) << ">,";

    std::string node_color;

    if (type == FullMatrixType)
      {
        node_color = "red";
      }
    else if (type == RkMatrixType)
      {
        node_color = "green";
      }
    else
      {
        node_color = "white";
      }
    out << "fillcolor = " << node_color << "]\n\n";

    /**
     * Construct the relationship between the current node and its children.
     */
    for (HMatrix<spacedim, Number> *submatrix : submatrices)
      {
        Assert(submatrix != nullptr, ExcInternalError());

        out << "\"" << dot_node_id << "\""
            << "->"
            << "\"" << submatrix->dot_node_id << "\"\n";
      }
    out << "\n";

    /**
     * Construct the relationship between the current node and its sequel on a
     * same level, if there is any. The connection edge uses dotted line.
     */
    if (next_same_level_hmat_node != nullptr)
      {
        out << "\"" << dot_node_id << "\""
            << "->"
            << "\"" << next_same_level_hmat_node->dot_node_id
            << "\" [style=dotted]\n";
      }

    /**
     * Construct the relationship between the current node and its sequel on a
     * same level and in a same row, if there is any. The connection edge uses
     * red dotted line.
     */
    if (next_same_level_same_row_hmat_node != nullptr)
      {
        out << "\"" << dot_node_id << "\""
            << "->"
            << "\"" << next_same_level_same_row_hmat_node->dot_node_id
            << "\" [style=solid,color=red]\n";
      }

    if (previous_same_level_same_row_hmat_node != nullptr)
      {
        out << "\"" << dot_node_id << "\""
            << "->"
            << "\"" << previous_same_level_same_row_hmat_node->dot_node_id
            << "\" [style=dotted,color=red]\n";
      }

    /**
     * Construct the relationship between the current node and its sequel on a
     * same level and in a same column, if there is any. The connection edge
     * uses green dotted line.
     */
    if (next_same_level_same_column_hmat_node != nullptr)
      {
        out << "\"" << dot_node_id << "\""
            << "->"
            << "\"" << next_same_level_same_column_hmat_node->dot_node_id
            << "\" [style=solid,color=green]\n";
      }

    if (previous_same_level_same_column_hmat_node != nullptr)
      {
        out << "\"" << dot_node_id << "\""
            << "->"
            << "\"" << previous_same_level_same_column_hmat_node->dot_node_id
            << "\" [style=dotted,color=green]\n";
      }

    /**
     * Print each submatrix node.
     */
    for (HMatrix<spacedim, Number> *submatrix : submatrices)
      {
        Assert(submatrix != nullptr, ExcInternalError());

        submatrix->_print_matrix_info_as_dot_node(out);
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::set_property_for_converted_fullmatrix(
    LAPACKFullMatrixExt<Number> &M) const
  {
    switch (property)
      {
          case HMatrixSupport::general: {
            M.set_property(LAPACKSupport::general);

            break;
          }
          case HMatrixSupport::symmetric: {
            M.set_property(LAPACKSupport::symmetric);

            break;
          }
          case HMatrixSupport::upper_triangular: {
            M.set_property(LAPACKSupport::upper_triangular);

            break;
          }
          case HMatrixSupport::lower_triangular: {
            M.set_property(LAPACKSupport::lower_triangular);

            break;
          }
          default: {
            Assert(false, ExcInvalidHMatrixProperty(property));
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::write_fullmatrix_leaf_node(
    std::ostream &out,
    const Number  singular_value_threshold) const
  {
    Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));

    const std::array<types::global_dof_index, 2> &tau_index_range =
      bc_node->get_data_reference()
        .get_tau_node()
        ->get_data_reference()
        .get_index_range();
    const std::array<types::global_dof_index, 2> &sigma_index_range =
      bc_node->get_data_reference()
        .get_sigma_node()
        ->get_data_reference()
        .get_index_range();

    /**
     * Print index range of cluster \f$\tau\f$.
     */
    out << "[";
    print_vector_values(out, tau_index_range, " ", false);
    out << "),";

    /**
     * Print index range of cluster \f$\sigma\f$.
     */
    out << "[";
    print_vector_values(out, sigma_index_range, " ", false);
    out << "),";

    /**
     * Print the \p is_near_field flag.
     */
    out << (bc_node->get_data_reference().get_is_near_field() ? 1 : 0) << ",";

    /**
     * Make a copy of the matrix block and calculate its rank using
     * SVD. The state of the matrix should be @p matrix for further @p svd
     * operation used in the rank caluclation. Therefore, we make a check here
     * and enforce it if necessary.
     */
    LAPACKFullMatrixExt<Number> copy(*fullmatrix);

    if (copy.get_state() != LAPACKSupport::matrix)
      {
        copy.set_state(LAPACKSupport::matrix);
      }

    const size_t rank = copy.rank(singular_value_threshold);

    /**
     * Print the \p rank flag.
     */
    out << rank << "\n";
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::write_rkmatrix_leaf_node(std::ostream &out) const
  {
    Assert(type == RkMatrixType, ExcInvalidHMatrixType(type));

    const std::array<types::global_dof_index, 2> &tau_index_range =
      bc_node->get_data_reference()
        .get_tau_node()
        ->get_data_reference()
        .get_index_range();
    const std::array<types::global_dof_index, 2> &sigma_index_range =
      bc_node->get_data_reference()
        .get_sigma_node()
        ->get_data_reference()
        .get_index_range();

    /**
     * Print index range of cluster \f$\tau\f$.
     */
    out << "[";
    print_vector_values(out, tau_index_range, " ", false);
    out << "),";

    /**
     * Print index range of cluster \f$\sigma\f$.
     */
    out << "[";
    print_vector_values(out, sigma_index_range, " ", false);
    out << "),";

    /**
     * Print the \p is_near_field flag.
     */
    out << (bc_node->get_data_reference().get_is_near_field() ? 1 : 0) << ",";

    /**
     * Print the \p rank flag.
     */
    out << rkmatrix->get_rank() << "\n";
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::write_leaf_set(
    std::ostream &out,
    const Number  singular_value_threshold) const
  {
    switch (type)
      {
          case FullMatrixType: {
            write_fullmatrix_leaf_node(out, singular_value_threshold);

            break;
          }
          case RkMatrixType: {
            write_rkmatrix_leaf_node(out);

            break;
          }
          case HierarchicalMatrixType: {
            for (HMatrix *submatrix : submatrices)
              {
                submatrix->write_leaf_set(out);
              }

            break;
          }
          default: {
            Assert(false, ExcInvalidHMatrixType(type));

            break;
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::write_leaf_set_by_iteration(
    std::ostream &out,
    const Number  singular_value_threshold) const
  {
    for (HMatrix *leaf_node : leaf_set)
      {
        switch (leaf_node->type)
          {
              case FullMatrixType: {
                leaf_node->write_fullmatrix_leaf_node(out,
                                                      singular_value_threshold);

                break;
              }
              case RkMatrixType: {
                leaf_node->write_rkmatrix_leaf_node(out);

                break;
              }
              default: {
                Assert(false, ExcInvalidHMatrixType(type));

                break;
              }
          }
      }
  }


  template <int spacedim, typename Number>
  HMatrix<spacedim, Number> *
  HMatrix<spacedim, Number>::find_row_diag_block_for_offdiag_block()
  {
    /**
     * We make an assertion here that the current \hmatnode should not be on
     * the top level in the \hmatrix hierarchy.
     */
    Assert(
      parent != nullptr,
      ExcMessage(
        "The current H-matrix node, the diagonal block of which on a same row is to be found, should not be on the top level!"));

    /**
     * According to the currently adopted tensor product way of constructing
     * block clusters from clusters, the diagonal block can only be the
     * first or the last sibling of the current \hmatnode. Therefore, when
     * the current
     * \hmatnode's @p submatrix_index is 1 (2), we will directly check if the
     * first (last) sibling is a diagonal block on a same row.
     *
     * We should also note that if an off-diagonal block is split into
     * sub-blocks and such case will occur when the fine non-tensor product
     * partition is adopted, none of its submatrices are diagonal blocks,
     * even though the
     * @p submatrix_index of which is 0 or 3.
     */

    /**
     * When the first or last sibling of the current \hmatnode is not a
     * diagonal block, we will look for the corresponding diagonal block on
     * a same row by first recursing back to the top level of the \hmatrix
     * hierarchy then recursing forward to the current level.
     */
    std::vector<unsigned int> submatrix_index_stack;
    submatrix_index_stack.reserve(this->bc_node->get_level());

    HMatrix<spacedim, Number> *current_hmat_during_recursion = this;
    bool                       is_recursion_continued        = true;
    while (is_recursion_continued)
      {
        if (current_hmat_during_recursion->parent == nullptr)
          {
            /**
             * When the current \hmatnode is on the top level of the
             * \hmatrix hierarchy, throw an error.
             */
            Assert(false, ExcInternalError());
            is_recursion_continued = false;
          }
        else
          {
            switch (current_hmat_during_recursion->submatrix_index)
              {
                  case 1: {
                    /**
                     * Check if the first sibling of the current \hmatnode
                     * is a diagonal block.
                     *
                     * \mynote{By default, the submatrices are organized in
                     * the following order. <code>
                     * | 0 | 1 |
                     * | - | - |
                     * | 2 | 3 |
                     * </code>}
                     */
                    if (current_hmat_during_recursion->parent->submatrices[0]
                          ->block_type ==
                        HMatrixSupport::BlockType::diagonal_block)
                      {
                        current_hmat_during_recursion =
                          current_hmat_during_recursion->parent->submatrices[0];
                        is_recursion_continued = false;
                      }
                    else
                      {
                        /**
                         * Go one recursion level up for further searching.
                         */
                        submatrix_index_stack.push_back(
                          current_hmat_during_recursion->submatrix_index);
                        current_hmat_during_recursion =
                          current_hmat_during_recursion->parent;
                      }

                    break;
                  }
                  case 2: {
                    /**
                     * Check if the last (3rd) sibling of the current
                     * \hmatnode is a diagonal block.
                     */
                    if (current_hmat_during_recursion->parent->submatrices[3]
                          ->block_type ==
                        HMatrixSupport::BlockType::diagonal_block)
                      {
                        current_hmat_during_recursion =
                          current_hmat_during_recursion->parent->submatrices[3];
                        is_recursion_continued = false;
                      }
                    else
                      {
                        /**
                         * Go one recursion level up for further searching.
                         */
                        submatrix_index_stack.push_back(
                          current_hmat_during_recursion->submatrix_index);
                        current_hmat_during_recursion =
                          current_hmat_during_recursion->parent;
                      }

                    break;
                  }
                  default: {
                    Assert(
                      current_hmat_during_recursion->block_type !=
                        HMatrixSupport::BlockType::diagonal_block,
                      ExcMessage(
                        "The current H-matrix node should not be a diagonal block!"));

                    /**
                     * Go one recursion level up for further searching.
                     */
                    submatrix_index_stack.push_back(
                      current_hmat_during_recursion->submatrix_index);
                    current_hmat_during_recursion =
                      current_hmat_during_recursion->parent;

                    break;
                  }
              }
          }
      }

    const unsigned int iter_num = submatrix_index_stack.size();
    for (unsigned int i = 0; i < iter_num; i++)
      {
        switch (submatrix_index_stack.back())
          {
            case 0:
              case 1: {
                current_hmat_during_recursion =
                  current_hmat_during_recursion->submatrices[0];

                break;
              }
            case 2:
              case 3: {
                current_hmat_during_recursion =
                  current_hmat_during_recursion->submatrices[3];

                break;
              }
          }

        submatrix_index_stack.pop_back();
      }

    return current_hmat_during_recursion;
  }


  template <int spacedim, typename Number>
  HMatrix<spacedim, Number> *
  HMatrix<spacedim, Number>::find_col_diag_block_for_offdiag_block()
  {
    /**
     * We make an assertion here that the current \hmatnode should not be on
     * the top level in the \hmatrix hierarchy.
     */
    Assert(
      parent != nullptr,
      ExcMessage(
        "The current H-matrix node, the diagonal block of which on a same row is to be found, should not be on the top level!"));

    /**
     * According to the currently adopted tensor product way of constructing
     * block clusters from clusters, the diagonal block can only be the
     * first or last sibling of the current \hmatnode. Therefore, when the
     * current
     * \hmatnode's @p submatrix_index is 1 (2), we will directly check if the
     * first (last) sibling is a diagonal block on a same column.
     *
     * We should also note that if an off-diagonal block is split into
     * sub-blocks and such case will occur when the fine non-tensor product
     * partition is adopted, none of its submatrices are diagonal blocks,
     * even though the
     * @p submatrix_index of which is 0 or 3.
     */

    /**
     * When the first or last sibling of the current \hmatnode is not a
     * diagonal block, we will look for the corresponding diagonal block on
     * a same column by first recursing back to the top level of the
     * \hmatrix hierarchy then recursing forward to the current level.
     */
    std::vector<unsigned int> submatrix_index_stack;
    submatrix_index_stack.reserve(this->bc_node->get_level());

    HMatrix<spacedim, Number> *current_hmat_during_recursion = this;
    bool                       is_recursion_continued        = true;
    while (is_recursion_continued)
      {
        if (current_hmat_during_recursion->parent == nullptr)
          {
            /**
             * When the current \hmatnode is on the top level of the
             * \hmatrix hierarchy, throw an error, because the diaognal
             * block should have been found already.
             */
            Assert(false, ExcInternalError());
            is_recursion_continued = false;
          }
        else
          {
            switch (current_hmat_during_recursion->submatrix_index)
              {
                  case 1: {
                    /**
                     * Check if the last (3rd) sibling of the current
                     * \hmatnode is a diagonal block.
                     *
                     * \mynote{By default, the submatrices are organized in
                     * the following order. <code>
                     * | 0 | 1 |
                     * | - | - |
                     * | 2 | 3 |
                     * </code>}
                     */
                    if (current_hmat_during_recursion->parent->submatrices[3]
                          ->block_type ==
                        HMatrixSupport::BlockType::diagonal_block)
                      {
                        current_hmat_during_recursion =
                          current_hmat_during_recursion->parent->submatrices[3];
                        is_recursion_continued = false;
                      }
                    else
                      {
                        /**
                         * Go one recursion level up for further searching.
                         */
                        submatrix_index_stack.push_back(
                          current_hmat_during_recursion->submatrix_index);
                        current_hmat_during_recursion =
                          current_hmat_during_recursion->parent;
                      }

                    break;
                  }
                  case 2: {
                    /**
                     * Check if the first sibling of the current \hmatnode
                     * is a diagonal block.
                     */
                    if (current_hmat_during_recursion->parent->submatrices[0]
                          ->block_type ==
                        HMatrixSupport::BlockType::diagonal_block)
                      {
                        current_hmat_during_recursion =
                          current_hmat_during_recursion->parent->submatrices[0];
                        is_recursion_continued = false;
                      }
                    else
                      {
                        /**
                         * Go one recursion level up for further searching.
                         */
                        submatrix_index_stack.push_back(
                          current_hmat_during_recursion->submatrix_index);
                        current_hmat_during_recursion =
                          current_hmat_during_recursion->parent;
                      }

                    break;
                  }
                  default: {
                    Assert(
                      current_hmat_during_recursion->block_type !=
                        HMatrixSupport::BlockType::diagonal_block,
                      ExcMessage(
                        "The current H-matrix node should not be a diagonal block!"));

                    /**
                     * Go one recursion level up for further searching.
                     */
                    submatrix_index_stack.push_back(
                      current_hmat_during_recursion->submatrix_index);
                    current_hmat_during_recursion =
                      current_hmat_during_recursion->parent;

                    break;
                  }
              }
          }
      }

    const unsigned int iter_num = submatrix_index_stack.size();
    for (unsigned int i = 0; i < iter_num; i++)
      {
        switch (submatrix_index_stack.back())
          {
            case 0:
              case 2: {
                current_hmat_during_recursion =
                  current_hmat_during_recursion->submatrices[0];

                break;
              }
            case 1:
              case 3: {
                current_hmat_during_recursion =
                  current_hmat_during_recursion->submatrices[3];

                break;
              }
          }

        submatrix_index_stack.pop_back();
      }

    return current_hmat_during_recursion;
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::truncate_to_rank(size_type new_rank)
  {
    switch (type)
      {
          case HierarchicalMatrixType: {
            for (HMatrix *submatrix : submatrices)
              {
                submatrix->truncate_to_rank(new_rank);
              }

            break;
          }
          case FullMatrixType: {
            /**
             * Do nothing.
             */

            break;
          }
          case RkMatrixType: {
            /**
             * Truncate the RkMatrix in-place.
             */
            rkmatrix->truncate_to_rank(new_rank);

            break;
          }
        case UndefinedMatrixType:
          default: {
            Assert(false, ExcInvalidHMatrixType(type));
            break;
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::truncate_to_rank_preserve_positive_definite(
    size_type  new_rank,
    const bool is_only_handle_tril)
  {
    truncate_to_rank_diag_preserve_positive_definite(new_rank,
                                                     is_only_handle_tril);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::truncate_to_rank_diag_preserve_positive_definite(
    size_type  new_rank,
    const bool is_only_handle_tril)
  {
    /**
     * At present, it is prescribed that the \bct should be a quad
     * tree.
     */
    Assert(type == HierarchicalMatrixType, ExcInvalidHMatrixType(type));
    AssertDimension(submatrices.size(), 4);

    /**
     * Make an assertion that the first and last submatrices of the current
     * \hmatnode are really diagonal blocks.
     */
    Assert(
      submatrices[0]->block_type == HMatrixSupport::BlockType::diagonal_block,
      ExcMessage(
        "The first submatrix of the current H-matrix node is not a diagonal block!"));
    Assert(
      submatrices[3]->block_type == HMatrixSupport::BlockType::diagonal_block,
      ExcMessage(
        "The last submatrix of the current H-matrix node is not a diagonal block!"));

    switch (submatrices[0]->type)
      {
          case HierarchicalMatrixType: {
            submatrices[0]->truncate_to_rank_diag_preserve_positive_definite(
              new_rank, is_only_handle_tril);

            break;
          }
          case FullMatrixType: {
            /**
             * Do nothing.
             */
            break;
          }
        case RkMatrixType:
          /**
           * Rank-k matrix should not appear as a diagonal block.
           */
          case UndefinedMatrixType: {
            Assert(false, ExcInvalidHMatrixType(type));
            break;
          }
      }

    switch (submatrices[3]->type)
      {
          case HierarchicalMatrixType: {
            submatrices[3]->truncate_to_rank_diag_preserve_positive_definite(
              new_rank, is_only_handle_tril);

            break;
          }
          case FullMatrixType: {
            /**
             * Do nothing.
             */
            break;
          }
        case RkMatrixType:
          /**
           * Rank-k matrix should not appear as a diagonal block.
           */
          case UndefinedMatrixType: {
            Assert(false, ExcInvalidHMatrixType(type));
            break;
          }
      }

    if (!is_only_handle_tril)
      {
        switch (submatrices[1]->type)
          {
              case HierarchicalMatrixType: {
                submatrices[1]
                  ->truncate_to_rank_off_diag_preserve_positive_definite(
                    new_rank, false);

                break;
              }
              case RkMatrixType: {
                LAPACKFullMatrixExt<double> C, D;
                submatrices[1]->rkmatrix->truncate_to_rank(new_rank, D, C);

                // DEBUG
                //              std::cout << "||D||_2=" << D.frobenius_norm()
                //                        << ",||C||_2=" << C.frobenius_norm()
                //                        << std::endl;

                /**
                 * The error matrices will be added to the diagonal blocks
                 * when
                 * handling the bottom left block, i.e. @p submatrices[2]. So
                 * here we do nothing after rank truncation of the rank-k
                 * matrix.
                 */

                break;
              }
              case FullMatrixType: {
                /**
                 * Do nothing.
                 */
                break;
              }
              case UndefinedMatrixType: {
                Assert(false, ExcInvalidHMatrixType(type));
                break;
              }
          }
      }

    switch (submatrices[2]->type)
      {
          case HierarchicalMatrixType: {
            submatrices[2]
              ->truncate_to_rank_off_diag_preserve_positive_definite(new_rank,
                                                                     true);

            break;
          }
          case RkMatrixType: {
            LAPACKFullMatrixExt<double> C, D;
            submatrices[2]->rkmatrix->truncate_to_rank(new_rank, D, C);

            /**
             * Since the first and last submatrices of the current \hmatnode
             * are diagonal blocks, directly add the error matrices into
             * them.
             */
            submatrices[0]->addsym_diag(C);
            submatrices[3]->addsym_diag(D);

            // DEBUG
            //          std::cout << "||D||_2=" << D.frobenius_norm()
            //                    << ",||C||_2=" << C.frobenius_norm() <<
            //                    std::endl;

            break;
          }
          case FullMatrixType: {
            /**
             * Do nothing.
             */
            break;
          }
          case UndefinedMatrixType: {
            Assert(false, ExcInvalidHMatrixType(type));
            break;
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::
    truncate_to_rank_off_diag_preserve_positive_definite(
      size_type  new_rank,
      const bool is_compensate_diag_blocks)
  {
    /**
     * At present, it is prescribed that the \bct should be a quad
     * tree.
     */
    Assert(type == HierarchicalMatrixType, ExcInvalidHMatrixType(type));
    AssertDimension(submatrices.size(), 4);

    /**
     * Handle the four lower triangular blocks.
     */
    for (HMatrix *submatrix : submatrices)
      {
        switch (submatrix->type)
          {
              case HierarchicalMatrixType: {
                submatrix->truncate_to_rank_off_diag_preserve_positive_definite(
                  new_rank, is_compensate_diag_blocks);

                break;
              }
              case FullMatrixType: {
                /**
                 * Do nothing.
                 */
                break;
              }
              case RkMatrixType: {
                LAPACKFullMatrixExt<double> C, D;
                submatrix->rkmatrix->truncate_to_rank(new_rank, D, C);

                if (is_compensate_diag_blocks)
                  {
                    /**
                     * Find the diagonal \hmatnode having the same column
                     * cluster as the current \hmatnode.
                     */
                    HMatrix<spacedim, Number> *diag_upper_left =
                      submatrix->find_col_diag_block_for_offdiag_block();
                    Assert(diag_upper_left != submatrix, ExcInternalError());
                    Assert(diag_upper_left != nullptr, ExcInternalError());
                    /**
                     * Find the diagonal \hmatnode having the same row
                     * cluster as the current \hmatnode.
                     */
                    HMatrix<spacedim, Number> *diag_bottom_right =
                      submatrix->find_row_diag_block_for_offdiag_block();
                    Assert(diag_bottom_right != submatrix, ExcInternalError());
                    Assert(diag_bottom_right != nullptr, ExcInternalError());

                    /**
                     * Perform error compensation for preserving the
                     * positive definiteness.
                     */
                    diag_upper_left->addsym_diag(C);
                    diag_bottom_right->addsym_diag(D);

                    // DEBUG
                    //                  std::cout << "||D||_2=" <<
                    //                  D.frobenius_norm()
                    //                            << ",||C||_2=" <<
                    //                            C.frobenius_norm() <<
                    //                            std::endl;
                  }

                break;
              }
              case UndefinedMatrixType: {
                Assert(false, ExcInvalidHMatrixType(type));
                break;
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::vmult(
    Vector<Number>                &y,
    const Vector<Number>          &x,
    const HMatrixSupport::Property top_hmat_property) const
  {
    switch (type)
      {
          case HierarchicalMatrixType: {
            /**
             * When the current \hmatnode is hierarchical, recursively call
             * @p vmult of its children.
             */
            for (HMatrix *submatrix : submatrices)
              {
                submatrix->vmult(y, x, top_hmat_property);
              }

            break;
          }
          case FullMatrixType: {
            /**
             * Here we comes to the matrix-vector multiplication with respect to
             * a near field leaf \hmatnode.
             */
            switch (top_hmat_property)
              {
                  case HMatrixSupport::Property::general: {
                    /**
                     * When the top level \hmatnode is general, perform the
                     * matrix-vector multiplication as usual.
                     */
                    Vector<Number> local_y(m);
                    Vector<Number> local_x(n);

                    /**
                     * Restrict vector x to the current matrix block.
                     */
                    for (size_type j = 0; j < n; j++)
                      {
                        local_x(j) = x((*col_index_range)[0] + j);
                      }

                    fullmatrix->vmult(local_y, local_x);

                    /**
                     * Merge back the result vector \p local_y to \p y.
                     */
                    for (size_type i = 0; i < m; i++)
                      {
                        y((*row_index_range)[0] + i) += local_y(i);
                      }

                    break;
                  }
                  case HMatrixSupport::Property::symmetric: {
                    /**
                     * When the top level \hmatnode is symmetric, the operation
                     * depends on the block type of the current leaf \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A leaf \hmatnode belonging to the diagonal block
                             * should also be symmetric, when the top level
                             * \hmatnode is symmetric.
                             */
                            Assert(property == HMatrixSupport::symmetric,
                                   ExcInvalidHMatrixProperty(property));
                            /**
                             * The full matrix associated with the current
                             * \hmatnode should also be symmetric.
                             */
                            Assert(fullmatrix->get_property() ==
                                     LAPACKSupport::symmetric,
                                   ExcInvalidLAPACKFullMatrixProperty(
                                     fullmatrix->get_property()));

                            /**
                             * Perform the matrix-vector multiplication using
                             * the
                             * LAPACK function @p symv internally. In my implementation, only
                             * those lower triangular elements in a symmetric
                             * full matrix are used by the function.
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) = x((*col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] + i) += local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we first perform the
                             * multiplication \f$Mx\f$ and then perform the
                             * multiplication \f$M^Tx\f$. This treatment
                             * considers both the contribution of the current
                             * matrix block as well as its symmetric
                             * counterpart.
                             *
                             * \alert{Not only should the full matrix itself be
                             * transposed, the roles of row indices and column
                             * indices should also be swapped.}
                             */

                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) = x((*col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] + i) += local_y(i);
                              }

                            Vector<Number> local_y_for_Tvmult(n);
                            Vector<Number> local_x_for_Tvmult(m);

                            /**
                             * Restrict vector x to the current transposed
                             * matrix block.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                local_x_for_Tvmult(i) =
                                  x((*row_index_range)[0] + i);
                              }

                            fullmatrix->Tvmult(local_y_for_Tvmult,
                                               local_x_for_Tvmult);

                            /**
                             * Merge back the result vector \p local_y_for_Tvmult
                             * to \p y.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                y((*col_index_range)[0] + j) +=
                                  local_y_for_Tvmult(j);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, since the upper part is not
                             * saved and its contribution has already been
                             * considered when we handle the lower triangular
                             * block, we do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::Property::lower_triangular: {
                    /**
                     * When the top level \hmatnode is lower triangular, the
                     * operation depends on the block type of the current leaf
                     * \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A leaf \hmatnode belonging to the diagonal block
                             * should also be lower triangular, when the top
                             * level \hmatnode is lower triangular.
                             */
                            Assert(property ==
                                     HMatrixSupport::Property::lower_triangular,
                                   ExcInvalidHMatrixProperty(property));
                            /**
                             * The full matrix associated with the current
                             * \hmatnode should also be lower triangular.
                             */
                            Assert(fullmatrix->get_property() ==
                                     LAPACKSupport::Property::lower_triangular,
                                   ExcInvalidLAPACKFullMatrixProperty(
                                     fullmatrix->get_property()));

                            /**
                             * Perform the matrix-vector multiplication using
                             * the
                             * LAPACK function @p trmv internally.
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) = x((*col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] + i) += local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we simply perform the
                             * multiplication \f$Mx\f$ by treating the current
                             * matrix as general.
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) = x((*col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] + i) += local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, we do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  default: {
                    throw(ExcInvalidHMatrixProperty(top_hmat_property));

                    break;
                  }
              }

            break;
          }
          case RkMatrixType: {
            /**
             * Here we comes to the matrix-vector multiplication with respect to
             * a far field leaf \hmatnode.
             */
            switch (top_hmat_property)
              {
                  case HMatrixSupport::Property::general: {
                    /**
                     * When the top level \hmatnode is general, perform the
                     * matrix-vector multiplication as usual.
                     */
                    Vector<Number> local_y(m);
                    Vector<Number> local_x(n);

                    /**
                     * Restrict vector x to the current matrix block.
                     */
                    for (size_type j = 0; j < n; j++)
                      {
                        local_x(j) = x((*col_index_range)[0] + j);
                      }

                    rkmatrix->vmult(local_y, local_x);

                    /**
                     * Merge back the result vector \p local_y to \p y.
                     */
                    for (size_type i = 0; i < m; i++)
                      {
                        y((*row_index_range)[0] + i) += local_y(i);
                      }

                    break;
                  }
                  case HMatrixSupport::Property::symmetric: {
                    /**
                     * When the top level \hmatnode is symmetric, the operation
                     * depends on the block type of the current leaf \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * When the current \hmatnode is rank-k matrix, it
                             * can never belong to the diagonal part.
                             */
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we first perform the
                             * multiplication \f$Mx\f$ and then perform the
                             * multiplication \f$M^Tx\f$. This treatment
                             * considers both the contribution of the current
                             * matrix block as well as its symmetric
                             * counterpart.
                             *
                             * \alert{Not only should the full matrix itself be
                             * transposed, the roles of row indices and column
                             * indices should also be swapped.}
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) = x((*col_index_range)[0] + j);
                              }

                            rkmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] + i) += local_y(i);
                              }

                            Vector<Number> local_y_for_Tvmult(n);
                            Vector<Number> local_x_for_Tvmult(m);

                            /**
                             * Restrict vector x to the current transposed
                             * matrix block.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                local_x_for_Tvmult(i) =
                                  x((*row_index_range)[0] + i);
                              }

                            rkmatrix->Tvmult(local_y_for_Tvmult,
                                             local_x_for_Tvmult);

                            /**
                             * Merge back the result vector \p local_y_for_Tvmult
                             * to \p y.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                y((*col_index_range)[0] + j) +=
                                  local_y_for_Tvmult(j);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::Property::lower_triangular: {
                    /**
                     * When the top level \hmatnode is lower triangular, the
                     * operation depends on the block type of the current leaf
                     * \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A rank-k matrix node can never belong to the
                             * diagonal part.
                             */
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we simply perform the
                             * multiplication \f$Mx\f$ as that for a general
                             * matrix.
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) = x((*col_index_range)[0] + j);
                              }

                            rkmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] + i) += local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  default: {
                    throw(ExcInvalidHMatrixProperty(top_hmat_property));

                    break;
                  }
              }

            break;
          }
        case UndefinedMatrixType:
          default: {
            Assert(false, ExcInvalidHMatrixType(type));
            break;
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::vmult(
    Vector<Number>                &y,
    const Number                   alpha,
    const Vector<Number>          &x,
    const HMatrixSupport::Property top_hmat_property) const
  {
    switch (type)
      {
          case HierarchicalMatrixType: {
            /**
             * When the current \hmatnode is hierarchical, recursively call
             * @p vmult of its children.
             */
            for (HMatrix *submatrix : submatrices)
              {
                submatrix->vmult(y, alpha, x, top_hmat_property);
              }

            break;
          }
          case FullMatrixType: {
            /**
             * Here we comes to the matrix-vector multiplication with respect to
             * a near field leaf \hmatnode.
             */
            switch (top_hmat_property)
              {
                  case HMatrixSupport::Property::general: {
                    /**
                     * When the top level \hmatnode is general, perform the
                     * matrix-vector multiplication as usual.
                     */
                    Vector<Number> local_y(m);
                    Vector<Number> local_x(n);

                    /**
                     * Restrict vector x to the current matrix block.
                     */
                    for (size_type j = 0; j < n; j++)
                      {
                        local_x(j) = x((*col_index_range)[0] + j);
                      }

                    fullmatrix->vmult(local_y, local_x);

                    /**
                     * Merge back the result vector \p local_y to \p y.
                     */
                    for (size_type i = 0; i < m; i++)
                      {
                        y((*row_index_range)[0] + i) += alpha * local_y(i);
                      }

                    break;
                  }
                  case HMatrixSupport::Property::symmetric: {
                    /**
                     * When the top level \hmatnode is symmetric, the operation
                     * depends on the block type of the current leaf \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A leaf \hmatnode belonging to the diagonal block
                             * should also be symmetric, when the top level
                             * \hmatnode is symmetric.
                             */
                            Assert(property == HMatrixSupport::symmetric,
                                   ExcInvalidHMatrixProperty(property));
                            /**
                             * The full matrix associated with the current
                             * \hmatnode should also be symmetric.
                             */
                            Assert(fullmatrix->get_property() ==
                                     LAPACKSupport::symmetric,
                                   ExcInvalidLAPACKFullMatrixProperty(
                                     fullmatrix->get_property()));

                            /**
                             * Perform the matrix-vector multiplication using
                             * the
                             * LAPACK function @p symv. In my implementation, only
                             * those lower triangular elements in a symmetric
                             * full matrix are used by the function.
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) = x((*col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we first perform the
                             * multiplication \f$Mx\f$ and then perform the
                             * multiplication \f$M^Tx\f$. This treatment
                             * considers both the contribution of the current
                             * matrix block as well as its symmetric
                             * counterpart.
                             *
                             * \alert{Not only should the full matrix itself be
                             * transposed, the roles of row indices and column
                             * indices should also be swapped when handling
                             * \f$M^Tx\f$.}
                             */

                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) = x((*col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            Vector<Number> local_y_for_Tvmult(n);
                            Vector<Number> local_x_for_Tvmult(m);

                            /**
                             * Restrict vector x to the current transposed
                             * matrix block.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                local_x_for_Tvmult(i) =
                                  x((*row_index_range)[0] + i);
                              }

                            fullmatrix->Tvmult(local_y_for_Tvmult,
                                               local_x_for_Tvmult);

                            /**
                             * Merge back the result vector \p local_y_for_Tvmult
                             * to \p y.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                y((*col_index_range)[0] + j) +=
                                  alpha * local_y_for_Tvmult(j);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            Assert(false,
                                   ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::Property::lower_triangular: {
                    /**
                     * When the top level \hmatnode is lower triangular, the
                     * operation depends on the block type of the current leaf
                     * \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A leaf \hmatnode belonging to the diagonal block
                             * should also be lower triangular, when the top
                             * level \hmatnode is lower triangular.
                             */
                            Assert(property ==
                                     HMatrixSupport::Property::lower_triangular,
                                   ExcInvalidHMatrixProperty(property));
                            /**
                             * The full matrix associated with the current
                             * \hmatnode should also be lower triangular.
                             */
                            Assert(fullmatrix->get_property() ==
                                     LAPACKSupport::Property::lower_triangular,
                                   ExcInvalidLAPACKFullMatrixProperty(
                                     fullmatrix->get_property()));

                            /**
                             * Perform the matrix-vector multiplication using
                             * the
                             * LAPACK function @p trmv internally.
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) = x((*col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we simply perform the
                             * multiplication \f$Mx\f$ by treating the current
                             * matrix as general.
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) = x((*col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, we do nothing.
                             */

                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  default: {
                    throw(ExcInvalidHMatrixProperty(top_hmat_property));

                    break;
                  }
              }

            break;
          }
          case RkMatrixType: {
            /**
             * Here we comes to the matrix-vector multiplication with respect to
             * a far field leaf \hmatnode.
             */
            switch (top_hmat_property)
              {
                  case HMatrixSupport::Property::general: {
                    /**
                     * When the top level \hmatnode is general, perform the
                     * matrix-vector multiplication as usual.
                     */
                    Vector<Number> local_y(m);
                    Vector<Number> local_x(n);

                    /**
                     * Restrict vector x to the current matrix block.
                     */
                    for (size_type j = 0; j < n; j++)
                      {
                        local_x(j) = x((*col_index_range)[0] + j);
                      }

                    rkmatrix->vmult(local_y, local_x);

                    /**
                     * Merge back the result vector \p local_y to \p y.
                     */
                    for (size_type i = 0; i < m; i++)
                      {
                        y((*row_index_range)[0] + i) += alpha * local_y(i);
                      }

                    break;
                  }
                  case HMatrixSupport::Property::symmetric: {
                    /**
                     * When the top level \hmatnode is symmetric, the operation
                     * depends on the block type of the current leaf \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * When the current \hmatnode is rank-k matrix, it
                             * can never belong to the diagonal part.
                             */
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we first perform the
                             * multiplication \f$Mx\f$ and then perform the
                             * multiplication \f$M^Tx\f$. This treatment
                             * considers both the contribution of the current
                             * matrix block as well as its symmetric
                             * counterpart.
                             *
                             * \alert{Not only should the full matrix itself be
                             * transposed, the roles of row indices and column
                             * indices should also be swapped when handling
                             * \f$M^Tx\f$.}
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) = x((*col_index_range)[0] + j);
                              }

                            rkmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            Vector<Number> local_y_for_Tvmult(n);
                            Vector<Number> local_x_for_Tvmult(m);

                            /**
                             * Restrict vector x to the current transposed
                             * matrix block.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                local_x_for_Tvmult(i) =
                                  x((*row_index_range)[0] + i);
                              }

                            rkmatrix->Tvmult(local_y_for_Tvmult,
                                             local_x_for_Tvmult);

                            /**
                             * Merge back the result vector \p local_y_for_Tvmult
                             * to \p y.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                y((*col_index_range)[0] + j) +=
                                  alpha * local_y_for_Tvmult(j);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::Property::lower_triangular: {
                    /**
                     * When the top level \hmatnode is lower triangular, the
                     * operation depends on the block type of the current leaf
                     * \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A rank-k matrix node can never belong to the
                             * diagonal part.
                             */
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we simply perform the
                             * multiplication \f$Mx\f$ as that for a general
                             * matrix.
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) = x((*col_index_range)[0] + j);
                              }

                            rkmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  default: {
                    throw(ExcInvalidHMatrixProperty(top_hmat_property));

                    break;
                  }
              }

            break;
          }
        case UndefinedMatrixType:
          default: {
            Assert(false, ExcInvalidHMatrixType(type));
            break;
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::vmult(
    Vector<Number>                  &y,
    const Vector<Number>            &x,
    const HMatrix<spacedim, Number> &starting_hmat,
    const HMatrixSupport::Property   top_hmat_property) const
  {
    switch (type)
      {
          case HierarchicalMatrixType: {
            /**
             * When the current \hmatnode is hierarchical, recursively call
             * @p vmult of its children.
             */
            for (HMatrix *submatrix : submatrices)
              {
                submatrix->vmult(y, x, starting_hmat, top_hmat_property);
              }

            break;
          }
          case FullMatrixType: {
            /**
             * Here we comes to the matrix-vector multiplication with respect to
             * a near field leaf \hmatnode.
             */
            switch (top_hmat_property)
              {
                  case HMatrixSupport::Property::general: {
                    /**
                     * When the top level \hmatnode is general, perform the
                     * matrix-vector multiplication as usual.
                     */
                    Vector<Number> local_y(m);
                    Vector<Number> local_x(n);

                    /**
                     * Restrict vector x to the current matrix block.
                     */
                    for (size_type j = 0; j < n; j++)
                      {
                        local_x(j) = x((*col_index_range)[0] -
                                       (*starting_hmat.col_index_range)[0] + j);
                      }

                    fullmatrix->vmult(local_y, local_x);

                    /**
                     * Merge back the result vector \p local_y to \p y.
                     */
                    for (size_type i = 0; i < m; i++)
                      {
                        y((*row_index_range)[0] -
                          (*starting_hmat.row_index_range)[0] + i) +=
                          local_y(i);
                      }

                    break;
                  }
                  case HMatrixSupport::Property::symmetric: {
                    /**
                     * When the top level \hmatnode is symmetric, the operation
                     * depends on the block type of the current leaf \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A leaf \hmatnode belonging to the diagonal block
                             * should also be symmetric, when the top level
                             * \hmatnode is symmetric.
                             */
                            Assert(property == HMatrixSupport::symmetric,
                                   ExcInvalidHMatrixProperty(property));
                            /**
                             * The full matrix associated with the current
                             * \hmatnode should also be symmetric.
                             */
                            Assert(fullmatrix->get_property() ==
                                     LAPACKSupport::symmetric,
                                   ExcInvalidLAPACKFullMatrixProperty(
                                     fullmatrix->get_property()));

                            /**
                             * Perform the matrix-vector multiplication using
                             * the
                             * LAPACK function @p symv. In my implementation, only
                             * those lower triangular elements in a symmetric
                             * full matrix are used by the function.
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) =
                                  x((*col_index_range)[0] -
                                    (*starting_hmat.col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] -
                                  (*starting_hmat.row_index_range)[0] + i) +=
                                  local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we first perform the
                             * multiplication \f$Mx\f$ and then perform the
                             * multiplication \f$M^Tx\f$. This treatment
                             * considers both the contribution of the current
                             * matrix block as well as its symmetric
                             * counterpart.
                             *
                             * \alert{Not only should the full matrix itself be
                             * transposed, the roles of row indices and column
                             * indices should also be swapped.}
                             */

                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) =
                                  x((*col_index_range)[0] -
                                    (*starting_hmat.col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] -
                                  (*starting_hmat.row_index_range)[0] + i) +=
                                  local_y(i);
                              }

                            Vector<Number> local_y_for_Tvmult(n);
                            Vector<Number> local_x_for_Tvmult(m);

                            /**
                             * Restrict vector x to the current transposed
                             * matrix block.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                local_x_for_Tvmult(i) =
                                  x((*row_index_range)[0] -
                                    (*starting_hmat.row_index_range)[0] + i);
                              }

                            fullmatrix->Tvmult(local_y_for_Tvmult,
                                               local_x_for_Tvmult);

                            /**
                             * Merge back the result vector \p local_y_for_Tvmult
                             * to \p y.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                y((*col_index_range)[0] -
                                  (*starting_hmat.col_index_range)[0] + j) +=
                                  local_y_for_Tvmult(j);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::Property::lower_triangular: {
                    /**
                     * When the top level \hmatnode is lower triangular, the
                     * operation depends on the block type of the current leaf
                     * \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A leaf \hmatnode belonging to the diagonal block
                             * should also be lower triangular, when the top
                             * level \hmatnode is lower triangular.
                             */
                            Assert(property ==
                                     HMatrixSupport::Property::lower_triangular,
                                   ExcInvalidHMatrixProperty(property));
                            /**
                             * The full matrix associated with the current
                             * \hmatnode should also be lower triangular.
                             */
                            Assert(fullmatrix->get_property() ==
                                     LAPACKSupport::Property::lower_triangular,
                                   ExcInvalidLAPACKFullMatrixProperty(
                                     fullmatrix->get_property()));

                            /**
                             * Perform the matrix-vector multiplication using
                             * the
                             * LAPACK function @p trmv internally.
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) =
                                  x((*col_index_range)[0] -
                                    (*starting_hmat.col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] -
                                  (*starting_hmat.row_index_range)[0] + i) +=
                                  local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we simply perform the
                             * multiplication \f$Mx\f$ by treating the current
                             * matrix as general.
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) =
                                  x((*col_index_range)[0] -
                                    (*starting_hmat.col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] -
                                  (*starting_hmat.row_index_range)[0] + i) +=
                                  local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, we do nothing.
                             */

                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  default: {
                    throw(ExcInvalidHMatrixProperty(top_hmat_property));

                    break;
                  }
              }

            break;
          }
          case RkMatrixType: {
            /**
             * Here we comes to the matrix-vector multiplication with respect to
             * a far field leaf \hmatnode.
             */
            switch (top_hmat_property)
              {
                  case HMatrixSupport::Property::general: {
                    /**
                     * When the top level \hmatnode is general, perform the
                     * matrix-vector multiplication as usual.
                     */
                    Vector<Number> local_y(m);
                    Vector<Number> local_x(n);

                    /**
                     * Restrict vector x to the current matrix block.
                     */
                    for (size_type j = 0; j < n; j++)
                      {
                        local_x(j) = x((*col_index_range)[0] -
                                       (*starting_hmat.col_index_range)[0] + j);
                      }

                    rkmatrix->vmult(local_y, local_x);

                    /**
                     * Merge back the result vector \p local_y to \p y.
                     */
                    for (size_type i = 0; i < m; i++)
                      {
                        y((*row_index_range)[0] -
                          (*starting_hmat.row_index_range)[0] + i) +=
                          local_y(i);
                      }

                    break;
                  }
                  case HMatrixSupport::Property::symmetric: {
                    /**
                     * When the top level \hmatnode is symmetric, the operation
                     * depends on the block type of the current leaf \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * When the current \hmatnode is rank-k matrix, it
                             * can never belong to the diagonal part.
                             */
                            Assert(false,
                                   ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we first perform the
                             * multiplication \f$Mx\f$ and then perform the
                             * multiplication \f$M^Tx\f$. This treatment
                             * considers both the contribution of the current
                             * matrix block as well as its symmetric
                             * counterpart.
                             *
                             * \alert{Not only should the full matrix itself be
                             * transposed, the roles of row indices and column
                             * indices should also be swapped.}
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) =
                                  x((*col_index_range)[0] -
                                    (*starting_hmat.col_index_range)[0] + j);
                              }

                            rkmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] -
                                  (*starting_hmat.row_index_range)[0] + i) +=
                                  local_y(i);
                              }

                            Vector<Number> local_y_for_Tvmult(n);
                            Vector<Number> local_x_for_Tvmult(m);

                            /**
                             * Restrict vector x to the current transposed
                             * matrix block.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                local_x_for_Tvmult(i) =
                                  x((*row_index_range)[0] -
                                    (*starting_hmat.row_index_range)[0] + i);
                              }

                            rkmatrix->Tvmult(local_y_for_Tvmult,
                                             local_x_for_Tvmult);

                            /**
                             * Merge back the result vector \p local_y_for_Tvmult
                             * to \p y.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                y((*col_index_range)[0] -
                                  (*starting_hmat.col_index_range)[0] + j) +=
                                  local_y_for_Tvmult(j);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::Property::lower_triangular: {
                    /**
                     * When the top level \hmatnode is lower triangular, the
                     * operation depends on the block type of the current leaf
                     * \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A rank-k matrix node can never belong to the
                             * diagonal part.
                             */
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we simply perform the
                             * multiplication \f$Mx\f$ as that for a general
                             * matrix.
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) =
                                  x((*col_index_range)[0] -
                                    (*starting_hmat.col_index_range)[0] + j);
                              }

                            rkmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] -
                                  (*starting_hmat.row_index_range)[0] + i) +=
                                  local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  default: {
                    throw(ExcInvalidHMatrixProperty(top_hmat_property));

                    break;
                  }
              }

            break;
          }
        case UndefinedMatrixType:
          default: {
            Assert(false, ExcInvalidHMatrixType(type));
            break;
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::vmult(
    Vector<Number>                  &y,
    const Number                     alpha,
    const Vector<Number>            &x,
    const HMatrix<spacedim, Number> &starting_hmat,
    const HMatrixSupport::Property   top_hmat_property) const
  {
    switch (type)
      {
          case HierarchicalMatrixType: {
            /**
             * When the current \hmatnode is hierarchical, recursively call
             * @p vmult of its children.
             */
            for (HMatrix *submatrix : submatrices)
              {
                submatrix->vmult(y, alpha, x, starting_hmat, top_hmat_property);
              }

            break;
          }
          case FullMatrixType: {
            /**
             * Here we comes to the matrix-vector multiplication with respect to
             * a near field leaf \hmatnode.
             */
            switch (top_hmat_property)
              {
                  case HMatrixSupport::Property::general: {
                    /**
                     * When the top level \hmatnode is general, perform the
                     * matrix-vector multiplication as usual.
                     */
                    Vector<Number> local_y(m);
                    Vector<Number> local_x(n);

                    /**
                     * Restrict vector x to the current matrix block.
                     */
                    for (size_type j = 0; j < n; j++)
                      {
                        local_x(j) = x((*col_index_range)[0] -
                                       (*starting_hmat.col_index_range)[0] + j);
                      }

                    fullmatrix->vmult(local_y, local_x);

                    /**
                     * Merge back the result vector \p local_y to \p y.
                     */
                    for (size_type i = 0; i < m; i++)
                      {
                        y((*row_index_range)[0] -
                          (*starting_hmat.row_index_range)[0] + i) +=
                          alpha * local_y(i);
                      }

                    break;
                  }
                  case HMatrixSupport::Property::symmetric: {
                    /**
                     * When the top level \hmatnode is symmetric, the operation
                     * depends on the block type of the current leaf \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A leaf \hmatnode belonging to the diagonal block
                             * should also be symmetric, when the top level
                             * \hmatnode is symmetric.
                             */
                            Assert(property == HMatrixSupport::symmetric,
                                   ExcInvalidHMatrixProperty(property));
                            /**
                             * The full matrix associated with the current
                             * \hmatnode should also be symmetric.
                             */
                            Assert(fullmatrix->get_property() ==
                                     LAPACKSupport::symmetric,
                                   ExcInvalidLAPACKFullMatrixProperty(
                                     fullmatrix->get_property()));

                            /**
                             * Perform the matrix-vector multiplication using
                             * the
                             * LAPACK function @p symv. In my implementation, only
                             * those lower triangular elements in a symmetric
                             * full matrix are used by the function.
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) =
                                  x((*col_index_range)[0] -
                                    (*starting_hmat.col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] -
                                  (*starting_hmat.row_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we first perform the
                             * multiplication \f$Mx\f$ and then perform the
                             * multiplication \f$M^Tx\f$. This treatment
                             * considers both the contribution of the current
                             * matrix block as well as its symmetric
                             * counterpart.
                             *
                             * \alert{Not only should the full matrix itself be
                             * transposed, the roles of row indices and column
                             * indices should also be swapped when handling
                             * \f$M^Tx\f$.}
                             */

                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) =
                                  x((*col_index_range)[0] -
                                    (*starting_hmat.col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] -
                                  (*starting_hmat.row_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            Vector<Number> local_y_for_Tvmult(n);
                            Vector<Number> local_x_for_Tvmult(m);

                            /**
                             * Restrict vector x to the current transposed
                             * matrix block.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                local_x_for_Tvmult(i) =
                                  x((*row_index_range)[0] -
                                    (*starting_hmat.row_index_range)[0] + i);
                              }

                            fullmatrix->Tvmult(local_y_for_Tvmult,
                                               local_x_for_Tvmult);

                            /**
                             * Merge back the result vector \p local_y_for_Tvmult
                             * to \p y.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                y((*col_index_range)[0] -
                                  (*starting_hmat.col_index_range)[0] + j) +=
                                  alpha * local_y_for_Tvmult(j);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            Assert(false,
                                   ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::Property::lower_triangular: {
                    /**
                     * When the top level \hmatnode is lower triangular, the
                     * operation depends on the block type of the current leaf
                     * \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A leaf \hmatnode belonging to the diagonal block
                             * should also be lower triangular, when the top
                             * level \hmatnode is lower triangular.
                             */
                            Assert(property ==
                                     HMatrixSupport::Property::lower_triangular,
                                   ExcInvalidHMatrixProperty(property));
                            /**
                             * The full matrix associated with the current
                             * \hmatnode should also be lower triangular.
                             */
                            Assert(fullmatrix->get_property() ==
                                     LAPACKSupport::Property::lower_triangular,
                                   ExcInvalidLAPACKFullMatrixProperty(
                                     fullmatrix->get_property()));

                            /**
                             * Perform the matrix-vector multiplication using
                             * the
                             * LAPACK function @p trmv internally.
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) =
                                  x((*col_index_range)[0] -
                                    (*starting_hmat.col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] -
                                  (*starting_hmat.row_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we simply perform the
                             * multiplication \f$Mx\f$ by treating the current
                             * matrix as general.
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) =
                                  x((*col_index_range)[0] -
                                    (*starting_hmat.col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] -
                                  (*starting_hmat.row_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, we do nothing.
                             */

                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  default: {
                    throw(ExcInvalidHMatrixProperty(top_hmat_property));

                    break;
                  }
              }

            break;
          }
          case RkMatrixType: {
            /**
             * Here we comes to the matrix-vector multiplication with respect to
             * a far field leaf \hmatnode.
             */
            switch (top_hmat_property)
              {
                  case HMatrixSupport::Property::general: {
                    /**
                     * When the top level \hmatnode is general, perform the
                     * matrix-vector multiplication as usual.
                     */
                    Vector<Number> local_y(m);
                    Vector<Number> local_x(n);

                    /**
                     * Restrict vector x to the current matrix block.
                     */
                    for (size_type j = 0; j < n; j++)
                      {
                        local_x(j) = x((*col_index_range)[0] -
                                       (*starting_hmat.col_index_range)[0] + j);
                      }

                    rkmatrix->vmult(local_y, local_x);

                    /**
                     * Merge back the result vector \p local_y to \p y.
                     */
                    for (size_type i = 0; i < m; i++)
                      {
                        y((*row_index_range)[0] -
                          (*starting_hmat.row_index_range)[0] + i) +=
                          alpha * local_y(i);
                      }

                    break;
                  }
                  case HMatrixSupport::Property::symmetric: {
                    /**
                     * When the top level \hmatnode is symmetric, the operation
                     * depends on the block type of the current leaf \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * When the current \hmatnode is rank-k matrix, it
                             * can never belong to the diagonal part.
                             */
                            Assert(false,
                                   ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we first perform the
                             * multiplication \f$Mx\f$ and then perform the
                             * multiplication \f$M^Tx\f$. This treatment
                             * considers both the contribution of the current
                             * matrix block as well as its symmetric
                             * counterpart.
                             *
                             * \alert{Not only should the full matrix itself be
                             * transposed, the roles of row indices and column
                             * indices should also be swapped when handling
                             * \f$M^Tx\f$.}
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) =
                                  x((*col_index_range)[0] -
                                    (*starting_hmat.col_index_range)[0] + j);
                              }

                            rkmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] -
                                  (*starting_hmat.row_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            Vector<Number> local_y_for_Tvmult(n);
                            Vector<Number> local_x_for_Tvmult(m);

                            /**
                             * Restrict vector x to the current transposed
                             * matrix block.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                local_x_for_Tvmult(i) =
                                  x((*row_index_range)[0] -
                                    (*starting_hmat.row_index_range)[0] + i);
                              }

                            rkmatrix->Tvmult(local_y_for_Tvmult,
                                             local_x_for_Tvmult);

                            /**
                             * Merge back the result vector \p local_y_for_Tvmult
                             * to \p y.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                y((*col_index_range)[0] -
                                  (*starting_hmat.col_index_range)[0] + j) +=
                                  alpha * local_y_for_Tvmult(j);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            Assert(false,
                                   ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::Property::lower_triangular: {
                    /**
                     * When the top level \hmatnode is lower triangular, the
                     * operation depends on the block type of the current leaf
                     * \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A rank-k matrix node can never belong to the
                             * diagonal part.
                             */
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we simply perform the
                             * multiplication \f$Mx\f$ as that for a general
                             * matrix.
                             */
                            Vector<Number> local_y(m);
                            Vector<Number> local_x(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x(j) =
                                  x((*col_index_range)[0] -
                                    (*starting_hmat.col_index_range)[0] + j);
                              }

                            rkmatrix->vmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] -
                                  (*starting_hmat.row_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  default: {
                    throw(ExcInvalidHMatrixProperty(top_hmat_property));

                    break;
                  }
              }

            break;
          }
        case UndefinedMatrixType:
          default: {
            Assert(false, ExcInvalidHMatrixType(type));
            break;
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::Tvmult(
    Vector<Number>                &y,
    const Vector<Number>          &x,
    const HMatrixSupport::Property top_hmat_property) const
  {
    switch (type)
      {
          case HierarchicalMatrixType: {
            /**
             * When the current \hmatnode is hierarchical, recursively call
             * @p Tvmult of its children.
             */
            for (HMatrix *submatrix : submatrices)
              {
                submatrix->Tvmult(y, x, top_hmat_property);
              }

            break;
          }
          case FullMatrixType: {
            /**
             * Here we comes to the transposed-matrix-vector multiplication with
             * respect to a near field leaf \hmatnode.
             */
            switch (top_hmat_property)
              {
                  case HMatrixSupport::Property::general: {
                    /**
                     * When the top level \hmatnode is general, perform the
                     * transposed-matrix-vector multiplication as usual.
                     */
                    Vector<Number> local_y(n);
                    Vector<Number> local_x(m);

                    /**
                     * Restrict vector x to the transposed matrix block.
                     */
                    for (size_type j = 0; j < m; j++)
                      {
                        local_x(j) = x((*row_index_range)[0] + j);
                      }

                    fullmatrix->Tvmult(local_y, local_x);

                    /**
                     * Merge back the result vector \p local_y to \p y.
                     */
                    for (size_type i = 0; i < n; i++)
                      {
                        y((*col_index_range)[0] + i) += local_y(i);
                      }

                    break;
                  }
                  case HMatrixSupport::Property::symmetric: {
                    /**
                     * When the top level \hmatnode is symmetric, the operation
                     * depends on the block type of the current leaf \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A leaf \hmatnode belonging to the diagonal block
                             * should also be symmetric, when the top level
                             * \hmatnode is symmetric.
                             */
                            Assert(property == HMatrixSupport::symmetric,
                                   ExcInvalidHMatrixProperty(property));
                            /**
                             * The full matrix associated with the current
                             * \hmatnode should also be symmetric.
                             */
                            Assert(fullmatrix->get_property() ==
                                     LAPACKSupport::symmetric,
                                   ExcInvalidLAPACKFullMatrixProperty(
                                     fullmatrix->get_property()));

                            /**
                             * Perform the transposed-matrix-vector
                             * multiplication. In my implementation, only those
                             * lower triangular elements in a symmetric full
                             * matrix are used by the function.
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the transposed matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) = x((*row_index_range)[0] + j);
                              }

                            fullmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] + i) += local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we first perform the
                             * multiplication \f$M^Tx\f$ and then perform the
                             * multiplication \f$Mx\f$. This treatment considers
                             * both the contribution of the current matrix block
                             * as well as its symmetric counterpart.
                             *
                             * \alert{Not only should the full matrix itself be
                             * transposed, the roles of row indices and column
                             * indices should also be swapped.}
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the transposed matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) = x((*row_index_range)[0] + j);
                              }

                            fullmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] + i) += local_y(i);
                              }

                            Vector<Number> local_y_for_vmult(m);
                            Vector<Number> local_x_for_vmult(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x_for_vmult(j) =
                                  x((*col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y_for_vmult,
                                              local_x_for_vmult);

                            /**
                             * Merge back the result vector \p local_y_for_vmult to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] + i) +=
                                  local_y_for_vmult(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, since the upper part is not
                             * saved and its contribution has already been
                             * considered when we handle the lower triangular
                             * block, we do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::Property::lower_triangular: {
                    /**
                     * When the top level \hmatnode is lower triangular, the
                     * operation depends on the block type of the current leaf
                     * \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A leaf \hmatnode belonging to the diagonal block
                             * should also be lower triangular, when the top
                             * level \hmatnode is lower triangular.
                             */
                            Assert(property ==
                                     HMatrixSupport::Property::lower_triangular,
                                   ExcInvalidHMatrixProperty(property));
                            /**
                             * The full matrix associated with the current
                             * \hmatnode should also be lower triangular.
                             */
                            Assert(fullmatrix->get_property() ==
                                     LAPACKSupport::Property::lower_triangular,
                                   ExcInvalidLAPACKFullMatrixProperty(
                                     fullmatrix->get_property()));

                            /**
                             * Perform the transposed-matrix-vector
                             * multiplication.
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the transposed matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) = x((*row_index_range)[0] + j);
                              }

                            fullmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] + i) += local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we perform the multiplication
                             * \f$M^Tx\f$ as that for a general matrix.
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the transposed matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) = x((*row_index_range)[0] + j);
                              }

                            fullmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] + i) += local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, since the upper part is not
                             * saved and has no contribution to the result, we
                             * do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  default: {
                    throw(ExcInvalidHMatrixProperty(top_hmat_property));

                    break;
                  }
              }

            break;
          }
          case RkMatrixType: {
            /**
             * Here we comes to the transposed matrix-vector multiplication with
             * respect to a far field leaf \hmatnode.
             */
            switch (top_hmat_property)
              {
                  case HMatrixSupport::Property::general: {
                    /**
                     * When the top level \hmatnode is general, perform the
                     * transposed matrix-vector multiplication as usual.
                     */
                    Vector<Number> local_y(n);
                    Vector<Number> local_x(m);

                    /**
                     * Restrict vector x to the current matrix block.
                     */
                    for (size_type j = 0; j < m; j++)
                      {
                        local_x(j) = x((*row_index_range)[0] + j);
                      }

                    rkmatrix->Tvmult(local_y, local_x);

                    /**
                     * Merge back the result vector \p local_y to \p y.
                     */
                    for (size_type i = 0; i < n; i++)
                      {
                        y((*col_index_range)[0] + i) += local_y(i);
                      }

                    break;
                  }
                  case HMatrixSupport::Property::symmetric: {
                    /**
                     * When the top level \hmatnode is symmetric, the operation
                     * depends on the block type of the current leaf \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * When the current \hmatnode is rank-k matrix, it
                             * can never belong to the diagonal part.
                             */
                            Assert(false,
                                   ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we first perform the
                             * multiplication \f$M^Tx\f$ and then perform the
                             * multiplication \f$Mx\f$. This treatment considers
                             * both the contribution of the current matrix block
                             * as well as its symmetric counterpart.
                             *
                             * \alert{Not only should the full matrix itself be
                             * transposed, the roles of row indices and column
                             * indices should also be swapped.}
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) = x((*row_index_range)[0] + j);
                              }

                            rkmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] + i) += local_y(i);
                              }

                            Vector<Number> local_y_for_vmult(m);
                            Vector<Number> local_x_for_vmult(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x_for_vmult(j) =
                                  x((*col_index_range)[0] + j);
                              }

                            rkmatrix->vmult(local_y_for_vmult,
                                            local_x_for_vmult);

                            /**
                             * Merge back the result vector \p local_y_for_vmult to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] + i) +=
                                  local_y_for_vmult(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::Property::lower_triangular: {
                    /**
                     * When the top level \hmatnode is lower triangular, the
                     * operation depends on the block type of the current leaf
                     * \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * When the current \hmatnode is rank-k matrix, it
                             * can never belong to the diagonal part.
                             */
                            Assert(false,
                                   ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we perform the multiplication
                             * \f$M^Tx\f$.
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) = x((*row_index_range)[0] + j);
                              }

                            rkmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] + i) += local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  default: {
                    throw(ExcInvalidHMatrixProperty(top_hmat_property));

                    break;
                  }
              }

            break;
          }
        case UndefinedMatrixType:
          default: {
            Assert(false, ExcInvalidHMatrixType(type));
            break;
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::Tvmult(
    Vector<Number>                &y,
    const Number                   alpha,
    const Vector<Number>          &x,
    const HMatrixSupport::Property top_hmat_property) const
  {
    switch (type)
      {
          case HierarchicalMatrixType: {
            /**
             * When the current \hmatnode is hierarchical, recursively call
             * @p Tvmult of its children.
             */
            for (HMatrix *submatrix : submatrices)
              {
                submatrix->Tvmult(y, alpha, x, top_hmat_property);
              }

            break;
          }
          case FullMatrixType: {
            /**
             * Here we comes to the transposed-matrix-vector multiplication with
             * respect to a near field leaf \hmatnode.
             */
            switch (top_hmat_property)
              {
                  case HMatrixSupport::Property::general: {
                    /**
                     * When the top level \hmatnode is general, perform the
                     * transposed-matrix-vector multiplication as usual.
                     */
                    Vector<Number> local_y(n);
                    Vector<Number> local_x(m);

                    /**
                     * Restrict vector x to the transposed matrix block.
                     */
                    for (size_type j = 0; j < m; j++)
                      {
                        local_x(j) = x((*row_index_range)[0] + j);
                      }

                    fullmatrix->Tvmult(local_y, local_x);

                    /**
                     * Merge back the result vector \p local_y to \p y.
                     */
                    for (size_type i = 0; i < n; i++)
                      {
                        y((*col_index_range)[0] + i) += alpha * local_y(i);
                      }

                    break;
                  }
                  case HMatrixSupport::Property::symmetric: {
                    /**
                     * When the top level \hmatnode is symmetric, the operation
                     * depends on the block type of the current leaf \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A leaf \hmatnode belonging to the diagonal block
                             * should also be symmetric, when the top level
                             * \hmatnode is symmetric.
                             */
                            Assert(property == HMatrixSupport::symmetric,
                                   ExcInvalidHMatrixProperty(property));
                            /**
                             * The full matrix associated with the current
                             * \hmatnode should also be symmetric.
                             */
                            Assert(fullmatrix->get_property() ==
                                     LAPACKSupport::symmetric,
                                   ExcInvalidLAPACKFullMatrixProperty(
                                     fullmatrix->get_property()));

                            /**
                             * Perform the transposed-matrix-vector
                             * multiplication. In my implementation, only those
                             * lower triangular elements in a symmetric full
                             * matrix are used by the function.
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the transposed matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) = x((*row_index_range)[0] + j);
                              }

                            fullmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we first perform the
                             * multiplication \f$M^Tx\f$ and then perform the
                             * multiplication \f$Mx\f$. This treatment considers
                             * both the contribution of the current matrix block
                             * as well as its symmetric counterpart.
                             *
                             * \alert{Not only should the full matrix itself be
                             * transposed, the roles of row indices and column
                             * indices should also be swapped.}
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the transposed matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) = x((*row_index_range)[0] + j);
                              }

                            fullmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            Vector<Number> local_y_for_vmult(m);
                            Vector<Number> local_x_for_vmult(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x_for_vmult(j) =
                                  x((*col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y_for_vmult,
                                              local_x_for_vmult);

                            /**
                             * Merge back the result vector \p local_y_for_vmult to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] + i) +=
                                  alpha * local_y_for_vmult(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, since the upper part is not
                             * saved and its contribution has already been
                             * considered when we handle the lower triangular
                             * block, we do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::Property::lower_triangular: {
                    /**
                     * When the top level \hmatnode is lower triangular, the
                     * operation depends on the block type of the current leaf
                     * \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A leaf \hmatnode belonging to the diagonal block
                             * should also be lower triangular, when the top
                             * level \hmatnode is lower triangular.
                             */
                            Assert(property ==
                                     HMatrixSupport::Property::lower_triangular,
                                   ExcInvalidHMatrixProperty(property));
                            /**
                             * The full matrix associated with the current
                             * \hmatnode should also be lower triangular.
                             */
                            Assert(fullmatrix->get_property() ==
                                     LAPACKSupport::Property::lower_triangular,
                                   ExcInvalidLAPACKFullMatrixProperty(
                                     fullmatrix->get_property()));

                            /**
                             * Perform the transposed-matrix-vector
                             * multiplication.
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the transposed matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) = x((*row_index_range)[0] + j);
                              }

                            fullmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we perform the multiplication
                             * \f$M^Tx\f$ as that for a general matrix.
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the transposed matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) = x((*row_index_range)[0] + j);
                              }

                            fullmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, since the upper part is not
                             * saved and has no contribution to the result, we
                             * do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  default: {
                    throw(ExcInvalidHMatrixProperty(top_hmat_property));

                    break;
                  }
              }

            break;
          }
          case RkMatrixType: {
            /**
             * Here we comes to the transposed matrix-vector multiplication with
             * respect to a far field leaf \hmatnode.
             */
            switch (top_hmat_property)
              {
                  case HMatrixSupport::Property::general: {
                    /**
                     * When the top level \hmatnode is general, perform the
                     * transposed matrix-vector multiplication as usual.
                     */
                    Vector<Number> local_y(n);
                    Vector<Number> local_x(m);

                    /**
                     * Restrict vector x to the current matrix block.
                     */
                    for (size_type j = 0; j < m; j++)
                      {
                        local_x(j) = x((*row_index_range)[0] + j);
                      }

                    rkmatrix->Tvmult(local_y, local_x);

                    /**
                     * Merge back the result vector \p local_y to \p y.
                     */
                    for (size_type i = 0; i < n; i++)
                      {
                        y((*col_index_range)[0] + i) += alpha * local_y(i);
                      }

                    break;
                  }
                  case HMatrixSupport::Property::symmetric: {
                    /**
                     * When the top level \hmatnode is symmetric, the operation
                     * depends on the block type of the current leaf \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * When the current \hmatnode is rank-k matrix, it
                             * can never belong to the diagonal part.
                             */
                            Assert(false,
                                   ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we first perform the
                             * multiplication \f$M^Tx\f$ and then perform the
                             * multiplication \f$Mx\f$. This treatment considers
                             * both the contribution of the current matrix block
                             * as well as its symmetric counterpart.
                             *
                             * \alert{Not only should the full matrix itself be
                             * transposed, the roles of row indices and column
                             * indices should also be swapped.}
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) = x((*row_index_range)[0] + j);
                              }

                            rkmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            Vector<Number> local_y_for_vmult(m);
                            Vector<Number> local_x_for_vmult(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x_for_vmult(j) =
                                  x((*col_index_range)[0] + j);
                              }

                            rkmatrix->vmult(local_y_for_vmult,
                                            local_x_for_vmult);

                            /**
                             * Merge back the result vector \p local_y_for_vmult to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] + i) +=
                                  alpha * local_y_for_vmult(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::Property::lower_triangular: {
                    /**
                     * When the top level \hmatnode is lower triangular, the
                     * operation depends on the block type of the current leaf
                     * \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * When the current \hmatnode is rank-k matrix, it
                             * can never belong to the diagonal part.
                             */
                            Assert(false,
                                   ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we perform the multiplication
                             * \f$M^Tx\f$.
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) = x((*row_index_range)[0] + j);
                              }

                            rkmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  default: {
                    Assert(false, ExcNotImplemented());

                    break;
                  }
              }

            break;
          }
        case UndefinedMatrixType:
          default: {
            Assert(false, ExcInvalidHMatrixType(type));
            break;
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::Tvmult(
    Vector<Number>                  &y,
    const Vector<Number>            &x,
    const HMatrix<spacedim, Number> &starting_hmat,
    const HMatrixSupport::Property   top_hmat_property) const
  {
    switch (type)
      {
          case HierarchicalMatrixType: {
            /**
             * When the current \hmatnode is hierarchical, recursively call
             * @p Tvmult of its children.
             */
            for (HMatrix *submatrix : submatrices)
              {
                submatrix->Tvmult(y, x, starting_hmat, top_hmat_property);
              }

            break;
          }
          case FullMatrixType: {
            /**
             * Here we comes to the transposed-matrix-vector multiplication with
             * respect to a near field leaf \hmatnode.
             */
            switch (top_hmat_property)
              {
                  case HMatrixSupport::Property::general: {
                    /**
                     * When the top level \hmatnode is general, perform the
                     * transposed-matrix-vector multiplication as usual.
                     */
                    Vector<Number> local_y(n);
                    Vector<Number> local_x(m);

                    /**
                     * Restrict vector x to the transposed matrix block.
                     */
                    for (size_type j = 0; j < m; j++)
                      {
                        local_x(j) = x((*row_index_range)[0] -
                                       (*starting_hmat.row_index_range)[0] + j);
                      }

                    fullmatrix->Tvmult(local_y, local_x);

                    /**
                     * Merge back the result vector \p local_y to \p y.
                     */
                    for (size_type i = 0; i < n; i++)
                      {
                        y((*col_index_range)[0] -
                          (*starting_hmat.col_index_range)[0] + i) +=
                          local_y(i);
                      }

                    break;
                  }
                  case HMatrixSupport::Property::symmetric: {
                    /**
                     * When the top level \hmatnode is symmetric, the operation
                     * depends on the block type of the current leaf \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A leaf \hmatnode belonging to the diagonal block
                             * should also be symmetric, when the top level
                             * \hmatnode is symmetric.
                             */
                            Assert(property == HMatrixSupport::symmetric,
                                   ExcInvalidHMatrixProperty(property));
                            /**
                             * The full matrix associated with the current
                             * \hmatnode should also be symmetric.
                             */
                            Assert(fullmatrix->get_property() ==
                                     LAPACKSupport::symmetric,
                                   ExcInvalidLAPACKFullMatrixProperty(
                                     fullmatrix->get_property()));

                            /**
                             * Perform the transposed-matrix-vector
                             * multiplication. In my implementation, only those
                             * lower triangular elements in a symmetric full
                             * matrix are used by the function.
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the transposed matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) =
                                  x((*row_index_range)[0] -
                                    (*starting_hmat.row_index_range)[0] + j);
                              }

                            fullmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] -
                                  (*starting_hmat.col_index_range)[0] + i) +=
                                  local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we first perform the
                             * multiplication \f$M^Tx\f$ and then perform the
                             * multiplication \f$Mx\f$. This treatment considers
                             * both the contribution of the current matrix block
                             * as well as its symmetric counterpart.
                             *
                             * \alert{Not only should the full matrix itself be
                             * transposed, the roles of row indices and column
                             * indices should also be swapped.}
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the transposed matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) =
                                  x((*row_index_range)[0] -
                                    (*starting_hmat.row_index_range)[0] + j);
                              }

                            fullmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] -
                                  (*starting_hmat.col_index_range)[0] + i) +=
                                  local_y(i);
                              }

                            Vector<Number> local_y_for_vmult(m);
                            Vector<Number> local_x_for_vmult(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x_for_vmult(j) =
                                  x((*col_index_range)[0] -
                                    (*starting_hmat.col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y_for_vmult,
                                              local_x_for_vmult);

                            /**
                             * Merge back the result vector \p local_y_for_vmult to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] -
                                  (*starting_hmat.row_index_range)[0] + i) +=
                                  local_y_for_vmult(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, since the upper part is not
                             * saved and its contribution has already been
                             * considered when we handle the lower triangular
                             * block, we do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::Property::lower_triangular: {
                    /**
                     * When the top level \hmatnode is lower triangular, the
                     * operation depends on the block type of the current leaf
                     * \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A leaf \hmatnode belonging to the diagonal block
                             * should also be lower triangular, when the top
                             * level \hmatnode is lower triangular.
                             */
                            Assert(property ==
                                     HMatrixSupport::Property::lower_triangular,
                                   ExcInvalidHMatrixProperty(property));
                            /**
                             * The full matrix associated with the current
                             * \hmatnode should also be lower triangular.
                             */
                            Assert(fullmatrix->get_property() ==
                                     LAPACKSupport::Property::lower_triangular,
                                   ExcInvalidLAPACKFullMatrixProperty(
                                     fullmatrix->get_property()));

                            /**
                             * Perform the transposed-matrix-vector
                             * multiplication.
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the transposed matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) =
                                  x((*row_index_range)[0] -
                                    (*starting_hmat.row_index_range)[0] + j);
                              }

                            fullmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] -
                                  (*starting_hmat.col_index_range)[0] + i) +=
                                  local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we perform the multiplication
                             * \f$M^Tx\f$ as that for a general matrix.
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the transposed matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) =
                                  x((*row_index_range)[0] -
                                    (*starting_hmat.row_index_range)[0] + j);
                              }

                            fullmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] -
                                  (*starting_hmat.col_index_range)[0] + i) +=
                                  local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, since the upper part is not
                             * saved and has no contribution to the result, we
                             * do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  default: {
                    throw(ExcInvalidHMatrixProperty(top_hmat_property));

                    break;
                  }
              }

            break;
          }
          case RkMatrixType: {
            /**
             * Here we comes to the transposed matrix-vector multiplication with
             * respect to a far field leaf \hmatnode.
             */
            switch (top_hmat_property)
              {
                  case HMatrixSupport::Property::general: {
                    /**
                     * When the top level \hmatnode is general, perform the
                     * transposed matrix-vector multiplication as usual.
                     */
                    Vector<Number> local_y(n);
                    Vector<Number> local_x(m);

                    /**
                     * Restrict vector x to the current matrix block.
                     */
                    for (size_type j = 0; j < m; j++)
                      {
                        local_x(j) = x((*row_index_range)[0] -
                                       (*starting_hmat.row_index_range)[0] + j);
                      }

                    rkmatrix->Tvmult(local_y, local_x);

                    /**
                     * Merge back the result vector \p local_y to \p y.
                     */
                    for (size_type i = 0; i < n; i++)
                      {
                        y((*col_index_range)[0] -
                          (*starting_hmat.col_index_range)[0] + i) +=
                          local_y(i);
                      }

                    break;
                  }
                  case HMatrixSupport::Property::symmetric: {
                    /**
                     * When the top level \hmatnode is symmetric, the operation
                     * depends on the block type of the current leaf \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * When the current \hmatnode is rank-k matrix, it
                             * can never belong to the diagonal part.
                             */
                            Assert(false,
                                   ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we first perform the
                             * multiplication \f$M^Tx\f$ and then perform the
                             * multiplication \f$Mx\f$. This treatment considers
                             * both the contribution of the current matrix block
                             * as well as its symmetric counterpart.
                             *
                             * \alert{Not only should the full matrix itself be
                             * transposed, the roles of row indices and column
                             * indices should also be swapped.}
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) =
                                  x((*row_index_range)[0] -
                                    (*starting_hmat.row_index_range)[0] + j);
                              }

                            rkmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] -
                                  (*starting_hmat.col_index_range)[0] + i) +=
                                  local_y(i);
                              }

                            Vector<Number> local_y_for_vmult(m);
                            Vector<Number> local_x_for_vmult(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x_for_vmult(j) =
                                  x((*col_index_range)[0] -
                                    (*starting_hmat.col_index_range)[0] + j);
                              }

                            rkmatrix->vmult(local_y_for_vmult,
                                            local_x_for_vmult);

                            /**
                             * Merge back the result vector \p local_y_for_vmult to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] -
                                  (*starting_hmat.row_index_range)[0] + i) +=
                                  local_y_for_vmult(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::Property::lower_triangular: {
                    /**
                     * When the top level \hmatnode is lower triangular, the
                     * operation depends on the block type of the current leaf
                     * \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * When the current \hmatnode is rank-k matrix, it
                             * can never belong to the diagonal part.
                             */
                            Assert(false,
                                   ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we perform the multiplication
                             * \f$M^Tx\f$.
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) =
                                  x((*row_index_range)[0] -
                                    (*starting_hmat.row_index_range)[0] + j);
                              }

                            rkmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] -
                                  (*starting_hmat.col_index_range)[0] + i) +=
                                  local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  default: {
                    throw(ExcInvalidHMatrixProperty(top_hmat_property));

                    break;
                  }
              }

            break;
          }
        case UndefinedMatrixType:
          default: {
            Assert(false, ExcInvalidHMatrixType(type));
            break;
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::Tvmult(
    Vector<Number>                  &y,
    const Number                     alpha,
    const Vector<Number>            &x,
    const HMatrix<spacedim, Number> &starting_hmat,
    const HMatrixSupport::Property   top_hmat_property) const
  {
    switch (type)
      {
          case HierarchicalMatrixType: {
            /**
             * When the current \hmatnode is hierarchical, recursively call
             * @p Tvmult of its children.
             */
            for (HMatrix *submatrix : submatrices)
              {
                submatrix->Tvmult(
                  y, alpha, x, starting_hmat, top_hmat_property);
              }

            break;
          }
          case FullMatrixType: {
            /**
             * Here we comes to the transposed-matrix-vector multiplication with
             * respect to a near field leaf \hmatnode.
             */
            switch (top_hmat_property)
              {
                  case HMatrixSupport::Property::general: {
                    /**
                     * When the top level \hmatnode is general, perform the
                     * transposed-matrix-vector multiplication as usual.
                     */
                    Vector<Number> local_y(n);
                    Vector<Number> local_x(m);

                    /**
                     * Restrict vector x to the transposed matrix block.
                     */
                    for (size_type j = 0; j < m; j++)
                      {
                        local_x(j) = x((*row_index_range)[0] -
                                       (*starting_hmat.row_index_range)[0] + j);
                      }

                    fullmatrix->Tvmult(local_y, local_x);

                    /**
                     * Merge back the result vector \p local_y to \p y.
                     */
                    for (size_type i = 0; i < n; i++)
                      {
                        y((*col_index_range)[0] -
                          (*starting_hmat.col_index_range)[0] + i) +=
                          alpha * local_y(i);
                      }

                    break;
                  }
                  case HMatrixSupport::Property::symmetric: {
                    /**
                     * When the top level \hmatnode is symmetric, the operation
                     * depends on the block type of the current leaf \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A leaf \hmatnode belonging to the diagonal block
                             * should also be symmetric, when the top level
                             * \hmatnode is symmetric.
                             */
                            Assert(property == HMatrixSupport::symmetric,
                                   ExcInvalidHMatrixProperty(property));
                            /**
                             * The full matrix associated with the current
                             * \hmatnode should also be symmetric.
                             */
                            Assert(fullmatrix->get_property() ==
                                     LAPACKSupport::symmetric,
                                   ExcInvalidLAPACKFullMatrixProperty(
                                     fullmatrix->get_property()));

                            /**
                             * Perform the transposed-matrix-vector
                             * multiplication. In my implementation, only those
                             * lower triangular elements in a symmetric full
                             * matrix are used by the function.
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the transposed matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) =
                                  x((*row_index_range)[0] -
                                    (*starting_hmat.row_index_range)[0] + j);
                              }

                            fullmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] -
                                  (*starting_hmat.col_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we first perform the
                             * multiplication \f$M^Tx\f$ and then perform the
                             * multiplication \f$Mx\f$. This treatment considers
                             * both the contribution of the current matrix block
                             * as well as its symmetric counterpart.
                             *
                             * \alert{Not only should the full matrix itself be
                             * transposed, the roles of row indices and column
                             * indices should also be swapped.}
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the transposed matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) =
                                  x((*row_index_range)[0] -
                                    (*starting_hmat.row_index_range)[0] + j);
                              }

                            fullmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] -
                                  (*starting_hmat.col_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            Vector<Number> local_y_for_vmult(m);
                            Vector<Number> local_x_for_vmult(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x_for_vmult(j) =
                                  x((*col_index_range)[0] -
                                    (*starting_hmat.col_index_range)[0] + j);
                              }

                            fullmatrix->vmult(local_y_for_vmult,
                                              local_x_for_vmult);

                            /**
                             * Merge back the result vector \p local_y_for_vmult to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] -
                                  (*starting_hmat.row_index_range)[0] + i) +=
                                  alpha * local_y_for_vmult(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, since the upper part is not
                             * saved and its contribution has already been
                             * considered when we handle the lower triangular
                             * block, we do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::Property::lower_triangular: {
                    /**
                     * When the top level \hmatnode is lower triangular, the
                     * operation depends on the block type of the current leaf
                     * \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * A leaf \hmatnode belonging to the diagonal block
                             * should also be lower triangular, when the top
                             * level \hmatnode is lower triangular.
                             */
                            Assert(property ==
                                     HMatrixSupport::Property::lower_triangular,
                                   ExcInvalidHMatrixProperty(property));
                            /**
                             * The full matrix associated with the current
                             * \hmatnode should also be lower triangular.
                             */
                            Assert(fullmatrix->get_property() ==
                                     LAPACKSupport::Property::lower_triangular,
                                   ExcInvalidLAPACKFullMatrixProperty(
                                     fullmatrix->get_property()));

                            /**
                             * Perform the transposed-matrix-vector
                             * multiplication.
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the transposed matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) =
                                  x((*row_index_range)[0] -
                                    (*starting_hmat.row_index_range)[0] + j);
                              }

                            fullmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] -
                                  (*starting_hmat.col_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we perform the multiplication
                             * \f$M^Tx\f$ as that for a general matrix.
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the transposed matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) =
                                  x((*row_index_range)[0] -
                                    (*starting_hmat.row_index_range)[0] + j);
                              }

                            fullmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] -
                                  (*starting_hmat.col_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, since the upper part is not
                             * saved and has no contribution to the result, we
                             * do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  default: {
                    throw(ExcInvalidHMatrixProperty(top_hmat_property));

                    break;
                  }
              }

            break;
          }
          case RkMatrixType: {
            /**
             * Here we comes to the transposed matrix-vector multiplication with
             * respect to a far field leaf \hmatnode.
             */
            switch (top_hmat_property)
              {
                  case HMatrixSupport::Property::general: {
                    /**
                     * When the top level \hmatnode is general, perform the
                     * transposed matrix-vector multiplication as usual.
                     */
                    Vector<Number> local_y(n);
                    Vector<Number> local_x(m);

                    /**
                     * Restrict vector x to the current matrix block.
                     */
                    for (size_type j = 0; j < m; j++)
                      {
                        local_x(j) = x((*row_index_range)[0] -
                                       (*starting_hmat.row_index_range)[0] + j);
                      }

                    rkmatrix->Tvmult(local_y, local_x);

                    /**
                     * Merge back the result vector \p local_y to \p y.
                     */
                    for (size_type i = 0; i < n; i++)
                      {
                        y((*col_index_range)[0] -
                          (*starting_hmat.col_index_range)[0] + i) +=
                          alpha * local_y(i);
                      }

                    break;
                  }
                  case HMatrixSupport::Property::symmetric: {
                    /**
                     * When the top level \hmatnode is symmetric, the operation
                     * depends on the block type of the current leaf \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * When the current \hmatnode is rank-k matrix, it
                             * can never belong to the diagonal part.
                             */
                            Assert(false,
                                   ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                          case HMatrixSupport::lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we first perform the
                             * multiplication \f$M^Tx\f$ and then perform the
                             * multiplication \f$Mx\f$. This treatment considers
                             * both the contribution of the current matrix block
                             * as well as its symmetric counterpart.
                             *
                             * \alert{Not only should the full matrix itself be
                             * transposed, the roles of row indices and column
                             * indices should also be swapped.}
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) =
                                  x((*row_index_range)[0] -
                                    (*starting_hmat.row_index_range)[0] + j);
                              }

                            rkmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] -
                                  (*starting_hmat.col_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            Vector<Number> local_y_for_vmult(m);
                            Vector<Number> local_x_for_vmult(n);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < n; j++)
                              {
                                local_x_for_vmult(j) =
                                  x((*col_index_range)[0] -
                                    (*starting_hmat.col_index_range)[0] + j);
                              }

                            rkmatrix->vmult(local_y_for_vmult,
                                            local_x_for_vmult);

                            /**
                             * Merge back the result vector \p local_y_for_vmult to \p y.
                             */
                            for (size_type i = 0; i < m; i++)
                              {
                                y((*row_index_range)[0] -
                                  (*starting_hmat.row_index_range)[0] + i) +=
                                  alpha * local_y_for_vmult(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  case HMatrixSupport::Property::lower_triangular: {
                    /**
                     * When the top level \hmatnode is lower triangular, the
                     * operation depends on the block type of the current leaf
                     * \hmatnode.
                     */
                    switch (block_type)
                      {
                          case HMatrixSupport::BlockType::diagonal_block: {
                            /**
                             * When the current \hmatnode is rank-k matrix, it
                             * can never belong to the diagonal part.
                             */
                            Assert(false,
                                   ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            lower_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the lower
                             * triangular part, we perform the multiplication
                             * \f$M^Tx\f$.
                             */
                            Vector<Number> local_y(n);
                            Vector<Number> local_x(m);

                            /**
                             * Restrict vector x to the current matrix block.
                             */
                            for (size_type j = 0; j < m; j++)
                              {
                                local_x(j) =
                                  x((*row_index_range)[0] -
                                    (*starting_hmat.row_index_range)[0] + j);
                              }

                            rkmatrix->Tvmult(local_y, local_x);

                            /**
                             * Merge back the result vector \p local_y to \p y.
                             */
                            for (size_type i = 0; i < n; i++)
                              {
                                y((*col_index_range)[0] -
                                  (*starting_hmat.col_index_range)[0] + i) +=
                                  alpha * local_y(i);
                              }

                            break;
                          }
                          case HMatrixSupport::BlockType::
                            upper_triangular_block: {
                            /**
                             * When the current \hmatnode belongs to the upper
                             * triangular part, do nothing.
                             */
                            break;
                          }
                          default: {
                            throw(ExcInvalidHMatrixBlockType(block_type));

                            break;
                          }
                      }

                    break;
                  }
                  default: {
                    throw(ExcInvalidHMatrixProperty(top_hmat_property));

                    break;
                  }
              }

            break;
          }
        case UndefinedMatrixType:
          default: {
            Assert(false, ExcInvalidHMatrixType(type));
            break;
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::h_h_mmult_reduction()
  {
    std::vector<
      std::pair<HMatrix<spacedim, Number> *, HMatrix<spacedim, Number> *>>
      Sigma_P_cannot_reduced;

    while (Sigma_P.size() > 0)
      {
        // Get the last element in the list.
        std::pair<HMatrix<spacedim, Number> *, HMatrix<spacedim, Number> *>
                                  &hmat_pair = Sigma_P.back();
        HMatrix<spacedim, Number> *M1        = hmat_pair.first;
        HMatrix<spacedim, Number> *M2        = hmat_pair.second;

        /**
         * When one of the operands is either full matrix or rank-k matrix,
         * perform direct multiplication.
         */
        if (M1->type == RkMatrixType)
          {
            rk_h_mmult_for_h_h_mmult(M1, M2, this);
          }
        else if (M2->type == RkMatrixType)
          {
            h_rk_mmult_for_h_h_mmult(M1, M2, this);
          }
        else if (M1->type == FullMatrixType)
          {
            f_h_mmult_for_h_h_mmult(M1, M2, this);
          }
        else if (M2->type == FullMatrixType)
          {
            h_f_mmult_for_h_h_mmult(M1, M2, this);
          }
        else if (M1->bc_node->get_split_mode() == VerticalSplitMode &&
                 M2->bc_node->get_split_mode() == HorizontalSplitMode)
          {
            // Internal splitting
            Sigma_P.pop_back();

            Assert(M1->submatrices[0], ExcInternalError());
            Assert(M2->submatrices[0], ExcInternalError());
            Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(M1->submatrices[0],
                                                     M2->submatrices[0]));

            Assert(M1->submatrices[1], ExcInternalError());
            Assert(M2->submatrices[1], ExcInternalError());
            Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(M1->submatrices[1],
                                                     M2->submatrices[1]));
          }
        else
          {
            /**
             * Migrate the current H-matrix node pair to the list \p
             * Sigma_P_cannot_reduced.
             */
            Sigma_P_cannot_reduced.push_back(hmat_pair);
            /**
             * Remove the current H-matrix node pair from the original list
             * in
             * \p M.
             */
            Sigma_P.pop_back();
          }
      }

    /**
     * Merge the elements in \p Sigma_P_cannot_reduced back to \p Sigma_P in \p M
     * for further processing.
     */
    for (std::pair<HMatrix<spacedim, Number> *, HMatrix<spacedim, Number> *>
           hmat_pair : Sigma_P_cannot_reduced)
      {
        Sigma_P.push_back(hmat_pair);
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::h_h_mmult_horizontal_split(
    BlockClusterTree<spacedim, Number> &bc_tree)
  {
    /**
     * Split the block cluster \f$b\f$ in \f$T_{\rm ind}\f$.
     */
    split_block_cluster_node(bc_node, bc_tree, HorizontalSplitMode);

    HMatrix<spacedim, Number> *child_hmat0 = new HMatrix<spacedim, Number>();
    InitHMatrixWrtBlockClusterNode(*child_hmat0, bc_node->get_child_pointer(0));
    /**
     * Append the initialized child to the list of submatrices
     * of \p M.
     */
    submatrices.push_back(child_hmat0);

    HMatrix<spacedim, Number> *child_hmat1 = new HMatrix<spacedim, Number>();
    InitHMatrixWrtBlockClusterNode(*child_hmat1, bc_node->get_child_pointer(1));
    /**
     * Append the initialized child to the list of submatrices
     * of \p hmat.
     */
    submatrices.push_back(child_hmat1);

    /**
     * Iterate over each multiplication subtask.
     */
    while (Sigma_P.size() > 0)
      {
        // Get the last element in the list.
        std::pair<HMatrix<spacedim, Number> *, HMatrix<spacedim, Number> *>
          &hmat_pair = Sigma_P.back();

        /**
         * Create \f$\mathcal{H}\f$-matrices corresponding to the
         * child block clusters after splitting.
         */
        if (hmat_pair.first->bc_node->get_split_mode() == HorizontalSplitMode &&
            hmat_pair.second->bc_node->get_split_mode() == UnsplitMode)
          {
            Assert(hmat_pair.first->submatrices[0], ExcInternalError());
            child_hmat0->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[0], hmat_pair.second));

            Assert(hmat_pair.first->submatrices[1], ExcInternalError());
            child_hmat1->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[1], hmat_pair.second));

            /**
             * Remove the current \hmatrix pair from
             * the list \p Sigma_P of the current matrix node.
             */
            Sigma_P.pop_back();
          }
        else if (hmat_pair.first->bc_node->get_split_mode() == CrossSplitMode &&
                 hmat_pair.second->bc_node->get_split_mode() ==
                   HorizontalSplitMode)
          {
            Assert(hmat_pair.first->submatrices[0], ExcInternalError());
            Assert(hmat_pair.second->submatrices[0], ExcInternalError());
            child_hmat0->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[0],
                hmat_pair.second->submatrices[0]));

            Assert(hmat_pair.first->submatrices[1], ExcInternalError());
            Assert(hmat_pair.second->submatrices[1], ExcInternalError());
            child_hmat0->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[1],
                hmat_pair.second->submatrices[1]));

            Assert(hmat_pair.first->submatrices[2], ExcInternalError());
            child_hmat1->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[2],
                hmat_pair.second->submatrices[0]));

            Assert(hmat_pair.first->submatrices[3], ExcInternalError());
            child_hmat1->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[3],
                hmat_pair.second->submatrices[1]));

            /**
             * Remove the current \hmatrix pair from
             * the list \p Sigma_P of the current matrix node.
             */
            Sigma_P.pop_back();
          }
        else
          {
            Assert(false, ExcInternalError());
          }
      }

    /**
     * Update the matrix type of the current
     * \hmatrix.
     */
    type = HierarchicalMatrixType;
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::h_h_mmult_vertical_split(
    BlockClusterTree<spacedim, Number> &bc_tree)
  {
    /**
     * Split the block cluster \f$b\f$ in \f$T_{\rm ind}\f$.
     */
    split_block_cluster_node(bc_node, bc_tree, VerticalSplitMode);

    HMatrix<spacedim, Number> *child_hmat0 = new HMatrix<spacedim, Number>();
    InitHMatrixWrtBlockClusterNode(*child_hmat0, bc_node->get_child_pointer(0));
    /**
     * Append the initialized child to the list of submatrices
     * of \p M.
     */
    submatrices.push_back(child_hmat0);

    HMatrix<spacedim, Number> *child_hmat1 = new HMatrix<spacedim, Number>();
    InitHMatrixWrtBlockClusterNode(*child_hmat1, bc_node->get_child_pointer(1));
    /**
     * Append the initialized child to the list of submatrices
     * of \p hmat.
     */
    submatrices.push_back(child_hmat1);

    /**
     * Iterate over each multiplication subtask.
     */
    while (Sigma_P.size() > 0)
      {
        // Get the last element in the list.
        std::pair<HMatrix<spacedim, Number> *, HMatrix<spacedim, Number> *>
          &hmat_pair = Sigma_P.back();

        /**
         * Create \f$\mathcal{H}\f$-matrices corresponding to the
         * child block clusters after splitting.
         */
        if (hmat_pair.first->bc_node->get_split_mode() == UnsplitMode &&
            hmat_pair.second->bc_node->get_split_mode() == VerticalSplitMode)
          {
            Assert(hmat_pair.second->submatrices[0], ExcInternalError());
            child_hmat0->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first, hmat_pair.second->submatrices[0]));

            Assert(hmat_pair.second->submatrices[1], ExcInternalError());
            child_hmat1->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first, hmat_pair.second->submatrices[1]));

            /**
             * Remove the current \hmatrix pair from
             * the list \p Sigma_P of the current matrix node.
             */
            Sigma_P.pop_back();
          }
        else if (hmat_pair.first->bc_node->get_split_mode() ==
                   VerticalSplitMode &&
                 hmat_pair.second->bc_node->get_split_mode() == CrossSplitMode)
          {
            Assert(hmat_pair.first->submatrices[0], ExcInternalError());
            Assert(hmat_pair.second->submatrices[0], ExcInternalError());
            child_hmat0->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[0],
                hmat_pair.second->submatrices[0]));

            Assert(hmat_pair.first->submatrices[1], ExcInternalError());
            Assert(hmat_pair.second->submatrices[2], ExcInternalError());
            child_hmat0->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[1],
                hmat_pair.second->submatrices[2]));

            Assert(hmat_pair.second->submatrices[1], ExcInternalError());
            child_hmat1->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[0],
                hmat_pair.second->submatrices[1]));

            Assert(hmat_pair.second->submatrices[3], ExcInternalError());
            child_hmat1->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[1],
                hmat_pair.second->submatrices[3]));

            /**
             * Remove the current \hmatrix pair from
             * the list \p Sigma_P of the current matrix node.
             */
            Sigma_P.pop_back();
          }
        else
          {
            Assert(false, ExcInternalError());
          }
      }

    /**
     * Update the matrix type of the current
     * \hmatrix.
     */
    type = HierarchicalMatrixType;
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::h_h_mmult_cross_split(
    BlockClusterTree<spacedim, Number> &bc_tree)
  {
    /**
     * Split the block cluster \f$b\f$ in \f$T_{\rm ind}\f$.
     */
    split_block_cluster_node(bc_node, bc_tree, CrossSplitMode);

    HMatrix<spacedim, Number> *child_hmat0 = new HMatrix<spacedim, Number>();
    InitHMatrixWrtBlockClusterNode(*child_hmat0, bc_node->get_child_pointer(0));
    /**
     * Append the initialized child to the list of submatrices
     * of \p M.
     */
    submatrices.push_back(child_hmat0);

    HMatrix<spacedim, Number> *child_hmat1 = new HMatrix<spacedim, Number>();
    InitHMatrixWrtBlockClusterNode(*child_hmat1, bc_node->get_child_pointer(1));
    /**
     * Append the initialized child to the list of submatrices
     * of \p hmat.
     */
    submatrices.push_back(child_hmat1);

    HMatrix<spacedim, Number> *child_hmat2 = new HMatrix<spacedim, Number>();
    InitHMatrixWrtBlockClusterNode(*child_hmat2, bc_node->get_child_pointer(2));
    /**
     * Append the initialized child to the list of submatrices
     * of \p M.
     */
    submatrices.push_back(child_hmat2);

    HMatrix<spacedim, Number> *child_hmat3 = new HMatrix<spacedim, Number>();
    InitHMatrixWrtBlockClusterNode(*child_hmat3, bc_node->get_child_pointer(3));
    /**
     * Append the initialized child to the list of submatrices
     * of \p hmat.
     */
    submatrices.push_back(child_hmat3);

    /**
     * Iterate over each multiplication subtask.
     */
    while (Sigma_P.size() > 0)
      {
        // Get the last element in the list.
        std::pair<HMatrix<spacedim, Number> *, HMatrix<spacedim, Number> *>
          &hmat_pair = Sigma_P.back();

        /**
         * Create \f$\mathcal{H}\f$-matrices corresponding to the
         * child block clusters after splitting.
         */
        if (hmat_pair.first->bc_node->get_split_mode() == CrossSplitMode &&
            hmat_pair.second->bc_node->get_split_mode() == CrossSplitMode)
          {
            /**
             * \f$\Sigma_{b_s(1)}^P := \Sigma_{b_s(1)}^P \cup
             * \{[\tilde{M}_1(1), \tilde{M}_2(1)], [\tilde{M}_1(2),
             * \tilde{M}_2(3)]\}\f$
             */
            Assert(hmat_pair.first->submatrices[0], ExcInternalError());
            Assert(hmat_pair.second->submatrices[0], ExcInternalError());
            child_hmat0->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[0],
                hmat_pair.second->submatrices[0]));

            Assert(hmat_pair.first->submatrices[1], ExcInternalError());
            Assert(hmat_pair.second->submatrices[2], ExcInternalError());
            child_hmat0->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[1],
                hmat_pair.second->submatrices[2]));

            /**
             * \f$\Sigma_{b_s(2)}^P := \Sigma_{b_s(2)}^P \cup
             * \{[\tilde{M}_1(1), \tilde{M}_2(2)], [\tilde{M}_1(2),
             * \tilde{M}_2(4)]\}\f$
             */
            Assert(hmat_pair.second->submatrices[1], ExcInternalError());
            child_hmat1->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[0],
                hmat_pair.second->submatrices[1]));

            Assert(hmat_pair.second->submatrices[3], ExcInternalError());
            child_hmat1->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[1],
                hmat_pair.second->submatrices[3]));

            /**
             * \f$\Sigma_{b_s(3)}^P := \Sigma_{b_s(3)}^P \cup
             * \{[\tilde{M}_1(3), \tilde{M}_2(1)], [\tilde{M}_1(4),
             * \tilde{M}_2(3)]\}\f$
             */
            Assert(hmat_pair.first->submatrices[2], ExcInternalError());
            child_hmat2->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[2],
                hmat_pair.second->submatrices[0]));

            Assert(hmat_pair.first->submatrices[3], ExcInternalError());
            child_hmat2->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[3],
                hmat_pair.second->submatrices[2]));

            /**
             * \f$\Sigma_{b_s(4)}^P := \Sigma_{b_s(4)}^P \cup
             * \{[\tilde{M}_1(3), \tilde{M}_2(2)], [\tilde{M}_1(4),
             * \tilde{M}_2(4)]\}\f$
             */
            child_hmat3->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[2],
                hmat_pair.second->submatrices[1]));

            child_hmat3->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[3],
                hmat_pair.second->submatrices[3]));

            /**
             * Remove the current \hmatrix pair from
             * the list \p Sigma_P of the current matrix node.
             */
            Sigma_P.pop_back();
          }
        else if (hmat_pair.first->bc_node->get_split_mode() ==
                   HorizontalSplitMode &&
                 hmat_pair.second->bc_node->get_split_mode() ==
                   VerticalSplitMode)
          {
            Assert(hmat_pair.first->submatrices[0], ExcInternalError());
            Assert(hmat_pair.second->submatrices[0], ExcInternalError());
            child_hmat0->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[0],
                hmat_pair.second->submatrices[0]));

            Assert(hmat_pair.second->submatrices[1], ExcInternalError());
            child_hmat1->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[0],
                hmat_pair.second->submatrices[1]));

            Assert(hmat_pair.first->submatrices[1], ExcInternalError());
            child_hmat2->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[1],
                hmat_pair.second->submatrices[0]));

            child_hmat3->Sigma_P.push_back(
              std::pair<HMatrix<spacedim, Number> *,
                        HMatrix<spacedim, Number> *>(
                hmat_pair.first->submatrices[1],
                hmat_pair.second->submatrices[1]));

            /**
             * Remove the current \hmatrix pair from
             * the list \p Sigma_P of the current matrix node.
             */
            Sigma_P.pop_back();
          }
        else
          {
            Assert(false, ExcInternalError());
          }
      }

    /**
     * Update the matrix type of the current
     * \hmatrix.
     */
    type = HierarchicalMatrixType;
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::mmult(
    HMatrix<spacedim, Number>                &C,
    HMatrix<spacedim, Number>                &B,
    const BlockClusterTree<spacedim, Number> &bct_a,
    const BlockClusterTree<spacedim, Number> &bct_b,
    BlockClusterTree<spacedim, Number>       &bct_c,
    const unsigned int                        fixed_rank)
  {
    /**
     * <dl class="section">
     *   <dt>Work flow</dt>
     *   <dd>
     */

    /**
     * <ul>
     * <li>Release the resource of the result matrix.
     */
    C.release();

    /**
     * <li>Initialize the induced block cluster tree \f$T_{\rm ind}\f$ for the
     * result matrix with a single root node.
     */
    C.Tind = BlockClusterTree<spacedim, Number>(
      bct_a.get_root()->get_data_reference().get_tau_node(),
      bct_b.get_root()->get_data_reference().get_sigma_node(),
      bct_c.get_n_min());

    /**
     * <li>Associate with the root node of the induced block cluster tree \f$T_{\rm ind}\f$.
     */
    std::pair<HMatrix<spacedim, Number> *, HMatrix<spacedim, Number> *>
      initial_hmat_pair(this, &B);
    InitHMatrixWrtBlockClusterNode(C, C.Tind.get_root(), initial_hmat_pair);
    /**
     * <li>Perform recursive multiplication while constructing the induced block
     * cluster tree \f$T_{\rm ind}\f$.
     */
    h_h_mmult_phase1_recursion(&C, C.Tind);

    /**
     * <li>After the construction of the induced block cluster tree \f$T_{\rm ind}\f$,
     * rebuild its leaf set as well as near field and far field sets, and
     * update the tree depth and maximum level.
     */
    C.Tind.build_leaf_set();
    C.Tind.categorize_near_and_far_field_sets();
    C.Tind.calc_depth_and_max_level();

    //  /**
    //   * DEBUG: Print the structure of the \f$T_{\rm ind}\f$ block cluster
    //   tree.
    //   */
    //  std::ofstream out1("Tind_after_phase1.dat");
    //  C.Tind.write_leaf_set(out1);
    //  out1.close();

    /**
     * <li>Build the leaf set of the result matrix.
     */
    C.build_leaf_set();

    //  // DEBUG
    //  std::cout << "=== Product matrix info before phase 2 ===" <<
    //  std::endl; C.print_matrix_info(std::cout);

    h_h_mmult_phase2(C, bct_c, fixed_rank);

    //  // DEBUG
    //  std::cout << "=== Product matrix info after phase 2 ===" <<
    //  std::endl; C.print_matrix_info(std::cout);

    //  /**
    //   * DEBUG: Print the structure of the \f$T_{\rm ind}\f$ block cluster
    //   tree.
    //   */
    //  std::ofstream out2("Tind_after_phase2.dat");
    //  C.Tind.write_leaf_set(out2);
    //  out2.close();

    /**
     *
     *   </dd>
     * </dl>
     */
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::mmult(
    HMatrix<spacedim, Number>                &C,
    HMatrix<spacedim, Number>                &B,
    const BlockClusterTree<spacedim, Number> &bct_a,
    const BlockClusterTree<spacedim, Number> &bct_b,
    BlockClusterTree<spacedim, Number>       &bct_c,
    const unsigned int                        fixed_rank,
    const bool                                adding)
  {
    if (adding)
      {
        HMatrix<spacedim, Number> C_prime;
        mmult(C_prime, B, bct_a, bct_b, bct_c, fixed_rank);
        C.add(C_prime, fixed_rank);
      }
    else
      {
        mmult(C, B, bct_a, bct_b, bct_c, fixed_rank);
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::mmult_level_conserving(
    HMatrix<spacedim, Number> &C,
    HMatrix<spacedim, Number> &B,
    const unsigned int         fixed_rank,
    const bool                 is_result_matrix_store_tril_only)
  {
    h_h_mmult_level_conserving(
      C, (*this), B, fixed_rank, is_result_matrix_store_tril_only);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::mmult_level_conserving(
    HMatrix<spacedim, Number> &C,
    const Number               alpha,
    HMatrix<spacedim, Number> &B,
    const unsigned int         fixed_rank,
    const bool                 is_result_matrix_store_tril_only)
  {
    h_h_mmult_level_conserving(
      C, alpha, (*this), B, fixed_rank, is_result_matrix_store_tril_only);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::mmult_level_conserving_for_parallel_lu(
    HMatrix<spacedim, Number> &C,
    const Number               alpha,
    HMatrix<spacedim, Number> &B,
    const unsigned int         fixed_rank,
    const bool                 is_result_matrix_store_tril_only)
  {
    h_h_mmult_level_conserving_for_parallel_lu(
      C, alpha, (*this), B, fixed_rank, is_result_matrix_store_tril_only);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::mTmult_level_conserving(
    HMatrix<spacedim, Number> &C,
    HMatrix<spacedim, Number> &B,
    const unsigned int         fixed_rank,
    const bool                 is_result_matrix_store_tril_only)
  {
    h_h_mTmult_level_conserving(
      C, (*this), B, fixed_rank, is_result_matrix_store_tril_only);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::mTmult_level_conserving(
    HMatrix<spacedim, Number> &C,
    const Number               alpha,
    HMatrix<spacedim, Number> &B,
    const unsigned int         fixed_rank,
    const bool                 is_result_matrix_store_tril_only)
  {
    h_h_mTmult_level_conserving(
      C, alpha, (*this), B, fixed_rank, is_result_matrix_store_tril_only);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::mTmult_level_conserving_for_parallel_cholesky(
    HMatrix<spacedim, Number> &C,
    const Number               alpha,
    HMatrix<spacedim, Number> &B,
    const unsigned int         fixed_rank,
    const bool                 is_result_matrix_store_tril_only)
  {
    h_h_mTmult_level_conserving_for_parallel_cholesky(
      C, alpha, (*this), B, fixed_rank, is_result_matrix_store_tril_only);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::Tmmult_level_conserving(
    HMatrix<spacedim, Number> &C,
    HMatrix<spacedim, Number> &B,
    const unsigned int         fixed_rank,
    const bool                 is_result_matrix_store_tril_only)
  {
    h_h_Tmmult_level_conserving(
      C, (*this), B, fixed_rank, is_result_matrix_store_tril_only);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::Tmmult_level_conserving(
    HMatrix<spacedim, Number> &C,
    const Number               alpha,
    HMatrix<spacedim, Number> &B,
    const unsigned int         fixed_rank,
    const bool                 is_result_matrix_store_tril_only)
  {
    h_h_Tmmult_level_conserving(
      C, alpha, (*this), B, fixed_rank, is_result_matrix_store_tril_only);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::add(HMatrix<spacedim, Number>       &C,
                                 const HMatrix<spacedim, Number> &B,
                                 const size_type fixed_rank_k) const
  {
    /**
     * <strong>Work flow</strong>
     */

    switch (type)
      {
          case HierarchicalMatrixType: {
            /**
             * Recursively add each pair of submatrices.
             */
            for (size_type i = 0; i < submatrices.size(); i++)
              {
                submatrices[i]->add(*(C.submatrices[i]),
                                    *(B.submatrices[i]),
                                    fixed_rank_k);
              }

            break;
          }
          case FullMatrixType: {
            /**
             * Perform addition of full matrices.
             */
            this->fullmatrix->add(*(C.fullmatrix), *(B.fullmatrix));

            break;
          }
          case RkMatrixType: {
            /**
             * Perform addition of rank-k matrices.
             */
            this->rkmatrix->add(*(C.rkmatrix), *(B.rkmatrix), fixed_rank_k);

            break;
          }
        case UndefinedMatrixType:
          Assert(false, ExcInvalidHMatrixType(type));
          break;
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::add(HMatrix<spacedim, Number>       &C,
                                 const Number                     b,
                                 const HMatrix<spacedim, Number> &B,
                                 const size_type fixed_rank_k) const
  {
    /**
     * <strong>Work flow</strong>
     */

    switch (type)
      {
          case HierarchicalMatrixType: {
            /**
             * Recursively add each pair of submatrices.
             */
            for (size_type i = 0; i < submatrices.size(); i++)
              {
                submatrices[i]->add(*(C.submatrices[i]),
                                    b,
                                    *(B.submatrices[i]),
                                    fixed_rank_k);
              }

            break;
          }
          case FullMatrixType: {
            /**
             * Perform addition of full matrices.
             */
            this->fullmatrix->add(*(C.fullmatrix), b, *(B.fullmatrix));

            break;
          }
          case RkMatrixType: {
            /**
             * Perform addition of rank-k matrices.
             */
            this->rkmatrix->add(*(C.rkmatrix), b, *(B.rkmatrix), fixed_rank_k);

            break;
          }
        case UndefinedMatrixType:
          Assert(false, ExcInvalidHMatrixType(type));
          break;
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::add(const HMatrix<spacedim, Number> &B,
                                 const size_type fixed_rank_k) const
  {
    /**
     * <strong>Work flow</strong>
     */

    switch (type)
      {
          case HierarchicalMatrixType: {
            /**
             * Recursively add each pair of submatrices.
             */
            for (size_type i = 0; i < submatrices.size(); i++)
              {
                submatrices[i]->add(*(B.submatrices[i]), fixed_rank_k);
              }

            break;
          }
          case FullMatrixType: {
            /**
             * Perform addition of full matrices.
             */
            this->fullmatrix->add(*(B.fullmatrix));

            break;
          }
          case RkMatrixType: {
            /**
             * Perform addition of rank-k matrices.
             */
            this->rkmatrix->add(*(B.rkmatrix), fixed_rank_k);

            break;
          }
        case UndefinedMatrixType:
          Assert(false, ExcInvalidHMatrixType(type));
          break;
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::add(const Number                     b,
                                 const HMatrix<spacedim, Number> &B,
                                 const size_type fixed_rank_k) const
  {
    /**
     * <strong>Work flow</strong>
     */

    switch (type)
      {
          case HierarchicalMatrixType: {
            /**
             * Recursively add each pair of submatrices.
             */
            for (size_type i = 0; i < submatrices.size(); i++)
              {
                submatrices[i]->add(b, *(B.submatrices[i]), fixed_rank_k);
              }

            break;
          }
          case FullMatrixType: {
            /**
             * Perform addition of full matrices.
             */
            this->fullmatrix->add(b, *(B.fullmatrix));

            break;
          }
          case RkMatrixType: {
            /**
             * Perform addition of rank-k matrices.
             */
            this->rkmatrix->add(b, *(B.rkmatrix), fixed_rank_k);

            break;
          }
        case UndefinedMatrixType:
          Assert(false, ExcInvalidHMatrixType(type));
          break;
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::add(
    const RkMatrix<Number>                       &B,
    const std::array<types::global_dof_index, 2> &B_row_index_range,
    const std::array<types::global_dof_index, 2> &B_col_index_range,
    const size_type                               fixed_rank_k,
    const bool is_result_matrix_store_tril_only) const
  {
    if (is_result_matrix_store_tril_only)
      {
        /**
         * When the result matrix is expected to be symmetric or lower
         * triangular, we perform assertions about its property and block type.
         */
        Assert(this->property == HMatrixSupport::symmetric ||
                 this->property == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(this->property));
        Assert(this->block_type == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(this->block_type));
      }

    switch (type)
      {
          case HierarchicalMatrixType: {
            /**
             * When the result matrix has children and is expected to be a
             * symmetric/lower triangular matrix, the addition operation will
             * not be carried out for the upper triangular part. Otherwise,
             * perform the recursive addition as usual. \alert{We should also
             * note that even though the current \hmatrix node is
             * symmetric/lower triangular, not all of its submatrices are
             * symmetric/lower triangular, i.e. only the first and the last
             * submatrices are symmetric/lower triangular and belong to the
             * diagonal part.}
             */
            if (is_result_matrix_store_tril_only)
              {
                for (size_type i = 0; i < submatrices.size(); i++)
                  {
                    if (submatrices[i]->block_type !=
                        HMatrixSupport::upper_triangular_block)
                      {
                        submatrices[i]->add(
                          B,
                          B_row_index_range,
                          B_col_index_range,
                          fixed_rank_k,
                          submatrices[i]->property ==
                              HMatrixSupport::symmetric ||
                            submatrices[i]->property ==
                              HMatrixSupport::lower_triangular);
                      }
                  }
              }
            else
              {
                for (size_type i = 0; i < submatrices.size(); i++)
                  {
                    submatrices[i]->add(B,
                                        B_row_index_range,
                                        B_col_index_range,
                                        fixed_rank_k,
                                        false);
                  }
              }

            break;
          }
          case FullMatrixType: {
            /**
             * Restrict the rank-k matrix to the local full matrix then
             * perform the addition with the leaf node of the \hmatrix.
             *
             * When the current \hmatnode is a full matrix, i.e. belongs to
             * the near field, it can belong to either the diagonal part or
             * off-diagonal part. When the current matrix is symmetric, it
             * must be a diagonal block. Then, the addition will be carried
             * out for the full matrix elements in the diagonal part and in
             * the lower triangular part only.
             */
            LAPACKFullMatrixExt<Number> fullmatrix_from_rk;
            B.restrictToFullMatrix(B_row_index_range,
                                   B_col_index_range,
                                   fullmatrix_from_rk,
                                   *(row_index_range),
                                   *(col_index_range));

            /**
             * \alert{2022-05-06 The explicit type cast here for
             * @p fullmatrix_from_rk is mandatory, otherwise the compiler will
             * complain about the ambiguity during looking for a matched
             * overloaded function of @p LAPACKFullMatrixExt::add.}
             */
            fullmatrix->add((const LAPACKFullMatrixExt<Number> &)
                              fullmatrix_from_rk,
                            is_result_matrix_store_tril_only);

            break;
          }
          case RkMatrixType: {
            /**
             * \mynote{When the current \hmatnode is a rank-k matrix, it
             * belongs to the far field, which itself cannot be a symmetric
             * \hmatrix and belongs to the diagonal part. Hence, in this
             * case, the flag
             * @p is_result_matrix_symm_apriori will not be checked and all
             * matrix elements will be added into the result rank-k matrix.
             * But still, we make an assertion here that the result matrix
             * should not be symmetric.}
             */
            Assert(!is_result_matrix_store_tril_only, ExcInternalError());

            /**
             * Create a local rank-k matrix by restricting from the original
             * large rank-k matrix.
             */
            RkMatrix<Number> rkmatrix_by_restriction(*(row_index_range),
                                                     *(col_index_range),
                                                     B,
                                                     B_row_index_range,
                                                     B_col_index_range);

            this->rkmatrix->add(rkmatrix_by_restriction, fixed_rank_k);

            break;
          }
        case UndefinedMatrixType:
          Assert(false, ExcInvalidHMatrixType(type));
          break;
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::add_for_parallel_lu_or_cholesky(
    const RkMatrix<Number>                       &B,
    const std::array<types::global_dof_index, 2> &B_row_index_range,
    const std::array<types::global_dof_index, 2> &B_col_index_range,
    const size_type                               fixed_rank_k,
    const bool is_result_matrix_store_tril_only)
  {
    if (is_result_matrix_store_tril_only)
      {
        /**
         * When the result matrix is expected to be symmetric or lower
         * triangular, we perform assertions about its property and block type.
         */
        Assert(this->property == HMatrixSupport::symmetric ||
                 this->property == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(this->property));
        Assert(this->block_type == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(this->block_type));
      }

    switch (type)
      {
          case HierarchicalMatrixType: {
            /**
             * When the result matrix has children and is expected to be a
             * symmetric/lower triangular matrix, the addition operation will
             * not be carried out for the upper triangular part. Otherwise,
             * perform the recursive addition as usual. \alert{We should also
             * note that even though the current \hmatrix node is
             * symmetric/lower triangular, not all of its submatrices are
             * symmetric/lower triangular, i.e. only the first and the last
             * submatrices are symmetric/lower triangular and belong to the
             * diagonal part.}
             */
            if (is_result_matrix_store_tril_only)
              {
                for (size_type i = 0; i < submatrices.size(); i++)
                  {
                    if (submatrices[i]->block_type !=
                        HMatrixSupport::upper_triangular_block)
                      {
                        /**
                         * 2024-01-13 N.B. The current submatrix @p submatrices[i]
                         * may still have its own hierarchical structure, hence,
                         * @p add_for_parallel_lu_or_cholesky should be recursively
                         * called.
                         */
                        submatrices[i]->add_for_parallel_lu_or_cholesky(
                          B,
                          B_row_index_range,
                          B_col_index_range,
                          fixed_rank_k,
                          submatrices[i]->property ==
                              HMatrixSupport::symmetric ||
                            submatrices[i]->property ==
                              HMatrixSupport::lower_triangular);
                      }
                  }
              }
            else
              {
                for (size_type i = 0; i < submatrices.size(); i++)
                  {
                    /**
                     * 2024-01-13 N.B. The current submatrix @p submatrices[i]
                     * may still have its own hierarchical structure, hence,
                     * @p add_for_parallel_lu_or_cholesky should be recursively
                     * called.
                     */
                    submatrices[i]->add_for_parallel_lu_or_cholesky(
                      B,
                      B_row_index_range,
                      B_col_index_range,
                      fixed_rank_k,
                      false);
                  }
              }

            break;
          }
          case FullMatrixType: {
            /**
             * Restrict the rank-k matrix to the local full matrix then
             * perform the addition with the leaf node of the \hmatrix.
             *
             * When the current \hmatnode is a full matrix, i.e. belongs to
             * the near field, it can belong to either the diagonal part or
             * off-diagonal part. When the current matrix is symmetric, it
             * must be a diagonal block. Then, the addition will be carried
             * out for the full matrix elements in the diagonal part and in
             * the lower triangular part only.
             */
            LAPACKFullMatrixExt<Number> fullmatrix_from_rk;
            B.restrictToFullMatrix(B_row_index_range,
                                   B_col_index_range,
                                   fullmatrix_from_rk,
                                   *(row_index_range),
                                   *(col_index_range));

            {
              /**
               * When we come to the addition into a leaf \hmatnode, the mutex
               * should be locked.
               */
              std::lock_guard<std::mutex> lg(update_lock);
              /**
               * \alert{2022-05-06 The explicit type cast here for
               * @p fullmatrix_from_rk is mandatory, otherwise the compiler will
               * complain about the ambiguity during looking for a matched
               * overloaded function of @p LAPACKFullMatrixExt::add.}
               */
              fullmatrix->add((const LAPACKFullMatrixExt<Number> &)
                                fullmatrix_from_rk,
                              is_result_matrix_store_tril_only);
            }

            break;
          }
          case RkMatrixType: {
            /**
             * \mynote{When the current \hmatnode is a rank-k matrix, it
             * belongs to the far field, which itself cannot be a symmetric
             * \hmatrix and belongs to the diagonal part. Hence, in this
             * case, the flag
             * @p is_result_matrix_symm_apriori will not be checked and all
             * matrix elements will be added into the result rank-k matrix.
             * But still, we make an assertion here that the result matrix
             * should not be symmetric.}
             */
            Assert(!is_result_matrix_store_tril_only, ExcInternalError());

            /**
             * Create a local rank-k matrix by restricting from the original
             * large rank-k matrix.
             */
            RkMatrix<Number> rkmatrix_by_restriction(*(row_index_range),
                                                     *(col_index_range),
                                                     B,
                                                     B_row_index_range,
                                                     B_col_index_range);

            {
              /**
               * When we come to the addition into a leaf \hmatnode, the mutex
               * should be locked.
               */
              std::lock_guard<std::mutex> lg(update_lock);

#if ARENA_OR_ISOLATE_IN_LU_AND_CHOL == 3
              this->rkmatrix->add(rkmatrix_by_restriction, fixed_rank_k);
#endif


#if ARENA_OR_ISOLATE_IN_LU_AND_CHOL == 1
              tbb::task_arena ta{ARENA_MAX_CONCURRENCY_IN_LU_AND_CHOL};
              ta.execute([this, &rkmatrix_by_restriction, fixed_rank_k] {
                this->rkmatrix->add(rkmatrix_by_restriction, fixed_rank_k);
              });
#endif

#if ARENA_OR_ISOLATE_IN_LU_AND_CHOL == 2
              /**
               * There will be nested parallelism from deal.ii library in the
               * following function call. Hence, it should be isolated.
               */
              tbb::this_task_arena::isolate(
                [this, &rkmatrix_by_restriction, fixed_rank_k] {
                  this->rkmatrix->add(rkmatrix_by_restriction, fixed_rank_k);
                });
#endif
            }

            break;
          }
        case UndefinedMatrixType:
          Assert(false, ExcInvalidHMatrixType(type));
          break;
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::add(
    const Number                                  b,
    const RkMatrix<Number>                       &B,
    const std::array<types::global_dof_index, 2> &B_row_index_range,
    const std::array<types::global_dof_index, 2> &B_col_index_range,
    const size_type                               fixed_rank_k,
    const bool is_result_matrix_store_tril_only) const
  {
    if (is_result_matrix_store_tril_only)
      {
        /**
         * When the result matrix is expected to be symmetric or lower
         * triangular, we perform assertions about its property and block type.
         */
        Assert(this->property == HMatrixSupport::symmetric ||
                 this->property == HMatrixSupport::lower_triangular,
               ExcInvalidHMatrixProperty(this->property));
        Assert(this->block_type == HMatrixSupport::diagonal_block,
               ExcInvalidHMatrixBlockType(this->block_type));
      }

    switch (type)
      {
          case HierarchicalMatrixType: {
            /**
             * When the result matrix has children and is expected to be a
             * symmetric matrix, the addition operation will not be carried
             * out for the upper triangular part. Otherwise, perform the
             * recursive addition as usual.
             */
            if (is_result_matrix_store_tril_only)
              {
                for (size_type i = 0; i < submatrices.size(); i++)
                  {
                    if (submatrices[i]->block_type !=
                        HMatrixSupport::upper_triangular_block)
                      {
                        submatrices[i]->add(
                          b,
                          B,
                          B_row_index_range,
                          B_col_index_range,
                          fixed_rank_k,
                          submatrices[i]->property ==
                              HMatrixSupport::symmetric ||
                            submatrices[i]->property ==
                              HMatrixSupport::lower_triangular);
                      }
                  }
              }
            else
              {
                for (size_type i = 0; i < submatrices.size(); i++)
                  {
                    submatrices[i]->add(b,
                                        B,
                                        B_row_index_range,
                                        B_col_index_range,
                                        fixed_rank_k,
                                        false);
                  }
              }

            break;
          }
          case FullMatrixType: {
            /**
             * Restrict the rank-k matrix to the local full matrix then
             * perform the addition with the leaf node of the \hmatrix.
             *
             * When the current \hmatnode is a full matrix, i.e. belongs to
             * the near field, it can belong to either the diagonal part or
             * off-diagonal part. When the current matrix is symmetric, it
             * must be a diagonal block. Then, the addition will be carried
             * out for the full matrix elements in the diagonal part and in
             * the lower triangular part only.
             */
            LAPACKFullMatrixExt<Number> fullmatrix_from_rk;
            B.restrictToFullMatrix(B_row_index_range,
                                   B_col_index_range,
                                   fullmatrix_from_rk,
                                   *(row_index_range),
                                   *(col_index_range));

            this->fullmatrix->add(b,
                                  (const LAPACKFullMatrixExt<Number> &)
                                    fullmatrix_from_rk,
                                  is_result_matrix_store_tril_only);

            break;
          }
          case RkMatrixType: {
            /**
             * \mynote{When the current \hmatnode is a rank-k matrix, it
             * belongs to the far field, which itself cannot be a symmetric
             * \hmatrix and belongs to the diagonal part. Hence, in this
             * case, the flag
             * @p is_result_matrix_symm_apriori will not be checked and all
             * matrix elements will be added into the result rank-k matrix.}
             */

            /**
             * Create a local rank-k matrix by restricting from the original
             * large rank-k matrix.
             */
            RkMatrix<Number> rkmatrix_by_restriction(*(row_index_range),
                                                     *(col_index_range),
                                                     B,
                                                     B_row_index_range,
                                                     B_col_index_range);

            this->rkmatrix->add(b, rkmatrix_by_restriction, fixed_rank_k);

            break;
          }
        case UndefinedMatrixType:
          Assert(false, ExcInvalidHMatrixType(type));
          break;
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::add(const RkMatrix<Number> &B,
                                 const size_type         fixed_rank_k,
                                 const bool is_result_matrix_store_tril_only)
  {
    AssertDimension(m, B.get_m());
    AssertDimension(n, B.get_n());

    this->add(B,
              *row_index_range,
              *col_index_range,
              fixed_rank_k,
              is_result_matrix_store_tril_only);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::add_for_parallel_lu_or_cholesky(
    const RkMatrix<Number> &B,
    const size_type         fixed_rank_k,
    const bool              is_result_matrix_store_tril_only)
  {
    AssertDimension(m, B.get_m());
    AssertDimension(n, B.get_n());

    this->add_for_parallel_lu_or_cholesky(B,
                                          *row_index_range,
                                          *col_index_range,
                                          fixed_rank_k,
                                          is_result_matrix_store_tril_only);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::add(const Number            b,
                                 const RkMatrix<Number> &B,
                                 const size_type         fixed_rank_k,
                                 const bool is_result_matrix_store_tril_only)
  {
    AssertDimension(m, B.get_m());
    AssertDimension(n, B.get_n());

    this->add(b,
              B,
              *row_index_range,
              *col_index_range,
              fixed_rank_k,
              is_result_matrix_store_tril_only);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::addsym_diag(const LAPACKFullMatrixExt<Number> &E)
  {
    if (E.m() != 0 && E.n() != 0)
      {
        /**
         * Only when the error matrix has non-zero dimension, there will be
         * actual addition to the diagonal blocks.
         */

        /**
         * Make an assertion that the current \hmatnode should be a diagonal
         * block.
         */
        Assert(block_type == HMatrixSupport::BlockType::diagonal_block,
               ExcMessage(
                 "The current H-matrix node should be a diagonal block!"));

        if (type == FullMatrixType)
          {
            /**
             * When the current \hmatnode is a leaf node, since it is a
             * diagonal block, it must be a full matrix. Then, we directly
             * add \f$EE^H\f$ into the current \hmatnode.
             */
            LAPACKFullMatrixExt<Number> EEH;
            E.mTmult(EEH, E);

            this->fullmatrix->add(EEH);
          }
        else
          {
            /**
             * Make an assertion that the current \hmatnode should have
             * submatrices.
             */
            Assert(type == HierarchicalMatrixType, ExcInvalidHMatrixType(type));

            std::array<types::global_dof_index, 2> &t1_index_range =
              *(submatrices[0]->row_index_range);
            std::array<types::global_dof_index, 2> &t2_index_range =
              *(submatrices[3]->row_index_range);

            LAPACKFullMatrixExt<Number> E1(t1_index_range[1] -
                                             t1_index_range[0],
                                           E.n());
            LAPACKFullMatrixExt<Number> E2(t2_index_range[1] -
                                             t2_index_range[0],
                                           E.n());

            /**
             * Restrict the rows of the error matrix \f$E\f$ to the cluster
             * \f$t_1\f$.
             */
            for (size_type i = 0; i < E1.m(); i++)
              {
                E1.fill_row(i,
                            t1_index_range[0] - (*this->row_index_range)[0] + i,
                            E,
                            std::sqrt(2.0));
              }

            /**
             * Restrict the rows of the error matrix \f$E\f$ to the cluster
             * \f$t_2\f$.
             */
            for (size_type i = 0; i < E2.m(); i++)
              {
                E2.fill_row(i,
                            t2_index_range[0] - (*this->row_index_range)[0] + i,
                            E,
                            std::sqrt(2.0));
              }

            submatrices[0]->addsym_diag(E1);
            submatrices[3]->addsym_diag(E2);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::add(HMatrix<spacedim, Number> &C,
                                 const RkMatrix<Number>    &B,
                                 const size_type            fixed_rank_k)
  {
    C = (*this);
    C.add(B, fixed_rank_k);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::add(HMatrix<spacedim, Number> &C,
                                 const Number               b,
                                 const RkMatrix<Number>    &B,
                                 const size_type            fixed_rank_k)
  {
    C = (*this);
    C.add(b, B, fixed_rank_k);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::invert_by_gauss_elim(
    HMatrix<spacedim, Number> &M_inv,
    const size_type            fixed_rank_k)
  {
    _invert_by_gauss_elim(M_inv, fixed_rank_k);

    /**
     * Rebuild the leaf set of the current \hmatrix and its inverse.
     */
    build_leaf_set();
    link_hmat_nodes_on_same_levels();

    M_inv.build_leaf_set();
    M_inv.link_hmat_nodes_on_same_levels();
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_by_forward_substitution(
    Vector<Number> &b,
    const bool      is_unit_diagonal) const
  {
    /**
     * The current \hmatnode should be square.
     */
    AssertDimension(m, n);

    if (type != HierarchicalMatrixType)
      {
        /**
         * When the current \hmatnode belongs to the leaf set, it must be a
         * full matrix and can be directly solved via forward substitution.
         */
        Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));
        Assert(fullmatrix != nullptr, ExcInternalError());

        Vector<Number> local_b(n);

        /**
         * Restrict vector \p b to the column cluster of the current \hmatnode.
         */
        for (size_type j = 0; j < n; j++)
          {
            local_b(j) = b((*col_index_range)[0] + j);
          }

        /**
         * Perform forward substitution for the full matrix. N.B. The right
         * hand side vector should be permuted if the current lower
         * triangular matrix is obtained from the row pivoted LU
         * factorization.
         */
        fullmatrix->solve_by_forward_substitution(
          local_b,
          false, // Is transposed
          is_unit_diagonal,
          true // Is the RHS vector permuted, which should be true when the
               // matrix has been applied LU factorization.
        );

        /**
         * Copy back the restricted vector \p local_b to the original vector \p b.
         */
        for (size_type i = 0; i < m; i++)
          {
            b((*row_index_range)[0] + i) = local_b(i);
          }
      }
    else
      {
        const unsigned int n_row_blocks = get_n_row_blocks();
        const unsigned int n_col_blocks = get_n_col_blocks();

        AssertDimension(n_row_blocks, n_col_blocks);

        /**
         * Iterate over each block row of the matrix.
         */
        for (size_type i = 0; i < n_row_blocks; i++)
          {
            /**
             * Iterate each block column before the i'th column, i.e. before
             * the diagonal submatrix block.
             */
            for (size_type j = 0; j < i; j++)
              {
                submatrices[i * n_col_blocks + j]->vmult(b, -1.0, b);
              }

            /**
             * Solve the current diagonal block using forward substitution
             * recursively.
             */
            submatrices[i * n_col_blocks + i]->solve_by_forward_substitution(
              b, is_unit_diagonal);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_by_forward_substitution(
    Vector<Number>       &x,
    const Vector<Number> &b,
    const bool            is_unit_diagonal) const
  {
    x = b;
    solve_by_forward_substitution(x, is_unit_diagonal);
  }



  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_by_forward_substitution(
    Vector<Number>                  &b,
    const HMatrix<spacedim, Number> &starting_hmat,
    const bool                       is_unit_diagonal) const
  {
    /**
     * The current \hmatnode should be square.
     */
    AssertDimension(m, n);

    if (type != HierarchicalMatrixType)
      {
        /**
         * When the current \hmatnode belongs to the leaf set, it must be a
         * full matrix and can be directly solved via forward substitution.
         */
        Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));
        Assert(fullmatrix != nullptr, ExcInternalError());

        Vector<Number> local_b(n);

        /**
         * Restrict vector \p b to the column cluster of the current \hmatnode.
         */
        for (size_type j = 0; j < n; j++)
          {
            local_b(j) = b((*col_index_range)[0] -
                           (*starting_hmat.col_index_range)[0] + j);
          }

        /**
         * Perform forward substitution for the full matrix. N.B. The right
         * hand side vector should be permuted if the current lower
         * triangular matrix is obtained from the row pivoted LU
         * factorization.
         */
        fullmatrix->solve_by_forward_substitution(
          local_b,
          false, // Is transposed
          is_unit_diagonal,
          true // Is the RHS vector permuted, which should be true when the
               // matrix has been applied LU factorization.
        );

        /**
         * Copy back the restricted vector \p local_b to the original vector \p b.
         */
        for (size_type i = 0; i < m; i++)
          {
            b((*row_index_range)[0] - (*starting_hmat.row_index_range)[0] + i) =
              local_b(i);
          }
      }
    else
      {
        /**
         * Iterate over each block row of the matrix.
         */
        const unsigned int n_row_blocks = get_n_row_blocks();
        const unsigned int n_col_blocks = get_n_col_blocks();

        AssertDimension(n_row_blocks, n_col_blocks);

        for (size_type i = 0; i < n_row_blocks; i++)
          {
            /**
             * Iterate each block column before the i'th column, i.e. before
             * the diagonal submatrix block.
             */
            for (size_type j = 0; j < i; j++)
              {
                submatrices[i * n_col_blocks + j]->vmult(b,
                                                         -1.0,
                                                         b,
                                                         starting_hmat);
              }

            /**
             * Solve the current diagonal block using forward substitution
             * recursively.
             */
            submatrices[i * n_col_blocks + i]->solve_by_forward_substitution(
              b, starting_hmat, is_unit_diagonal);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_by_forward_substitution(
    Vector<Number>                  &x,
    const Vector<Number>            &b,
    const HMatrix<spacedim, Number> &starting_hmat,
    const bool                       is_unit_diagonal) const
  {
    x = b;
    solve_by_forward_substitution(x, starting_hmat, is_unit_diagonal);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_by_forward_substitution_matrix_valued(
    HMatrix<spacedim, Number> &X,
    HMatrix<spacedim, Number> &Z,
    const unsigned int         fixed_rank,
    const bool                 is_unit_diagonal) const
  {
    AssertDimension(Z.m, X.m);
    AssertDimension(Z.n, X.n);
    Assert(
      Z.type == X.type,
      ExcMessage(
        "Matrix Z and X should be built on a same block cluster and thus they should have a same H-matrix type!"));
    AssertDimension(this->m, this->n);
    AssertDimension(this->n, X.m);

    if (Z.type == FullMatrixType)
      {
        /**
         * When the current \hmatnode of \p X or \p Z is a full matrix, we need to
         * solve a multiple RHS vector problem.
         */
        Vector<Number> X_col(X.m);
        Vector<Number> Z_col(Z.m);

        /**
         * Iterate over each column of \p X and \p Z.
         */
        for (size_type j = 0; j < Z.n; j++)
          {
            Z.fullmatrix->get_column(j, Z_col);

            /**
             * Solve the current lower triangular \hmatrix
             * \f$L\vert_{\tau,\tau}X\vert_{\tau,j}=Z\vert_{\tau,j}\f$ using
             * the forward substitution for \hmatrices.
             */
            this->solve_by_forward_substitution(X_col,
                                                Z_col,
                                                (*this),
                                                is_unit_diagonal);

            /**
             * Merge back the solution vector \p X_col into \p X, while the matrix
             * \p Z is intact.
             */
            X.fullmatrix->fill_col(j, X_col);
          }
      }
    else if (Z.type == RkMatrixType)
      {
        /**
         * When the current \hmatnode of \p X or \p Z is a rank-k matrix, we
         * iterate over each column of its component matrix \p A and solve a
         * multiple RHS problem. The resulted solution matrix \p A' is just the
         * component matrix \p A of the rank-k matrix \p X.
         *
         * Copy the data of the rank-k matrix \p Z to the rank-k matrix \p X. The
         * component matrix \p B of \p X will be intact, while the component
         * matrix \p A of X will be solved by using the forward substitution for \hmatrices.
         *
         * This can be further elucidated as: because
         * \f$L\vert_{\tau\times\tau}X\vert_{\tau\times\sigma} =
         * Z\vert_{\tau\times\sigma}\f$, where \f$Z\vert_{\tau\times\sigma}
         * = AB^T\f$. Since \f$X\f$ is also a rank-k matrix, let
         * \f$X=A'B^T\f$. Hence, the component matrix \f$A'\f$ of \f$X\f$
         * can be solved as \f$L\vert_{\tau\times\tau}A'=A\f$.
         */
        (*X.rkmatrix) = (*Z.rkmatrix);

        Vector<Number> A_prime_col(X.m);
        for (size_type j = 0; j < Z.rkmatrix->get_formal_rank(); j++)
          {
            Z.rkmatrix->get_A().get_column(j, A_prime_col);

            this->solve_by_forward_substitution(A_prime_col,
                                                (*this),
                                                is_unit_diagonal);

            /**
             * Merge back the column vector of \p A' into \p A'.
             */
            X.rkmatrix->get_A().fill_col(j, A_prime_col);
          }
      }
    else
      {
        /**
         * When the current \hmatnode of \p X or \p Z does not belong to the leaf
         * set, perform a recursive forward substitution based on the
         * submatrix structure of the current \hmatrix \f$L\f$.
         */

        /**
         * The number of row blocks and column blocks of
         * \f$L\vert_{\tau\times\tau}\f$ should be the same.
         */
        AssertDimension(this->get_n_row_blocks(),
                        this->bc_node->get_data_reference()
                          .get_sigma_node()
                          ->get_child_num());

        /**
         * Number of row blocks of \f$X\vert_{\tau\times\sigma}\f$ or
         * \f$Z\vert_{\tau\times\sigma}\f$, which should be the same as the
         * number of row or column blocks of \f$L\vert_{\tau\times\tau}\f$.
         */
        const unsigned int n_row_blocks = X.get_n_row_blocks();
        AssertDimension(this->get_n_row_blocks(), n_row_blocks);
        /**
         * Number of column blocks of \f$X\vert_{\tau\times\sigma}\f$ or
         * \f$Z\vert_{\tau\times\sigma}\f$.
         */
        const unsigned int n_col_blocks = X.get_n_col_blocks();

        /**
         * \mynote{N.B. \p n_row_blocks does not have to be equal to \p n_col_blocks,
         * since \p X or \p Z may be rectangular.}
         */
        AssertDimension(n_row_blocks, Z.get_n_row_blocks());
        AssertDimension(n_col_blocks, Z.get_n_col_blocks());

        /**
         * Iterate over each block row of \f$L\vert_{\tau\times\tau}\f$.
         */
        for (size_type i = 0; i < n_row_blocks; i++)
          {
            /**
             * Iterate over each child cluster node of the cluster
             * \f$\sigma\f$, i.e. each block column of
             * \f$X\vert_{\tau\times\sigma}\f$ or
             * \f$Z\vert_{\tau\times\sigma}\f$.
             */
            for (size_type j = 0; j < n_col_blocks; j++)
              {
                /**
                 * Iterate over each block column before the i'th column in
                 * \f$L\vert_{\tau\times\tau}\f$.
                 */
                for (size_type k = 0; k < i; k++)
                  {
                    this->submatrices[i * n_row_blocks + k]
                      ->mmult_level_conserving(
                        *(Z.submatrices[i * n_col_blocks + j]),
                        -1.0,
                        *(X.submatrices[k * n_col_blocks + j]),
                        fixed_rank);
                  }

                /**
                 * Go down one level of recursion and solve the current
                 * diagonal block matrix \f$L\vert_{\tau_i\times\tau_i}\f$.
                 */
                this->submatrices[i * n_row_blocks + i]
                  ->solve_by_forward_substitution_matrix_valued(
                    *(X.submatrices[i * n_col_blocks + j]),
                    *(Z.submatrices[i * n_col_blocks + j]),
                    fixed_rank,
                    is_unit_diagonal);
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_by_forward_substitution_matrix_valued(
    HMatrix<spacedim, Number> &Z,
    const unsigned int         fixed_rank,
    const bool                 is_unit_diagonal) const
  {
    AssertDimension(this->m, this->n);
    AssertDimension(this->n, Z.m);

    if (Z.type == FullMatrixType)
      {
        /**
         * When the current \hmatnode of \p Z is a full matrix, we need to
         * solve a multiple RHS vector problem.
         */
        Vector<Number> Z_col(Z.m);

        /**
         * Iterate over each column of \p Z.
         */
        for (size_type j = 0; j < Z.n; j++)
          {
            Z.fullmatrix->get_column(j, Z_col);

            /**
             * Solve the current lower triangular \hmatrix
             * \f$L\vert_{\tau,\tau}X\vert_{\tau,j}=Z\vert_{\tau,j}\f$ using
             * the forward substitution for \hmatrices.
             */
            this->solve_by_forward_substitution(Z_col,
                                                (*this),
                                                is_unit_diagonal);

            /**
             * Merge back the solution vector \p Z_col into \p Z.
             */
            Z.fullmatrix->fill_col(j, Z_col);
          }
      }
    else if (Z.type == RkMatrixType)
      {
        /**
         * When the current \hmatnode of \p X or \p Z is a rank-k matrix, we
         * iterate over each column of its component matrix \p A and solve a
         * multiple RHS problem. The resulted solution matrix \p A' is just the
         * component matrix \p A of the rank-k matrix \p X.
         *
         * Copy the data of the rank-k matrix \p Z to the rank-k matrix \p X. The
         * component matrix \p B of \p X will be intact, while the component
         * matrix \p A of X will be solved by using the forward substitution for \hmatrices.
         *
         * This can be further elucidated as: because
         * \f$L\vert_{\tau\times\tau}X\vert_{\tau\times\sigma} =
         * Z\vert_{\tau\times\sigma}\f$, where \f$Z\vert_{\tau\times\sigma}
         * = AB^T\f$. Since \f$X\f$ is also a rank-k matrix, let
         * \f$X=A'B^T\f$. Hence, the component matrix \f$A'\f$ of \f$X\f$
         * can be solved as \f$L\vert_{\tau\times\tau}A'=A\f$.
         */
        Vector<Number> A_prime_col(Z.m);
        for (size_type j = 0; j < Z.rkmatrix->get_formal_rank(); j++)
          {
            Z.rkmatrix->get_A().get_column(j, A_prime_col);

            this->solve_by_forward_substitution(A_prime_col,
                                                (*this),
                                                is_unit_diagonal);

            /**
             * Merge back the column vector of \p A' into \p A'.
             */
            Z.rkmatrix->get_A().fill_col(j, A_prime_col);
          }
      }
    else
      {
        /**
         * When the current \hmatnode of \p X or \p Z does not belong to the leaf
         * set, perform a recursive forward substitution based on the
         * submatrix structure of the current \hmatrix \f$L\f$.
         */

        /**
         * The number of row blocks and column blocks of
         * \f$L\vert_{\tau\times\tau}\f$ should be the same.
         */
        AssertDimension(this->get_n_row_blocks(),
                        this->bc_node->get_data_reference()
                          .get_sigma_node()
                          ->get_child_num());

        /**
         * Number of row blocks of \f$X\vert_{\tau\times\sigma}\f$ or
         * \f$Z\vert_{\tau\times\sigma}\f$, which should be the same as the
         * number of row or column blocks of \f$L\vert_{\tau\times\tau}\f$.
         */
        const unsigned int n_row_blocks = Z.get_n_row_blocks();
        AssertDimension(this->get_n_row_blocks(), n_row_blocks);
        /**
         * Number of column blocks of \f$X\vert_{\tau\times\sigma}\f$ or
         * \f$Z\vert_{\tau\times\sigma}\f$.
         */
        const unsigned int n_col_blocks = Z.get_n_col_blocks();

        /**
         * Iterate over each block row of \f$L\vert_{\tau\times\tau}\f$.
         */
        for (size_type i = 0; i < n_row_blocks; i++)
          {
            /**
             * Iterate over each child cluster node of the cluster
             * \f$\sigma\f$, i.e. each block column of
             * \f$X\vert_{\tau\times\sigma}\f$ or
             * \f$Z\vert_{\tau\times\sigma}\f$.
             */
            for (size_type j = 0; j < n_col_blocks; j++)
              {
                /**
                 * Iterate over each block column before the i'th column in
                 * \f$L\vert_{\tau\times\tau}\f$.
                 */
                for (size_type k = 0; k < i; k++)
                  {
                    this->submatrices[i * n_row_blocks + k]
                      ->mmult_level_conserving(
                        *(Z.submatrices[i * n_col_blocks + j]),
                        -1.0,
                        *(Z.submatrices[k * n_col_blocks + j]),
                        fixed_rank);
                  }

                /**
                 * Go down one level of recursion and solve the current
                 * diagonal block matrix \f$L\vert_{\tau_i\times\tau_i}\f$.
                 */
                this->submatrices[i * n_row_blocks + i]
                  ->solve_by_forward_substitution_matrix_valued(
                    *(Z.submatrices[i * n_col_blocks + j]),
                    fixed_rank,
                    is_unit_diagonal);
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::
    solve_cholesky_by_forward_substitution_matrix_valued(
      HMatrix<spacedim, Number> &X,
      HMatrix<spacedim, Number> &Z,
      const unsigned int         fixed_rank) const
  {
    solve_by_forward_substitution_matrix_valued(X, Z, fixed_rank, false);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::
    solve_cholesky_by_forward_substitution_matrix_valued(
      HMatrix<spacedim, Number> &Z,
      const unsigned int         fixed_rank) const
  {
    solve_by_forward_substitution_matrix_valued(Z, fixed_rank, false);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_transpose_by_forward_substitution(
    Vector<Number> &b) const
  {
    /**
     * The current \hmatnode should be square.
     */
    AssertDimension(m, n);

    if (type != HierarchicalMatrixType)
      {
        /**
         * When the current \hmatnode belongs to the leaf set, it must be a
         * full matrix, whose transpose can be directly solved via forward
         * substitution.
         */
        Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));
        Assert(fullmatrix != nullptr, ExcInternalError());

        Vector<Number> local_b(m);

        /**
         * Restrict vector \p b to the row cluster of the current \hmatnode.
         */
        for (size_type i = 0; i < m; i++)
          {
            local_b(i) = b((*row_index_range)[0] + i);
          }

        /**
         * Perform forward substitution for the transpose of the full
         * matrix. N.B. The right hand side vector will not be permuted.
         */
        fullmatrix->solve_by_forward_substitution(local_b, true, false, false);

        /**
         * Copy back the restricted vector \p local_b to the original vector \p b.
         */
        for (size_type j = 0; j < n; j++)
          {
            b((*col_index_range)[0] + j) = local_b(j);
          }
      }
    else
      {
        const unsigned int n_col_blocks = get_n_col_blocks();

        AssertDimension(get_n_row_blocks(), n_col_blocks);

        /**
         * Iterate over each block column of the matrix, which is equivalent to
         * block row of its transpose.
         */
        for (size_type j = 0; j < n_col_blocks; j++)
          {
            /**
             * Iterate each block row before the j'th row, i.e. before the
             * diagonal submatrix block.
             */
            for (size_type i = 0; i < j; i++)
              {
                submatrices[i * n_col_blocks + j]->Tvmult(b, -1.0, b);
              }

            /**
             * Solve the current diagonal block using forward substitution
             * recursively.
             */
            submatrices[j * n_col_blocks + j]
              ->solve_transpose_by_forward_substitution(b);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_transpose_by_forward_substitution(
    Vector<Number>       &x,
    const Vector<Number> &b) const
  {
    x = b;
    solve_transpose_by_forward_substitution(x);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_transpose_by_forward_substitution(
    Vector<Number>                  &b,
    const HMatrix<spacedim, Number> &starting_hmat) const
  {
    /**
     * The current \hmatnode should be square.
     */
    AssertDimension(m, n);

    if (type != HierarchicalMatrixType)
      {
        /**
         * When the current \hmatnode belongs to the leaf set, it must be a
         * full matrix, whose transpose can be directly solved via forward
         * substitution.
         */
        Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));
        Assert(fullmatrix != nullptr, ExcInternalError());

        Vector<Number> local_b(m);

        /**
         * Restrict vector \p b to the row cluster of the current \hmatnode.
         */
        for (size_type i = 0; i < m; i++)
          {
            local_b(i) = b((*row_index_range)[0] -
                           (*starting_hmat.row_index_range)[0] + i);
          }

        /**
         * Perform forward substitution for the transpose of the full
         * matrix. N.B. The right hand side vector will not be permuted.
         */
        fullmatrix->solve_by_forward_substitution(local_b, true, false, false);

        /**
         * Copy back the restricted vector \p local_b to the original vector \p b.
         */
        for (size_type j = 0; j < n; j++)
          {
            b((*col_index_range)[0] - (*starting_hmat.col_index_range)[0] + j) =
              local_b(j);
          }
      }
    else
      {
        const unsigned int n_col_blocks = get_n_col_blocks();

        AssertDimension(get_n_row_blocks(), n_col_blocks);

        /**
         * Iterate over each block column of the matrix, which is equivalent to
         * block row of its transpose.
         */
        for (size_type j = 0; j < n_col_blocks; j++)
          {
            /**
             * Iterate each block row before the j'th row, i.e. before the
             * diagonal submatrix block.
             */
            for (size_type i = 0; i < j; i++)
              {
                submatrices[i * n_col_blocks + j]->Tvmult(b,
                                                          -1.0,
                                                          b,
                                                          starting_hmat);
              }

            /**
             * Solve the current diagonal block using forward substitution
             * recursively.
             */
            submatrices[j * n_col_blocks + j]
              ->solve_transpose_by_forward_substitution(b, starting_hmat);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_transpose_by_forward_substitution(
    Vector<Number>                  &x,
    const Vector<Number>            &b,
    const HMatrix<spacedim, Number> &starting_hmat) const
  {
    x = b;
    solve_transpose_by_forward_substitution(x, starting_hmat);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::
    solve_transpose_by_forward_substitution_matrix_valued(
      HMatrix<spacedim, Number> &X,
      HMatrix<spacedim, Number> &Z,
      const unsigned int         fixed_rank) const
  {
    AssertDimension(Z.m, X.m);
    AssertDimension(Z.n, X.n);
    Assert(
      Z.type == X.type,
      ExcMessage(
        "Matrix Z and X should be built on a same block cluster and thus have a same H-matrix type!"));
    AssertDimension(this->m, this->n);
    AssertDimension(X.n, this->m);

    if (Z.type == FullMatrixType)
      {
        /**
         * When the current \hmatnode of \p X or \p Z is a full matrix, we need to
         * solve a multiple RHS problem.
         */
        Vector<Number> X_row(X.n);
        Vector<Number> Z_row(Z.n);

        /**
         * Iterate over each row of \p X and \p Z.
         */
        for (size_type i = 0; i < Z.m; i++)
          {
            Z.fullmatrix->get_row(i, Z_row);

            /**
             * Solve the problem
             * \f$X\vert_{i,\sigma}U\vert_{\sigma\times\sigma} =
             * Z\vert_{i,\sigma}\f$ using the transposed forward
             * substitution for \hmatrices.
             */
            this->solve_transpose_by_forward_substitution(X_row,
                                                          Z_row,
                                                          (*this));

            /**
             * Merge back the solution vector \p X_row into \p X, while the matrix
             * \p Z is intact.
             */
            X.fullmatrix->fill_row(i, X_row);
          }
      }
    else if (Z.type == RkMatrixType)
      {
        (*X.rkmatrix) = (*Z.rkmatrix);

        // Let \f$Z\vert_{\tau\times\sigma} = A\cdot B^T\f$ and
        // \f$X\vert_{\tau\times\sigma}=A\cdot B'^T\f$, solve the problem \f$U^T
        // B' = B\f$.
        Vector<Number> B_prime_col(X.n);
        for (size_type j = 0; j < Z.rkmatrix->get_formal_rank(); j++)
          {
            // Get the current RHS vector directly into the solution vector.
            Z.rkmatrix->get_B().get_column(j, B_prime_col);

            /**
             * Solve the problem using the transposed forward substitution
             * for \hmatrices.
             */
            this->solve_transpose_by_forward_substitution(B_prime_col, (*this));

            /**
             * Merge back the column vector of \p B' into the component matrix \f$B'\f$
             * that is contained in the rank-k matrix
             * \f$X\vert_{\tau\times\sigma}\f$.
             */
            X.rkmatrix->get_B().fill_col(j, B_prime_col);
          }
      }
    else
      {
        /**
         * When the current \hmatnode of \p X or \p Z does not belong to the leaf
         * set, perform a recursive forward substitution on the transposed
         * matrix \f$U^T\f$, which is based on the submatrix structure of the
         * current \hmatrix \f$U\f$.
         */

        /**
         * The number of row blocks and column blocks of
         * \f$L\vert_{\tau\times\tau}\f$ should be the same.
         */
        AssertDimension(this->get_n_row_blocks(),
                        this->bc_node->get_data_reference()
                          .get_sigma_node()
                          ->get_child_num());

        /**
         * Number of row blocks of \f$X\vert_{\tau\times\sigma}\f$ or
         * \f$Z\vert_{\tau\times\sigma}\f$.
         */
        const unsigned int n_row_blocks = X.get_n_row_blocks();
        /**
         * Number of column blocks of \f$X\vert_{\tau\times\sigma}\f$ or
         * \f$Z\vert_{\tau\times\sigma}\f$, which should be the same as the
         * number of row or column blocks of
         * \f$U\vert_{\sigma\times\sigma}\f$.
         */
        const unsigned int n_col_blocks = X.get_n_col_blocks();
        AssertDimension(this->get_n_row_blocks(), n_col_blocks);

        /**
         * \mynote{N.B. The number of row and column blocks in \f$X\f$ and
         * \f$Z\f$ should be consistent respectively. But \p n_row_blocks does
         * not have to be equal to \p n_col_blocks, since \p X or \p Z may be
         * rectangular.}
         */
        AssertDimension(n_row_blocks, Z.get_n_row_blocks());
        AssertDimension(n_col_blocks, Z.get_n_col_blocks());

        /**
         * Iterate over each block column of \f$U\vert_{\sigma\times\sigma}\f$,
         * which is equivalent to over each row column of its transpose.
         */
        for (size_type j = 0; j < n_col_blocks; j++)
          {
            /**
             * Iterate over each child cluster node of the cluster \f$\tau\f$,
             * i.e. each block row of \f$X\vert_{\tau\times\sigma}\f$ or
             * \f$Z\vert_{\tau\times\sigma}\f$, which is equivalent to iterating
             * over each block column of their transposed matrices.
             */
            for (size_type i = 0; i < n_row_blocks; i++)
              {
                /**
                 * Iterate over each block row before the j'th row in
                 * \f$U\vert_{\sigma\times\sigma}\f$, which is equivalent to
                 * over each block column before the j'th column in its
                 * transpose.
                 */
                for (size_type k = 0; k < j; k++)
                  {
                    X.submatrices[i * n_col_blocks + k]->mmult_level_conserving(
                      *(Z.submatrices[i * n_col_blocks + j]),
                      -1.0,
                      *(this->submatrices[k * n_col_blocks + j]),
                      fixed_rank);
                  }

                /**
                 * Go down one level of recursion and solve the current diagonal
                 * block matrix \f$U\vert_{\sigma_j\times\sigma_j}\f$.
                 */
                this->submatrices[j * n_col_blocks + j]
                  ->solve_transpose_by_forward_substitution_matrix_valued(
                    *(X.submatrices[i * n_col_blocks + j]),
                    *(Z.submatrices[i * n_col_blocks + j]),
                    fixed_rank);
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::
    solve_transpose_by_forward_substitution_matrix_valued(
      HMatrix<spacedim, Number> &Z,
      const unsigned int         fixed_rank) const
  {
    AssertDimension(this->m, this->n);
    AssertDimension(Z.n, this->m);

    if (Z.type == FullMatrixType)
      {
        /**
         * When the current \hmatnode of \p Z is a full matrix, we need to
         * solve a multiple RHS problem.
         */
        Vector<Number> Z_row(Z.n);

        /**
         * Iterate over each row of \p Z.
         */
        for (size_type i = 0; i < Z.m; i++)
          {
            Z.fullmatrix->get_row(i, Z_row);

            /**
             * Solve the problem
             * \f$X\vert_{i,\sigma}U\vert_{\sigma\times\sigma} =
             * Z\vert_{i,\sigma}\f$ using the transposed forward
             * substitution for \hmatrices.
             */
            this->solve_transpose_by_forward_substitution(Z_row, (*this));

            /**
             * Merge back the solution vector \p Z_row into \p Z.
             */
            Z.fullmatrix->fill_row(i, Z_row);
          }
      }
    else if (Z.type == RkMatrixType)
      {
        // Let \f$Z\vert_{\tau\times\sigma} = A\cdot B^T\f$ and
        // \f$X\vert_{\tau\times\sigma}=A\cdot B'^T\f$, solve the problem \f$U^T
        // B' = B\f$.
        Vector<Number> B_col(Z.n);
        for (size_type j = 0; j < Z.rkmatrix->get_formal_rank(); j++)
          {
            // Get the current RHS vector directly into the solution vector.
            Z.rkmatrix->get_B().get_column(j, B_col);

            /**
             * Solve the problem using the transposed forward substitution
             * for \hmatrices.
             */
            this->solve_transpose_by_forward_substitution(B_col, (*this));

            /**
             * Merge back the column vector into the component matrix \f$B\f$.
             */
            Z.rkmatrix->get_B().fill_col(j, B_col);
          }
      }
    else
      {
        /**
         * When the current \hmatnode of \p Z does not belong to the leaf
         * set, perform a recursive forward substitution on the transposed
         * matrix \f$U^T\f$, which is based on the submatrix structure of the
         * current \hmatrix \f$U\f$.
         */

        /**
         * The number of row blocks and column blocks of
         * \f$L\vert_{\tau\times\tau}\f$ should be the same.
         */
        AssertDimension(this->get_n_row_blocks(),
                        this->bc_node->get_data_reference()
                          .get_sigma_node()
                          ->get_child_num());

        /**
         * Number of row blocks of \f$Z\vert_{\tau\times\sigma}\f$.
         */
        const unsigned int n_row_blocks = Z.get_n_row_blocks();
        /**
         * Number of column blocks of \f$Z\vert_{\tau\times\sigma}\f$, which
         * should be the same as the number of row or column blocks of
         * \f$U\vert_{\sigma\times\sigma}\f$.
         */
        const unsigned int n_col_blocks = Z.get_n_col_blocks();
        AssertDimension(this->get_n_row_blocks(), n_col_blocks);

        /**
         * Iterate over each block column of \f$U\vert_{\sigma\times\sigma}\f$,
         * which is equivalent to over each row column of its transpose.
         */
        for (size_type j = 0; j < n_col_blocks; j++)
          {
            /**
             * Iterate over each child cluster node of the cluster \f$\tau\f$,
             * i.e. each block row of \f$Z\vert_{\tau\times\sigma}\f$, which is
             * equivalent to iterating over each block column of their
             * transposed matrices.
             */
            for (size_type i = 0; i < n_row_blocks; i++)
              {
                /**
                 * Iterate over each block row before the j'th row in
                 * \f$U\vert_{\sigma\times\sigma}\f$, which is equivalent to
                 * over each block column before the j'th column in its
                 * transpose.
                 */
                for (size_type k = 0; k < j; k++)
                  {
                    Z.submatrices[i * n_col_blocks + k]->mmult_level_conserving(
                      *(Z.submatrices[i * n_col_blocks + j]),
                      -1.0,
                      *(this->submatrices[k * n_col_blocks + j]),
                      fixed_rank);
                  }

                /**
                 * Go down one level of recursion and solve the current diagonal
                 * block matrix \f$U\vert_{\sigma_j\times\sigma_j}\f$.
                 */
                this->submatrices[j * n_col_blocks + j]
                  ->solve_transpose_by_forward_substitution_matrix_valued(
                    *(Z.submatrices[i * n_col_blocks + j]), fixed_rank);
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::
    solve_cholesky_transpose_by_forward_substitution_matrix_valued(
      HMatrix<spacedim, Number> &X,
      HMatrix<spacedim, Number> &Z,
      const unsigned int         fixed_rank) const
  {
    AssertDimension(Z.m, X.m);
    AssertDimension(Z.n, X.n);
    Assert(
      Z.type == X.type,
      ExcMessage(
        "Matrix Z and X should be built on a same block cluster and thus have a same H-matrix type!"));
    AssertDimension(this->m, this->n);
    /**
     * The current \hmatrix is \f$L\vert_{\sigma\times\sigma}\f$ and the
     * equation is
     * \f$L\vert_{\sigma\times\sigma}X\vert_{\sigma\times\tau}^T =
     * X\vert_{\sigma\times\tau}^T\f$, the column dimension of \f$L\f$ should be
     * the same as the column dimension of \f$X\f$.
     */
    AssertDimension(X.n, this->n);

    if (Z.type == FullMatrixType)
      {
        /**
         * When the current \hmatnode of \p X or \p Z is a full matrix, we need to
         * solve a multiple RHS vector problem.
         */
        Vector<Number> X_row(X.n);
        Vector<Number> Z_row(Z.n);

        /**
         * Iterate over each row of \p X and \p Z.
         */
        for (size_type i = 0; i < Z.m; i++)
          {
            Z.fullmatrix->get_row(i, Z_row);

            /**
             * Solve the problem
             * \f$L\vert_{\sigma\times\sigma}X\vert_{\sigma,i}^{\mathrm{T}} =
             * Z\vert_{\sigma,i}^{\mathrm{T}}\f$ using the forward substitution
             * for \hmatrices, while the lower triangular matrix is not unit,
             * since it is obtained from Cholesky factorization.
             */
            this->solve_by_forward_substitution(X_row, Z_row, (*this), false);

            /**
             * Merge back the solution vector \p X_row into \p X, while the matrix
             * \p Z is intact.
             */
            X.fullmatrix->fill_row(i, X_row);
          }
      }
    else if (Z.type == RkMatrixType)
      {
        (*X.rkmatrix) = (*Z.rkmatrix);

        Vector<Number> B_prime_col(X.n);
        for (size_type j = 0; j < Z.rkmatrix->get_formal_rank(); j++)
          {
            Z.rkmatrix->get_B().get_column(j, B_prime_col);

            /**
             * Solve the lower triangular \hmatrix using the forward
             * substitution for \hmatrices, while the matrix does not have
             * unit diagonal.
             */
            this->solve_by_forward_substitution(B_prime_col, (*this), false);

            /**
             * Merge back the column vector into the component matrix \f$B'\f$.
             */
            X.rkmatrix->get_B().fill_col(j, B_prime_col);
          }
      }
    else
      {
        /**
         * When the current \hmatnode of \p X or \p Z does not belong to the leaf
         * set, perform a recursive forward substitution based on the
         * submatrix structure of the current \hmatrix \f$L\f$.
         */

        /**
         * The number of row blocks and column blocks of
         * \f$L\vert_{\sigma\times\sigma}\f$ should be the same.
         */
        AssertDimension(this->get_n_row_blocks(),
                        this->bc_node->get_data_reference()
                          .get_sigma_node()
                          ->get_child_num());

        /**
         * Number of row blocks of \f$X\vert_{\tau\times\sigma}\f$ or
         * \f$Z\vert_{\tau\times\sigma}\f$.
         */
        const unsigned int n_row_blocks = X.get_n_row_blocks();
        /**
         * Number of column blocks of \f$X\vert_{\tau\times\sigma}\f$ or
         * \f$Z\vert_{\tau\times\sigma}\f$, which should be the same as the
         * number of row or column blocks of
         * \f$L\vert_{\sigma\times\sigma}\f$.
         */
        const unsigned int n_col_blocks = X.get_n_col_blocks();
        AssertDimension(this->get_n_col_blocks(), n_col_blocks);

        /**
         * \mynote{N.B. \p n_row_blocks does not have to be equal to \p n_col_blocks,
         * since \p X or \p Z may be rectangular.}
         */
        AssertDimension(n_row_blocks, Z.get_n_row_blocks());
        AssertDimension(n_col_blocks, Z.get_n_col_blocks());

        /**
         * Iterate over each block row of \f$L\vert_{\sigma\times\sigma}\f$,
         * which is also each block column of \f$X\vert_{\tau\times\sigma}\f$ or
         * \f$Z\vert_{\tau\times\sigma}\f$.
         */
        for (size_type j = 0; j < n_col_blocks; j++)
          {
            /**
             * Iterate over each child cluster node of the cluster
             * \f$\tau\f$, i.e. each block row of
             * \f$X\vert_{\tau\times\sigma}\f$ or
             * \f$Z\vert_{\tau\times\sigma}\f$.
             */
            for (size_type i = 0; i < n_row_blocks; i++)
              {
                /**
                 * Iterate over each block column before the j'th column in
                 * \f$L\vert_{\sigma\times\sigma}\f$.
                 *
                 * N.B. Here we are actually computing:
                 * \f[
                 * Z\vert_{\tau[i]\times\sigma[j]} :=
                 * Z\vert_{\tau[i]\times\sigma[j]} -
                 * X\vert_{\tau[i]\times\sigma[k]} \cdot
                 * \left(L\vert_{\sigma[j]\times\sigma[k]}\right)^T \f]
                 */
                for (size_type k = 0; k < j; k++)
                  {
                    X.submatrices[i * n_col_blocks + k]
                      ->mTmult_level_conserving(
                        *(Z.submatrices[i * n_col_blocks + j]),
                        -1.0,
                        *(this->submatrices[j * n_col_blocks + k]),
                        fixed_rank);
                  }

                /**
                 * Go down one level of recursion and solve the current
                 * diagonal block matrix \f$U\vert_{\sigma_i \times
                 * \sigma_i}\f$.
                 */
                this->submatrices[j * n_col_blocks + j]
                  ->solve_cholesky_transpose_by_forward_substitution_matrix_valued(
                    *(X.submatrices[i * n_col_blocks + j]),
                    *(Z.submatrices[i * n_col_blocks + j]),
                    fixed_rank);
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::
    solve_cholesky_transpose_by_forward_substitution_matrix_valued(
      HMatrix<spacedim, Number> &Z,
      const unsigned int         fixed_rank) const
  {
    AssertDimension(this->m, this->n);
    /**
     * The current \hmatrix is \f$L\vert_{\sigma\times\sigma}\f$ and the
     * equation is
     * \f$L\vert_{\sigma\times\sigma}X\vert_{\sigma\times\tau}^T =
     * Z\vert_{\sigma\times\tau}^T\f$, the column dimension of \f$L\f$ should be
     * the same as the column dimension of \f$Z\f$.
     */
    AssertDimension(Z.n, this->n);

    if (Z.type == FullMatrixType)
      {
        /**
         * When the current \hmatnode of \p Z is a full matrix, we need to
         * solve a multiple RHS vector problem.
         */
        Vector<Number> Z_row(Z.n);

        /**
         * Iterate over each row of \p Z.
         */
        for (size_type i = 0; i < Z.m; i++)
          {
            Z.fullmatrix->get_row(i, Z_row);

            /**
             * Solve the problem
             * \f$L\vert_{\sigma\times\sigma}X\vert_{\sigma,i} =
             * Z\vert_{\sigma,i}\f$ using the forward substitution for
             * \hmatrices, while the lower triangular matrix is not unit, since
             * it is obtained from Cholesky factorization.
             */
            this->solve_by_forward_substitution(Z_row, (*this), false);

            /**
             * Merge back the solution vector \p Z_row into \p Z.
             */
            Z.fullmatrix->fill_row(i, Z_row);
          }
      }
    else if (Z.type == RkMatrixType)
      {
        Vector<Number> B_col(Z.n);
        for (size_type j = 0; j < Z.rkmatrix->get_formal_rank(); j++)
          {
            Z.rkmatrix->get_B().get_column(j, B_col);

            /**
             * Solve the lower triangular \hmatrix using the forward
             * substitution for \hmatrices, while the matrix does not have
             * unit diagonal.
             */
            this->solve_by_forward_substitution(B_col, (*this), false);

            /**
             * Merge back the column vector into the component matrix \f$B\f$.
             */
            Z.rkmatrix->get_B().fill_col(j, B_col);
          }
      }
    else
      {
        /**
         * When the current \hmatnode of \p Z does not belong to the leaf
         * set, perform a recursive forward substitution based on the
         * submatrix structure of the current \hmatrix \f$L\f$.
         */

        /**
         * The number of row blocks and column blocks of
         * \f$L\vert_{\sigma\times\sigma}\f$ should be the same.
         */
        AssertDimension(this->get_n_row_blocks(),
                        this->bc_node->get_data_reference()
                          .get_sigma_node()
                          ->get_child_num());

        /**
         * Number of row blocks of \f$Z\vert_{\tau\times\sigma}\f$.
         */
        const unsigned int n_row_blocks = Z.get_n_row_blocks();
        /**
         * Number of column blocks of \f$Z\vert_{\tau\times\sigma}\f$, which
         * should be the same as the number of row or column blocks of
         * \f$L\vert_{\sigma\times\sigma}\f$.
         */
        const unsigned int n_col_blocks = Z.get_n_col_blocks();
        AssertDimension(this->get_n_col_blocks(), n_col_blocks);

        /**
         * Iterate over each block row of \f$L\vert_{\sigma\times\sigma}\f$,
         * which is also each block column of \f$Z\vert_{\tau\times\sigma}\f$.
         */
        for (size_type j = 0; j < n_col_blocks; j++)
          {
            /**
             * Iterate over each child cluster node of the cluster
             * \f$\tau\f$, i.e. each block row of
             * \f$Z\vert_{\tau\times\sigma}\f$.
             */
            for (size_type i = 0; i < n_row_blocks; i++)
              {
                /**
                 * Iterate over each block column before the j'th column in
                 * \f$L\vert_{\sigma\times\sigma}\f$.
                 *
                 * N.B. Here we are actually computing:
                 * \f[
                 * Z\vert_{\tau[i]\times\sigma[j]} :=
                 * Z\vert_{\tau[i]\times\sigma[j]} -
                 * X\vert_{\tau[i]\times\sigma[k]} \cdot
                 * \left(L\vert_{\sigma[j]\times\sigma[k]}\right)^T \f]
                 */
                for (size_type k = 0; k < j; k++)
                  {
                    Z.submatrices[i * n_col_blocks + k]
                      ->mTmult_level_conserving(
                        *(Z.submatrices[i * n_col_blocks + j]),
                        -1.0,
                        *(this->submatrices[j * n_col_blocks + k]),
                        fixed_rank);
                  }

                /**
                 * Go down one level of recursion and solve the current
                 * diagonal block matrix \f$U\vert_{\sigma_i \times
                 * \sigma_i}\f$.
                 */
                this->submatrices[j * n_col_blocks + j]
                  ->solve_cholesky_transpose_by_forward_substitution_matrix_valued(
                    *(Z.submatrices[i * n_col_blocks + j]), fixed_rank);
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_block_triangular_by_forward_substitution(
    Vector<Number> &b,
    const bool      is_unit_block_diagonal) const
  {
    /**
     * The current \hmatnode should be square.
     */
    AssertDimension(m, n);

    if (type != HierarchicalMatrixType)
      {
        /**
         * When the current \hmatnode belongs to the leaf set, it must be a
         * full matrix and can be solved via LU factorization.
         */
        Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));
        Assert(fullmatrix != nullptr, ExcInternalError());

        if (is_unit_block_diagonal)
          {
            /**
             * In this case, the diagonal block in the leaf set should be an
             * identity matrix, the solution \p x is the same as the right hand
             * side vector \p b, so here we do nothing.
             */
          }
        else
          {
            /**
             * In this case, the diagonal block in the leaf set should be
             * general full matrix and forward substitution cannot be
             * applied any more. Instead, LU factorization is adopted.
             */
            Vector<Number> local_b(n);

            /**
             * Restrict vector \p b to the column cluster of the current
             * \hmatnode.
             */
            for (size_type j = 0; j < n; j++)
              {
                local_b(j) = b((*col_index_range)[0] + j);
              }

            /**
             * Solve the full matrix using LU factorization.
             */
            fullmatrix->compute_lu_factorization();
            fullmatrix->solve(local_b);

            /**
             * Copy back the restricted vector \p local_b to the original vector
             * \p b.
             */
            for (size_type i = 0; i < m; i++)
              {
                b((*row_index_range)[0] + i) = local_b(i);
              }
          }
      }
    else
      {
        /**
         * Iterate over each block row of the matrix.
         */
        const unsigned int n_row_blocks = get_n_row_blocks();
        const unsigned int n_col_blocks = get_n_col_blocks();

        AssertDimension(n_row_blocks, n_col_blocks);

        for (size_type i = 0; i < n_row_blocks; i++)
          {
            /**
             * Iterate each block column before the i'th column, i.e. before
             * the diagonal submatrix block.
             */
            for (size_type j = 0; j < i; j++)
              {
                submatrices[i * n_col_blocks + j]->vmult(b, -1.0, b);
              }

            /**
             * Solve the current diagonal block using forward substitution
             * recursively.
             */
            submatrices[i * n_col_blocks + i]
              ->solve_block_triangular_by_forward_substitution(
                b, is_unit_block_diagonal);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_block_triangular_by_forward_substitution(
    Vector<Number>       &x,
    const Vector<Number> &b,
    const bool            is_unit_block_diagonal) const
  {
    x = b;
    solve_block_triangular_by_forward_substitution(x, is_unit_block_diagonal);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_block_triangular_by_forward_substitution(
    Vector<Number>                  &b,
    const HMatrix<spacedim, Number> &starting_hmat,
    const bool                       is_unit_block_diagonal) const
  {
    /**
     * The current \hmatnode should be square.
     */
    AssertDimension(m, n);

    if (type != HierarchicalMatrixType)
      {
        /**
         * When the current \hmatnode belongs to the leaf set, it must be a
         * full matrix and can be solved via LU factorization.
         */
        Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));
        Assert(fullmatrix != nullptr, ExcInternalError());

        if (is_unit_block_diagonal)
          {
            /**
             * In this case, the diagonal block in the leaf set should be an
             * identity matrix, the solution \p x is the same as the right hand
             * side vector \p b, so here we do nothing.
             */
          }
        else
          {
            /**
             * In this case, the diagonal block in the leaf set should be
             * general full matrix and forward substitution cannot be
             * applied any more. Instead, LU factorization is adopted.
             */
            Vector<Number> local_b(n);

            /**
             * Restrict vector \p b to the column cluster of the current
             * \hmatnode.
             */
            for (size_type j = 0; j < n; j++)
              {
                local_b(j) = b((*col_index_range)[0] -
                               (*starting_hmat.col_index_range)[0] + j);
              }

            /**
             * Solve the full matrix using LU factorization.
             */
            fullmatrix->compute_lu_factorization();
            fullmatrix->solve(local_b);

            /**
             * Copy back the restricted vector \p local_b to the original vector
             * \p b.
             */
            for (size_type i = 0; i < m; i++)
              {
                b((*row_index_range)[0] - (*starting_hmat.row_index_range)[0] +
                  i) = local_b(i);
              }
          }
      }
    else
      {
        /**
         * Iterate over each block row of the matrix.
         */
        const unsigned int n_row_blocks = get_n_row_blocks();
        const unsigned int n_col_blocks = get_n_col_blocks();

        AssertDimension(n_row_blocks, n_col_blocks);

        for (size_type i = 0; i < n_row_blocks; i++)
          {
            /**
             * Iterate each block column before the i'th column, i.e. before
             * the diagonal submatrix block.
             */
            for (size_type j = 0; j < i; j++)
              {
                submatrices[i * n_col_blocks + j]->vmult(b,
                                                         -1.0,
                                                         b,
                                                         starting_hmat);
              }

            /**
             * Solve the current diagonal block using forward substitution
             * recursively.
             */
            submatrices[i * n_col_blocks + i]
              ->solve_block_triangular_by_forward_substitution(
                b, starting_hmat, is_unit_block_diagonal);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_block_triangular_by_forward_substitution(
    Vector<Number>                  &x,
    const Vector<Number>            &b,
    const HMatrix<spacedim, Number> &starting_hmat,
    const bool                       is_unit_block_diagonal) const
  {
    x = b;
    solve_block_triangular_by_forward_substitution(x,
                                                   starting_hmat,
                                                   is_unit_block_diagonal);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_cholesky_by_forward_substitution(
    Vector<Number> &b) const
  {
    Assert(state == HMatrixSupport::cholesky, ExcInvalidHMatrixState(state));

    solve_by_forward_substitution(b, false);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_cholesky_by_forward_substitution(
    Vector<Number>       &x,
    const Vector<Number> &b) const
  {
    Assert(state == HMatrixSupport::cholesky, ExcInvalidHMatrixState(state));

    solve_by_forward_substitution(x, b, false);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_cholesky_by_forward_substitution(
    Vector<Number>                  &b,
    const HMatrix<spacedim, Number> &starting_hmat) const
  {
    Assert(state == HMatrixSupport::cholesky, ExcInvalidHMatrixState(state));

    solve_by_forward_substitution(b, starting_hmat, false);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_cholesky_by_forward_substitution(
    Vector<Number>                  &x,
    const Vector<Number>            &b,
    const HMatrix<spacedim, Number> &starting_hmat) const
  {
    Assert(state == HMatrixSupport::cholesky, ExcInvalidHMatrixState(state));

    solve_by_forward_substitution(x, b, starting_hmat, false);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_by_backward_substitution(
    Vector<Number> &b,
    const bool      is_unit_diagonal) const
  {
    /**
     * The current \hmatnode should be square.
     */
    AssertDimension(m, n);

    if (type != HierarchicalMatrixType)
      {
        /**
         * When the current \hmatnode belongs to the leaf set, it must be a
         * full matrix and can be directly solved via backward substitution.
         */
        Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));
        Assert(fullmatrix != nullptr, ExcInternalError());

        Vector<Number> local_b(n);

        /**
         * Restrict vector \p b to the column cluster of the current \hmatnode.
         */
        for (size_type j = 0; j < n; j++)
          {
            local_b(j) = b((*col_index_range)[0] + j);
          }

        /**
         * Perform backward substitution for the full matrix.
         */
        fullmatrix->solve_by_backward_substitution(local_b,
                                                   false, // Is transposed
                                                   is_unit_diagonal);

        /**
         * Copy back the restricted vector \p local_b to the original vector \p b.
         */
        for (size_type i = 0; i < m; i++)
          {
            b((*row_index_range)[0] + i) = local_b(i);
          }
      }
    else
      {
        /**
         * Iterate over each block row of the matrix.
         */
        const unsigned int n_row_blocks = get_n_row_blocks();
        const unsigned int n_col_blocks = get_n_col_blocks();

        AssertDimension(n_row_blocks, n_col_blocks);

        /**
         * For the type of the loop variable @p i, if <code>unsigned int</code>
         * is used, when @p i is zero, @p i-- produces the largest integer that
         * <code>unsigned int</code> can represent, which is larger than zero.
         * Then the loop will not stop.
         */
        for (int i = n_row_blocks - 1; i >= 0; i--)
          {
            /**
             * Iterate each block column after the i'th column, i.e. after
             * the diagonal submatrix block.
             */
            for (size_type j = i + 1; j < n_col_blocks; j++)
              {
                submatrices[i * n_col_blocks + j]->vmult(b, -1.0, b);
              }

            /**
             * Solve the current diagonal block using backward substitution
             * recursively.
             */
            submatrices[i * n_col_blocks + i]->solve_by_backward_substitution(
              b, is_unit_diagonal);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_by_backward_substitution(
    Vector<Number>       &x,
    const Vector<Number> &b,
    const bool            is_unit_diagonal) const
  {
    x = b;
    solve_by_backward_substitution(x, is_unit_diagonal);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_by_backward_substitution(
    Vector<Number>                  &b,
    const HMatrix<spacedim, Number> &starting_hmat,
    const bool                       is_unit_diagonal) const
  {
    /**
     * The current \hmatnode should be square.
     */
    AssertDimension(m, n);

    if (type != HierarchicalMatrixType)
      {
        /**
         * When the current \hmatnode belongs to the leaf set, it must be a
         * full matrix and can be directly solved via backward substitution.
         */
        Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));
        Assert(fullmatrix != nullptr, ExcInternalError());

        Vector<Number> local_b(n);

        /**
         * Restrict vector \p b to the column cluster of the current \hmatnode.
         */
        for (size_type j = 0; j < n; j++)
          {
            local_b(j) = b((*col_index_range)[0] -
                           (*starting_hmat.col_index_range)[0] + j);
          }

        /**
         * Perform backward substitution for the full matrix.
         */
        fullmatrix->solve_by_backward_substitution(local_b,
                                                   false, // Is transposed
                                                   is_unit_diagonal);

        /**
         * Copy back the restricted vector \p local_b to the original vector \p b.
         */
        for (size_type i = 0; i < m; i++)
          {
            b((*row_index_range)[0] - (*starting_hmat.row_index_range)[0] + i) =
              local_b(i);
          }
      }
    else
      {
        /**
         * Iterate over each block row of the matrix.
         */
        const unsigned int n_row_blocks = get_n_row_blocks();
        const unsigned int n_col_blocks = get_n_col_blocks();

        AssertDimension(n_row_blocks, n_col_blocks);

        /**
         * For the type of the loop variable @p i, if <code>unsigned int</code>
         * is used, when @p i is zero, @p i-- produces the largest integer that
         * <code>unsigned int</code> can represent, which is larger than zero.
         * Then the loop will not stop.
         */
        for (int i = n_row_blocks - 1; i >= 0; i--)
          {
            /**
             * Iterate each block column after the i'th column, i.e. after
             * the diagonal submatrix block.
             */
            for (size_type j = i + 1; j < n_col_blocks; j++)
              {
                submatrices[i * n_col_blocks + j]->vmult(b,
                                                         -1.0,
                                                         b,
                                                         starting_hmat);
              }

            /**
             * Solve the current diagonal block using backward substitution.
             */
            submatrices[i * n_col_blocks + i]->solve_by_backward_substitution(
              b, starting_hmat, is_unit_diagonal);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_by_backward_substitution(
    Vector<Number>                  &x,
    const Vector<Number>            &b,
    const HMatrix<spacedim, Number> &starting_hmat,
    const bool                       is_unit_diagonal) const
  {
    x = b;
    solve_by_backward_substitution(x, starting_hmat, is_unit_diagonal);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_block_triangular_by_backward_substitution(
    Vector<Number> &b,
    const bool      is_unit_block_diagonal) const
  {
    /**
     * The current \hmatnode should be square.
     */
    AssertDimension(m, n);

    if (type != HierarchicalMatrixType)
      {
        /**
         * When the current \hmatnode belongs to the leaf set, it must be a
         * full matrix and can be solved via LU factorization.
         */
        Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));
        Assert(fullmatrix != nullptr, ExcInternalError());

        if (is_unit_block_diagonal)
          {
            /**
             * In this case, the diagonal block in the leaf set should be an
             * identity matrix, the solution \p x is the same as the right hand
             * side vector \p b, so here we do nothing.
             */
          }
        else
          {
            /**
             * In this case, the diagonal block in the leaf set should be
             * general full matrix and forward substitution cannot be
             * applied any more. Instead, LU factorization is adopted.
             */
            Vector<Number> local_b(n);

            /**
             * Restrict vector \p b to the column cluster of the current
             * \hmatnode.
             */
            for (size_type j = 0; j < n; j++)
              {
                local_b(j) = b((*col_index_range)[0] + j);
              }

            /**
             * Solve the full matrix using LU factorization.
             */
            fullmatrix->compute_lu_factorization();
            fullmatrix->solve(local_b);

            /**
             * Copy back the restricted vector \p local_b to the **global** vector
             * \p b.
             */
            for (size_type i = 0; i < m; i++)
              {
                b((*row_index_range)[0] + i) = local_b(i);
              }
          }
      }
    else
      {
        /**
         * Iterate over each block row of the matrix.
         */
        const unsigned int n_row_blocks = get_n_row_blocks();
        const unsigned int n_col_blocks = get_n_col_blocks();

        AssertDimension(n_row_blocks, n_col_blocks);

        /**
         * For the type of the loop variable @p i, if <code>unsigned int</code>
         * is used, when @p i is zero, @p i-- produces the largest integer that
         * <code>unsigned int</code> can represent, which is larger than zero.
         * Then the loop will not stop.
         */
        for (int i = n_row_blocks - 1; i >= 0; i--)
          {
            /**
             * Iterate each block column after the i'th column, i.e. after
             * the diagonal submatrix block.
             */
            for (size_type j = i + 1; j < n_col_blocks; j++)
              {
                submatrices[i * n_col_blocks + j]->vmult(b, -1.0, b);
              }

            /**
             * Solve the current diagonal block using backward substitution.
             */
            submatrices[i * n_col_blocks + i]
              ->solve_block_triangular_by_backward_substitution(
                b, is_unit_block_diagonal);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_block_triangular_by_backward_substitution(
    Vector<Number>       &x,
    const Vector<Number> &b,
    const bool            is_unit_block_diagonal) const
  {
    x = b;
    solve_block_triangular_by_backward_substitution(x, is_unit_block_diagonal);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_block_triangular_by_backward_substitution(
    Vector<Number>                  &b,
    const HMatrix<spacedim, Number> &starting_hmat,
    const bool                       is_unit_block_diagonal) const
  {
    /**
     * The current \hmatnode should be square.
     */
    AssertDimension(m, n);

    if (type != HierarchicalMatrixType)
      {
        /**
         * When the current \hmatnode belongs to the leaf set, it must be a
         * full matrix and can be solved via LU factorization.
         */
        Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));
        Assert(fullmatrix != nullptr, ExcInternalError());

        if (is_unit_block_diagonal)
          {
            /**
             * In this case, the diagonal block in the leaf set should be an
             * identity matrix, the solution \p x is the same as the right hand
             * side vector \p b, so here we do nothing.
             */
          }
        else
          {
            /**
             * In this case, the diagonal block in the leaf set should be
             * general full matrix and forward substitution cannot be
             * applied any more. Instead, LU factorization is adopted.
             */
            Vector<Number> local_b(n);

            /**
             * Restrict vector \p b to the column cluster of the current
             * \hmatnode.
             */
            for (size_type j = 0; j < n; j++)
              {
                local_b(j) = b((*col_index_range)[0] -
                               (*starting_hmat.col_index_range)[0] + j);
              }

            /**
             * Solve the full matrix using LU factorization.
             */
            fullmatrix->compute_lu_factorization();
            fullmatrix->solve(local_b);

            /**
             * Copy back the restricted vector \p local_b to the **global** vector
             * \p b.
             */
            for (size_type i = 0; i < m; i++)
              {
                b((*row_index_range)[0] - (*starting_hmat.row_index_range)[0] +
                  i) = local_b(i);
              }
          }
      }
    else
      {
        /**
         * Iterate over each block row of the matrix.
         */
        const unsigned int n_row_blocks = get_n_row_blocks();
        const unsigned int n_col_blocks = get_n_col_blocks();

        AssertDimension(n_row_blocks, n_col_blocks);

        /**
         * For the type of the loop variable @p i, if <code>unsigned int</code>
         * is used, when @p i is zero, @p i-- produces the largest integer that
         * <code>unsigned int</code> can represent, which is larger than zero.
         * Then the loop will not stop.
         */
        for (int i = n_row_blocks - 1; i >= 0; i--)
          {
            /**
             * Iterate each block column after the i'th column, i.e. after
             * the diagonal submatrix block.
             */
            for (size_type j = i + 1; j < n_col_blocks; j++)
              {
                submatrices[i * n_col_blocks + j]->vmult(b,
                                                         -1.0,
                                                         b,
                                                         starting_hmat);
              }

            /**
             * Solve the current diagonal block using backward substitution.
             */
            submatrices[i * n_col_blocks + i]
              ->solve_block_triangular_by_backward_substitution(
                b, starting_hmat, is_unit_block_diagonal);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_block_triangular_by_backward_substitution(
    Vector<Number>                  &x,
    const Vector<Number>            &b,
    const HMatrix<spacedim, Number> &starting_hmat,
    const bool                       is_unit_block_diagonal) const
  {
    x = b;
    solve_block_triangular_by_backward_substitution(x,
                                                    starting_hmat,
                                                    is_unit_block_diagonal);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_cholesky_by_backward_substitution(
    Vector<Number> &b) const
  {
    Assert(state == HMatrixSupport::cholesky, ExcInvalidHMatrixState(state));

    /**
     * The current \hmatnode should be square.
     */
    AssertDimension(m, n);

    if (type != HierarchicalMatrixType)
      {
        /**
         * When the current \hmatnode belongs to the leaf set, it must be a
         * full matrix and can be directly solved via backward substitution.
         */
        Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));
        Assert(fullmatrix != nullptr, ExcInternalError());

        Vector<Number> local_b(m);

        /**
         * Restrict vector \p b to the \alert{row} cluster of the current
         * \hmatnode, since the actual matrix to be solved is the
         * transposition of the current matrix.
         */
        for (size_type i = 0; i < m; i++)
          {
            local_b(i) = b((*row_index_range)[0] + i);
          }

        /**
         * Perform backward substitution for the full matrix, where the
         * transposed matrix is solved. N.B. Since the current lower triangular
         * matrix is obtained from Cholesky factorization, it is not unit
         * diagonal.
         */
        fullmatrix->solve_by_backward_substitution(local_b,
                                                   true, // Is transposed
                                                   false // Is unit diagonal
        );

        /**
         * Copy back the restricted vector \p local_b to the original vector \p b.
         */
        for (size_type j = 0; j < n; j++)
          {
            b((*col_index_range)[0] + j) = local_b(j);
          }
      }
    else
      {
        const unsigned int n_row_blocks = get_n_row_blocks();
        const unsigned int n_col_blocks = get_n_col_blocks();

        AssertDimension(n_row_blocks, n_col_blocks);

        /**
         * Iterate over each block column of the matrix.
         */
        for (int j = n_col_blocks - 1; j >= 0; j--)
          {
            /**
             * Iterate each row column after the j'th row, i.e. after the
             * diagonal submatrix block.
             */
            for (size_type i = j + 1; i < n_row_blocks; i++)
              {
                /**
                 * Since the transpose of the current matrix is to be
                 * solved, \p Tvmult is used here instead of \p vmult.
                 */
                submatrices[i * n_col_blocks + j]->Tvmult(b, -1.0, b);
              }

            /**
             * Solve the current diagonal block using backward substitution
             * recursively.
             */
            submatrices[j * n_col_blocks + j]
              ->solve_cholesky_by_backward_substitution(b);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_cholesky_by_backward_substitution(
    Vector<Number>       &x,
    const Vector<Number> &b) const
  {
    x = b;
    solve_cholesky_by_backward_substitution(x);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_cholesky_by_backward_substitution(
    Vector<Number>                  &b,
    const HMatrix<spacedim, Number> &starting_hmat) const
  {
    /**
     * The current \hmatnode should be square.
     */
    AssertDimension(m, n);

    if (type != HierarchicalMatrixType)
      {
        /**
         * When the current \hmatnode belongs to the leaf set, it must be a
         * full matrix and can be directly solved via backward substitution.
         */
        Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));
        Assert(fullmatrix != nullptr, ExcInternalError());

        Vector<Number> local_b(m);

        /**
         * Restrict vector \p b to the \alert{row} cluster of the current
         * \hmatnode, since the actual matrix to be solved is the
         * transposition of the current matrix.
         */
        for (size_type i = 0; i < m; i++)
          {
            local_b(i) = b((*row_index_range)[0] -
                           (*starting_hmat.row_index_range)[0] + i);
          }

        /**
         * Perform backward substitution for the full matrix, where the
         * transposed matrix is solved.
         */
        fullmatrix->solve_by_backward_substitution(local_b,
                                                   true, // Is transposed
                                                   false // Is unit diagonal
        );

        /**
         * Copy back the restricted vector \p local_b to the original vector \p b.
         */
        for (size_type j = 0; j < n; j++)
          {
            b((*col_index_range)[0] - (*starting_hmat.col_index_range)[0] + j) =
              local_b(j);
          }
      }
    else
      {
        const unsigned int n_row_blocks = get_n_row_blocks();
        const unsigned int n_col_blocks = get_n_col_blocks();

        AssertDimension(n_row_blocks, n_col_blocks);

        /**
         * Iterate over each block column of the matrix.
         */
        for (int j = n_col_blocks - 1; j >= 0; j--)
          {
            /**
             * Iterate each row column after the j'th row, i.e. after the
             * diagonal submatrix block.
             */
            for (size_type i = j + 1; i < n_row_blocks; i++)
              {
                /**
                 * Since the transpose of the current matrix is to be
                 * solved, \p Tvmult is used here instead of \p vmult.
                 */
                submatrices[i * n_col_blocks + j]->Tvmult(b,
                                                          -1.0,
                                                          b,
                                                          starting_hmat);
              }

            /**
             * Solve the current diagonal block using backward substitution
             * recursively.
             */
            submatrices[j * n_col_blocks + j]
              ->solve_cholesky_by_backward_substitution(b, starting_hmat);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_cholesky_by_backward_substitution(
    Vector<Number>                  &x,
    const Vector<Number>            &b,
    const HMatrix<spacedim, Number> &starting_hmat) const
  {
    x = b;
    solve_cholesky_by_backward_substitution(x, starting_hmat);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::compute_lu_factorization(
    HMatrix<spacedim, Number> &LU,
    const unsigned int         fixed_rank)
  {
    this->_compute_lu_factorization(LU, fixed_rank);

    /**
     * After LU factorization, set the state of the result matrix to be @p lu and
     * that of the original matrix as @p unusable.
     */
    LU.set_state(HMatrixSupport::lu);
    this->set_state(HMatrixSupport::unusable);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::compute_lu_factorization(
    const unsigned int fixed_rank)
  {
    this->_compute_lu_factorization(fixed_rank);

    /**
     * After LU factorization, set the state of the current matrix to be @p lu.
     */
    this->set_state(HMatrixSupport::lu);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::_compute_lu_factorization(
    HMatrix<spacedim, Number> &LU,
    const unsigned int         fixed_rank) const
  {
    if (type != HierarchicalMatrixType)
      {
        /**
         * When the current \hmatnode belongs to the leaf set, it must be a
         * full matrix and the LU factorization can be directly applied to
         * it using LAPACK.
         *
         * N.B. The LU factorization performed by LAPACK has row partial
         * pivoting.
         */
        Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));
        Assert(fullmatrix != nullptr, ExcInternalError());
        Assert(LU.fullmatrix != nullptr, ExcInternalError());

        /**
         * Copy the full matrix from the source matrix to the result matrix \p LU.
         */
        *(LU.fullmatrix) = *fullmatrix;

        /**
         * After the LU factorization, L and U matrices are stored in the
         * same full matrix. Hence, this operation is in situ.
         */
        LU.fullmatrix->compute_lu_factorization();
      }
    else
      {
        const unsigned int n_row_blocks = get_n_row_blocks();
        const unsigned int n_col_blocks = get_n_col_blocks();

        /**
         * At present, LU factorization is only to be applied to square
         * matrix and block square matrix.
         */
        AssertDimension(n_row_blocks, n_col_blocks);

        /**
         * When the current \hmatnode is not a leaf, iterate over each block
         * row.
         */
        for (size_type i = 0; i < n_row_blocks; i++)
          {
            /**
             * Iterate over each block column.
             */
            for (size_type j = 0; j < n_col_blocks; j++)
              {
                /**
                 * Iterate over each block column before the \f$\min\{i,
                 * j\}\f$-th column using the loop counter \f$k\f$. The
                 * corresponding submatrix product \f$L_{i,k}U_{k,j}\f$
                 * needs to be subtracted from the RHS submatrix
                 * \f$M_{ij}\f$.
                 */
                const size_type min_ij = std::min(i, j);
                /**
                 * Create a local \hmatrix \f$Z_{ij}\f$ as the new RHS
                 * matrix.
                 */
                HMatrix<spacedim, Number> Z(
                  *(submatrices[i * n_col_blocks + j]));
                for (size_type k = 0; k < min_ij; k++)
                  {
                    LU.submatrices[i * n_col_blocks + k]
                      ->mmult_level_conserving(
                        Z,
                        -1.0,
                        *(LU.submatrices[k * n_col_blocks + j]),
                        fixed_rank);
                  }

                if (j < i)
                  {
                    /**
                     * When the current block column is before the
                     * i'th column, solve \f$L_{ij} U_{jj}=M_{ij}\f$ to get
                     * \f$L_{ij}\f$ using the matrix-valued transposed
                     * forward substitution.
                     */
                    LU.submatrices[j * n_col_blocks + j]
                      ->solve_transpose_by_forward_substitution_matrix_valued(
                        *(LU.submatrices[i * n_col_blocks + j]), Z, fixed_rank);
                  }
                else if (j == i)
                  {
                    /**
                     * When the current block column is i, go down one level
                     * of recursion for LU factorization.
                     */
                    Z._compute_lu_factorization(
                      *(LU.submatrices[i * n_col_blocks + i]), fixed_rank);
                  }
                else if (j > i)
                  {
                    /**
                     * Solve \f$L_{ii}U_{ij}=M_{ij}\f$ for \f$L_{ii}\f$.
                     */
                    LU.submatrices[i * n_col_blocks + i]
                      ->solve_by_forward_substitution_matrix_valued(
                        *(LU.submatrices[i * n_col_blocks + j]), Z, fixed_rank);
                  }
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::_compute_lu_factorization(
    const unsigned int fixed_rank)
  {
    if (type != HierarchicalMatrixType)
      {
        /**
         * When the current \hmatnode belongs to the leaf set, it must be a
         * full matrix and the LU factorization can be directly applied to
         * it using LAPACK.
         *
         * N.B. The LU factorization performed by LAPACK has row partial
         * pivoting.
         */
        Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));
        Assert(fullmatrix != nullptr, ExcInternalError());

        /**
         * After the LU factorization, L and U matrices are stored in the
         * same full matrix. Hence, this operation is in situ.
         */
        fullmatrix->compute_lu_factorization();
      }
    else
      {
        const unsigned int n_row_blocks = get_n_row_blocks();
        const unsigned int n_col_blocks = get_n_col_blocks();

        /**
         * At present, LU factorization is only to be applied to square
         * matrix and block square matrix.
         */
        AssertDimension(n_row_blocks, n_col_blocks);

        /**
         * When the current \hmatnode is not a leaf, iterate over each block
         * row.
         */
        for (size_type i = 0; i < n_row_blocks; i++)
          {
            /**
             * Iterate over each block column.
             */
            for (size_type j = 0; j < n_col_blocks; j++)
              {
                /**
                 * Iterate over each block column before the \f$\min\{i,
                 * j\}\f$-th column using the loop counter \f$k\f$. The
                 * corresponding submatrix product \f$L_{i,k}U_{k,j}\f$
                 * needs to be subtracted from the RHS submatrix
                 * \f$M_{ij}\f$.
                 */
                const size_type min_ij = std::min(i, j);

                for (size_type k = 0; k < min_ij; k++)
                  {
                    submatrices[i * n_col_blocks + k]->mmult_level_conserving(
                      *(submatrices[i * n_col_blocks + j]),
                      -1.0,
                      *(submatrices[k * n_col_blocks + j]),
                      fixed_rank);
                  }

                if (j < i)
                  {
                    /**
                     * When the current block column is before the
                     * i'th column, solve \f$L_{ij} U_{jj}=M_{ij}\f$ to get
                     * \f$L_{ij}\f$ using the matrix-valued transposed
                     * forward substitution.
                     */
                    submatrices[j * n_col_blocks + j]
                      ->solve_transpose_by_forward_substitution_matrix_valued(
                        *(submatrices[i * n_col_blocks + j]), fixed_rank);
                  }
                else if (j == i)
                  {
                    /**
                     * When the current block column is i, go down one level
                     * of recursion for LU factorization.
                     */
                    submatrices[i * n_col_blocks + i]
                      ->_compute_lu_factorization(fixed_rank);
                  }
                else if (j > i)
                  {
                    /**
                     * Solve \f$L_{ii}U_{ij}=M_{ij}\f$ for \f$L_{ii}\f$.
                     */
                    submatrices[i * n_col_blocks + i]
                      ->solve_by_forward_substitution_matrix_valued(
                        *(submatrices[i * n_col_blocks + j]), fixed_rank);
                  }
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::compute_lu_factorization_task_parallel(
    const unsigned int fixed_rank)
  {
#if ENABLE_DEBUG == 1 && ENABLE_TIMER == 1
    Timer timer;
#endif
    /**
     * Link same level \hmatnodes on the cross of each diagonal block.
     */
    this->link_hmat_nodes_on_cross_from_diagonal_blocks(this->property);
#if ENABLE_DEBUG == 1 && ENABLE_TIMER == 1
    timer.stop();
    print_wall_time(std::cout, timer, "link h-matrix nodes");
#endif

    /**
     * Mutex used for monitoring the parallel execution of H-LU factorization.
     */
    std::mutex log_stream_lock;

    /**
     * Build the DAG.
     */
    tbb::flow::graph dag;

#if ENABLE_DEBUG == 1 && ENABLE_TIMER == 1
    timer.start();
#endif
    compute_lu_dag(dag, fixed_rank, log_stream_lock);
#if ENABLE_DEBUG == 1 && ENABLE_TIMER == 1
    timer.stop();
    print_wall_time(std::cout, timer, "compute dag");
#endif

#if ENABLE_DEBUG == 1 && ENABLE_TIMER == 1
    timer.start();
#endif
    lu_assign_update_to_solve_and_factorize_dependencies();
#if ENABLE_DEBUG == 1 && ENABLE_TIMER == 1
    timer.stop();
    print_wall_time(std::cout, timer, "contribute update");
#endif

    /**
     * Send a message to the starting task node, i.e. the first leaf node, and
     * trigger the parallel execution of the factorization.
     */
    Assert(leaf_set[0]->factorize_lu_or_cholesky_graph_node,
           ExcInternalError());

#if ENABLE_DEBUG == 1 && ENABLE_TIMER == 1
    timer.start();
#endif
    leaf_set[0]->factorize_lu_or_cholesky_graph_node->try_put(
      tbb::flow::continue_msg());

    dag.wait_for_all();
#if ENABLE_DEBUG == 1 && ENABLE_TIMER == 1
    timer.stop();
    print_wall_time(std::cout, timer, "compute lu");
#endif
    clear_lu_or_cholesky_task_nodes();

    /**
     * After LU factorization, set the state of the current matrix to be @p lu.
     */
    this->set_state(HMatrixSupport::lu);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::compute_lu_dag(tbb::flow::graph  &dag,
                                            const unsigned int fixed_rank,
                                            std::mutex        &log_stream_lock)
  {
    const unsigned int n_row_blocks = get_n_row_blocks();
    const unsigned int n_col_blocks = get_n_col_blocks();

    /**
     * At present, LU factorization is only to be applied to square
     * matrix and block square matrix.
     */
    AssertDimension(n_row_blocks, n_col_blocks);

    /**
     * Iterative over each block row.
     */
    for (size_type i = 0; i < n_row_blocks; i++)
      {
        // <code>i * n_col_blocks + i</code> returns the linear index for the
        // diagonal block on the i-th row.
        HMatrix<spacedim, Number> *current_diag_block =
          submatrices[i * n_col_blocks + i];
        const bool is_diag_block_leaf = current_diag_block->is_leaf();

        current_diag_block->compute_lu_dag(dag, fixed_rank, log_stream_lock);
        current_diag_block->lu_factorize_diagonal_block_task(dag,
                                                             log_stream_lock);

        /**
         * Iterate over each matrix blocks on a same level and in a same
         * column from the diagonal block, which corresponds to the
         * @p solve_upper stage.
         */
        for (HMatrix<spacedim, Number> *current_diag_column_block =
               current_diag_block->next_same_level_same_column_hmat_node;
             current_diag_column_block != nullptr;
             current_diag_column_block =
               current_diag_column_block->next_same_level_same_column_hmat_node)
          {
            if (is_diag_block_leaf || current_diag_column_block->is_leaf())
              {
                /**
                 * Since there is one \hmatnode belongs to the leaf set, the
                 * following @p solve_upper task has actual computation and is
                 * not recursive.
                 */
                current_diag_block->lu_solve_upper_task(
                  dag, *current_diag_column_block, fixed_rank, log_stream_lock);

                /**
                 * Create the dependency from factorization of the current
                 * diagonal block to the @p solve_upper task with respect to the
                 * current column block.
                 */
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 2
                std::cout << "factorize-to-solve-upper at level "
                          << current_diag_block->bc_node->get_level() << ": ["
                          << (*current_diag_block->row_index_range)[0] << ","
                          << (*current_diag_block->row_index_range)[1] << "), ["
                          << (*current_diag_block->col_index_range)[0] << ","
                          << (*current_diag_block->col_index_range)[1]
                          << ") --> ["
                          << (*current_diag_column_block->row_index_range)[0]
                          << ","
                          << (*current_diag_column_block->row_index_range)[1]
                          << "), ["
                          << (*current_diag_column_block->col_index_range)[0]
                          << ","
                          << (*current_diag_column_block->col_index_range)[1]
                          << ")" << std::endl;
#endif
                tbb::flow::make_edge(
                  *(current_diag_block->factorize_lu_or_cholesky_graph_node),
                  *(current_diag_column_block
                      ->solve_upper_or_lower_lu_or_cholesky_graph_node));
              }
          }

        /**
         * Iterate over each matrix blocks on a same level and in a same row
         * from the diagonal block, which corresponds to the @p solve_lower
         * stage.
         */
        for (HMatrix<spacedim, Number> *current_diag_row_block =
               current_diag_block->next_same_level_same_row_hmat_node;
             current_diag_row_block != nullptr;
             current_diag_row_block =
               current_diag_row_block->next_same_level_same_row_hmat_node)
          {
            if (is_diag_block_leaf || current_diag_row_block->is_leaf())
              {
                /**
                 * Since there is one \hmatnode belongs to the leaf set, the
                 * following solve task has actual computation and is not
                 * recursive.
                 */
                current_diag_block->lu_solve_lower_task(dag,
                                                        *current_diag_row_block,
                                                        fixed_rank,
                                                        log_stream_lock);

                /**
                 * Create the dependency from factorization of the current
                 * diagonal block to the @p solve_lower task with respect to the
                 * current row block.
                 */
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 2
                std::cout << "factorize-to-solve-lower at level "
                          << current_diag_block->bc_node->get_level() << ": ["
                          << (*current_diag_block->row_index_range)[0] << ","
                          << (*current_diag_block->row_index_range)[1] << "), ["
                          << (*current_diag_block->col_index_range)[0] << ","
                          << (*current_diag_block->col_index_range)[1]
                          << ") --> ["
                          << (*current_diag_row_block->row_index_range)[0]
                          << ","
                          << (*current_diag_row_block->row_index_range)[1]
                          << "), ["
                          << (*current_diag_row_block->col_index_range)[0]
                          << ","
                          << (*current_diag_row_block->col_index_range)[1]
                          << ")" << std::endl;
#endif
                tbb::flow::make_edge(
                  *(current_diag_block->factorize_lu_or_cholesky_graph_node),
                  *(current_diag_row_block
                      ->solve_upper_or_lower_lu_or_cholesky_graph_node));
              }
          }

        /**
         * Iterate over each trailing matrix block on a same level from the
         * diagonal block, which corresponds to the @p update stage. Both the
         * row and column index sets of the matrix block should be larger than
         * that of the diagonal block.
         */
        for (HMatrix<spacedim, Number> *
               current_trailing_block =
                current_diag_block->next_same_level_hmat_node,
              *current_diag_row_block =
                current_diag_block->next_same_level_same_row_hmat_node,
              *current_diag_column_block =
                current_diag_block->next_same_level_same_column_hmat_node;
             current_trailing_block != nullptr;
             current_trailing_block =
               current_trailing_block->next_same_level_hmat_node)
          {
            /**
             * Sift out the matrix blocks having larger row and column index
             * sets than the diagonal block.
             */
            if ((*current_trailing_block->row_index_range)[0] >=
                  (*current_diag_block->row_index_range)[1] &&
                (*current_trailing_block->col_index_range)[0] >=
                  (*current_diag_block->col_index_range)[1])
              {
                bool is_diag_row_block_found    = false;
                bool is_diag_column_block_found = false;

                /**
                 * Move the pointer @p current_diag_row_block, so that it
                 * is in a same column with the current trailing block.
                 */
                while (current_diag_row_block != nullptr &&
                       current_diag_row_block != current_diag_block)
                  {
                    if (*current_diag_row_block->col_index_range ==
                        *current_trailing_block->col_index_range)
                      {
                        /**
                         * When the two column index ranges match.
                         */
                        is_diag_row_block_found = true;

                        break;
                      }
                    else if ((*current_trailing_block->col_index_range)[0] >=
                             (*current_diag_row_block->col_index_range)[1])
                      {
                        /**
                         * Move forward @p current_diag_row_block.
                         */
                        current_diag_row_block =
                          current_diag_row_block
                            ->next_same_level_same_row_hmat_node;

                        if (current_diag_row_block != nullptr &&
                            (*current_diag_row_block->col_index_range)[0] >=
                              (*current_trailing_block->col_index_range)[1])
                          {
                            /**
                             * There is no corresponding same column block for
                             * the current trailing block. This is based on the
                             * assumption/fact that the index ranges of the same
                             * level same row H-matrix blocks are increasing.
                             */
                            break;
                          }
                      }
                    else if ((*current_diag_row_block->col_index_range)[0] >=
                             (*current_trailing_block->col_index_range)[1])
                      {
                        /**
                         * Move back @p current_diag_row_block.
                         */
                        current_diag_row_block =
                          current_diag_row_block
                            ->previous_same_level_same_row_hmat_node;

                        if (current_diag_row_block != nullptr &&
                            current_diag_row_block != current_diag_block &&
                            (*current_trailing_block->col_index_range)[0] >=
                              (*current_diag_row_block->col_index_range)[1])
                          {
                            /**
                             * There is no corresponding same column block for
                             * the current trailing block. This is based on the
                             * assumption/fact that the index ranges of the same
                             * level same row H-matrix blocks are increasing.
                             */
                            break;
                          }
                      }
                  }

                if (is_diag_row_block_found)
                  {
                    /**
                     * Move the pointer @p current_diag_column_block, so that it
                     * is in a same row with the current trailing block.
                     */
                    while (current_diag_column_block != nullptr &&
                           current_diag_column_block != current_diag_block)
                      {
                        if (*current_diag_column_block->row_index_range ==
                            *current_trailing_block->row_index_range)
                          {
                            /**
                             * When the two column index ranges match.
                             */
                            is_diag_column_block_found = true;

                            break;
                          }
                        else if ((*current_trailing_block
                                     ->row_index_range)[0] >=
                                 (*current_diag_column_block
                                     ->row_index_range)[1])
                          {
                            /**
                             * Move forward @p current_diag_column_block.
                             */
                            current_diag_column_block =
                              current_diag_column_block
                                ->next_same_level_same_column_hmat_node;

                            if (current_diag_column_block != nullptr &&
                                (*current_diag_column_block
                                    ->row_index_range)[0] >=
                                  (*current_trailing_block->row_index_range)[1])
                              {
                                /**
                                 * There is no corresponding same row block for
                                 * the current trailing block. This is based on
                                 * the assumption/fact that the index ranges of
                                 * the same level same column H-matrix blocks
                                 * are increasing.
                                 */
                                break;
                              }
                          }
                        else if ((*current_diag_column_block
                                     ->row_index_range)[0] >=
                                 (*current_trailing_block->row_index_range)[1])
                          {
                            /**
                             * Move back @p current_diag_column_block.
                             */
                            current_diag_column_block =
                              current_diag_column_block
                                ->previous_same_level_same_column_hmat_node;

                            if (current_diag_column_block != nullptr &&
                                current_diag_column_block !=
                                  current_diag_block &&
                                (*current_trailing_block->row_index_range)[0] >=
                                  (*current_diag_column_block
                                      ->row_index_range)[1])
                              {
                                /**
                                 * There is no corresponding same row block for
                                 * the current trailing block. This is based on
                                 * the assumption/fact that the index ranges of
                                 * the same level same column H-matrix blocks
                                 * are increasing.
                                 */
                                break;
                              }
                          }
                      }

                    if (!is_diag_column_block_found)
                      {
                        /**
                         * Reset the pointer @p current_diag_column_block for
                         * the next trailing block if it has touched either end
                         * of the doubly linked list.
                         */
                        if (current_diag_column_block == nullptr ||
                            current_diag_column_block == current_diag_block)
                          {
                            current_diag_column_block =
                              current_diag_block
                                ->next_same_level_same_column_hmat_node;
                          }
                      }
                  }
                else
                  {
                    /**
                     * Reset the pointer @p current_diag_row_block for the next
                     * trailing block if it has touched either end of the doubly
                     * linked list.
                     */
                    if (current_diag_row_block == nullptr ||
                        current_diag_row_block == current_diag_block)
                      {
                        current_diag_row_block =
                          current_diag_block
                            ->next_same_level_same_row_hmat_node;
                      }
                  }

                /**
                 * Only when the corresponding same level, same row block and
                 * column block are found, update task will be added.
                 */
                if (is_diag_row_block_found && is_diag_column_block_found)
                  {
                    if (current_trailing_block->is_leaf() ||
                        current_diag_row_block->is_leaf() ||
                        current_diag_column_block->is_leaf())
                      {
                        /**
                         * Add the update task to the current trailing
                         * \hmatnode.
                         */
                        current_trailing_block->lu_update_task(
                          dag,
                          *current_diag_block,
                          *current_diag_column_block,
                          *current_diag_row_block,
                          fixed_rank,
                          log_stream_lock);

                        /**
                         * Iterate over the sub-block cluster tree associated
                         * with @p current_diag_row_block and build the
                         * edge from @p solve_lower node to the current @p update node.
                         */
                        current_diag_row_block
                          ->lu_build_solve_lower_to_update_dependencies(
                            *current_trailing_block);

                        /**
                         * Iterate over the sub-block cluster tree associated
                         * with @p current_diag_column_block and build the
                         * edge from @p solve_upper to the current @p update node.
                         */
                        current_diag_column_block
                          ->lu_or_cholesky_build_solve_upper_to_update_dependencies(
                            *current_trailing_block);
                      }
                  }
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::lu_factorize_diagonal_block_task(
    tbb::flow::graph &dag,
    std::mutex       &log_stream_lock)
  {
    /**
     * Only a diagonal block can be directly factorized.
     */
    Assert(block_type == HMatrixSupport::BlockType::diagonal_block,
           ExcInvalidHMatrixBlockType(block_type));

    this->factorize_lu_or_cholesky_graph_node = std::make_shared<TaskNode>(
      dag, [this, &log_stream_lock](const tbb::flow::continue_msg &msg) {
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 3
        {
          std::lock_guard<std::mutex> lg(log_stream_lock);

          std::cout << std::this_thread::get_id() << "#lu_factorize: ["
                    << (*this->row_index_range)[0] << ","
                    << (*this->row_index_range)[1] << "), ["
                    << (*this->col_index_range)[0] << ","
                    << (*this->col_index_range)[1] << ")" << std::endl;
        }
#endif

        if (this->is_leaf())
          {
            /**
             * When the current \hmatnode belongs to the leaf set, it must be a
             * full matrix and the LU factorization can be directly applied to
             * it using LAPACK.
             *
             * N.B. The LU factorization performed by LAPACK has row partial
             * pivoting.
             */
            Assert(this->type == FullMatrixType,
                   ExcInvalidHMatrixType(this->type));
            Assert(this->fullmatrix != nullptr, ExcInternalError());

            /**
             * After the LU factorization, L and U matrices are stored in the
             * same full matrix. Hence, this operation is in situ.
             */
            this->fullmatrix->compute_lu_factorization();
          }

        return msg;
      });
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::lu_solve_upper_task(tbb::flow::graph          &dag,
                                                 HMatrix<spacedim, Number> &Z,
                                                 const unsigned int fixed_rank,
                                                 std::mutex &log_stream_lock)
  {
    /**
     * The current \hmatnode should be a diagonal block, while \f$Z\f$ is not.
     */
    Assert(block_type == HMatrixSupport::BlockType::diagonal_block,
           ExcInvalidHMatrixBlockType(block_type));
    Assert(Z.block_type != HMatrixSupport::BlockType::diagonal_block,
           ExcInvalidHMatrixBlockType(Z.block_type));

    /**
     * There should be no @p solve_upper or @p solve_lower task associated with
     * the \hmatnode \f$Z\f$.
     */
    Assert(!Z.solve_upper_or_lower_lu_or_cholesky_graph_node,
           ExcInternalError());

    Z.solve_upper_or_lower_lu_or_cholesky_graph_node =
      std::make_shared<TaskNode>(
        dag,
        [this, &Z, fixed_rank, &log_stream_lock](
          const tbb::flow::continue_msg &msg) {
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 3
          {
            std::lock_guard<std::mutex> lg(log_stream_lock);

            std::cout << std::this_thread::get_id() << "#lu_solve_upper: ["
                      << (*Z.row_index_range)[0] << ","
                      << (*Z.row_index_range)[1] << "), ["
                      << (*Z.col_index_range)[0] << ","
                      << (*Z.col_index_range)[1] << ")" << std::endl;
          }
#endif

          this->solve_transpose_by_forward_substitution_matrix_valued(
            Z, fixed_rank);
          return msg;
        });
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::lu_solve_lower_task(tbb::flow::graph          &dag,
                                                 HMatrix<spacedim, Number> &Z,
                                                 const unsigned int fixed_rank,
                                                 std::mutex &log_stream_lock)
  {
    /**
     * The current \hmatnode should be a diagonal block, while \f$Z\f$ is not.
     */
    Assert(block_type == HMatrixSupport::BlockType::diagonal_block,
           ExcInvalidHMatrixBlockType(block_type));
    Assert(Z.block_type != HMatrixSupport::BlockType::diagonal_block,
           ExcInvalidHMatrixBlockType(Z.block_type));

    /**
     * There should be no @p solve_upper or @p solve_lower task associated with
     * the \hmatnode \f$Z\f$.
     */
    Assert(!Z.solve_upper_or_lower_lu_or_cholesky_graph_node,
           ExcInternalError());

    Z.solve_upper_or_lower_lu_or_cholesky_graph_node =
      std::make_shared<TaskNode>(
        dag,
        [this, &Z, fixed_rank, &log_stream_lock](
          const tbb::flow::continue_msg &msg) {
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 3
          {
            std::lock_guard<std::mutex> lg(log_stream_lock);

            std::cout << std::this_thread::get_id() << "#lu_solve_lower: ["
                      << (*Z.row_index_range)[0] << ","
                      << (*Z.row_index_range)[1] << "), ["
                      << (*Z.col_index_range)[0] << ","
                      << (*Z.col_index_range)[1] << ")" << std::endl;
          }
#endif

          this->solve_by_forward_substitution_matrix_valued(Z, fixed_rank);
          return msg;
        });
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::lu_update_task(
    tbb::flow::graph          &dag,
    HMatrix<spacedim, Number> &diag_block,
    HMatrix<spacedim, Number> &diag_column_block,
    HMatrix<spacedim, Number> &diag_row_block,
    const unsigned int         fixed_rank,
    std::mutex                &log_stream_lock)
  {
    this->update_lu_or_cholesky_graph_nodes.push_back(
      UpdateTaskNodeForLUOrCholesky(
        &diag_block,
        std::make_shared<TaskNode>(
          dag,
          [this,
           &diag_column_block,
           &diag_row_block,
           fixed_rank,
           &log_stream_lock](const tbb::flow::continue_msg &msg) {
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 3
            {
              std::lock_guard<std::mutex> lg(log_stream_lock);

              std::cout << std::this_thread::get_id() << "#lu_update: ["
                        << (*diag_column_block.row_index_range)[0] << ","
                        << (*diag_column_block.row_index_range)[1] << "), ["
                        << (*diag_column_block.col_index_range)[0] << ","
                        << (*diag_column_block.col_index_range)[1] << ") * ["
                        << (*diag_row_block.row_index_range)[0] << ","
                        << (*diag_row_block.row_index_range)[1] << "), ["
                        << (*diag_row_block.col_index_range)[0] << ","
                        << (*diag_row_block.col_index_range)[1] << ")"
                        << " --> [" << (*this->row_index_range)[0] << ","
                        << (*this->row_index_range)[1] << "), ["
                        << (*this->col_index_range)[0] << ","
                        << (*this->col_index_range)[1] << ")" << std::endl;
            }
#endif

            diag_column_block.mmult_level_conserving_for_parallel_lu(
              *this, -1.0, diag_row_block, fixed_rank);

            return msg;
          })));
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::
    lu_or_cholesky_build_solve_upper_to_update_dependencies(
      HMatrix<spacedim, Number> &update_block)
  {
    /**
     * If the current \hmatnode has been associated with a @p solve_upper node,
     * link it with the newest @p update node in the @p update_block.
     */
    if (solve_upper_or_lower_lu_or_cholesky_graph_node)
      {
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 2
        std::cout << "solve-upper-to-update at level ("
                  << this->bc_node->get_level() << ","
                  << update_block.bc_node->get_level() << "): ["
                  << (*this->row_index_range)[0] << ","
                  << (*this->row_index_range)[1] << "), ["
                  << (*this->col_index_range)[0] << ","
                  << (*this->col_index_range)[1] << ") --> ["
                  << (*update_block.row_index_range)[0] << ","
                  << (*update_block.row_index_range)[1] << "), ["
                  << (*update_block.col_index_range)[0] << ","
                  << (*update_block.col_index_range)[1] << ")" << std::endl;
#endif

        tbb::flow::make_edge(
          *solve_upper_or_lower_lu_or_cholesky_graph_node,
          *update_block.update_lu_or_cholesky_graph_nodes.back().update);
      }

    /**
     * Recursion into child matrices.
     */
    for (auto submatrix : submatrices)
      {
        submatrix->lu_or_cholesky_build_solve_upper_to_update_dependencies(
          update_block);
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::lu_build_solve_lower_to_update_dependencies(
    HMatrix<spacedim, Number> &update_block)
  {
    /**
     * If the current \hmatnode has been associated with a @p solve_lower node,
     * link it with the newest @p update node in the @p update_block.
     */
    if (solve_upper_or_lower_lu_or_cholesky_graph_node)
      {
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 2
        std::cout << "solve-lower-to-update at level ("
                  << this->bc_node->get_level() << ","
                  << update_block.bc_node->get_level() << "): ["
                  << (*this->row_index_range)[0] << ","
                  << (*this->row_index_range)[1] << "), ["
                  << (*this->col_index_range)[0] << ","
                  << (*this->col_index_range)[1] << ") --> ["
                  << (*update_block.row_index_range)[0] << ","
                  << (*update_block.row_index_range)[1] << "), ["
                  << (*update_block.col_index_range)[0] << ","
                  << (*update_block.col_index_range)[1] << ")" << std::endl;
#endif

        tbb::flow::make_edge(
          *solve_upper_or_lower_lu_or_cholesky_graph_node,
          *update_block.update_lu_or_cholesky_graph_nodes.back().update);
      }

    /**
     * Recursion into child matrices.
     */
    for (auto submatrix : submatrices)
      {
        submatrix->lu_build_solve_lower_to_update_dependencies(update_block);
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::lu_build_update_to_factorize_dependencies(
    HMatrix<spacedim, Number> &factorize_block)
  {
    for (auto &update_node : update_lu_or_cholesky_graph_nodes)
      {
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 2
        std::cout << "update-to-factorize at level ("
                  << this->bc_node->get_level() << ","
                  << factorize_block.bc_node->get_level() << "): ["
                  << (*this->row_index_range)[0] << ","
                  << (*this->row_index_range)[1] << "), ["
                  << (*this->col_index_range)[0] << ","
                  << (*this->col_index_range)[1] << ") --> ["
                  << (*factorize_block.row_index_range)[0] << ","
                  << (*factorize_block.row_index_range)[1] << "), ["
                  << (*factorize_block.col_index_range)[0] << ","
                  << (*factorize_block.col_index_range)[1] << ")" << std::endl;
#endif

        tbb::flow::make_edge(
          *update_node.update,
          *factorize_block.factorize_lu_or_cholesky_graph_node);
      }

    /**
     * Recursion into child matrices.
     */
    for (auto submatrix : submatrices)
      {
        submatrix->lu_build_update_to_factorize_dependencies(factorize_block);
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::
    lu_build_update_to_solve_upper_or_lower_dependencies(
      HMatrix<spacedim, Number> &solve_upper_or_lower_block)
  {
    Assert(block_type == HMatrixSupport::BlockType::upper_triangular_block ||
             block_type == HMatrixSupport::BlockType::lower_triangular_block,
           ExcInternalError());

    for (auto &update_node : update_lu_or_cholesky_graph_nodes)
      {
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 2
        if (solve_upper_or_lower_block.block_type ==
            HMatrixSupport::BlockType::upper_triangular_block)
          {
            std::cout << "update-to-solve-lower at level ("
                      << this->bc_node->get_level() << ","
                      << solve_upper_or_lower_block.bc_node->get_level()
                      << "): ["
                      << (*update_node.diagonal_hmat_node->row_index_range)[0]
                      << ","
                      << (*update_node.diagonal_hmat_node->row_index_range)[1]
                      << "), ["
                      << (*update_node.diagonal_hmat_node->col_index_range)[0]
                      << ","
                      << (*update_node.diagonal_hmat_node->col_index_range)[1]
                      << ") --> ["
                      << (*solve_upper_or_lower_block.row_index_range)[0] << ","
                      << (*solve_upper_or_lower_block.row_index_range)[1]
                      << "), ["
                      << (*solve_upper_or_lower_block.col_index_range)[0] << ","
                      << (*solve_upper_or_lower_block.col_index_range)[1] << ")"
                      << std::endl;
          }
        else if (solve_upper_or_lower_block.block_type ==
                 HMatrixSupport::BlockType::lower_triangular_block)
          {
            std::cout << "update-to-solve-upper at level ("
                      << this->bc_node->get_level() << ","
                      << solve_upper_or_lower_block.bc_node->get_level()
                      << "): ["
                      << (*update_node.diagonal_hmat_node->row_index_range)[0]
                      << ","
                      << (*update_node.diagonal_hmat_node->row_index_range)[1]
                      << "), ["
                      << (*update_node.diagonal_hmat_node->col_index_range)[0]
                      << ","
                      << (*update_node.diagonal_hmat_node->col_index_range)[1]
                      << ") --> ["
                      << (*solve_upper_or_lower_block.row_index_range)[0] << ","
                      << (*solve_upper_or_lower_block.row_index_range)[1]
                      << "), ["
                      << (*solve_upper_or_lower_block.col_index_range)[0] << ","
                      << (*solve_upper_or_lower_block.col_index_range)[1] << ")"
                      << std::endl;
          }
        else
          {
            Assert(false, ExcInternalError());
          }
#endif

        tbb::flow::make_edge(
          *update_node.update,
          *solve_upper_or_lower_block
             .solve_upper_or_lower_lu_or_cholesky_graph_node);
      }

    /**
     * Recursion into child matrices.
     */
    for (auto submatrix : submatrices)
      {
        submatrix->lu_build_update_to_solve_upper_or_lower_dependencies(
          solve_upper_or_lower_block);
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim,
          Number>::lu_assign_update_to_solve_and_factorize_dependencies()
  {
    if (solve_upper_or_lower_lu_or_cholesky_graph_node)
      {
        /**
         * Collect @p update task nodes from child \hmatnodes and build the
         * task edges from @p update to @p solve_upper or @p solve_lower.
         */
        lu_build_update_to_solve_upper_or_lower_dependencies(*this);

        /**
         * In this case, the \hmatnode is either upper or lower triangular,
         * which cannot be a diagonal block, nor of its descendants. Therefore,
         * there will be no task edges from @p update to @p factorize anymore.
         */
      }
    else
      {
        if (block_type == HMatrixSupport::BlockType::diagonal_block)
          {
            /**
             * For the top level \hmatnode, it is a diagonal block but has no
             * factorization task with it. Therefore, here we check if the
             * factorization task node exists.
             */
            if (factorize_lu_or_cholesky_graph_node)
              {
                lu_build_update_to_factorize_dependencies(*this);

                /**
                 * Build the dependency between factorization task nodes on
                 * successive levels, i.e. after all diagonal blocks on a deeper
                 * level are factorized, their parent diagonal block can then be
                 * factorized.
                 */
                if (parent != nullptr &&
                    parent->factorize_lu_or_cholesky_graph_node &&
                    // Only when the current matrix block is the last diagonal
                    // block within its parent matrix, the
                    // factorization-to-factorization task dependency will be
                    // created.
                    submatrix_index == (parent->get_n_row_blocks() - 1) *
                                         (parent->get_n_col_blocks() + 1))
                  {
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 2
                    std::cout << "factorize-to-factorize at level ("
                              << this->bc_node->get_level() << ","
                              << parent->bc_node->get_level() << "): ["
                              << (*this->row_index_range)[0] << ","
                              << (*this->row_index_range)[1] << "), ["
                              << (*this->col_index_range)[0] << ","
                              << (*this->col_index_range)[1] << ") --> ["
                              << (*parent->row_index_range)[0] << ","
                              << (*parent->row_index_range)[1] << "), ["
                              << (*parent->col_index_range)[0] << ","
                              << (*parent->col_index_range)[1] << ")"
                              << std::endl;
#endif

                    tbb::flow::make_edge(
                      *factorize_lu_or_cholesky_graph_node,
                      *parent->factorize_lu_or_cholesky_graph_node);
                  }
              }
          }

        /**
         * After processing the diagonal block, the algorithm continues to shift
         * down update task nodes to child \hmatnodes.
         */

        for (auto submatrix : submatrices)
          {
            /**
             * Shift down the @p update task nodes.
             */
            if (update_lu_or_cholesky_graph_nodes.size() > 0)
              {
                submatrix->update_lu_or_cholesky_graph_nodes.insert(
                  submatrix->update_lu_or_cholesky_graph_nodes.end(),
                  update_lu_or_cholesky_graph_nodes.begin(),
                  update_lu_or_cholesky_graph_nodes.end());
              }

            submatrix->lu_assign_update_to_solve_and_factorize_dependencies();
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::_compute_cholesky_factorization(
    HMatrix<spacedim, Number> &L,
    const unsigned int         fixed_rank) const
  {
    Assert(this->state == HMatrixSupport::matrix,
           ExcInvalidHMatrixState(this->state));
    Assert(this->property == HMatrixSupport::symmetric,
           ExcInvalidHMatrixProperty(this->property));
    Assert(this->block_type == HMatrixSupport::diagonal_block,
           ExcInvalidHMatrixBlockType(this->block_type));

    Assert(L.state == HMatrixSupport::matrix, ExcInvalidHMatrixState(L.state));
    Assert(L.property == HMatrixSupport::lower_triangular ||
             L.property == HMatrixSupport::symmetric,
           ExcInvalidHMatrixProperty(L.property));
    Assert(L.block_type == HMatrixSupport::diagonal_block,
           ExcInvalidHMatrixBlockType(L.block_type));

    if (type != HierarchicalMatrixType)
      {
        /**
         * When the current \hmatnode belongs to the leaf set, it must be a
         * full matrix and the Cholesky factorization can be directly
         * applied to it using LAPACK.
         *
         * N.B. Unlike the LU factorization, the Cholesky factorization
         * performed by LAPACK has no pivoting.
         */
        Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));
        Assert(fullmatrix != nullptr, ExcInternalError());
        Assert(L.fullmatrix != nullptr, ExcInternalError());

        /**
         * Copy the full matrix from the source matrix to the result matrix \p L.
         * \alert{N.B. The result matrix @p L is lower triangular, so the
         * associated full matrix is also lower triangular. However, after
         * copying the data from @p this->fullmatrix to @p L.fullmatrix, the
         * property of @p L.fullmatrix has been overwritten as @p symmetric,
         * which is just what we desire, since full matrix Cholesky
         * factorization
         * will be applied to @p L.fullmatrix.}
         */
        *(L.fullmatrix) = *fullmatrix;

        Assert(L.fullmatrix->get_property() == LAPACKSupport::symmetric,
               ExcInvalidLAPACKFullMatrixProperty(
                 L.fullmatrix->get_property()));

        /**
         * After the Cholesky factorization, the matrix \p L is stored in the same
         * full matrix. Hence, this operation is in situ.
         */
        L.fullmatrix->compute_cholesky_factorization();
      }
    else
      {
        const unsigned int n_row_blocks = get_n_row_blocks();
        const unsigned int n_col_blocks = get_n_col_blocks();

        /**
         * At present, Cholesky factorization is only to be applied to
         * square matrix and block square matrix.
         */
        AssertDimension(n_row_blocks, n_col_blocks);

        /**
         * When the current \hmatnode is not a leaf, iterate over each block
         * row.
         */
        for (size_type i = 0; i < n_row_blocks; i++)
          {
            /**
             * Iterate over each block column from beginning to the diagonal
             * block.
             */
            for (size_type j = 0; j <= i; j++)
              {
                /**
                 * Create a local \hmatrix \f$Z_{ij}\f$ as the new RHS
                 * matrix.
                 */
                HMatrix<spacedim, Number> Z(
                  *(submatrices[i * n_col_blocks + j]));

                /**
                 * Iterate over each block column before the \f$j\f$-th
                 * column.
                 *
                 * \alert{2022-04-24 When \f$i\equiv j\f$, the product
                 * \f$L_{ik}\cdot L_{jk}^T\f$ is a symmetric matrix, which
                 * needs a special treatment when it is to be added to the
                 * symmetric \hmatrix \f$Z\f$. Because the property of the
                 * \hmatrix block
                 * \f$L_{ik}\f$ is @p general not @p symmetric, all of its
                 * submatrices have been allocated with memory, while the
                 * symmetric block \f$Z\f$ only stores its diagonal and
                 * lower triangular blocks, which cannot accept values
                 * assembled form the upper triangular part.}
                 */
                for (size_type k = 0; k < j; k++)
                  {
                    L.submatrices[i * n_col_blocks + k]
                      ->mTmult_level_conserving(
                        Z,
                        -1.0,
                        *(L.submatrices[j * n_col_blocks + k]),
                        fixed_rank,
                        (i == j));
                  }

                if (j < i)
                  {
                    /**
                     * When the current block column is before the i'th
                     * column, solve \f$L_{ij} L_{jj}^T = M_{ij}\f$ using
                     * the matrix-valued Cholesky transposed forward
                     * substitution.
                     */
                    L.submatrices[j * n_col_blocks + j]
                      ->solve_cholesky_transpose_by_forward_substitution_matrix_valued(
                        *(L.submatrices[i * n_col_blocks + j]), Z, fixed_rank);
                  }
                else if (j == i)
                  {
                    /**
                     * When coming to the diagonal block, go down one level
                     * of recursion for Cholesky factorization.
                     */
                    Z._compute_cholesky_factorization(
                      *(L.submatrices[i * n_col_blocks + i]), fixed_rank);
                  }
                else
                  {
                    Assert(false, ExcInternalError());
                  }
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::compute_cholesky_factorization(
    HMatrix<spacedim, Number> &L,
    const unsigned int         fixed_rank)
  {
    this->_compute_cholesky_factorization(L, fixed_rank);

    /**
     * After Cholesky factorization, set the state of the result matrix to be
     * @p cholesky and that of the original matrix as @p unusable. Since the
     * property of @p L is already lower triangular, there is no need to reset it
     * here.
     */
    L.set_state(HMatrixSupport::cholesky);
    this->set_state(HMatrixSupport::unusable);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::_compute_cholesky_factorization(
    const unsigned int fixed_rank)
  {
    Assert(this->state == HMatrixSupport::matrix,
           ExcInvalidHMatrixState(this->state));
    Assert(this->property == HMatrixSupport::symmetric,
           ExcInvalidHMatrixProperty(this->property));
    Assert(this->block_type == HMatrixSupport::diagonal_block,
           ExcInvalidHMatrixBlockType(this->block_type));

    if (type != HierarchicalMatrixType)
      {
        /**
         * When the current \hmatnode belongs to the leaf set, it must be a
         * full matrix and the Cholesky factorization can be directly
         * applied to it using LAPACK.
         *
         * N.B. Unlike the LU factorization, the Cholesky factorization
         * performed by LAPACK has no pivoting.
         */
        Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));
        Assert(fullmatrix != nullptr, ExcInternalError());

        Assert(fullmatrix->get_property() == LAPACKSupport::Property::symmetric,
               ExcInvalidLAPACKFullMatrixProperty(fullmatrix->get_property()));

        /**
         * After the Cholesky factorization, the matrix \p L is stored in the same
         * full matrix. Hence, this operation is in situ.
         */
        fullmatrix->compute_cholesky_factorization();
      }
    else
      {
        const unsigned int n_row_blocks = get_n_row_blocks();
        const unsigned int n_col_blocks = get_n_col_blocks();

        /**
         * At present, Cholesky factorization is only to be applied to
         * square matrix and block square matrix.
         */
        AssertDimension(n_row_blocks, n_col_blocks);

        /**
         * When the current \hmatnode is not a leaf, iterate over each block
         * row.
         */
        for (size_type i = 0; i < n_row_blocks; i++)
          {
            /**
             * Iterate over each block column from beginning to the diagonal
             * block.
             */
            for (size_type j = 0; j <= i; j++)
              {
                /**
                 * Iterate over each block column before the \f$j\f$-th
                 * column.
                 *
                 * \alert{2022-04-24 When \f$i\equiv j\f$, the product
                 * \f$L_{ik}\cdot L_{jk}^T\f$ is a symmetric matrix, which
                 * needs a special treatment when it is to be added to the
                 * symmetric \hmatrix \f$Z\f$. Because the property of the
                 * \hmatrix block
                 * \f$L_{ik}\f$ is @p general not @p symmetric, all of its
                 * submatrices have been allocated with memory, while the
                 * symmetric block \f$Z\f$ only stores its diagonal and
                 * lower triangular blocks, which cannot accept values
                 * assembled form the upper triangular part.}
                 */
                for (size_type k = 0; k < j; k++)
                  {
                    submatrices[i * n_col_blocks + k]->mTmult_level_conserving(
                      *(submatrices[i * n_col_blocks + j]),
                      -1.0,
                      *(submatrices[j * n_col_blocks + k]),
                      fixed_rank,
                      (i == j));
                  }

                if (j < i)
                  {
                    /**
                     * When the current block column is before the i'th
                     * column, solve \f$L_{ij} L_{jj}^T = M_{ij}\f$ using
                     * the matrix-valued Cholesky transposed forward
                     * substitution.
                     */
                    submatrices[j * n_col_blocks + j]
                      ->solve_cholesky_transpose_by_forward_substitution_matrix_valued(
                        *(submatrices[i * n_col_blocks + j]), fixed_rank);
                  }
                else if (j == i)
                  {
                    /**
                     * When coming to the diagonal block, go down one level
                     * of recursion for Cholesky factorization.
                     */
                    submatrices[i * n_col_blocks + i]
                      ->_compute_cholesky_factorization(fixed_rank);
                  }
                else
                  {
                    Assert(false, ExcInternalError());
                  }
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::compute_cholesky_factorization(
    const unsigned int fixed_rank)
  {
    this->_compute_cholesky_factorization(fixed_rank);

    /**
     * After Cholesky factorization, set the state of the current matrix to be
     * @p cholesky and set its property as @p lower_triangular.
     */
    this->set_state(HMatrixSupport::cholesky);
    this->set_property(HMatrixSupport::lower_triangular);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::compute_cholesky_dag(tbb::flow::graph  &dag,
                                                  const unsigned int fixed_rank,
                                                  std::mutex &log_stream_lock)
  {
    const unsigned int n_row_blocks = get_n_row_blocks();
    const unsigned int n_col_blocks = get_n_col_blocks();

    AssertDimension(n_row_blocks, n_col_blocks);

    /**
     * Iterative over each block row.
     */
    for (size_type i = 0; i < n_row_blocks; i++)
      {
        // <code>i * n_col_blocks + i</code> returns the linear index for the
        // diagonal block on the i-th row.
        HMatrix<spacedim, Number> *current_diag_block =
          submatrices[i * n_col_blocks + i];
        const bool is_diag_block_leaf = current_diag_block->is_leaf();

        current_diag_block->compute_cholesky_dag(dag,
                                                 fixed_rank,
                                                 log_stream_lock);
        current_diag_block->cholesky_factorize_diagonal_block_task(
          dag, log_stream_lock);

        /**
         * Iterate over each matrix blocks on a same level and in a same
         * column from the diagonal block, which corresponds to the
         * @p solve_upper stage.
         */
        for (HMatrix<spacedim, Number> *current_diag_column_block =
               current_diag_block->next_same_level_same_column_hmat_node;
             current_diag_column_block != nullptr;
             current_diag_column_block =
               current_diag_column_block->next_same_level_same_column_hmat_node)
          {
            if (is_diag_block_leaf || current_diag_column_block->is_leaf())
              {
                /**
                 * Since there is one \hmatnode belongs to the leaf set, the
                 * following @p solve_upper task has actual
                 * computation and is not recursive.
                 */
                current_diag_block->cholesky_solve_upper_task(
                  dag, *current_diag_column_block, fixed_rank, log_stream_lock);

                /**
                 * Create the dependency from factorization of the current
                 * diagonal block to the @p solve_upper task with respect to the
                 * current column block.
                 */
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 2
                std::cout << "factorize-to-solve-transpose-upper at level "
                          << current_diag_block->bc_node->get_level() << ": ["
                          << (*current_diag_block->row_index_range)[0] << ","
                          << (*current_diag_block->row_index_range)[1] << "), ["
                          << (*current_diag_block->col_index_range)[0] << ","
                          << (*current_diag_block->col_index_range)[1]
                          << ") --> ["
                          << (*current_diag_column_block->row_index_range)[0]
                          << ","
                          << (*current_diag_column_block->row_index_range)[1]
                          << "), ["
                          << (*current_diag_column_block->col_index_range)[0]
                          << ","
                          << (*current_diag_column_block->col_index_range)[1]
                          << ")" << std::endl;
#endif
                tbb::flow::make_edge(
                  *(current_diag_block->factorize_lu_or_cholesky_graph_node),
                  *(current_diag_column_block
                      ->solve_upper_or_lower_lu_or_cholesky_graph_node));
              }
          }

        /**
         * Iterate over each trailing matrix block on a same level from the
         * diagonal block, which corresponds to the @p update stage. Both the
         * row and column index sets of the matrix block should be larger than
         * that of the diagonal block.
         *
         * @p current_diag_column_block1 points to the H-matrix node, which is
         * on a same row with the current trailing matrix node.
         * @p current_diag_column_block2 points to the H-matrix node, the
         * transpose of which is on a same column with the current trailing
         * matrix node.
         *
         * Both of them are on a same column with the current diagonal matrix
         * node.
         */
        for (HMatrix<spacedim, Number> *
               current_trailing_block =
                current_diag_block->next_same_level_hmat_node,
              *current_diag_column_block1 =
                current_diag_block->next_same_level_same_column_hmat_node,
              *current_diag_column_block2 =
                current_diag_block->next_same_level_same_column_hmat_node;
             current_trailing_block != nullptr;
             current_trailing_block =
               current_trailing_block->next_same_level_hmat_node)
          {
            /**
             * Sift out the matrix blocks having larger row and column index
             * sets than the diagonal block.
             */
            if ((*current_trailing_block->row_index_range)[0] >=
                  (*current_diag_block->row_index_range)[1] &&
                (*current_trailing_block->col_index_range)[0] >=
                  (*current_diag_block->col_index_range)[1])
              {
                bool is_diag_column_block1_found = false;
                bool is_diag_column_block2_found = false;

                /**
                 * Move the pointer @p current_diag_column_block1, so that it
                 * is in a same row with the current trailing block.
                 */
                while (current_diag_column_block1 != nullptr &&
                       current_diag_column_block1 != current_diag_block)
                  {
                    if (*current_diag_column_block1->row_index_range ==
                        *current_trailing_block->row_index_range)
                      {
                        /**
                         * When the two column index ranges match.
                         */
                        is_diag_column_block1_found = true;

                        break;
                      }
                    else if ((*current_trailing_block->row_index_range)[0] >=
                             (*current_diag_column_block1->row_index_range)[1])
                      {
                        /**
                         * Move forward @p current_diag_column_block1.
                         */
                        current_diag_column_block1 =
                          current_diag_column_block1
                            ->next_same_level_same_column_hmat_node;

                        if (current_diag_column_block1 != nullptr &&
                            (*current_diag_column_block1->row_index_range)[0] >=
                              (*current_trailing_block->row_index_range)[1])
                          {
                            /**
                             * There is no corresponding same row block for
                             * the current trailing block. This is based on
                             * the assumption/fact that the index ranges of
                             * the same level same column H-matrix blocks
                             * are increasing.
                             */
                            break;
                          }
                      }
                    else if ((*current_diag_column_block1
                                 ->row_index_range)[0] >=
                             (*current_trailing_block->row_index_range)[1])
                      {
                        /**
                         * Move back @p current_diag_column_block1.
                         */
                        current_diag_column_block1 =
                          current_diag_column_block1
                            ->previous_same_level_same_column_hmat_node;

                        if (current_diag_column_block1 != nullptr &&
                            current_diag_column_block1 != current_diag_block &&
                            (*current_trailing_block->row_index_range)[0] >=
                              (*current_diag_column_block1->row_index_range)[1])
                          {
                            /**
                             * There is no corresponding same row block for
                             * the current trailing block. This is based on
                             * the assumption/fact that the index ranges of
                             * the same level same column H-matrix blocks
                             * are increasing.
                             */
                            break;
                          }
                      }
                  }

                if (is_diag_column_block1_found)
                  {
                    /**
                     * Move the pointer @p current_diag_column_block2, so that
                     * its transpose is in a same column with the current
                     * trailing block.
                     */
                    while (current_diag_column_block2 != nullptr &&
                           current_diag_column_block2 != current_diag_block)
                      {
                        if (*current_diag_column_block2->row_index_range ==
                            *current_trailing_block->col_index_range)
                          {
                            /**
                             * When the two index ranges match.
                             */
                            is_diag_column_block2_found = true;

                            break;
                          }
                        else if ((*current_trailing_block
                                     ->col_index_range)[0] >=
                                 (*current_diag_column_block2
                                     ->row_index_range)[1])
                          {
                            /**
                             * Move forward @p current_diag_column_block2.
                             */
                            current_diag_column_block2 =
                              current_diag_column_block2
                                ->next_same_level_same_column_hmat_node;

                            if (current_diag_column_block2 != nullptr &&
                                (*current_diag_column_block2
                                    ->row_index_range)[0] >=
                                  (*current_trailing_block->col_index_range)[1])
                              {
                                /**
                                 * There is no corresponding same column block
                                 * for the current trailing block. This is based
                                 * on the assumption/fact that the index ranges
                                 * of the same level same column H-matrix blocks
                                 * are increasing.
                                 */
                                break;
                              }
                          }
                        else if ((*current_diag_column_block2
                                     ->row_index_range)[0] >=
                                 (*current_trailing_block->col_index_range)[1])
                          {
                            /**
                             * Move back @p current_diag_column_block2.
                             */
                            current_diag_column_block2 =
                              current_diag_column_block2
                                ->previous_same_level_same_column_hmat_node;

                            if (current_diag_column_block2 != nullptr &&
                                current_diag_column_block2 !=
                                  current_diag_block &&
                                (*current_trailing_block->col_index_range)[0] >=
                                  (*current_diag_column_block2
                                      ->row_index_range)[1])
                              {
                                /**
                                 * There is no corresponding same column block
                                 * for the current trailing block. This is based
                                 * on the assumption/fact that the index ranges
                                 * of the same level same column H-matrix blocks
                                 * are increasing.
                                 */
                                break;
                              }
                          }
                      }

                    if (!is_diag_column_block2_found)
                      {
                        /**
                         * Reset the pointer @p current_diag_column_block2 for
                         * the next trailing block if it has touched either end
                         * of the doubly linked list.
                         */
                        if (current_diag_column_block2 == nullptr ||
                            current_diag_column_block2 == current_diag_block)
                          {
                            current_diag_column_block2 =
                              current_diag_block
                                ->next_same_level_same_column_hmat_node;
                          }
                      }
                  }
                else
                  {
                    /**
                     * Reset the pointer @p current_diag_column_block1 for
                     * the next trailing block if it has touched either end
                     * of the doubly linked list.
                     */
                    if (current_diag_column_block1 == nullptr ||
                        current_diag_column_block1 == current_diag_block)
                      {
                        current_diag_column_block1 =
                          current_diag_block
                            ->next_same_level_same_column_hmat_node;
                      }
                  }

                /**
                 * Only when the corresponding same level, same row and column
                 * (after transpose) block for the current trailing block are
                 * found, update task will be added.
                 */
                if (is_diag_column_block1_found && is_diag_column_block2_found)
                  {
                    if (current_trailing_block->is_leaf() ||
                        current_diag_column_block1->is_leaf() ||
                        current_diag_column_block2->is_leaf())
                      {
                        /**
                         * Add the update task to the current trailing
                         * \hmatnode.
                         */
                        current_trailing_block->cholesky_update_task(
                          dag,
                          *current_diag_block,
                          *current_diag_column_block1,
                          *current_diag_column_block2,
                          fixed_rank,
                          log_stream_lock);

                        /**
                         * Iterate over the sub-block cluster tree associated
                         * with @p current_diag_column_block1 and build the
                         * edge from @p solve_upper to the current @p update node.
                         */
                        current_diag_column_block1
                          ->lu_or_cholesky_build_solve_upper_to_update_dependencies(
                            *current_trailing_block);

                        /**
                         * Iterate over the sub-block cluster tree associated
                         * with @p current_diag_column_block2 and build the
                         * edge from @p solve_upper to the current @p update node.
                         */
                        current_diag_column_block2
                          ->lu_or_cholesky_build_solve_upper_to_update_dependencies(
                            *current_trailing_block);
                      }
                  }
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::cholesky_factorize_diagonal_block_task(
    tbb::flow::graph &dag,
    std::mutex       &log_stream_lock)
  {
    /**
     * Only a diagonal block can be directly factorized.
     */
    Assert(block_type == HMatrixSupport::BlockType::diagonal_block,
           ExcInvalidHMatrixBlockType(block_type));

    this->factorize_lu_or_cholesky_graph_node = std::make_shared<TaskNode>(
      dag, [this, &log_stream_lock](const tbb::flow::continue_msg &msg) {
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 3
        {
          std::lock_guard<std::mutex> lg(log_stream_lock);

          std::cout << std::this_thread::get_id() << "#cholesky_factorize: ["
                    << (*this->row_index_range)[0] << ","
                    << (*this->row_index_range)[1] << "), ["
                    << (*this->col_index_range)[0] << ","
                    << (*this->col_index_range)[1] << ")" << std::endl;
        }
#endif

        if (this->is_leaf())
          {
            /**
             * When the current \hmatnode belongs to the leaf set, it must be a
             * symmetric full matrix and the Cholesky factorization can be
             * directly applied to it using LAPACK.
             */
            Assert(this->type == FullMatrixType,
                   ExcInvalidHMatrixType(this->type));
            Assert(this->fullmatrix != nullptr, ExcInternalError());
            Assert(this->fullmatrix->get_property() ==
                     LAPACKSupport::Property::symmetric,
                   ExcInvalidLAPACKFullMatrixProperty(
                     fullmatrix->get_property()));

            /**
             * After the Cholesky factorization, the matrix \p L is stored in the same
             * full matrix. Hence, this operation is in situ.
             */
            this->fullmatrix->compute_cholesky_factorization();
          }

        return msg;
      });
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::cholesky_solve_upper_task(
    tbb::flow::graph          &dag,
    HMatrix<spacedim, Number> &Z,
    const unsigned int         fixed_rank,
    std::mutex                &log_stream_lock)
  {
    /**
     * The current \hmatnode should be a diagonal block, while \f$Z\f$ is not.
     */
    Assert(block_type == HMatrixSupport::BlockType::diagonal_block,
           ExcInvalidHMatrixBlockType(block_type));
    Assert(Z.block_type != HMatrixSupport::BlockType::diagonal_block,
           ExcInvalidHMatrixBlockType(Z.block_type));

    /**
     * There should be no @p solve_upper task associated with
     * the \hmatnode \f$Z\f$.
     */
    Assert(!Z.solve_upper_or_lower_lu_or_cholesky_graph_node,
           ExcInternalError());

    Z.solve_upper_or_lower_lu_or_cholesky_graph_node =
      std::make_shared<TaskNode>(
        dag,
        [this, &Z, fixed_rank, &log_stream_lock](
          const tbb::flow::continue_msg &msg) {
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 3
          {
            std::lock_guard<std::mutex> lg(log_stream_lock);

            std::cout << std::this_thread::get_id()
                      << "#cholesky_solve_upper: [" << (*Z.row_index_range)[0]
                      << "," << (*Z.row_index_range)[1] << "), ["
                      << (*Z.col_index_range)[0] << ","
                      << (*Z.col_index_range)[1] << ")" << std::endl;
          }
#endif

          this->solve_cholesky_transpose_by_forward_substitution_matrix_valued(
            Z, fixed_rank);
          return msg;
        });
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::cholesky_update_task(
    tbb::flow::graph          &dag,
    HMatrix<spacedim, Number> &diag_block,
    HMatrix<spacedim, Number> &diag_column_block1,
    HMatrix<spacedim, Number> &diag_column_block2,
    const unsigned int         fixed_rank,
    std::mutex                &log_stream_lock)
  {
    this->update_lu_or_cholesky_graph_nodes.push_back(
      UpdateTaskNodeForLUOrCholesky(
        &diag_block,
        std::make_shared<TaskNode>(
          dag,
          [this,
           &diag_column_block1,
           &diag_column_block2,
           fixed_rank,
           &log_stream_lock](const tbb::flow::continue_msg &msg) {
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 3
            {
              std::lock_guard<std::mutex> lg(log_stream_lock);

              std::cout << std::this_thread::get_id() << "#cholesky_update: ["
                        << (*diag_column_block1.row_index_range)[0] << ","
                        << (*diag_column_block1.row_index_range)[1] << "), ["
                        << (*diag_column_block1.col_index_range)[0] << ","
                        << (*diag_column_block1.col_index_range)[1] << ") * ["
                        << (*diag_column_block2.row_index_range)[0] << ","
                        << (*diag_column_block2.row_index_range)[1] << "), ["
                        << (*diag_column_block2.col_index_range)[0] << ","
                        << (*diag_column_block2.col_index_range)[1] << ")^T"
                        << " --> [" << (*this->row_index_range)[0] << ","
                        << (*this->row_index_range)[1] << "), ["
                        << (*this->col_index_range)[0] << ","
                        << (*this->col_index_range)[1] << ")" << std::endl;
            }
#endif

            diag_column_block1.mTmult_level_conserving_for_parallel_cholesky(
              *this,
              -1.0,
              diag_column_block2,
              fixed_rank,
              this->property == HMatrixSupport::Property::symmetric);

            return msg;
          })));
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::cholesky_build_update_to_factorize_dependencies(
    HMatrix<spacedim, Number> &factorize_block)
  {
    for (auto &update_node : update_lu_or_cholesky_graph_nodes)
      {
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 2
        std::cout << "update-to-factorize at level ("
                  << this->bc_node->get_level() << ","
                  << factorize_block.bc_node->get_level() << "): ["
                  << (*this->row_index_range)[0] << ","
                  << (*this->row_index_range)[1] << "), ["
                  << (*this->col_index_range)[0] << ","
                  << (*this->col_index_range)[1] << ") --> ["
                  << (*factorize_block.row_index_range)[0] << ","
                  << (*factorize_block.row_index_range)[1] << "), ["
                  << (*factorize_block.col_index_range)[0] << ","
                  << (*factorize_block.col_index_range)[1] << ")" << std::endl;
#endif

        tbb::flow::make_edge(
          *update_node.update,
          *factorize_block.factorize_lu_or_cholesky_graph_node);
      }

    /**
     * Recursion into child matrices except upper triangular blocks.
     */
    for (auto submatrix : submatrices)
      {
        if (submatrix->block_type !=
            HMatrixSupport::BlockType::upper_triangular_block)
          {
            submatrix->cholesky_build_update_to_factorize_dependencies(
              factorize_block);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::cholesky_build_update_to_solve_upper_dependencies(
    HMatrix<spacedim, Number> &solve_upper_block)
  {
    Assert(block_type == HMatrixSupport::BlockType::lower_triangular_block,
           ExcInternalError());

    for (auto &update_node : update_lu_or_cholesky_graph_nodes)
      {
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 2
        Assert(solve_upper_block.block_type ==
                 HMatrixSupport::BlockType::lower_triangular_block,
               ExcInvalidHMatrixBlockType(solve_upper_block.block_type));

        std::cout << "update-to-solve-upper at level ("
                  << this->bc_node->get_level() << ","
                  << solve_upper_block.bc_node->get_level() << "): ["
                  << (*update_node.diagonal_hmat_node->row_index_range)[0]
                  << ","
                  << (*update_node.diagonal_hmat_node->row_index_range)[1]
                  << "), ["
                  << (*update_node.diagonal_hmat_node->col_index_range)[0]
                  << ","
                  << (*update_node.diagonal_hmat_node->col_index_range)[1]
                  << ") --> [" << (*solve_upper_block.row_index_range)[0] << ","
                  << (*solve_upper_block.row_index_range)[1] << "), ["
                  << (*solve_upper_block.col_index_range)[0] << ","
                  << (*solve_upper_block.col_index_range)[1] << ")"
                  << std::endl;
#endif

        tbb::flow::make_edge(
          *update_node.update,
          *solve_upper_block.solve_upper_or_lower_lu_or_cholesky_graph_node);
      }

    /**
     * Recursion into child matrices except upper triangular blocks.
     */
    for (auto submatrix : submatrices)
      {
        if (submatrix->block_type !=
            HMatrixSupport::BlockType::upper_triangular_block)
          {
            submatrix->cholesky_build_update_to_solve_upper_dependencies(
              solve_upper_block);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim,
          Number>::cholesky_assign_update_to_solve_and_factorize_dependencies()
  {
    if (solve_upper_or_lower_lu_or_cholesky_graph_node)
      {
        /**
         * Collect @p update task nodes from child \hmatnodes and build the
         * task edges from @p update to @p solve_upper or @p solve_lower.
         */
        cholesky_build_update_to_solve_upper_dependencies(*this);

        /**
         * In this case, the \hmatnode is either upper or lower triangular,
         * which cannot be a diagonal block, nor of its descendants. Therefore,
         * there will be no task edges from @p update to @p factorize anymore.
         */
      }
    else
      {
        if (block_type == HMatrixSupport::BlockType::diagonal_block)
          {
            /**
             * For the top level \hmatnode, it is a diagonal block but has no
             * factorization task with it. Therefore, here we check if the
             * factorization task node exists.
             */
            if (factorize_lu_or_cholesky_graph_node)
              {
                cholesky_build_update_to_factorize_dependencies(*this);

                /**
                 * Build the dependency between factorization task nodes on
                 * successive levels, i.e. after all diagonal blocks on a deeper
                 * level are factorized, their parent diagonal block can then be
                 * factorized.
                 */
                if (parent != nullptr &&
                    parent->factorize_lu_or_cholesky_graph_node &&
                    // Only when the current matrix block is the last diagonal
                    // block within its parent matrix, the
                    // factorization-to-factorization task dependency will be
                    // created.
                    submatrix_index == (parent->get_n_row_blocks() - 1) *
                                         (parent->get_n_col_blocks() + 1))
                  {
#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 2
                    std::cout << "factorize-to-factorize at level ("
                              << this->bc_node->get_level() << ","
                              << parent->bc_node->get_level() << "): ["
                              << (*this->row_index_range)[0] << ","
                              << (*this->row_index_range)[1] << "), ["
                              << (*this->col_index_range)[0] << ","
                              << (*this->col_index_range)[1] << ") --> ["
                              << (*parent->row_index_range)[0] << ","
                              << (*parent->row_index_range)[1] << "), ["
                              << (*parent->col_index_range)[0] << ","
                              << (*parent->col_index_range)[1] << ")"
                              << std::endl;
#endif

                    tbb::flow::make_edge(
                      *factorize_lu_or_cholesky_graph_node,
                      *parent->factorize_lu_or_cholesky_graph_node);
                  }
              }
          }

        /**
         * After processing the diagonal block, the algorithm continues to shift
         * down update task nodes to child \hmatnodes.
         */

        for (auto submatrix : submatrices)
          {
            if (submatrix->block_type !=
                HMatrixSupport::BlockType::upper_triangular_block)
              {
                /**
                 * Shift down the @p update task nodes.
                 */
                if (update_lu_or_cholesky_graph_nodes.size() > 0)
                  {
                    submatrix->update_lu_or_cholesky_graph_nodes.insert(
                      submatrix->update_lu_or_cholesky_graph_nodes.end(),
                      update_lu_or_cholesky_graph_nodes.begin(),
                      update_lu_or_cholesky_graph_nodes.end());
                  }

                submatrix
                  ->cholesky_assign_update_to_solve_and_factorize_dependencies();
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::compute_cholesky_factorization_task_parallel(
    const unsigned int fixed_rank)
  {
#if ENABLE_DEBUG == 1 && ENABLE_TIMER == 1
    Timer timer;
#endif
    /**
     * Link same level \hmatnodes on the cross of each diagonal block.
     */
    this->link_hmat_nodes_on_cross_from_diagonal_blocks(this->property);
#if ENABLE_DEBUG == 1 && ENABLE_TIMER == 1
    timer.stop();
    print_wall_time(std::cout, timer, "link h-matrix nodes");
#endif

    /**
     * Mutex used for monitoring the parallel execution of H-LU factorization.
     */
    std::mutex log_stream_lock;

    /**
     * Build the DAG.
     */
    tbb::flow::graph dag;

#if ENABLE_DEBUG == 1 && ENABLE_TIMER == 1
    timer.start();
#endif
    compute_cholesky_dag(dag, fixed_rank, log_stream_lock);
#if ENABLE_DEBUG == 1 && ENABLE_TIMER == 1
    timer.stop();
    print_wall_time(std::cout, timer, "compute dag");
#endif

#if ENABLE_DEBUG == 1 && ENABLE_TIMER == 1
    timer.start();
#endif
    cholesky_assign_update_to_solve_and_factorize_dependencies();
#if ENABLE_DEBUG == 1 && ENABLE_TIMER == 1
    timer.stop();
    print_wall_time(std::cout, timer, "contribute update");
#endif

    /**
     * Send a message to the starting task node, i.e. the first leaf node, and
     * trigger the parallel execution of the factorization.
     */
    Assert(leaf_set[0]->factorize_lu_or_cholesky_graph_node,
           ExcInternalError());

#if ENABLE_DEBUG == 1 && ENABLE_TIMER == 1
    timer.start();
#endif
    leaf_set[0]->factorize_lu_or_cholesky_graph_node->try_put(
      tbb::flow::continue_msg());

    dag.wait_for_all();
#if ENABLE_DEBUG == 1 && ENABLE_TIMER == 1
    timer.stop();
    print_wall_time(std::cout, timer, "compute cholesky");
#endif
    clear_lu_or_cholesky_task_nodes();

    /**
     * After Cholesky factorization, set the state of the current matrix to be
     * @p cholesky and set its property as @p lower_triangular.
     */
    this->set_state(HMatrixSupport::cholesky);
    this->set_property(HMatrixSupport::lower_triangular);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_lu(Vector<Number>       &x,
                                      const Vector<Number> &b) const
  {
    Assert(state == HMatrixSupport::lu, ExcInvalidHMatrixState(state));

    x = b;
    // @p L has unit diagonal.
    solve_by_forward_substitution(x, true);
    // @p U has non-unit diagonal.
    solve_by_backward_substitution(x, false);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::solve_cholesky(Vector<Number>       &x,
                                            const Vector<Number> &b) const
  {
    Assert(state == HMatrixSupport::cholesky,
           ExcMessage(std::string("Invalid H-matrix state: ") +
                      std::string(HMatrixSupport::state_name(state))));

    x = b;
    solve_cholesky_by_forward_substitution(x);
    solve_cholesky_by_backward_substitution(x);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::_invert_by_gauss_elim(
    HMatrix<spacedim, Number> &M_inv,
    const size_type            fixed_rank_k)
  {
    AssertDimension(m, n);

    /**
     * If the current matrix block to be handled has a same \f$\tau\f$
     * cluster and
     * \f$\sigma\f$ cluster and belongs to the leaf set of \p M_root, directly
     * calculate its inverse as full matrix.
     *
     * \alert{2021-10-05 At present, we assume the \hmatrix hierarchy is
     * completely the same as the associated \bct, or rather, the \bct is
     * not finer than the \hmatrix. Therefore, whether the \bcn is a leaf is
     * equivalent to whether the \hmatnode is a leaf. In a more generalized
     * implementation, the \bct can be finer than the \hmatrix hierarchy.}
     */
    if (*(bc_node->get_data_reference().get_tau_node()) ==
          *(bc_node->get_data_reference().get_sigma_node()) &&
        bc_node->is_leaf())
      {
        Assert(type == FullMatrixType, ExcInvalidHMatrixType(type));

        this->fullmatrix->invert_by_gauss_elim(*(M_inv.fullmatrix));
      }
    else
      {
        AssertDimension(get_n_row_blocks(), get_n_col_blocks());

        /**
         * Number of matrix blocks in a row, which is also the number of
         * matrix blocks in a column.
         */
        const size_type k = get_n_col_blocks();

        /**
         * Stage 1: eliminate the lower triangular part of the matrix.
         */
        for (size_type l = 0; l < k; l++)
          {
            /**
             * Calculate the inverse of the diagonal block \f$M
             * \vert_{\tau[l]\times\tau[l]}\f$. The formula \f$l + l \cdot
             * k\f$
             * calculates the 1D index of the diagonal block in \p submatrices.
             * This is because the submatrices of the current
             * \hmatnode is stored in the following order:
             *
             * <code>
             * submatrices = {tau[0]*sigma[0], tau[0]*sigma[1],
             * tau[1]*sigma[0], tau[1]*sigma[1]}
             * </code>
             *
             * Since \f$\tau\f$ is the same as \f$\sigma\f$, we have
             *
             * <code>
             * submatrices = {tau[0]*tau[0], tau[0]*tau[1], tau[1]*tau[0],
             * tau[1]*tau[1]}
             * </code>
             *
             * Hence, the index of \p tau[0]*tau[0] in \p submatrices is 0 and the
             * index of \p tau[1]*tau[1] in \p submatrices is 3. The former
             * index is calculated as <code>0 + 0 * 2 = 0</code>, while the
             * latter index is calculated as <code>1 + 1 * 2 = 3</code>.
             */
            const size_type diag_block_index_in_submatrices = l + l * k;
            submatrices[diag_block_index_in_submatrices]->_invert_by_gauss_elim(
              *(M_inv.submatrices[diag_block_index_in_submatrices]),
              fixed_rank_k);

            /**
             * Iterate over the columns from \f$l + 1\f$ to \f$k\f$ in the
             * source matrix and scale each matrix block with the factor \p
             * M_inv.submatrices[diag_block_index_in_submatrices]. Also note
             * that
             * the column index starts from zero, therefore the loop
             * variable \f$j \in [l+1, k)\f$.
             */
            for (size_type j = l + 1; j < k; j++)
              {
                HMatrix<spacedim, Number> *C =
                  new HMatrix<spacedim, Number>(submatrices[j + l * k]->bc_node,
                                                fixed_rank_k);
                M_inv.submatrices[diag_block_index_in_submatrices]
                  ->mmult_level_conserving(*C,
                                           *(submatrices[j + l * k]),
                                           fixed_rank_k);

                /**
                 * Migrate the newly created \hmat to the target submatrix.
                 */
                *(submatrices[j + l * k]) = std::move(*C);

                delete C;
              }

            /**
             * Iterate over the columns from \f$0\f$ to \f$l - 1\f$ in the
             * inverse matrix and scale each matrix block with the factor \p
             * M_inv.submatrices[diag_block_index_in_submatrices].
             */
            for (size_type j = 0; j < l; j++)
              {
                HMatrix<spacedim, Number> *C = new HMatrix<spacedim, Number>(
                  M_inv.submatrices[j + l * k]->bc_node, fixed_rank_k);
                M_inv.submatrices[diag_block_index_in_submatrices]
                  ->mmult_level_conserving(*C,
                                           *(M_inv.submatrices[j + l * k]),
                                           fixed_rank_k);

                /**
                 * Migrate the newly created \hmat to the target submatrix.
                 */
                *(M_inv.submatrices[j + l * k]) = std::move(*C);

                delete C;
              }

            /**
             * Iterate over the rows from \f$l + 1\f$ to \f$k - 1\f$ in
             * order to eliminate the matrix blocks \f$M_{l+1,l}, \cdots,
             * M_{k - 1,l}\f$.
             */
            for (size_type i = l + 1; i < k; i++)
              {
                for (size_type j = 0; j <= l; j++)
                  {
                    HMatrix<spacedim, Number> *C =
                      new HMatrix<spacedim, Number>(
                        M_inv.submatrices[j + i * k]->bc_node, fixed_rank_k);
                    submatrices[l + i * k]->mmult_level_conserving(
                      *C, *(M_inv.submatrices[j + l * k]), fixed_rank_k);
                    M_inv.submatrices[j + i * k]->add(-1.0, *C, fixed_rank_k);

                    delete C;
                  }

                for (size_type j = l + 1; j < k; j++)
                  {
                    HMatrix<spacedim, Number> *C =
                      new HMatrix<spacedim, Number>(
                        submatrices[j + i * k]->bc_node, fixed_rank_k);
                    submatrices[l + i * k]->mmult_level_conserving(
                      *C, *(submatrices[j + l * k]), fixed_rank_k);
                    submatrices[j + i * k]->add(-1.0, *C, fixed_rank_k);

                    delete C;
                  }
              }
          }

        /**
         * Stage 2: eliminate the upper triangular part of the matrix.
         */
        for (size_type l = k - 1; l > 0; l--)
          {
            /**
             * Eliminate the elements \f$M_{l-1,l}, \cdots, M_{1,l}\f$.
             */
            size_type i = l - 1;
            while (true)
              {
                for (size_type j = 0; j < k; j++)
                  {
                    HMatrix<spacedim, Number> *C =
                      new HMatrix<spacedim, Number>(
                        M_inv.submatrices[j + i * k]->bc_node, fixed_rank_k);
                    submatrices[l + i * k]->mmult_level_conserving(
                      *C, *(M_inv.submatrices[j + l * k]), fixed_rank_k);
                    M_inv.submatrices[j + i * k]->add(-1.0, *C, fixed_rank_k);

                    delete C;
                  }

                if (i == 0)
                  {
                    break;
                  }
                else
                  {
                    i--;
                  }
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::coarsen_to_subtree(
    const BlockClusterTree<spacedim, Number> &subtree,
    const unsigned int                        fixed_rank_k)
  {
    coarsen_to_partition(subtree.get_leaf_set(), fixed_rank_k);
    build_leaf_set();
    link_hmat_nodes_on_same_levels();
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::coarsen_to_partition(
    const std::vector<
      typename BlockClusterTree<spacedim, Number>::node_pointer_type>
                      &partition,
    const unsigned int fixed_rank_k)
  {
    /**
     * N.B. The function call \p find_pointer_data here involves the comparison of
     * two block cluster nodes, which internally compares the contained two
     * block clusters, which further compares the contained tau node and
     * sigma node pointers. Therefore, at the moment, the inner most
     * comparison is shallow comparison.
     */
    if (find_pointer_data(partition.begin(), partition.end(), this->bc_node) !=
        partition.end())
      {
        /**
         * The block cluster node associated with the current \hmatnode
         * belongs to the given \p partition. Then \f$\mathcal{T}_r^{\mathcal{R}
         * \leftarrow \mathcal{H}}\f$ will be applied to this \hmatnode.
         */
        convertHMatBlockToRkMatrix(this, fixed_rank_k);
      }
    else
      {
        /**
         * When the block cluster node associated with the current
         * \hmatnode does not belong to the \p partition,
         * recursively call this same member function of its each child.
         */
        for (HMatrix *submatrix : submatrices)
          {
            submatrix->coarsen_to_partition(partition, fixed_rank_k);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::link_hmat_nodes_on_same_levels()
  {
    const HMatrixSupport::Property top_hmat_property = this->property;

    std::queue<HMatrix<spacedim, Number> *> work_queue;

    if (submatrices.size() > 0)
      {
        work_queue.push(this);

        while (!work_queue.empty())
          {
            HMatrix<spacedim, Number> *current_hmat_node = work_queue.front();
            work_queue.pop();

            /**
             * When there is a subsequent \hmatrix node in the queue and if it
             * is on a same level as the current \hmatrix node, link them.
             */
            if (work_queue.size() > 0)
              {
                HMatrix<spacedim, Number> *next_hmat_node = work_queue.front();
                if (current_hmat_node->bc_node->get_level() ==
                    next_hmat_node->bc_node->get_level())
                  {
                    current_hmat_node->next_same_level_hmat_node =
                      next_hmat_node;
                  }
                else
                  {
                    current_hmat_node->next_same_level_hmat_node = nullptr;
                  }
              }
            else
              {
                current_hmat_node->next_same_level_hmat_node = nullptr;
              }

            /**
             * Push submatrix nodes of the current \hmatrix node into the queue.
             */
            for (auto hmat : current_hmat_node->submatrices)
              {
                switch (top_hmat_property)
                  {
                    case HMatrixSupport::Property::general:
                      work_queue.push(hmat);

                      break;
                    case HMatrixSupport::Property::symmetric:
                    case HMatrixSupport::Property::lower_triangular:
                      if (hmat->block_type ==
                            HMatrixSupport::BlockType::diagonal_block ||
                          hmat->block_type ==
                            HMatrixSupport::BlockType::lower_triangular_block)
                        {
                          work_queue.push(hmat);
                        }

                      break;
                    case HMatrixSupport::Property::upper_triangular:
                      if (hmat->block_type ==
                            HMatrixSupport::BlockType::diagonal_block ||
                          hmat->block_type ==
                            HMatrixSupport::BlockType::upper_triangular_block)
                        {
                          work_queue.push(hmat);
                        }

                      break;
                    default:
                      Assert(false,
                             ExcInvalidHMatrixProperty(top_hmat_property));

                      break;
                  }
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::link_hmat_nodes_on_cross_from_diagonal_blocks(
    const HMatrixSupport::Property top_hmat_property)
  {
    Assert(block_type == HMatrixSupport::BlockType::diagonal_block,
           ExcInvalidHMatrixBlockType(block_type));

    /**
     * Iterate over each \hmatrix node on the same level by starting from the
     * current diagonal block.
     */
    HMatrix<spacedim, Number> *current_hmat_node_on_same_row    = this;
    HMatrix<spacedim, Number> *current_hmat_node_on_same_column = this;

    this->next_same_level_same_row_hmat_node        = nullptr;
    this->next_same_level_same_column_hmat_node     = nullptr;
    this->previous_same_level_same_row_hmat_node    = nullptr;
    this->previous_same_level_same_column_hmat_node = nullptr;

    HMatrix<spacedim, Number> *current_hmat_node_on_same_level =
      this->next_same_level_hmat_node;

    while (current_hmat_node_on_same_level != nullptr)
      {
        /**
         * Link same level H-matrix blocks on a same row with respect to the
         * diagonal block, when the top level H-matrix is a general or upper
         * triangular matrix.
         */
        if (top_hmat_property == HMatrixSupport::Property::general ||
            top_hmat_property == HMatrixSupport::Property::upper_triangular)
          {
            /**
             * Check if the current \hmatrix node is on the same row as the
             * starting diagonal block.
             */
            if (*current_hmat_node_on_same_level->row_index_range ==
                *this->row_index_range)
              {
                /**
                 * When a same level block on a same row is found, its column
                 * index range must be larger than that of the diagonal block
                 * (but may not be contiguous).
                 */
                Assert((*current_hmat_node_on_same_level->col_index_range)[0] >=
                         (*this->col_index_range)[1],
                       ExcInternalError());

                current_hmat_node_on_same_row
                  ->next_same_level_same_row_hmat_node =
                  current_hmat_node_on_same_level;
                current_hmat_node_on_same_level
                  ->previous_same_level_same_row_hmat_node =
                  current_hmat_node_on_same_row;

                /**
                 * Move the same row hmat node pointer forward.
                 */
                current_hmat_node_on_same_row =
                  current_hmat_node_on_same_row
                    ->next_same_level_same_row_hmat_node;
              }
          }

        /**
         * Link same level H-matrix blocks on a same column with respect to the
         * diagonal block, when the top level H-matrix is a general, symmetric
         * or lower triangular matrix.
         */
        if (top_hmat_property == HMatrixSupport::Property::general ||
            top_hmat_property == HMatrixSupport::Property::symmetric ||
            top_hmat_property == HMatrixSupport::Property::lower_triangular)
          {
            /**
             * Check if the current \hmatrix node is on the same column as the
             * starting diagonal block.
             */
            if (*current_hmat_node_on_same_level->col_index_range ==
                *this->col_index_range)
              {
                /**
                 * When a same level block on a same column is found, its row
                 * index range must be larger than that of the diagonal block
                 * (but may not be contiguous).
                 */
                Assert((*current_hmat_node_on_same_level->row_index_range)[0] >=
                         (*this->row_index_range)[1],
                       ExcInternalError());

                current_hmat_node_on_same_column
                  ->next_same_level_same_column_hmat_node =
                  current_hmat_node_on_same_level;
                current_hmat_node_on_same_level
                  ->previous_same_level_same_column_hmat_node =
                  current_hmat_node_on_same_column;

                /**
                 * Move the same column hmat node pointer forward.
                 */
                current_hmat_node_on_same_column =
                  current_hmat_node_on_same_column
                    ->next_same_level_same_column_hmat_node;
              }
          }

        /**
         * Move the same level hmat node pointer forward.
         */
        current_hmat_node_on_same_level =
          current_hmat_node_on_same_level->next_same_level_hmat_node;
      }

    /**
     * Recursion into diagonal submatrices.
     */
    if (submatrices.size() > 0)
      {
        const unsigned int n_row_blocks = get_n_row_blocks();
        const unsigned int n_col_blocks = get_n_col_blocks();

        for (size_type i = 0; i < n_row_blocks; i++)
          {
            submatrices[i * n_col_blocks + i]
              ->link_hmat_nodes_on_cross_from_diagonal_blocks(
                top_hmat_property);
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::build_leaf_set()
  {
    leaf_set.clear();
    near_field_leaf_set.clear();
    far_field_leaf_set.clear();

    switch (HMatrix<spacedim, Number>::leaf_set_traversal_method)
      {
          case SpaceFillingCurveType::Z: {
            _build_leaf_set_z_traversal(leaf_set,
                                        near_field_leaf_set,
                                        far_field_leaf_set);

            break;
          }
          case SpaceFillingCurveType::Hilbert: {
            /**
             * The top level H-matrix is type A.
             */
            _build_leaf_set_hilbert_traversal(leaf_set,
                                              near_field_leaf_set,
                                              far_field_leaf_set,
                                              HilbertBlockType::A);

            break;
          }
      }
  }


  template <int spacedim, typename Number>
  inline std::vector<HMatrix<spacedim, Number> *> &
  HMatrix<spacedim, Number>::get_leaf_set()
  {
    return leaf_set;
  }


  template <int spacedim, typename Number>
  inline const std::vector<HMatrix<spacedim, Number> *> &
  HMatrix<spacedim, Number>::get_leaf_set() const
  {
    return leaf_set;
  }


  template <int spacedim, typename Number>
  inline std::vector<HMatrix<spacedim, Number> *> &
  HMatrix<spacedim, Number>::get_near_field_leaf_set()
  {
    return near_field_leaf_set;
  }


  template <int spacedim, typename Number>
  inline const std::vector<HMatrix<spacedim, Number> *> &
  HMatrix<spacedim, Number>::get_near_field_leaf_set() const
  {
    return near_field_leaf_set;
  }


  template <int spacedim, typename Number>
  inline std::vector<HMatrix<spacedim, Number> *> &
  HMatrix<spacedim, Number>::get_far_field_leaf_set()
  {
    return far_field_leaf_set;
  }


  template <int spacedim, typename Number>
  inline const std::vector<HMatrix<spacedim, Number> *> &
  HMatrix<spacedim, Number>::get_far_field_leaf_set() const
  {
    return far_field_leaf_set;
  }

  template <int spacedim, typename Number>
  inline std::array<types::global_dof_index, 2> *
  HMatrix<spacedim, Number>::get_row_index_range()
  {
    return row_index_range;
  }


  template <int spacedim, typename Number>
  inline const std::array<types::global_dof_index, 2> *
  HMatrix<spacedim, Number>::get_row_index_range() const
  {
    return row_index_range;
  }


  template <int spacedim, typename Number>
  inline std::array<types::global_dof_index, 2> *
  HMatrix<spacedim, Number>::get_col_index_range()
  {
    return col_index_range;
  }


  template <int spacedim, typename Number>
  inline const std::array<types::global_dof_index, 2> *
  HMatrix<spacedim, Number>::get_col_index_range() const
  {
    return col_index_range;
  }


  template <int spacedim, typename Number>
  typename std::vector<HMatrix<spacedim, Number> *>::iterator
  HMatrix<spacedim, Number>::find_block_cluster_in_leaf_set(
    const BlockCluster<spacedim, Number> &block_cluster)
  {
    typename std::vector<HMatrix<spacedim, Number> *>::iterator iter;
    for (iter = leaf_set.begin(); iter != leaf_set.end(); iter++)
      {
        /**
         * Perform a shallow comparison, i.e. compare by pointer address, of
         * the block clusters.
         *
         * <dl class="section note">
         *   <dt>Note</dt>
         *   <dd>The data held by those previously found leaf nodes of the
         * source \hmatrix have already been migrated to the leaf nodes of
         * the new \hmatrix, which will make the data fields in these leaf
         * nodes being empty. Hence, we will bypass them.</dd>
         * </dl>
         */
        if ((*iter)->bc_node != nullptr)
          {
            if ((*iter)->bc_node->get_data_reference() == block_cluster)
              {
                break;
              }
          }
      }

    return iter;
  }


  template <int spacedim, typename Number>
  typename std::vector<HMatrix<spacedim, Number> *>::const_iterator
  HMatrix<spacedim, Number>::find_block_cluster_in_leaf_set(
    const BlockCluster<spacedim, Number> &block_cluster) const
  {
    for (typename std::vector<HMatrix<spacedim, Number> *>::const_iterator
           iter = leaf_set.cbegin();
         iter != leaf_set.cend();
         iter++)
      {
        /**
         * Perform a shallow comparison, i.e. compare by pointer address, of
         * the block clusters.
         *
         * <dl class="section note">
         *   <dt>Note</dt>
         *   <dd>The data held by those previously found leaf nodes of the
         * source \hmatrix have already been migrated to the leaf nodes of
         * the new \hmatrix, which will make the data fields in these leaf
         * nodes being empty. Hence, we will bypass them.</dd>
         * </dl>
         */
        if ((*iter)->bc_node != nullptr)
          {
            if ((*iter)->bc_node->get_data_reference() == block_cluster)
              {
                return iter;
              }
          }
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::refine_to_supertree()
  {
    /**
     * <dl class="section">
     *   <dt>Work flow</dt>
     *   <dd>
     */

    /**
     * Iterate over the leaf set of the \hmatrix hierarchy.
     */
    for (HMatrix *hmat_leaf_node : leaf_set)
      {
        /**
         * Refine from the current \hmatrix leaf node.
         */
        RefineHMatrixWrtExtendedBlockClusterTree(hmat_leaf_node,
                                                 hmat_leaf_node);

        /**
         * After the refinement operation, we check the number of child
         * matrices of the current \hmatrix leaf node.
         */
        if (hmat_leaf_node->submatrices.size() > 0)
          {
            /**
             * If the current \hmatrix leaf node has a non-empty
             * collection of submatrices, it has really been refined. Then
             * delete its originally associated matrix data, either a full
             * matrix or a rank-k matrix, and modify its matrix type as \p
             * HierarchicalMatrixType.
             */
            switch (hmat_leaf_node->type)
              {
                  case FullMatrixType: {
                    delete hmat_leaf_node->fullmatrix;
                    hmat_leaf_node->fullmatrix = nullptr;

                    break;
                  }
                  case RkMatrixType: {
                    delete hmat_leaf_node->rkmatrix;
                    hmat_leaf_node->rkmatrix = nullptr;

                    break;
                  }
                  default: {
                    Assert(false, ExcInvalidHMatrixType(hmat_leaf_node->type));

                    break;
                  }
              }

            hmat_leaf_node->type = HierarchicalMatrixType;
          }
      }

    /**
     * After the refinement operation for all the leaf nodes of the original
     * \hmatrix hierarchy finishes, rebuild the leaf set of the
     * new \hmatrix hierarchy.
     */
    build_leaf_set();
    link_hmat_nodes_on_same_levels();

    /**
     *   </dd>
     * </dl>
     */
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::convert_between_different_block_cluster_trees(
    BlockClusterTree<spacedim, Number> &bct1,
    BlockClusterTree<spacedim, Number> &bct2,
    const unsigned int                  fixed_rank_k2)
  {
    /**
     * Make a copy of the leaf set of the target block cluster tree @p bct2,
     * which will be used for the final coarsening.
     */
    std::vector<typename BlockClusterTree<spacedim, Number>::node_pointer_type>
      target_leaf_set(bct2.get_leaf_set());

    /**
     * Extend the block cluster tree @p bct1 associated with the current
     * \hmatrix to the coarsest tree which is finer than the target block
     * cluster
     * tree @p bct2. If the block cluster tree has really been extended (because
     * it is possible that @p bct1 is already finer than @p bct2), refine the
     * \hmatrix to its extended block cluster tree.
     */
    if (bct1.extend_finer_than_partition(target_leaf_set))
      {
        this->refine_to_supertree();
      }

    /**
     * Extend \p bct2 to the finer partition obtained from \p bct1 as above (i.e.
     * having been extended). N.B. Now the leaf set of \p bct1 after refinement
     * is the same as that of \p bct2 after this extension.
     */
    bool is_bct2_extended = bct2.extend_to_finer_partition(bct1.get_leaf_set());

    /**
     * Create a new \hmatrix with respect to the extended \p bct2,
     * which accepts the data migrated from the leaf set of the current
     * \hmatrix. N.B. The current \hmatrix has been refined to the super
     * tree above.
     *
     * <dl class="section note">
     *   <dt>Note</dt>
     *   <dd><ul>
     *   <li>The actual data of an \hmatrix are stored in the leaf set nodes.
     *   <li>This hierarchical structure of the new \hmatrix is built with
     *   respect to the extended block cluster tree \p bct2.
     *   <li>The shallow copy constructor cannot be used here because the new
     *   \hmatrix has a different block cluster tree structure from the
     * current \hmatrix, even though they have the same partition after tree
     * extension.
     *   </ul></dd>
     * </dl>
     */
    HMatrix<spacedim, Number> hmat_new(bct2, std::move(*this));

    if (is_bct2_extended)
      {
        /**
         * Coarsen the new \hmatrix to the original leaf set of \p
         * bct2. Then rebuild its leaf set.
         */
        hmat_new.coarsen_to_partition(target_leaf_set, fixed_rank_k2);
        hmat_new.build_leaf_set();
        hmat_new.link_hmat_nodes_on_same_levels();

        /**
         * \mynote{The structure of the \bct associated with the \hmat is
         * still same as before, which has more levels than the \hmat.
         * Therefore, we should prune the \bct to make it consistent with
         * the \hmat.}
         */
        //      std::ofstream out1("target_bct_with_extension.dat");
        //      bct2.write_leaf_set(out1);
        //      out1.close();
        //      std::cout << "=== bct2 with extension ===\n";
        //      std::cout << "Number of nodes: " << bct2.get_node_num()
        //                << "\nDepth: " << bct2.get_depth()
        //                << "\nMax level: " << bct2.get_max_level() <<
        //                std::endl;
        bct2.prune_to_partition(target_leaf_set, true);
        //      std::ofstream out2("target_bct_after_pruning.dat");
        //      bct2.write_leaf_set(out2);
        //      out2.close();
        //      std::cout << "=== bct2 after pruning ===\n";
        //      std::cout << "Number of nodes: " << bct2.get_node_num()
        //                << "\nDepth: " << bct2.get_depth()
        //                << "\nMax level: " << bct2.get_max_level() <<
        //                std::endl;
      }

    /**
     * Move the new \hmatrix to the current
     * \hmatrix by shallow assignment.
     */
    (*this) = std::move(hmat_new);
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::remove_hmat_pair_from_mm_product_list(
    const HMatrix<spacedim, Number> *M1,
    const HMatrix<spacedim, Number> *M2)
  {
    std::pair<HMatrix<spacedim, Number> *, HMatrix<spacedim, Number> *>
      current_hmat_pair(const_cast<HMatrix<spacedim, Number> *>(M1),
                        const_cast<HMatrix<spacedim, Number> *>(M2));

    typename std::vector<std::pair<HMatrix<spacedim, Number> *,
                                   HMatrix<spacedim, Number> *>>::iterator
      matched_hmat_pair_iter =
        std::find(Sigma_P.begin(), Sigma_P.end(), current_hmat_pair);

    if (matched_hmat_pair_iter != Sigma_P.end())
      {
        Sigma_P.erase(matched_hmat_pair_iter);
      }
  }


  template <int spacedim, typename Number>
  void
  HMatrix<spacedim, Number>::remove_hmat_pair_from_mm_product_list(
    const std::pair<const HMatrix<spacedim, Number> *,
                    const HMatrix<spacedim, Number> *> &hmat_pair)
  {
    typename std::vector<std::pair<HMatrix<spacedim, Number> *,
                                   HMatrix<spacedim, Number> *>>::iterator
      matched_hmat_pair_iter =
        std::find(Sigma_P.begin(), Sigma_P.end(), hmat_pair);

    if (matched_hmat_pair_iter != Sigma_P.end())
      {
        Sigma_P.erase(matched_hmat_pair_iter);
      }
  }


  template <int spacedim, typename Number>
  TreeNodeSplitMode
  HMatrix<spacedim, Number>::determine_mm_split_mode_from_Sigma_P()
  {
    TreeNodeSplitMode initial_split_mode, current_split_mode;

    size_type counter = 0;
    for (const std::pair<HMatrix<spacedim, Number> *,
                         HMatrix<spacedim, Number> *> &hmat_pair : Sigma_P)
      {
        if ((hmat_pair.first->bc_node->get_split_mode() ==
               HorizontalSplitMode &&
             hmat_pair.second->bc_node->get_split_mode() == UnsplitMode) ||
            (hmat_pair.first->bc_node->get_split_mode() == CrossSplitMode &&
             hmat_pair.second->bc_node->get_split_mode() ==
               HorizontalSplitMode))
          {
            current_split_mode = HorizontalSplitMode;
          }
        else if ((hmat_pair.first->bc_node->get_split_mode() == UnsplitMode &&
                  hmat_pair.second->bc_node->get_split_mode() ==
                    VerticalSplitMode) ||
                 (hmat_pair.first->bc_node->get_split_mode() ==
                    VerticalSplitMode &&
                  hmat_pair.second->bc_node->get_split_mode() ==
                    CrossSplitMode))
          {
            current_split_mode = VerticalSplitMode;
          }
        else if ((hmat_pair.first->bc_node->get_split_mode() ==
                    CrossSplitMode &&
                  hmat_pair.second->bc_node->get_split_mode() ==
                    CrossSplitMode) ||
                 (hmat_pair.first->bc_node->get_split_mode() ==
                    HorizontalSplitMode &&
                  hmat_pair.second->bc_node->get_split_mode() ==
                    VerticalSplitMode))
          {
            current_split_mode = CrossSplitMode;
          }
        else
          {
            Assert(
              false,
              ExcMessage(
                "Inconsistent case met during H-matrix MM multiplication"));
          }

        if (counter == 0)
          {
            initial_split_mode = current_split_mode;
          }
        else if (current_split_mode != initial_split_mode)
          {
            Assert(
              false,
              ExcMessage(
                "Inconsistent case met during H-matrix MM multiplication"));
          }

        counter++;
      }

    return initial_split_mode;
  }

  template <int spacedim, typename Number>
  std::size_t
  HMatrix<spacedim, Number>::memory_consumption_of_current_hmat_node() const
  {
    std::size_t memory_for_hmat_node = 0;

    /**
     * If the current \hmatnode is a leaf node, get the memory for the
     * associated matrix.
     */
    if (type == FullMatrixType)
      {
        memory_for_hmat_node += this->fullmatrix->memory_consumption();
      }
    else if (type == RkMatrixType)
      {
        memory_for_hmat_node += this->rkmatrix->memory_consumption();
      }

    /**
     * Count the memory for other members in the current \hmatnode.
     */
    memory_for_hmat_node +=
      sizeof(*this) +
      (MemoryConsumption::memory_consumption(leaf_set) - sizeof(leaf_set)) +
      (MemoryConsumption::memory_consumption(submatrices) -
       sizeof(submatrices)) +
      (MemoryConsumption::memory_consumption(near_field_leaf_set) -
       sizeof(near_field_leaf_set)) +
      (MemoryConsumption::memory_consumption(far_field_leaf_set) -
       sizeof(far_field_leaf_set)) +
      (Tind.memory_consumption() - sizeof(Tind)) +
      (MemoryConsumption::memory_consumption(Sigma_P) - sizeof(Sigma_P)) +
      (MemoryConsumption::memory_consumption(Sigma_R) - sizeof(Sigma_R)) +
      (MemoryConsumption::memory_consumption(Sigma_F) - sizeof(Sigma_F));

    return memory_for_hmat_node;
  }


  template <int spacedim, typename Number>
  std::size_t
  HMatrix<spacedim, Number>::memory_consumption() const
  {
    std::size_t total_memory = 0;

    total_memory += memory_consumption_of_current_hmat_node();

    for (auto submatrix : submatrices)
      {
        total_memory += submatrix->memory_consumption();
      }

    return total_memory;
  }


  template <int spacedim, typename Number>
  std::size_t
  HMatrix<spacedim, Number>::memory_consumption_of_leaf_set() const
  {
    std::size_t total_memory = 0;

    for (auto hmat : leaf_set)
      {
        total_memory += hmat->memory_consumption();
      }

    return total_memory;
  }


  template <int spacedim, typename Number>
  std::size_t
  HMatrix<spacedim, Number>::memory_consumption_of_near_field_leaf_set() const
  {
    std::size_t total_memory = 0;

    for (auto hmat : near_field_leaf_set)
      {
        total_memory += hmat->memory_consumption();
      }

    return total_memory;
  }


  template <int spacedim, typename Number>
  std::size_t
  HMatrix<spacedim, Number>::memory_consumption_of_far_field_leaf_set() const
  {
    std::size_t total_memory = 0;

    for (auto hmat : far_field_leaf_set)
      {
        total_memory += hmat->memory_consumption();
      }

    return total_memory;
  }
} // namespace HierBEM

#endif /* INCLUDE_HMATRIX_H_ */
