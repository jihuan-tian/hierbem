// Copyright (C) 2022-2025 Jihuan Tian <jihuan_tian@hotmail.com>
//
// This file is part of the HierBEM library.
//
// HierBEM is free software: you can use it, redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as published by the
// Free Software Foundation, either version 3 of the License, or (at your
// option) any later version. The full text of the license can be found in the
// file LICENSE at the top level directory of HierBEM.

/**
 * @file bem_general.h
 * @brief Introduction of bem_general.h
 *
 * @date 2022-03-04
 * @author Jihuan Tian
 */
#ifndef HIERBEM_INCLUDE_BEM_BEM_GENERAL_H_
#define HIERBEM_INCLUDE_BEM_BEM_GENERAL_H_

#include <deal.II/base/exceptions.h>
#include <deal.II/base/function.h>
#include <deal.II/base/numbers.h>
#include <deal.II/base/point.h>
#include <deal.II/base/quadrature.h>
#include <deal.II/base/quadrature_lib.h>
#include <deal.II/base/tensor.h>
#include <deal.II/base/types.h>
#include <deal.II/base/work_stream.h>

#include <deal.II/dofs/dof_handler.h>
#include <deal.II/dofs/dof_tools.h>

#include <deal.II/fe/fe_update_flags.h>
#include <deal.II/fe/mapping_q.h>

#include <deal.II/lac/sparse_matrix.h>

#include <deal.II/numerics/vector_tools.h>
#include <deal.II/numerics/vector_tools_interpolate.templates.h>

#include <functional>
#include <map>
#include <set>
#include <type_traits>
#include <utility>
#include <vector>

#include "bem_kernels.hcu"
#include "bem_tools.h"
#include "bem_values.hcu"
#include "cad_mesh/gmsh_manipulation.h"
#include "cad_mesh/subdomain_topology.h"
#include "config.h"
#include "dofs/dof_tools_ext.h"
#include "linear_algebra/linalg.h"
#include "mapping/mapping_info.h"
#include "quadrature/sauter_quadrature.hcu"
#include "utilities/number_traits.h"

HBEM_NS_OPEN

using namespace dealii;
using namespace BEMTools;

/**
 * Assemble the mass matrix in FEM on one cell.
 *
 * The results is stored in a local cellwise matrix in the copy data.
 *
 * @pre
 * @post
 * @tparam dim
 * @tparam spacedim
 * @tparam RangeNumberType
 * @param factor
 * @param iterator_for_cell_iterator_pairs
 * @param scratch_data
 * @param copy_data
 */
template <int dim, int spacedim, typename RangeNumberType>
void
assemble_fem_scaled_mass_matrix_on_one_cell(
  const RangeNumberType factor,
  const typename std::vector<std::pair<
    typename DoFHandler<dim, spacedim>::active_cell_iterator,
    typename DoFHandler<dim, spacedim>::active_cell_iterator>>::const_iterator
    &iterator_for_cell_iterator_pairs,
  CellWiseScratchDataForMassMatrix<dim, spacedim>               &scratch_data,
  CellWiseCopyDataForMassMatrix<dim, spacedim, RangeNumberType> &copy_data)
{
  /**
   * Clear the local matrix in case that it is reused from another finished
   * task. N.B. Its memory has already been allocated in the constructor of
   * @p CellWisePerTaskData.
   */
  copy_data.local_matrix.reinit(
    copy_data.local_dof_indices_for_test_space.size(),
    copy_data.local_dof_indices_for_trial_space.size());

  /**
   * N.B. The construction of the object <code>scratch.fe_values</code> is
   * carried out in the constructor of <code>CellWiseScratchData</code>.
   *
   * \comment{2022-06-27 I added a @p const keyword at the front to protect
   * the internal data in the cell. Since the vector of cell iterator pairs
   * persists at least in this function, I create references to the two cell
   * iterators instead of making copies.}
   */
  const typename DoFHandler<dim, spacedim>::active_cell_iterator
    &cell_iter_for_test_space_domain = iterator_for_cell_iterator_pairs->first;
  const typename DoFHandler<dim, spacedim>::active_cell_iterator &
    cell_iter_for_trial_space_domain = iterator_for_cell_iterator_pairs->second;

  /**
   * Reinitialize the @p FEValues objects for test space and trial space
   * for the current cell.
   */
  scratch_data.fe_values_for_test_space.reinit(cell_iter_for_test_space_domain);
  scratch_data.fe_values_for_trial_space.reinit(
    cell_iter_for_trial_space_domain);

  AssertDimension(
    scratch_data.fe_values_for_test_space.get_quadrature().size(),
    scratch_data.fe_values_for_trial_space.get_quadrature().size());
  const unsigned int n_q_points =
    scratch_data.fe_values_for_test_space.get_quadrature().size();

  const unsigned int dofs_per_cell_for_test_space =
    scratch_data.fe_values_for_test_space.get_fe().dofs_per_cell;
  const unsigned int dofs_per_cell_for_trial_space =
    scratch_data.fe_values_for_trial_space.get_fe().dofs_per_cell;

  /**
   *  Extract the DoF indices. N.B. Before calling
   * <code>get_dof_indices</code>, the memory for the argument vector should
   * have been allocated. Here, the memory for
   * <code>data.local_dof_indices</code> has been allocated in the
   * constructor of <code>CellWisePerTaskData</code>.
   */
  cell_iter_for_test_space_domain->get_dof_indices(
    copy_data.local_dof_indices_for_test_space);
  cell_iter_for_trial_space_domain->get_dof_indices(
    copy_data.local_dof_indices_for_trial_space);

  /**
   * Calculate the local mass matrix multiplied by a factor in the
   * current cell.
   */
  // Iterate over test function DoFs.
  for (unsigned int i = 0; i < dofs_per_cell_for_test_space; i++)
    {
      // Iterate over trial function DoFs.
      for (unsigned int j = 0; j < dofs_per_cell_for_trial_space; j++)
        {
          // Iterate over each quadrature point.
          for (unsigned int q = 0; q < n_q_points; q++)
            {
              Assert(
                scratch_data.fe_values_for_test_space.JxW(q) ==
                  scratch_data.fe_values_for_trial_space.JxW(q),
                ExcMessage(
                  "The JxW values in test space domain and trial space domain should be the same!"));

              copy_data.local_matrix(i, j) +=
                factor *
                scratch_data.fe_values_for_test_space.shape_value(i, q) *
                scratch_data.fe_values_for_trial_space.shape_value(j, q) *
                scratch_data.fe_values_for_test_space.JxW(q);
            }
        }
    }
}


/**
 * Assemble the mass matrix in FEM on one cell.
 *
 * This version is used for building a mass matrix on a subdomain.
 */
template <int dim, int spacedim, typename RangeNumberType>
void
assemble_fem_scaled_mass_matrix_on_one_cell(
  const RangeNumberType    factor,
  const std::vector<bool> &dof_selectors_test_space,
  const std::vector<bool> &dof_selectors_trial_space,
  const typename std::vector<std::pair<
    typename DoFHandler<dim, spacedim>::active_cell_iterator,
    typename DoFHandler<dim, spacedim>::active_cell_iterator>>::const_iterator
    &iterator_for_cell_iterator_pairs,
  CellWiseScratchDataForMassMatrix<dim, spacedim>               &scratch_data,
  CellWiseCopyDataForMassMatrix<dim, spacedim, RangeNumberType> &copy_data)
{
  /**
   * Clear the local matrix in case that it is reused from another finished
   * task. N.B. Its memory has already been allocated in the constructor of
   * @p CellWisePerTaskData.
   */
  copy_data.local_matrix.reinit(
    copy_data.local_dof_indices_for_test_space.size(),
    copy_data.local_dof_indices_for_trial_space.size());

  /**
   * N.B. The construction of the object <code>scratch.fe_values</code> is
   * carried out in the constructor of <code>CellWiseScratchData</code>.
   *
   * \comment{2022-06-27 I added a @p const keyword at the front to protect
   * the internal data in the cell. Since the vector of cell iterator pairs
   * persists at least in this function, I create references to the two cell
   * iterators instead of making copies.}
   */
  const typename DoFHandler<dim, spacedim>::active_cell_iterator
    &cell_iter_for_test_space_domain = iterator_for_cell_iterator_pairs->first;
  const typename DoFHandler<dim, spacedim>::active_cell_iterator &
    cell_iter_for_trial_space_domain = iterator_for_cell_iterator_pairs->second;

  /**
   * Reinitialize the @p FEValues objects for test space and trial space
   * for the current cell.
   */
  scratch_data.fe_values_for_test_space.reinit(cell_iter_for_test_space_domain);
  scratch_data.fe_values_for_trial_space.reinit(
    cell_iter_for_trial_space_domain);

  AssertDimension(
    scratch_data.fe_values_for_test_space.get_quadrature().size(),
    scratch_data.fe_values_for_trial_space.get_quadrature().size());
  const unsigned int n_q_points =
    scratch_data.fe_values_for_test_space.get_quadrature().size();

  const unsigned int dofs_per_cell_for_test_space =
    scratch_data.fe_values_for_test_space.get_fe().dofs_per_cell;
  const unsigned int dofs_per_cell_for_trial_space =
    scratch_data.fe_values_for_trial_space.get_fe().dofs_per_cell;

  /**
   *  Extract the DoF indices. N.B. Before calling
   * <code>get_dof_indices</code>, the memory for the argument vector should
   * have been allocated. Here, the memory for
   * <code>data.local_dof_indices</code> has been allocated in the
   * constructor of <code>CellWisePerTaskData</code>.
   */
  cell_iter_for_test_space_domain->get_dof_indices(
    copy_data.local_dof_indices_for_test_space);
  cell_iter_for_trial_space_domain->get_dof_indices(
    copy_data.local_dof_indices_for_trial_space);

  /**
   * Calculate the local mass matrix multiplied by a factor in the
   * current cell.
   */
  // Iterate over test function DoFs.
  for (unsigned int i = 0; i < dofs_per_cell_for_test_space; i++)
    {
      // Iterate over trial function DoFs.
      for (unsigned int j = 0; j < dofs_per_cell_for_trial_space; j++)
        {
          if (dof_selectors_test_space.at(
                copy_data.local_dof_indices_for_test_space[i]) &&
              dof_selectors_trial_space.at(
                copy_data.local_dof_indices_for_trial_space[j]))
            // Iterate over each quadrature point.
            for (unsigned int q = 0; q < n_q_points; q++)
              {
                Assert(
                  scratch_data.fe_values_for_test_space.JxW(q) ==
                    scratch_data.fe_values_for_trial_space.JxW(q),
                  ExcMessage(
                    "The JxW values in test space domain and trial space domain should be the same!"));

                copy_data.local_matrix(i, j) +=
                  factor *
                  scratch_data.fe_values_for_test_space.shape_value(i, q) *
                  scratch_data.fe_values_for_trial_space.shape_value(j, q) *
                  scratch_data.fe_values_for_test_space.JxW(q);
              }
        }
    }
}


/**
 * @brief Copy locally assembled mass matrix on a cell to the global mass
 * matrix.
 */
template <int dim, int spacedim, typename RangeNumberType, typename MatrixType>
void
copy_cell_local_to_global_for_fem_matrix(
  const CellWiseCopyDataForMassMatrix<dim, spacedim, RangeNumberType> &data,
  MatrixType &target_matrix)
{
  const unsigned int dofs_per_cell_for_test_space  = data.local_matrix.m();
  const unsigned int dofs_per_cell_for_trial_space = data.local_matrix.n();

  for (unsigned int i = 0; i < dofs_per_cell_for_test_space; i++)
    {
      for (unsigned int j = 0; j < dofs_per_cell_for_trial_space; j++)
        {
          target_matrix.add(data.local_dof_indices_for_test_space[i],
                            data.local_dof_indices_for_trial_space[j],
                            data.local_matrix(i, j));
        }
    }
}


/**
 * Copy locally assembled mass matrix on a cell to the global mass matrix.
 *
 * In this version, the global mass matrix is built on a subdomain. Only those
 * entries in the local cell matrix corresponding to selected DoFs will be added
 * to the target matrix.
 */
template <int dim, int spacedim, typename RangeNumberType, typename MatrixType>
void
copy_cell_local_to_global_for_fem_matrix(
  const CellWiseCopyDataForMassMatrix<dim, spacedim, RangeNumberType> &data,
  const std::vector<bool> &dof_selectors_test_space,
  const std::vector<types::global_dof_index>
                          &full_to_local_dof_id_map_test_space,
  const std::vector<bool> &dof_selectors_trial_space,
  const std::vector<types::global_dof_index>
             &full_to_local_dof_id_map_trial_space,
  MatrixType &target_matrix)
{
  const unsigned int dofs_per_cell_for_test_space  = data.local_matrix.m();
  const unsigned int dofs_per_cell_for_trial_space = data.local_matrix.n();

  for (unsigned int i = 0; i < dofs_per_cell_for_test_space; i++)
    {
      for (unsigned int j = 0; j < dofs_per_cell_for_trial_space; j++)
        {
          if (dof_selectors_test_space.at(
                data.local_dof_indices_for_test_space[i]) &&
              dof_selectors_trial_space.at(
                data.local_dof_indices_for_trial_space[j]))
            target_matrix.add(full_to_local_dof_id_map_test_space.at(
                                data.local_dof_indices_for_test_space[i]),
                              full_to_local_dof_id_map_trial_space.at(
                                data.local_dof_indices_for_trial_space[j]),
                              data.local_matrix(i, j));
        }
    }
}


/**
 * Initialize the cell iterator pointer pairs for the DoFHandlers
 * associated with test space and trial space. N.B. The test space comes
 * before the trial space.
 *
 * \mynote{This function is to assist the assembly of the FEM mass matrix.
 * For Dirichlet problem, it is \f$\mathcal{I}\f$ on \f$\left(
 * H^{-\frac{1}{2}+s}(\Gamma_{\rm D}), H^{\frac{1}{2}+s}(\Gamma_{\rm D})
 * \right) \f$.
 *
 * For mixed boundary value problem, they are
 * 1. \f$\mathcal{I}_1\f$ on \f$\left( H^{-\frac{1}{2}+s}(\Gamma_{\rm D}),
 * H^{\frac{1}{2}+s}(\Gamma_{\rm D}) \right) \f$
 * 2. \f$\mathcal{I}_2\f$ on \f$\left( H^{\frac{1}{2}+s}(\Gamma_{\rm N}),
 * H^{-\frac{1}{2}+s}(\Gamma_{\rm N}) \right)\f$
 *
 * It can be seen that for the mass matrices, the test space and trial
 * space are situated on a same triangulation.}
 *
 * @param dof_handler_for_test_space
 * @param dof_handler_for_trial_space
 * @param cell_iterator_pairs_for_mass_matrix
 */
template <int dim, int spacedim>
void
initialize_cell_iterator_pairs_for_mass_matrix(
  const DoFHandler<dim, spacedim> &dof_handler_for_test_space,
  const DoFHandler<dim, spacedim> &dof_handler_for_trial_space,
  std::vector<
    std::pair<typename DoFHandler<dim, spacedim>::active_cell_iterator,
              typename DoFHandler<dim, spacedim>::active_cell_iterator>>
    &cell_iterator_pairs_for_mass_matrix)
{
  /**
   * Because the two spaces are associated with a same triangulation, the
   * number of cells inferred from the two DoFHandlers should be the same.
   */
  AssertDimension(
    dof_handler_for_test_space.get_triangulation().n_active_cells(),
    dof_handler_for_trial_space.get_triangulation().n_active_cells());

  /**
   * The memory for the result vector should be preallocated.
   */
  AssertDimension(
    dof_handler_for_test_space.get_triangulation().n_active_cells(),
    cell_iterator_pairs_for_mass_matrix.size());

  typename DoFHandler<dim, spacedim>::active_cell_iterator
    cell_iterator_for_test_space = dof_handler_for_test_space.begin_active();
  typename DoFHandler<dim, spacedim>::active_cell_iterator
    cell_iterator_for_trial_space = dof_handler_for_trial_space.begin_active();

  std::size_t counter = 0;
  for (; cell_iterator_for_test_space != dof_handler_for_test_space.end();
       cell_iterator_for_test_space++,
       cell_iterator_for_trial_space++,
       counter++)
    {
      /**
       * \mynote{N.B. The cell iterator for the test space appears before
       * that for the trial space in the pair.}
       */
      cell_iterator_pairs_for_mass_matrix[counter].first =
        cell_iterator_for_test_space;
      cell_iterator_pairs_for_mass_matrix[counter].second =
        cell_iterator_for_trial_space;
    }
}


/**
 * Initialize the cell iterator pointer pairs for the DoFHandlers
 * associated with test space and trial space on the subdomain. N.B. The test
 * space comes before the trial space.
 *
 * This version only iterate over the cells in the subdomain specified by a set
 * of material ids.
 */
template <int dim, int spacedim>
void
initialize_cell_iterator_pairs_for_mass_matrix(
  const DoFHandler<dim, spacedim>    &dof_handler_for_test_space,
  const DoFHandler<dim, spacedim>    &dof_handler_for_trial_space,
  const std::set<types::material_id> &subdomain_material_ids,
  std::vector<
    std::pair<typename DoFHandler<dim, spacedim>::active_cell_iterator,
              typename DoFHandler<dim, spacedim>::active_cell_iterator>>
    &cell_iterator_pairs_for_mass_matrix)
{
  /**
   * Because the two spaces are associated with a same triangulation, the
   * number of cells inferred from the two DoFHandlers should be the same.
   */
  AssertDimension(
    dof_handler_for_test_space.get_triangulation().n_active_cells(),
    dof_handler_for_trial_space.get_triangulation().n_active_cells());

  typename DoFHandler<dim, spacedim>::active_cell_iterator
    cell_iterator_for_test_space = dof_handler_for_test_space.begin_active();
  typename DoFHandler<dim, spacedim>::active_cell_iterator
    cell_iterator_for_trial_space = dof_handler_for_trial_space.begin_active();

  for (; cell_iterator_for_test_space != dof_handler_for_test_space.end();
       cell_iterator_for_test_space++, cell_iterator_for_trial_space++)
    {
      auto found_iter = subdomain_material_ids.find(
        cell_iterator_for_test_space->material_id());

      if (found_iter != subdomain_material_ids.end())
        cell_iterator_pairs_for_mass_matrix.push_back(
          {cell_iterator_for_test_space, cell_iterator_for_trial_space});
    }
}


/**
 * Assemble the mass matrix in FEM.
 *
 * \mynote{We should bear in mind the following points.
 * 1. The test and ansatz function spaces related to the mass matrix may
 * be two different function spaces but residing on a same triangulation;
 * 2. Unlike a full matrix involved in BEM, a non-zero cellwise integration
 * for the assembly of the mass matrix requires the test and ansatz basis
 * functions have overlapping supports.
 * 3. Since the two function spaces on a same triangulation are different
 * spaces, there are two DoF handlers and two cell iterators. And the two cell
 * iterators should step forward synchronously. Therefore, in this function,
 * there is the definition of cell iterator pair.}
 *
 * @param dof_handler_for_test_space
 * @param dof_handler_for_trial_space
 * @param factor
 * @param quad_rule
 * @param target_matrix The target mass matrix to be assembled, which can be
 * either a full matrix or sparse matrix.
 */
template <int dim, int spacedim, typename RangeNumberType, typename MatrixType>
void
assemble_fem_scaled_mass_matrix(
  const DoFHandler<dim, spacedim> &dof_handler_for_test_space,
  const DoFHandler<dim, spacedim> &dof_handler_for_trial_space,
  const RangeNumberType            factor,
  const Quadrature<dim>           &quad_rule,
  MatrixType                      &target_matrix)
{
  // Because the test and ansatz function spaces related to the mass matrix
  // are on a same spatial domain, here we make an assertion about the
  // equality of the number of cells in their respective triangulations.
  AssertDimension(
    dof_handler_for_test_space.get_triangulation().n_active_cells(),
    dof_handler_for_trial_space.get_triangulation().n_active_cells());

  std::vector<
    std::pair<typename DoFHandler<dim, spacedim>::active_cell_iterator,
              typename DoFHandler<dim, spacedim>::active_cell_iterator>>
    cell_iterator_pairs_for_mass_matrix(
      dof_handler_for_test_space.get_triangulation().n_active_cells());

  initialize_cell_iterator_pairs_for_mass_matrix(
    dof_handler_for_test_space,
    dof_handler_for_trial_space,
    cell_iterator_pairs_for_mass_matrix);

  WorkStream::run(
    cell_iterator_pairs_for_mass_matrix.begin(),
    cell_iterator_pairs_for_mass_matrix.end(),
    [factor](const auto &iterator_for_cell_iterator_pairs,
             auto       &scratch_data,
             auto       &copy_data) {
      assemble_fem_scaled_mass_matrix_on_one_cell(
        factor, iterator_for_cell_iterator_pairs, scratch_data, copy_data);
    },
    [&target_matrix](const auto &data) {
      copy_cell_local_to_global_for_fem_matrix(data, target_matrix);
    },
    CellWiseScratchDataForMassMatrix<dim, spacedim>(
      dof_handler_for_test_space.get_fe(),
      dof_handler_for_trial_space.get_fe(),
      quad_rule,
      update_values | update_JxW_values),
    CellWiseCopyDataForMassMatrix<dim, spacedim, RangeNumberType>(
      dof_handler_for_test_space.get_fe(),
      dof_handler_for_trial_space.get_fe()));
}


/**
 * Assemble the mass matrix in FEM on subdomain for active cells.
 *
 * The shape functions may extend over the boundary of the subdomain, so that
 * we iterate over each cell in the triangulation, without checking if the
 * cell is within the subdomain.
 */
template <int dim, int spacedim, typename RangeNumberType, typename MatrixType>
void
assemble_fem_scaled_mass_matrix(
  const DoFHandler<dim, spacedim> &dof_handler_for_test_space,
  const DoFHandler<dim, spacedim> &dof_handler_for_trial_space,
  const std::vector<bool>         &dof_selectors_test_space,
  const std::vector<types::global_dof_index>
                          &full_to_local_dof_id_map_test_space,
  const std::vector<bool> &dof_selectors_trial_space,
  const std::vector<types::global_dof_index>
                        &full_to_local_dof_id_map_trial_space,
  const RangeNumberType  factor,
  const Quadrature<dim> &quad_rule,
  MatrixType            &target_matrix)
{
  // Because the test and ansatz function spaces related to the mass matrix
  // are on a same spatial domain, here we make an assertion about the
  // equality of the number of cells in their respective triangulations.
  AssertDimension(
    dof_handler_for_test_space.get_triangulation().n_active_cells(),
    dof_handler_for_trial_space.get_triangulation().n_active_cells());

  std::vector<
    std::pair<typename DoFHandler<dim, spacedim>::active_cell_iterator,
              typename DoFHandler<dim, spacedim>::active_cell_iterator>>
    cell_iterator_pairs_for_mass_matrix(
      dof_handler_for_test_space.get_triangulation().n_active_cells());

  initialize_cell_iterator_pairs_for_mass_matrix(
    dof_handler_for_test_space,
    dof_handler_for_trial_space,
    cell_iterator_pairs_for_mass_matrix);

  WorkStream::run(
    cell_iterator_pairs_for_mass_matrix.begin(),
    cell_iterator_pairs_for_mass_matrix.end(),
    [factor,
     &dof_selectors_test_space,
     &dof_selectors_trial_space](const auto &iterator_for_cell_iterator_pairs,
                                 auto       &scratch_data,
                                 auto       &copy_data) {
      assemble_fem_scaled_mass_matrix_on_one_cell(
        factor,
        dof_selectors_test_space,
        dof_selectors_trial_space,
        iterator_for_cell_iterator_pairs,
        scratch_data,
        copy_data);
    },
    [&](const auto &data) {
      copy_cell_local_to_global_for_fem_matrix(
        data,
        dof_selectors_test_space,
        full_to_local_dof_id_map_test_space,
        dof_selectors_trial_space,
        full_to_local_dof_id_map_trial_space,
        target_matrix);
    },
    CellWiseScratchDataForMassMatrix<dim, spacedim>(
      dof_handler_for_test_space.get_fe(),
      dof_handler_for_trial_space.get_fe(),
      quad_rule,
      update_values | update_JxW_values),
    CellWiseCopyDataForMassMatrix<dim, spacedim, RangeNumberType>(
      dof_handler_for_test_space.get_fe(),
      dof_handler_for_trial_space.get_fe()));
}


/**
 * Assemble the mass matrix in FEM on subdomain for active cells.
 *
 * The shape functions are assumed to be truncated within the subdomain, so
 * we iterate over each cell in the subdomain.
 */
template <int dim, int spacedim, typename RangeNumberType, typename MatrixType>
void
assemble_fem_scaled_mass_matrix(
  const DoFHandler<dim, spacedim>    &dof_handler_for_test_space,
  const DoFHandler<dim, spacedim>    &dof_handler_for_trial_space,
  const std::set<types::material_id> &subdomain_material_ids,
  const std::vector<bool>            &dof_selectors_test_space,
  const std::vector<types::global_dof_index>
                          &full_to_local_dof_id_map_test_space,
  const std::vector<bool> &dof_selectors_trial_space,
  const std::vector<types::global_dof_index>
                        &full_to_local_dof_id_map_trial_space,
  const RangeNumberType  factor,
  const Quadrature<dim> &quad_rule,
  MatrixType            &target_matrix)
{
  // Because the test and ansatz function spaces related to the mass matrix
  // are on a same spatial domain, here we make an assertion about the
  // equality of the number of cells in their respective triangulations.
  AssertDimension(
    dof_handler_for_test_space.get_triangulation().n_active_cells(),
    dof_handler_for_trial_space.get_triangulation().n_active_cells());

  std::vector<
    std::pair<typename DoFHandler<dim, spacedim>::active_cell_iterator,
              typename DoFHandler<dim, spacedim>::active_cell_iterator>>
    cell_iterator_pairs_for_mass_matrix;
  cell_iterator_pairs_for_mass_matrix.reserve(
    dof_handler_for_test_space.get_triangulation().n_active_cells());

  initialize_cell_iterator_pairs_for_mass_matrix(
    dof_handler_for_test_space,
    dof_handler_for_trial_space,
    subdomain_material_ids,
    cell_iterator_pairs_for_mass_matrix);

  WorkStream::run(
    cell_iterator_pairs_for_mass_matrix.begin(),
    cell_iterator_pairs_for_mass_matrix.end(),
    [factor,
     &dof_selectors_test_space,
     &dof_selectors_trial_space](const auto &iterator_for_cell_iterator_pairs,
                                 auto       &scratch_data,
                                 auto       &copy_data) {
      assemble_fem_scaled_mass_matrix_on_one_cell(
        factor,
        dof_selectors_test_space,
        dof_selectors_trial_space,
        iterator_for_cell_iterator_pairs,
        scratch_data,
        copy_data);
    },
    [&](const auto &data) {
      copy_cell_local_to_global_for_fem_matrix(
        data,
        dof_selectors_test_space,
        full_to_local_dof_id_map_test_space,
        dof_selectors_trial_space,
        full_to_local_dof_id_map_trial_space,
        target_matrix);
    },
    CellWiseScratchDataForMassMatrix<dim, spacedim>(
      dof_handler_for_test_space.get_fe(),
      dof_handler_for_trial_space.get_fe(),
      quad_rule,
      update_values | update_JxW_values),
    CellWiseCopyDataForMassMatrix<dim, spacedim, RangeNumberType>(
      dof_handler_for_test_space.get_fe(),
      dof_handler_for_trial_space.get_fe()));
}


/**
 * Assemble the mass matrix in FEM in a single thread.
 *
 * @pre
 * @post
 * @tparam dim
 * @tparam spacedim
 * @tparam RangeNumberType
 * @tparam MatrixType
 * @param dof_handler_for_test_space
 * @param dof_handler_for_trial_space
 * @param factor
 * @param quad_rule
 * @param target_full_matrix
 */
template <int dim, int spacedim, typename RangeNumberType, typename MatrixType>
void
assemble_fem_scaled_mass_matrix_serial(
  const DoFHandler<dim, spacedim> &dof_handler_for_test_space,
  const DoFHandler<dim, spacedim> &dof_handler_for_trial_space,
  const RangeNumberType            factor,
  const Quadrature<dim>           &quad_rule,
  MatrixType                      &target_full_matrix)
{
  // Because the test and ansatz function spaces related to the mass matrix
  // are on a same spatial domain, here we make an assertion about the
  // equality of the number of cells in their respective triangulations.
  AssertDimension(
    dof_handler_for_test_space.get_triangulation().n_active_cells(),
    dof_handler_for_trial_space.get_triangulation().n_active_cells());

  std::vector<
    std::pair<typename DoFHandler<dim, spacedim>::active_cell_iterator,
              typename DoFHandler<dim, spacedim>::active_cell_iterator>>
    cell_iterator_pairs_for_mass_matrix(
      dof_handler_for_test_space.get_triangulation().n_active_cells());

  initialize_cell_iterator_pairs_for_mass_matrix(
    dof_handler_for_test_space,
    dof_handler_for_trial_space,
    cell_iterator_pairs_for_mass_matrix);

  CellWiseScratchDataForMassMatrix<dim, spacedim> scratch_data(
    dof_handler_for_test_space.get_fe(),
    dof_handler_for_trial_space.get_fe(),
    quad_rule,
    update_values | update_JxW_values);

  CellWiseCopyDataForMassMatrix<dim, spacedim, RangeNumberType> copy_data(
    dof_handler_for_test_space.get_fe(), dof_handler_for_trial_space.get_fe());

  for (auto cell_pair_iter = cell_iterator_pairs_for_mass_matrix.begin();
       cell_pair_iter != cell_iterator_pairs_for_mass_matrix.end();
       cell_pair_iter++)
    {
      assemble_fem_scaled_mass_matrix_on_one_cell(factor,
                                                  cell_pair_iter,
                                                  scratch_data,
                                                  copy_data);

      copy_cell_local_to_global_for_fem_matrix(copy_data, target_full_matrix);
    }
}


template <int dim, int spacedim, typename RangeNumberType, typename MatrixType>
void
copy_pair_of_cells_local_to_global_for_bem_full_matrix(
  const PairCellWisePerTaskData<dim, spacedim, RangeNumberType> &data,
  MatrixType &target_full_matrix)
{
  const unsigned int kx_dofs_per_cell = data.local_pair_cell_matrix.m();
  const unsigned int ky_dofs_per_cell = data.local_pair_cell_matrix.n();

  for (unsigned int i = 0; i < kx_dofs_per_cell; i++)
    {
      for (unsigned int j = 0; j < ky_dofs_per_cell; j++)
        {
          target_full_matrix.add(data.kx_local_dof_indices_permuted[i],
                                 data.ky_local_dof_indices_permuted[j],
                                 data.local_pair_cell_matrix(i, j));
        }
    }
}


/**
 * Assemble a full matrix for a bilinear form in BEM.
 *
 * @param kernel
 * @param factor
 * @param dof_handler_for_test_space
 * @param dof_handler_for_trial_space
 * @param kx_mapping
 * @param ky_mapping
 * @param kx_mapping_data
 * @param ky_mapping_data
 * @param sauter_quad_rule
 * @param target_full_matrix
 */
template <int dim,
          int spacedim,
          template <int, typename>
          typename KernelFunctionType,
          typename KernelNumberType,
          typename SurfaceNormalDetector,
          typename MatrixType>
void
assemble_bem_full_matrix(
  const KernelFunctionType<spacedim, KernelNumberType> &kernel,
  const KernelNumberType                                factor,
  const DoFHandler<dim, spacedim>                 &dof_handler_for_test_space,
  const DoFHandler<dim, spacedim>                 &dof_handler_for_trial_space,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                                  &material_id_to_mapping_index,
  const SurfaceNormalDetector     &normal_detector,
  const SauterQuadratureRule<dim> &sauter_quad_rule,
  MatrixType                      &target_full_matrix)
{
  using real_type = typename numbers::NumberTraits<KernelNumberType>::real_type;

  /**
   * Precalculate data tables for shape values at quadrature points.
   *
   * \mynote{Precalculate shape function values and their gradient
   * values at each quadrature point. N.B.
   * 1. The data tables for shape function values and their gradient
   * values should be calculated for both function space on
   * \f$K_x\f$ and function space on \f$K_y\f$.
   * 2. Being different from the integral in FEM, the integral in
   * BEM handled by Sauter's quadrature rule has multiple parts of
   * \f$k_3\f$ (except the regular cell neighboring type), each of
   * which should be evaluated at a different set of quadrature
   * points in the unit cell after coordinate transformation from
   * the parametric space. Therefore, an additional dimension with respect to
   * \f$k_3\f$ term index should be added to the data table compared
   * to the usual FEValues and this brings about
   * the class @p BEMValues.
   * 3. In Galerkin BEM, finite elements for the Dirichlet domain
   * and Neumann domain are different. For SLP BEM matrix, both the
   * test function space, to which \f$K_x\f$ belongs, space and the
   * trial function space, to which \f$K_y\f$ belongs, is @p FE_DGQ.
   * For DLP BEM matrix and the mass matrix, the test function space
   * is @p FE_DGQ and the trial function space is @p FE_Q.}
   */
  BEMValues<dim, spacedim, real_type> bem_values(
    dof_handler_for_test_space.get_fe(),
    dof_handler_for_trial_space.get_fe(),
    mappings,
    sauter_quad_rule.quad_rule_for_same_panel,
    sauter_quad_rule.quad_rule_for_common_edge,
    sauter_quad_rule.quad_rule_for_common_vertex,
    sauter_quad_rule.quad_rule_for_regular);

  bem_values.fill_shape_function_value_tables();

  /**
   * Create data structure for parallel matrix assembly.
   *
   * \alert{Since @p scratch_data and @p per_task_data should be copied into
   * each thread and will further be modified in the working
   * function @p assemble_on_one_pair_of_cells, they should be passed by value.}
   */
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> scratch_data(
    dof_handler_for_test_space.get_fe(),
    dof_handler_for_trial_space.get_fe(),
    mappings,
    bem_values);
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> per_task_data(
    dof_handler_for_test_space.get_fe(), dof_handler_for_trial_space.get_fe());

  for (const auto &e : dof_handler_for_test_space.active_cell_iterators())
    {
      /**
       * Calculate Kx related data so that they won't be redundantly
       * calculated within @p sauter_quadrature_on_one_pair_of_cells.
       */
      const unsigned int kx_mapping_index =
        material_id_to_mapping_index.at(e->material_id());
      MappingInfo<dim, spacedim> &kx_mapping_info = *mappings[kx_mapping_index];

      kx_mapping_info.get_mapping().compute_mapping_support_points(e);
      scratch_data.kx_mapping_support_points_in_default_order =
        kx_mapping_info.get_mapping().get_support_points();
      e->get_dof_indices(
        scratch_data.kx_local_dof_indices_in_default_dof_order);

      /**
       * Apply parallelization to the inner loop.
       *
       * \alert{@p bem_values will not be modified inside the working
       * function, so it is safe to pass it by const reference in the call of
       * @p std::bind.}
       */
      WorkStream::run(
        dof_handler_for_trial_space.begin_active(),
        dof_handler_for_trial_space.end(),
        [&](const auto &ky_cell_iter, auto &scratch_data, auto &copy_data) {
          sauter_quadrature_on_one_pair_of_cells_parallel_over_ky(
            kernel,
            factor,
            e,
            ky_cell_iter,
            mappings,
            material_id_to_mapping_index,
            kx_mapping_info,
            bem_values,
            normal_detector,
            scratch_data,
            copy_data,
            true);
        },
        [&target_full_matrix](const auto &data) {
          copy_pair_of_cells_local_to_global_for_bem_full_matrix(
            data, target_full_matrix);
        },
        scratch_data,
        per_task_data);
    }

  scratch_data.release();
  per_task_data.release();
}


/**
 * Assemble a BEM full matrix in a single thread.
 *
 * @pre
 * @post
 * @tparam dim
 * @tparam spacedim
 * @tparam KernelFunctionType
 * @tparam KernelNumberType
 * @tparam SurfaceNormalDetector
 * @tparam MatrixType
 * @param kernel
 * @param factor
 * @param dof_handler_for_test_space
 * @param dof_handler_for_trial_space
 * @param mappings
 * @param sauter_quad_rule
 * @param target_full_matrix
 */
template <int dim,
          int spacedim,
          template <int, typename>
          typename KernelFunctionType,
          typename KernelNumberType,
          typename SurfaceNormalDetector,
          typename MatrixType>
void
assemble_bem_full_matrix_serial(
  const KernelFunctionType<spacedim, KernelNumberType> &kernel,
  const KernelNumberType                                factor,
  const DoFHandler<dim, spacedim>                 &dof_handler_for_test_space,
  const DoFHandler<dim, spacedim>                 &dof_handler_for_trial_space,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                                  &material_id_to_mapping_index,
  const SurfaceNormalDetector     &normal_detector,
  const SauterQuadratureRule<dim> &sauter_quad_rule,
  MatrixType                      &target_full_matrix)
{
  using real_type = typename numbers::NumberTraits<KernelNumberType>::real_type;

  /**
   * Precalculate data tables for shape values at quadrature points.
   *
   * \mynote{Precalculate shape function values and their gradient
   * values at each quadrature point. N.B.
   * 1. The data tables for shape function values and their gradient
   * values should be calculated for both function space on
   * \f$K_x\f$ and function space on \f$K_y\f$.
   * 2. Being different from the integral in FEM, the integral in
   * BEM handled by Sauter's quadrature rule has multiple parts of
   * \f$k_3\f$ (except the regular cell neighboring type), each of
   * which should be evaluated at a different set of quadrature
   * points in the unit cell after coordinate transformation from
   * the parametric space. Therefore, an additional dimension with respect to
   * \f$k_3\f$ term index should be added to the data table compared
   * to the usual FEValues and this brings about
   * the class @p BEMValues.
   * 3. In Galerkin BEM, finite elements for the Dirichlet domain
   * and Neumann domain are different. For SLP BEM matrix, both the
   * test function space, to which \f$K_x\f$ belongs, space and the
   * trial function space, to which \f$K_y\f$ belongs, is @p FE_DGQ.
   * For DLP BEM matrix and the mass matrix, the test function space
   * is @p FE_DGQ and the trial function space is @p FE_Q.}
   */
  BEMValues<dim, spacedim, real_type> bem_values(
    dof_handler_for_test_space.get_fe(),
    dof_handler_for_trial_space.get_fe(),
    mappings,
    sauter_quad_rule.quad_rule_for_same_panel,
    sauter_quad_rule.quad_rule_for_common_edge,
    sauter_quad_rule.quad_rule_for_common_vertex,
    sauter_quad_rule.quad_rule_for_regular);

  bem_values.fill_shape_function_value_tables();

  /**
   * Create data structure for parallel matrix assembly.
   *
   * \alert{Since @p scratch_data and @p per_task_data should be copied into
   * each thread and will further be modified in the working
   * function @p assemble_on_one_pair_of_cells, they should be passed by value.}
   */
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> scratch_data(
    dof_handler_for_test_space.get_fe(),
    dof_handler_for_trial_space.get_fe(),
    mappings,
    bem_values);
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> per_task_data(
    dof_handler_for_test_space.get_fe(), dof_handler_for_trial_space.get_fe());

  for (const auto &e : dof_handler_for_test_space.active_cell_iterators())
    {
      /**
       * Calculate Kx related data so that they won't be redundantly
       * calculated within @p sauter_quadrature_on_one_pair_of_cells.
       */
      const unsigned int kx_mapping_index =
        material_id_to_mapping_index.at(e->material_id());
      MappingInfo<dim, spacedim> &kx_mapping_info = *mappings[kx_mapping_index];

      kx_mapping_info.get_mapping().compute_mapping_support_points(e);
      scratch_data.kx_mapping_support_points_in_default_order =
        kx_mapping_info.get_mapping().get_support_points();
      e->get_dof_indices(
        scratch_data.kx_local_dof_indices_in_default_dof_order);

      for (const auto &f : dof_handler_for_trial_space.active_cell_iterators())
        {
          const unsigned int ky_mapping_index =
            material_id_to_mapping_index.at(f->material_id());
          MappingInfo<dim, spacedim> &ky_mapping_info =
            *mappings[ky_mapping_index];

          sauter_quadrature_on_one_pair_of_cells(kernel,
                                                 factor,
                                                 e,
                                                 f,
                                                 kx_mapping_info,
                                                 ky_mapping_info,
                                                 bem_values,
                                                 normal_detector,
                                                 scratch_data,
                                                 per_task_data,
                                                 true);

          copy_pair_of_cells_local_to_global_for_bem_full_matrix(
            per_task_data, target_full_matrix);
        }
    }

  scratch_data.release();
  per_task_data.release();
}


/**
 * @p ScratchData for assembling the right hand side vector related to a
 * linear form, i.e. \f$\left\langle f, v \right\rangle\f$, where \f$f\f$ is a
 * linear operator and \f$v\f$ is the test function.
 */
template <int dim, int spacedim = dim>
struct CellWiseScratchDataForRHSLinearForm
{
  FEValues<dim, spacedim> fe_values_for_test_space;

  /**
   * Constructor
   *
   * @param fe_for_test_space
   * @param quadrature
   * @param update_flags
   */
  CellWiseScratchDataForRHSLinearForm(
    const FiniteElement<dim, spacedim> &fe_for_test_space,
    const Quadrature<dim>              &quadrature,
    const UpdateFlags                   update_flags)
    : fe_values_for_test_space(fe_for_test_space, quadrature, update_flags)
  {}

  /**
   * Copy constructor
   *
   * \mynote{@p FEValues class itself does not have a copy constructor, thus
   * it cannot be copied but should be reconstructed from the input object.}
   *
   * @param scratch_data
   */
  CellWiseScratchDataForRHSLinearForm(
    const CellWiseScratchDataForRHSLinearForm<dim, spacedim> &scratch_data)
    : fe_values_for_test_space(
        scratch_data.fe_values_for_test_space.get_fe(),
        scratch_data.fe_values_for_test_space.get_quadrature(),
        scratch_data.fe_values_for_test_space.get_update_flags())
  {}
};


/**
 * @p CopyData for assembling the right hand side vector related to a linear
 * form, i.e. \f$\left\langle f, v \right\rangle\f$, where \f$f\f$ is a linear
 * operator and \f$v\f$ is the test function.
 */
template <int dim, int spacedim = dim, typename RangeNumberType = double>
struct CellWiseCopyDataForRHSLinearForm
{
  /**
   * The local right hand side vector related to the DoFs in the current cell.
   */
  Vector<RangeNumberType> local_rhs_vector;

  /**
   * \mynote{Memory should be preallocated for this vector before calling
   * <code>get_dof_indices</code>.}
   */
  std::vector<types::global_dof_index> local_dof_indices_for_test_space;

  /**
   * Constructor
   *
   * @param fe_for_test_space
   */
  CellWiseCopyDataForRHSLinearForm(
    const FiniteElement<dim, spacedim> &fe_for_test_space)
    : local_rhs_vector(fe_for_test_space.dofs_per_cell)
    , local_dof_indices_for_test_space(fe_for_test_space.dofs_per_cell)
  {}

  /**
   * Copy constructor
   *
   * @param copy_data
   */
  CellWiseCopyDataForRHSLinearForm(
    const CellWiseCopyDataForRHSLinearForm<dim, spacedim, RangeNumberType>
      &copy_data)
    : local_rhs_vector(copy_data.local_rhs_vector)
    , local_dof_indices_for_test_space(
        copy_data.local_dof_indices_for_test_space)
  {}
};


/**
 * Assemble the RHS linear form vector on a local cell, which will be the
 * working function in the parallel assembly process. This version computes
 * the quadrature points in the real cell, at which the linear operator is to
 * be evaluated.
 *
 * @param f The linear operator on the right hand side
 * @param cell_iter
 * @param scratch_data
 * @param copy_data
 */
template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename FunctionNumberType>
void
local_assemble_rhs_linear_form_vector(
  const Function<spacedim, FunctionNumberType>                   &f,
  const typename DoFHandler<dim, spacedim>::active_cell_iterator &cell_iter,
  CellWiseScratchDataForRHSLinearForm<dim, spacedim>             &scratch_data,
  CellWiseCopyDataForRHSLinearForm<dim, spacedim, RangeNumberType> &copy_data)
{
  static_assert(
    is_number_larger_or_equal<RangeNumberType, FunctionNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<FunctionNumberType>::real_type>::value);

  scratch_data.fe_values_for_test_space.reinit(cell_iter);

  const unsigned int n_q_points =
    scratch_data.fe_values_for_test_space.get_quadrature().size();

  const unsigned int dofs_per_cell =
    scratch_data.fe_values_for_test_space.get_fe().dofs_per_cell;

  copy_data.local_rhs_vector.reinit(dofs_per_cell);

  for (unsigned int q = 0; q < n_q_points; q++)
    {
      for (unsigned int i = 0; i < dofs_per_cell; i++)
        {
          copy_data.local_rhs_vector(i) +=
            scratch_data.fe_values_for_test_space.shape_value(i, q) *
            f(scratch_data.fe_values_for_test_space.quadrature_point(q)) *
            scratch_data.fe_values_for_test_space.JxW(q);
        }
    }

  cell_iter->get_dof_indices(copy_data.local_dof_indices_for_test_space);
}


/**
 * Assemble the RHS linear form vector on a local cell, which will be the
 * working function in the parallel assembly process. In this version, the
 * linear functional \f$f\f$ is a constant, which does not need computation of
 * the quadrature point coordinates in the real cell.
 *
 * @param f The value of the constant function
 * @param cell_iter
 * @param scratch_data
 * @param copy_data
 */
template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename FunctionNumberType>
void
local_assemble_const_rhs_linear_form_vector(
  const FunctionNumberType                                        f,
  const typename DoFHandler<dim, spacedim>::active_cell_iterator &cell_iter,
  CellWiseScratchDataForRHSLinearForm<dim, spacedim>             &scratch_data,
  CellWiseCopyDataForRHSLinearForm<dim, spacedim, RangeNumberType> &copy_data)
{
  static_assert(
    is_number_larger_or_equal<RangeNumberType, FunctionNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<FunctionNumberType>::real_type>::value);

  scratch_data.fe_values_for_test_space.reinit(cell_iter);

  const unsigned int n_q_points =
    scratch_data.fe_values_for_test_space.get_quadrature().size();

  const unsigned int dofs_per_cell =
    scratch_data.fe_values_for_test_space.get_fe().dofs_per_cell;

  copy_data.local_rhs_vector.reinit(dofs_per_cell);

  for (unsigned int q = 0; q < n_q_points; q++)
    {
      for (unsigned int i = 0; i < dofs_per_cell; i++)
        {
          copy_data.local_rhs_vector(i) +=
            scratch_data.fe_values_for_test_space.shape_value(i, q) * f *
            scratch_data.fe_values_for_test_space.JxW(q);
        }
    }

  cell_iter->get_dof_indices(copy_data.local_dof_indices_for_test_space);
}


/**
 * Copy the RHS linear form vector on a local cell to the global vector.
 *
 * @param copy_data
 * @param rhs_vector
 */
template <int dim, int spacedim, typename RangeNumberType, typename VectorType>
void
copy_cell_local_to_global_rhs_linear_form_vector(
  const CellWiseCopyDataForRHSLinearForm<dim, spacedim, RangeNumberType>
             &copy_data,
  VectorType &rhs_vector)
{
  AssertDimension(copy_data.local_dof_indices_for_test_space.size(),
                  copy_data.local_rhs_vector.size());

  rhs_vector.add(copy_data.local_dof_indices_for_test_space,
                 copy_data.local_rhs_vector);
}


/**
 * Assemble the RHS linear form vector with respect to the linear operator
 * \f$f\f$. This version computes the quadrature points in the real cell, at
 * which the linear operator \f$f\f$ is to be evaluated.
 *
 * @param f
 * @param dof_handler_for_test_space
 * @param quad_rule
 * @param rhs_vector
 */
template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename FunctionNumberType,
          typename VectorType>
void
assemble_rhs_linear_form_vector(
  const Function<spacedim, FunctionNumberType> &f,
  const DoFHandler<dim, spacedim>              &dof_handler_for_test_space,
  const Quadrature<dim>                        &quad_rule,
  VectorType                                   &rhs_vector)
{
  static_assert(
    is_number_larger_or_equal<RangeNumberType, FunctionNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<FunctionNumberType>::real_type>::value);

  WorkStream::run(
    dof_handler_for_test_space.begin_active(),
    dof_handler_for_test_space.end(),
    [&f](const auto &cell_iter, auto &scratch_data, auto &copy_data) {
      local_assemble_rhs_linear_form_vector(f,
                                            cell_iter,
                                            scratch_data,
                                            copy_data);
    },
    [&rhs_vector](const auto &copy_data) {
      copy_cell_local_to_global_rhs_linear_form_vector(copy_data, rhs_vector);
    },
    CellWiseScratchDataForRHSLinearForm<dim, spacedim>(
      dof_handler_for_test_space.get_fe(),
      quad_rule,
      update_values | update_JxW_values | update_quadrature_points),
    CellWiseCopyDataForRHSLinearForm<dim, spacedim, RangeNumberType>(
      dof_handler_for_test_space.get_fe()));
}


/**
 * Assemble the RHS linear form vector with respect to the linear operator
 * \f$f\f$. In this version, the linear functional \f$f\f$ is a constant,
 * which does not need computation of the quadrature point coordinates in the
 * real cell.
 *
 * @param f
 * @param dof_handler_for_test_space
 * @param quad_rule
 * @param rhs_vector
 */
template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename FunctionNumberType,
          typename VectorType>
void
assemble_rhs_linear_form_vector(
  const FunctionNumberType         f,
  const DoFHandler<dim, spacedim> &dof_handler_for_test_space,
  const Quadrature<dim>           &quad_rule,
  VectorType                      &rhs_vector)
{
  static_assert(
    is_number_larger_or_equal<RangeNumberType, FunctionNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<FunctionNumberType>::real_type>::value);

  WorkStream::run(
    dof_handler_for_test_space.begin_active(),
    dof_handler_for_test_space.end(),
    [&f](const auto &cell_iter, auto &scratch_data, auto &copy_data) {
      local_assemble_const_rhs_linear_form_vector(f,
                                                  cell_iter,
                                                  scratch_data,
                                                  copy_data);
    },
    [&rhs_vector](const auto &copy_data) {
      copy_cell_local_to_global_rhs_linear_form_vector(copy_data, rhs_vector);
    },
    CellWiseScratchDataForRHSLinearForm<dim, spacedim>(
      dof_handler_for_test_space.get_fe(),
      quad_rule,
      update_values | update_JxW_values),
    CellWiseCopyDataForRHSLinearForm<dim, spacedim, RangeNumberType>(
      dof_handler_for_test_space.get_fe()));
}


/**
 * Assemble indicator vectors for subdomain with respect to a given DoF handler.
 *
 * This function iterates over each subdomain and interpolates the indicator
 * function on the surfaces belonging to the subdomain. N.B. Because each
 * surface may be assigned a different manifold and accordingly a different
 * mapping order may be used, the interpolation is performed surface by surface.
 *
 * TODO: Handle the case when a subdomain is multiply connected so it has
 * multiple boundary components.
 *
 * @param indicator_vectors The memory for these vectors should be allocated
 * before calling this function.
 */
template <int dim, int spacedim, typename VectorType>
void
interpolate_indicator_vectors_for_subdomains(
  const DoFHandler<dim, spacedim>                 &dof_handler,
  const SubdomainTopology<dim, spacedim>          &subdomain_topology,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                          &material_id_to_mapping_index,
  std::vector<VectorType> &indicator_vectors)
{
  // At the moment, all subdomains are considered to be singly connected and the
  // number of subdomains should be equal to the number of indicator vectors.
  AssertDimension(subdomain_topology.get_subdomain_to_surface().size(),
                  indicator_vectors.size());

  using value_type = typename VectorType::value_type;

  Functions::ConstantFunction<spacedim, value_type> indicator(value_type(1.0));

  unsigned int subdomain_counter = 0;
  // Iterate over each subdomain.
  for (const auto &subdomain_to_surface :
       subdomain_topology.get_subdomain_to_surface())
    {
      // Iterate over each surface belonging to the subdomain. The interpolation
      // results will be appended to the indictor vector for the current
      // subdomain.
      for (auto surface_tag : subdomain_to_surface.second)
        {
          std::map<types::material_id, const Function<spacedim, value_type> *>
            indicator_function_map;
          indicator_function_map[static_cast<types::material_id>(surface_tag)] =
            &indicator;

          VectorTools::interpolate_based_on_material_id(
            mappings
              .at(material_id_to_mapping_index.at(
                static_cast<types::material_id>(surface_tag)))
              ->get_mapping(),
            dof_handler,
            indicator_function_map,
            indicator_vectors[subdomain_counter]);
        }

      subdomain_counter++;
    }
}


/**
 * Evaluate the integral of the product of the given kernel function and the
 * list of basis functions on the current cell.
 *
 * @param kernel
 * @param target_point
 * @param factor
 * @param cell_iter
 * @param mapping
 * @param is_source_point_normal_vector_negated
 * @param scratch
 * @param data
 */
template <int dim,
          int spacedim,
          template <int, typename>
          typename KernelFunctionType,
          typename KernelNumberType>
void
integral_transform_of_trial_bases_on_one_cell(
  const KernelFunctionType<spacedim, KernelNumberType> &kernel,
  const Point<spacedim,
              typename numbers::NumberTraits<KernelNumberType>::real_type>
    &target_point,
  const Tensor<1,
               spacedim,
               typename numbers::NumberTraits<KernelNumberType>::real_type>
                        &target_normal_vector,
  const KernelNumberType factor,
  const typename DoFHandler<dim, spacedim>::active_cell_iterator &cell_iter,
  const bool is_source_point_normal_vector_negated,
  CellWiseScratchDataForPotentialEval<dim, spacedim>                   &scratch,
  CellWisePerTaskDataForPotentialEval<dim, spacedim, KernelNumberType> &data)
{
  using real_type = typename numbers::NumberTraits<KernelNumberType>::real_type;

  /**
   * Clear the local result vector.
   */
  data.local_vector.reinit(data.local_dof_indices_for_trial_space.size());

  /**
   * Reinitialize the @p FEValues object for the trial space on the current
   * cell.
   */
  scratch.fe_values_for_trial_space.reinit(cell_iter);

  const unsigned int n_q_points =
    scratch.fe_values_for_trial_space.get_quadrature().size();

  const unsigned int dofs_per_cell =
    scratch.fe_values_for_trial_space.get_fe().dofs_per_cell;

  /**
   * Iterate over each quadrature point.
   */
  for (unsigned int q = 0; q < n_q_points; q++)
    {
      /**
       * Evaluate the kernel function at the target point (for \f$x\f$) and
       * the current quadrature point (for \f$y\f$), i.e. only the \f$y\f$
       * coordinates are pulled back to the unit cell.
       *
       * \mynote{When calculating the potential at a target point, only the
       * normal vector on \f$K_y\f$ is needed. Therefore, the normal vector
       * on \f$K_x\f$ passed to the kernel function can be arbitrary.}
       */
      KernelNumberType scaled_kernel_value =
        kernel.value(target_point,
                     static_cast<Point<spacedim, real_type>>(
                       scratch.fe_values_for_trial_space.quadrature_point(q)),
                     target_normal_vector,
                     (is_source_point_normal_vector_negated ? -1.0 : 1.0) *
                       static_cast<Tensor<1, spacedim, real_type>>(
                         scratch.fe_values_for_trial_space.normal_vector(q))) *
        factor;

      /**
       * Iterate over each shape function.
       */
      for (unsigned int i = 0; i < dofs_per_cell; i++)
        {
          data.local_vector(i) +=
            scaled_kernel_value *
            scratch.fe_values_for_trial_space.shape_value(i, q) *
            scratch.fe_values_for_trial_space.JxW(q);
        }
    }

  /**
   * Extract DoF indices on the cell.
   */
  cell_iter->get_dof_indices(data.local_dof_indices_for_trial_space);
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType,
          template <typename>
          typename VectorType>
void
copy_cell_local_to_global_for_potential_eval(
  const CellWisePerTaskDataForPotentialEval<dim, spacedim, KernelNumberType>
                              &copy_data,
  VectorType<RangeNumberType> &result_vector)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  AssertDimension(copy_data.local_dof_indices_for_trial_space.size(),
                  copy_data.local_vector.size());

  result_vector.add(copy_data.local_dof_indices_for_trial_space,
                    copy_data.local_vector);
}


/**
 * Evaluate the potential values in the spatial domain at a list of target
 * points using the representation formula derived from the direct method.
 *
 * \f[
 * u(x) = -\int_{\Gamma} \widetilde{\gamma}_{1,y} G(x,y) \gamma_0^{\rm int}
 * u(y) \intd s_y + \int_{\Gamma} G(x,y) \widetilde{\gamma}_{1,y} u(y) \intd
 * s_y
 * \]
 *
 * @tparam dim
 * @tparam spacedim
 * @tparam KernelFunctionType
 * @tparam KernelNumberType
 * @tparam VectorType The number type of @p VectorType should be >= @p KernelNumberType
 * @param kernel
 * @param factor
 * @param dof_handler_for_trial_space DoF handler related to either the
 * Dirichlet data or Neumann data on the boundary.
 * @param dof_values_in_trial_space DoF values related to either the
 * Dirichlet data or Neumann data on the boundary.
 * @param mapping
 * @param is_source_point_normal_vector_negated When the boundary surface mesh
 * is extracted from a volume mesh and an exterior problem is solved, this flag
 * should be true.
 * @param point_list
 * @param potential_values
 */
template <int dim,
          int spacedim,
          template <int, typename>
          typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          template <typename>
          typename VectorType>
void
evaluate_potential_at_points(
  const KernelFunctionType<spacedim, KernelNumberType> &kernel,
  const KernelNumberType                                factor,
  const DoFHandler<dim, spacedim>   &dof_handler_for_trial_space,
  const VectorType<RangeNumberType> &dof_values_in_trial_space,
  const std::vector<
    Point<spacedim,
          typename numbers::NumberTraits<KernelNumberType>::real_type>>
                              &target_points,
  VectorType<RangeNumberType> &potential_values,
  const bool                   is_source_point_normal_vector_negated = false)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  AssertDimension(target_points.size(), potential_values.size());

  const FiniteElement<dim, spacedim> &fe = dof_handler_for_trial_space.get_fe();

  const types::global_dof_index n_dofs = dof_handler_for_trial_space.n_dofs();
  VectorType<KernelNumberType>  kernel_evaluation_discretized_to_dofs(n_dofs);

  QGauss<dim> quad_rule(fe.degree + 1);

  /**
   * Iterate over each target point.
   */
  const unsigned int n_target_points = target_points.size();

  // Dummy normal vector at the target point, which will not needed by the
  // kernel function.
  Tensor<1,
         spacedim,
         typename numbers::NumberTraits<KernelNumberType>::real_type>
    target_normal_vector_dummy;
  for (unsigned int i = 0; i < n_target_points; i++)
    {
      kernel_evaluation_discretized_to_dofs.reinit(n_dofs);

      WorkStream::run(
        dof_handler_for_trial_space.begin_active(),
        dof_handler_for_trial_space.end(),
        [&kernel,
         &target_points,
         &target_normal_vector_dummy,
         i,
         factor,
         is_source_point_normal_vector_negated](const auto &cell_iter,
                                                auto       &scratch,
                                                auto       &data) {
          integral_transform_of_trial_bases_on_one_cell(
            kernel,
            target_points[i],
            target_normal_vector_dummy,
            factor,
            cell_iter,
            is_source_point_normal_vector_negated,
            scratch,
            data);
        },
        [&kernel_evaluation_discretized_to_dofs](const auto &copy_data) {
          copy_cell_local_to_global_for_potential_eval(
            copy_data, kernel_evaluation_discretized_to_dofs);
        },
        CellWiseScratchDataForPotentialEval<dim, spacedim>(
          fe,
          quad_rule,
          update_quadrature_points | update_values | update_JxW_values |
            update_normal_vectors),
        CellWisePerTaskDataForPotentialEval<dim, spacedim, KernelNumberType>(
          fe));

      /**
       * Calculate the linear combination of the kernel evaluation and DoF
       * values. N.B. The implementation here appends the results to the result
       * vector, so that a single vector can accumulate the contribution from
       * both the single layer and double layer potentials.
       *
       * In the linear combination, @p dof_values_in_trial_space is placed before
       * @p kernel_evaluation_discretized_to_dofs, since it has a larger number
       * type.
       */
      potential_values(i) +=
        LinAlg::linear_combination_tbb(dof_values_in_trial_space,
                                       kernel_evaluation_discretized_to_dofs);
    }
}


template <int dim,
          int spacedim,
          template <int, typename>
          typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          template <typename>
          typename VectorType>
void
evaluate_conormal_trace_at_points(
  const KernelFunctionType<spacedim, KernelNumberType> &kernel,
  const KernelNumberType                                factor,
  const DoFHandler<dim, spacedim>   &dof_handler_for_trial_space,
  const VectorType<RangeNumberType> &dof_values_in_trial_space,
  const std::vector<
    Point<spacedim,
          typename numbers::NumberTraits<KernelNumberType>::real_type>>
    &target_points,
  const std::vector<
    Tensor<1,
           spacedim,
           typename numbers::NumberTraits<KernelNumberType>::real_type>>
                              &target_normal_vectors,
  VectorType<RangeNumberType> &conormal_traces,
  const bool                   is_source_point_normal_vector_negated = false)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  AssertDimension(target_points.size(), conormal_traces.size());

  const FiniteElement<dim, spacedim> &fe = dof_handler_for_trial_space.get_fe();

  const types::global_dof_index n_dofs = dof_handler_for_trial_space.n_dofs();
  VectorType<KernelNumberType>  kernel_evaluation_discretized_to_dofs(n_dofs);

  QGauss<dim> quad_rule(fe.degree + 1);

  /**
   * Iterate over each target point.
   */
  const unsigned int n_target_points = target_points.size();

  for (unsigned int i = 0; i < n_target_points; i++)
    {
      kernel_evaluation_discretized_to_dofs.reinit(n_dofs);

      WorkStream::run(
        dof_handler_for_trial_space.begin_active(),
        dof_handler_for_trial_space.end(),
        [&kernel,
         &target_points,
         &target_normal_vectors,
         i,
         factor,
         is_source_point_normal_vector_negated](const auto &cell_iter,
                                                auto       &scratch,
                                                auto       &data) {
          integral_transform_of_trial_bases_on_one_cell(
            kernel,
            target_points[i],
            target_normal_vectors[i],
            factor,
            cell_iter,
            is_source_point_normal_vector_negated,
            scratch,
            data);
        },
        [&kernel_evaluation_discretized_to_dofs](const auto &copy_data) {
          copy_cell_local_to_global_for_potential_eval(
            copy_data, kernel_evaluation_discretized_to_dofs);
        },
        CellWiseScratchDataForPotentialEval<dim, spacedim>(
          fe,
          quad_rule,
          update_quadrature_points | update_values | update_JxW_values |
            update_normal_vectors),
        CellWisePerTaskDataForPotentialEval<dim, spacedim, KernelNumberType>(
          fe));

      /**
       * Calculate the linear combination of the kernel evaluation and DoF
       * values. N.B. The implementation here appends the results to the result
       * vector, so that a single vector can accumulate the contribution from
       * both the single layer and double layer potentials.
       *
       * In the linear combination, @p dof_values_in_trial_space is placed before
       * @p kernel_evaluation_discretized_to_dofs, since it has a larger number
       * type.
       */
      conormal_traces(i) +=
        LinAlg::linear_combination_tbb(dof_values_in_trial_space,
                                       kernel_evaluation_discretized_to_dofs);
    }
}


/**
 * @tparam target_dim The manifold dimensional of the target, which can be a surface or a volume.
 */
template <int dim,
          int spacedim,
          int target_dim,
          template <int, typename>
          typename SLPKernelType,
          template <int, typename>
          typename DLPKernelType,
          typename RangeNumberType,
          typename KernelNumberType,
          template <typename>
          typename VectorType>
void
evaluate_representation_formula_for_potential(
  const SLPKernelType<spacedim, KernelNumberType> &slp_kernel,
  const DLPKernelType<spacedim, KernelNumberType> &dlp_kernel,
  const DoFHandler<dim, spacedim>        &dof_handler_for_dirichlet_space,
  const DoFHandler<dim, spacedim>        &dof_handler_for_neumann_space,
  const VectorType<RangeNumberType>      &dirichlet_data,
  const VectorType<RangeNumberType>      &neumann_data,
  const DoFHandler<target_dim, spacedim> &dof_handler_for_target,
  const unsigned int                      mapping_order_for_target,
  VectorType<RangeNumberType>            &potential_values,
  const bool                              is_interior_domain,
  const bool is_source_point_normal_vector_negated = false)
{
  std::vector<
    Point<spacedim,
          typename numbers::NumberTraits<KernelNumberType>::real_type>>
    target_points(dof_handler_for_target.n_dofs());

  // Create a @p MappingInfo object with the given order.
  MappingQ<target_dim, spacedim> mapping(mapping_order_for_target);
  // Compute target support points.
  DoFToolsExt::map_dofs_to_support_points(mapping,
                                          dof_handler_for_target,
                                          target_points);

  // Single layer potential
  evaluate_potential_at_points(slp_kernel,
                               KernelNumberType(is_interior_domain ? 1.0 :
                                                                     -1.0),
                               dof_handler_for_neumann_space,
                               neumann_data,
                               target_points,
                               potential_values,
                               is_source_point_normal_vector_negated);

  // Double layer potential
  evaluate_potential_at_points(dlp_kernel,
                               KernelNumberType(is_interior_domain ? -1.0 :
                                                                     1.0),
                               dof_handler_for_dirichlet_space,
                               dirichlet_data,
                               target_points,
                               potential_values,
                               is_source_point_normal_vector_negated);
}


template <int dim,
          int spacedim,
          template <int, typename>
          typename ADLPKernelType,
          template <int, typename>
          typename HyperSingularKernelType,
          typename RangeNumberType,
          typename KernelNumberType,
          template <typename>
          typename VectorType>
void
evaluate_representation_formula_for_conormal_trace(
  const ADLPKernelType<spacedim, KernelNumberType> &adlp_kernel,
  const HyperSingularKernelType<spacedim, KernelNumberType>
                                    &hypersingular_kernel,
  const DoFHandler<dim, spacedim>   &dof_handler_for_dirichlet_space,
  const DoFHandler<dim, spacedim>   &dof_handler_for_neumann_space,
  const VectorType<RangeNumberType> &dirichlet_data,
  const VectorType<RangeNumberType> &neumann_data,
  const DoFHandler<dim, spacedim>   &dof_handler_for_target_surface,
  const unsigned int                 mapping_order_for_target_surface,
  VectorType<RangeNumberType>       &conormal_traces,
  const bool                         is_interior_domain,
  const bool is_target_point_normal_vector_negated = false,
  const bool is_source_point_normal_vector_negated = false)
{
  std::vector<
    Point<spacedim,
          typename numbers::NumberTraits<KernelNumberType>::real_type>>
    target_points(dof_handler_for_target_surface.n_dofs());
  std::vector<
    Tensor<1,
           spacedim,
           typename numbers::NumberTraits<KernelNumberType>::real_type>>
    target_normal_vectors(dof_handler_for_target_surface.n_dofs());

  // Create a @p MappingInfo object with the given order.
  MappingInfo<dim, spacedim> mapping_info(mapping_order_for_target_surface);
  // Compute target support points.
  DoFToolsExt::map_dofs_to_support_points_and_normal_vectors(
    mapping_info,
    dof_handler_for_target_surface,
    target_points,
    target_normal_vectors,
    is_target_point_normal_vector_negated);

  // Adjoint double layer potential
  evaluate_conormal_trace_at_points(adlp_kernel,
                                    KernelNumberType(is_interior_domain ? 1.0 :
                                                                          -1.0),
                                    dof_handler_for_neumann_space,
                                    neumann_data,
                                    target_points,
                                    target_normal_vectors,
                                    conormal_traces,
                                    is_source_point_normal_vector_negated);

  // Hypersingular potential
  evaluate_conormal_trace_at_points(hypersingular_kernel,
                                    KernelNumberType(is_interior_domain ? 1.0 :
                                                                          -1.0),
                                    dof_handler_for_dirichlet_space,
                                    dirichlet_data,
                                    target_points,
                                    target_normal_vectors,
                                    conormal_traces,
                                    is_source_point_normal_vector_negated);
}

HBEM_NS_CLOSE

#endif // HIERBEM_INCLUDE_BEM_BEM_GENERAL_H_
