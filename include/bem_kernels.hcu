/**
 * @file bem_kernels.h
 * @brief Introduction of bem_kernels.h
 *
 * @date 2022-03-04
 * @author Jihuan Tian
 */
#ifndef INCLUDE_BEM_KERNELS_HCU_
#define INCLUDE_BEM_KERNELS_HCU_

#include <deal.II/base/point.h>
#include <deal.II/base/subscriptor.h>
#include <deal.II/base/table.h>
#include <deal.II/base/table_indices.h>
#include <deal.II/base/utilities.h>

#include <deal.II/dofs/dof_accessor.h>
#include <deal.II/dofs/dof_handler.h>

#include <deal.II/fe/fe.h>
#include <deal.II/fe/fe_data.h>
#include <deal.II/fe/fe_q.h>
#include <deal.II/fe/fe_tools.h>
#include <deal.II/fe/fe_values.h>
#include <deal.II/fe/mapping_q_generic.h>

#include <deal.II/grid/tria.h>

#include <assert.h>

#include <algorithm>
#include <array>
#include <cmath>
#include <vector>

#include "bem_tools.hcu"
#include "bem_values.h"
#include "cpu_table.h"
#include "cu_bem_values.hcu"
#include "cu_fullmatrix.hcu"
#include "cu_table.hcu"
#include "cu_tensor.hcu"
#include "cu_vector.hcu"
#include "generic_functors.h"
#include "lapack_full_matrix_ext.h"
#include "utilities.hcu"

namespace HierBEM
{
  using namespace dealii;
  using namespace BEMTools;

  enum KernelType
  {
    SingleLayer,
    DoubleLayer,
    AdjointDoubleLayer,
    HyperSingular,
    HyperSingularRegular,
    NoneType
  };

  namespace CUDAWrappers
  {
    /**
     * Kernel function pulled back to the unit cell.
     *
     * \mynote{1. The unit cell has the manifold dimension @p dim.
     * 2. Here we use the "template template" technique to define the template
     * parameter @p KernelFunctionType. Its first template parameter is the
     * space dimension and the second parameter is the value type.}
     */
    template <int dim,
              int spacedim,
              template <int, typename>
              typename KernelFunctionType,
              typename RangeNumberType = double>
    class KernelPulledbackToUnitCell
    {
    public:
      const unsigned int n_components;

      /**
       * Constructor on the device.
       *
       * @param kernel_function
       * @param cell_neighboring_type
       * @param bem_values
       * @param scratch
       * @param kx_dof_index
       * @param ky_dof_index
       */
      __host__ __device__
      KernelPulledbackToUnitCell(
        const KernelFunctionType<spacedim, RangeNumberType> &kernel_function,
        const CellNeighboringType &cell_neighboring_type,
        const unsigned int         kx_dof_index = 0,
        const unsigned int         ky_dof_index = 0);

      /**
       * Destructor.
       *
       * \mynote{Since this class has only references to other objects as its
       * members and their memory is not managed by this class, the destructor
       * provided by the compiler is adopted.}
       */
      __host__ __device__ ~KernelPulledbackToUnitCell();

      /**
       * Assignment operator
       *
       * @param f
       * @return
       */
      __host__ __device__ KernelPulledbackToUnitCell &
      operator=(const KernelPulledbackToUnitCell &f);

      /**
       * Set the current DoF index related to \f$K_x\f$.
       *
       * @param kx_dof_index
       */
      __host__ __device__ void
      set_kx_dof_index(const unsigned int kx_dof_index);

      /**
       * Set the current DoF index related to \f$K_y\f$.
       *
       * @param ky_dof_index
       */
      __host__ __device__ void
      set_ky_dof_index(const unsigned int ky_dof_index);

      /**
       * Evaluate the BEM kernel function on the host.
       *
       * @param k3_index
       * @param quad_no
       * @param bem_values
       * @param scratch_data
       * @param component
       * @return
       */
      __host__ RangeNumberType
      value(const unsigned int                               k3_index,
            const unsigned int                               quad_no,
            const BEMValues<dim, spacedim, RangeNumberType> &bem_values,
            const PairCellWiseScratchData<dim, spacedim, RangeNumberType>
                              &scratch_data,
            const unsigned int component = 0) const;

      /**
       * Evaluate the BEM kernel function on the device.
       *
       * @param k3_index
       * @param quad_no
       * @param component
       * @return
       */
      __device__ RangeNumberType
      value(const unsigned int                                   k3_index,
            const unsigned int                                   quad_no,
            const CUDABEMValues<dim, spacedim, RangeNumberType> &bem_values,
            const CUDAPairCellWiseScratchData<dim, spacedim, RangeNumberType>
                              &scratch_data,
            const unsigned int component = 0) const;

    private:
      const KernelFunctionType<spacedim, RangeNumberType> &kernel_function;

      CellNeighboringType cell_neighboring_type;

      /**
       * The current index for accessing the list of DoFs in the lexicographic
       * order in \f$K_x\f$.
       */
      unsigned int kx_dof_index;
      /**
       * The current index for accessing the list of DoFs in the lexicographic
       * order or reversed lexicographic order in \f$K_y\f$.
       */
      unsigned int ky_dof_index;
    };


    template <int dim,
              int spacedim,
              template <int, typename>
              typename KernelFunctionType,
              typename RangeNumberType>
    __host__ __device__
    KernelPulledbackToUnitCell<dim,
                               spacedim,
                               KernelFunctionType,
                               RangeNumberType>::
      KernelPulledbackToUnitCell(
        const KernelFunctionType<spacedim, RangeNumberType> &kernel_function,
        const CellNeighboringType &cell_neighboring_type,
        const unsigned int         kx_dof_index,
        const unsigned int         ky_dof_index)
      : n_components(kernel_function.n_components)
      , kernel_function(kernel_function)
      , cell_neighboring_type(cell_neighboring_type)
      , kx_dof_index(kx_dof_index)
      , ky_dof_index(ky_dof_index)
    {}


    template <int dim,
              int spacedim,
              template <int, typename>
              typename KernelFunctionType,
              typename RangeNumberType>
    __host__ __device__ KernelPulledbackToUnitCell<
      dim,
      spacedim,
      KernelFunctionType,
      RangeNumberType>::~KernelPulledbackToUnitCell() = default;


    template <int dim,
              int spacedim,
              template <int, typename>
              typename KernelFunctionType,
              typename RangeNumberType>
    __host__ __device__ KernelPulledbackToUnitCell<dim,
                                                   spacedim,
                                                   KernelFunctionType,
                                                   RangeNumberType>                     &
    KernelPulledbackToUnitCell<
                          dim,
                          spacedim,
                          KernelFunctionType,
                          RangeNumberType>::operator=(const KernelPulledbackToUnitCell &f)
    {
      assert(n_components == f.n_components);

      kernel_function       = f.kernel_function;
      cell_neighboring_type = f.cell_neighboring_type;
      kx_dof_index          = f.kx_dof_index;
      ky_dof_index          = f.ky_dof_index;

      return *this;
    }


    template <int dim,
              int spacedim,
              template <int, typename>
              typename KernelFunctionType,
              typename RangeNumberType>
    __host__ __device__ void
    KernelPulledbackToUnitCell<
      dim,
      spacedim,
      KernelFunctionType,
      RangeNumberType>::set_kx_dof_index(const unsigned int kx_dof_index)
    {
      this->kx_dof_index = kx_dof_index;
    }


    template <int dim,
              int spacedim,
              template <int, typename>
              typename KernelFunctionType,
              typename RangeNumberType>
    __host__ __device__ void
    KernelPulledbackToUnitCell<
      dim,
      spacedim,
      KernelFunctionType,
      RangeNumberType>::set_ky_dof_index(const unsigned int ky_dof_index)
    {
      this->ky_dof_index = ky_dof_index;
    }


    template <int dim,
              int spacedim,
              template <int, typename>
              typename KernelFunctionType,
              typename RangeNumberType>
    __host__ RangeNumberType
    KernelPulledbackToUnitCell<dim,
                               spacedim,
                               KernelFunctionType,
                               RangeNumberType>::
      value(const unsigned int                               k3_index,
            const unsigned int                               quad_no,
            const BEMValues<dim, spacedim, RangeNumberType> &bem_values,
            const PairCellWiseScratchData<dim, spacedim, RangeNumberType>
                              &scratch_data,
            const unsigned int component) const
    {
      Assert(dim == 2 && spacedim == 3, ExcNotImplemented());

      /**
       * N.B. The shape function value and their gradient value data tables are
       * related to the finite element objects. Because the values in these
       * tables are directly evaluated in the unit cell, which do not depend on
       * the real cells, i.e. when coming to a new cell, these values need not
       * be updated,
       * hence they are members of @p BEMValues instead of @p ScratchData.
       */
      const Table<3, RangeNumberType> *kx_shape_value_table = nullptr;
      const Table<3, RangeNumberType> *ky_shape_value_table = nullptr;
      const Table<2, LAPACKFullMatrixExt<RangeNumberType>>
        *kx_shape_grad_matrix_table = nullptr;
      const Table<2, LAPACKFullMatrixExt<RangeNumberType>>
        *ky_shape_grad_matrix_table = nullptr;

      /**
       * N.B. The covariant transformation matrix data tables are related to the
       * mapping objects instead of the finite element objects. This is natural
       * to understand, the covariant transformation is caused by the coordinate
       * mapping from the unit cell to the real cell.
       *
       * Because the mapping is dependent on real cells, these data should be
       * updated when coming to a new cell. Hence, they are members of
       * @p ScratchData instead of @p BEMValues.
       */
      const Table<2, LAPACKFullMatrixExt<RangeNumberType>>
        *kx_covariants_table = nullptr;
      const Table<2, LAPACKFullMatrixExt<RangeNumberType>>
        *ky_covariants_table = nullptr;

      Point<spacedim>                      x, y;
      RangeNumberType                      Jx = 0;
      RangeNumberType                      Jy = 0;
      Tensor<1, spacedim, RangeNumberType> nx, ny;

      /**
       * Select data tables according to the cell neighboring type.
       */
      switch (cell_neighboring_type)
        {
            case SamePanel: {
              kx_shape_value_table =
                &(bem_values.kx_shape_value_table_for_same_panel);
              ky_shape_value_table =
                &(bem_values.ky_shape_value_table_for_same_panel);

              /**
               * When the kernel type is regularized hyper singular, extract
               * covariant transformation matrices from @p ScratchData and
               * gradient of shape functions from @p BEMValues.
               */
              if (kernel_function.kernel_type == HyperSingularRegular)
                {
                  kx_shape_grad_matrix_table =
                    &(bem_values.kx_shape_grad_matrix_table_for_same_panel);
                  ky_shape_grad_matrix_table =
                    &(bem_values.ky_shape_grad_matrix_table_for_same_panel);
                  kx_covariants_table =
                    &(scratch_data.kx_covariants_same_panel);
                  ky_covariants_table =
                    &(scratch_data.ky_covariants_same_panel);
                }

              x  = scratch_data.kx_quad_points_same_panel(k3_index, quad_no);
              y  = scratch_data.ky_quad_points_same_panel(k3_index, quad_no);
              Jx = scratch_data.kx_jacobians_same_panel(k3_index, quad_no);
              Jy = scratch_data.ky_jacobians_same_panel(k3_index, quad_no);
              nx = scratch_data.kx_normals_same_panel(k3_index, quad_no);
              ny = scratch_data.ky_normals_same_panel(k3_index, quad_no);

              break;
            }
            case CommonEdge: {
              kx_shape_value_table =
                &(bem_values.kx_shape_value_table_for_common_edge);
              ky_shape_value_table =
                &(bem_values.ky_shape_value_table_for_common_edge);

              /**
               * When the kernel type is regularized hyper singular, extract
               * covariant transformation matrices from @p ScratchData and
               * gradient of shape functions from @p BEMValues.
               */
              if (kernel_function.kernel_type == HyperSingularRegular)
                {
                  kx_shape_grad_matrix_table =
                    &(bem_values.kx_shape_grad_matrix_table_for_common_edge);
                  ky_shape_grad_matrix_table =
                    &(bem_values.ky_shape_grad_matrix_table_for_common_edge);
                  kx_covariants_table =
                    &(scratch_data.kx_covariants_common_edge);
                  ky_covariants_table =
                    &(scratch_data.ky_covariants_common_edge);
                }

              x  = scratch_data.kx_quad_points_common_edge(k3_index, quad_no);
              y  = scratch_data.ky_quad_points_common_edge(k3_index, quad_no);
              Jx = scratch_data.kx_jacobians_common_edge(k3_index, quad_no);
              Jy = scratch_data.ky_jacobians_common_edge(k3_index, quad_no);
              nx = scratch_data.kx_normals_common_edge(k3_index, quad_no);
              ny = scratch_data.ky_normals_common_edge(k3_index, quad_no);

              break;
            }
            case CommonVertex: {
              kx_shape_value_table =
                &(bem_values.kx_shape_value_table_for_common_vertex);
              ky_shape_value_table =
                &(bem_values.ky_shape_value_table_for_common_vertex);

              /**
               * When the kernel type is regularized hyper singular, extract
               * covariant transformation matrices from @p ScratchData and
               * gradient of shape functions from @p BEMValues.
               */
              if (kernel_function.kernel_type == HyperSingularRegular)
                {
                  kx_shape_grad_matrix_table =
                    &(bem_values.kx_shape_grad_matrix_table_for_common_vertex);
                  ky_shape_grad_matrix_table =
                    &(bem_values.ky_shape_grad_matrix_table_for_common_vertex);
                  kx_covariants_table =
                    &(scratch_data.kx_covariants_common_vertex);
                  ky_covariants_table =
                    &(scratch_data.ky_covariants_common_vertex);
                }

              x  = scratch_data.kx_quad_points_common_vertex(k3_index, quad_no);
              y  = scratch_data.ky_quad_points_common_vertex(k3_index, quad_no);
              Jx = scratch_data.kx_jacobians_common_vertex(k3_index, quad_no);
              Jy = scratch_data.ky_jacobians_common_vertex(k3_index, quad_no);
              nx = scratch_data.kx_normals_common_vertex(k3_index, quad_no);
              ny = scratch_data.ky_normals_common_vertex(k3_index, quad_no);

              break;
            }
            case Regular: {
              kx_shape_value_table =
                &(bem_values.kx_shape_value_table_for_regular);
              ky_shape_value_table =
                &(bem_values.ky_shape_value_table_for_regular);

              /**
               * When the kernel type is regularized hyper singular, extract
               * covariant transformation matrices from @p ScratchData and
               * gradient of shape functions from @p BEMValues.
               */
              if (kernel_function.kernel_type == HyperSingularRegular)
                {
                  kx_shape_grad_matrix_table =
                    &(bem_values.kx_shape_grad_matrix_table_for_regular);
                  ky_shape_grad_matrix_table =
                    &(bem_values.ky_shape_grad_matrix_table_for_regular);
                  kx_covariants_table = &(scratch_data.kx_covariants_regular);
                  ky_covariants_table = &(scratch_data.ky_covariants_regular);
                }

              x  = scratch_data.kx_quad_points_regular(k3_index, quad_no);
              y  = scratch_data.ky_quad_points_regular(k3_index, quad_no);
              Jx = scratch_data.kx_jacobians_regular(k3_index, quad_no);
              Jy = scratch_data.ky_jacobians_regular(k3_index, quad_no);
              nx = scratch_data.kx_normals_regular(k3_index, quad_no);
              ny = scratch_data.ky_normals_regular(k3_index, quad_no);

              break;
            }
            default: {
              kx_shape_value_table = nullptr;
              ky_shape_value_table = nullptr;

              if (kernel_function.kernel_type == HyperSingularRegular)
                {
                  kx_shape_grad_matrix_table = nullptr;
                  ky_shape_grad_matrix_table = nullptr;
                  kx_covariants_table        = nullptr;
                  ky_covariants_table        = nullptr;
                }

              Assert(false, ExcInternalError());
              break;
            }
        }

      /**
       * Negate the normal vector in \f$K_y\f$ when the cell neighboring type is
       * common edge. This is because the cell \f$K_y\f$'s orientation has been
       * reversed.
       */
      if (cell_neighboring_type == CommonEdge)
        {
          ny = -ny;
        }

      if (kernel_function.kernel_type == HyperSingularRegular)
        {
          /**
           * Extract the gradient values of the current shape function at the
           * current quadrature point in the unit cell for \f$K_x\f$ as well as
           * \f$K_y\f$.
           */
          Vector<RangeNumberType> kx_shape_grad_in_unit_cell(dim);
          Vector<RangeNumberType> ky_shape_grad_in_unit_cell(dim);

          for (unsigned int i = 0; i < dim; i++)
            {
              kx_shape_grad_in_unit_cell(i) =
                (*kx_shape_grad_matrix_table)(k3_index, quad_no)(kx_dof_index,
                                                                 i);
              ky_shape_grad_in_unit_cell(i) =
                (*ky_shape_grad_matrix_table)(k3_index, quad_no)(ky_dof_index,
                                                                 i);
            }

          /**
           * Apply covariant transformation to the gradient tensors in the unit
           * cell.
           */
          Vector<RangeNumberType> kx_shape_grad_in_real_cell(spacedim);
          Vector<RangeNumberType> ky_shape_grad_in_real_cell(spacedim);
          (*kx_covariants_table)(k3_index, quad_no)
            .vmult(kx_shape_grad_in_real_cell, kx_shape_grad_in_unit_cell);
          (*ky_covariants_table)(k3_index, quad_no)
            .vmult(ky_shape_grad_in_real_cell, ky_shape_grad_in_unit_cell);

          /**
           * Calculate the surface gradient tensor of the shape functions, which
           * is the cross product of normal vector and the volume gradient
           * vector.
           *
           * \mynote{The cross product operation requires the input vectors be
           * transformed to tensors.}
           */
          Tensor<1, spacedim, RangeNumberType> kx_shape_surface_curl =
            dealii::cross_product_3d(nx,
                                     VectorToTensor<spacedim,
                                                    RangeNumberType,
                                                    Vector<RangeNumberType>>(
                                       kx_shape_grad_in_real_cell));
          Tensor<1, spacedim, RangeNumberType> ky_shape_surface_curl =
            dealii::cross_product_3d(ny,
                                     VectorToTensor<spacedim,
                                                    RangeNumberType,
                                                    Vector<RangeNumberType>>(
                                       ky_shape_grad_in_real_cell));

          return kernel_function.value(x, y, nx, ny, component) * Jx * Jy *
                 scalar_product(kx_shape_surface_curl, ky_shape_surface_curl);
        }
      else
        {
          /**
           * Evaluate the original kernel function at the specified pair of
           * points in the real cells with their normal vectors, the result of
           * which is then multiplied by the Jacobians and shape function
           * values.
           */
          return kernel_function.value(x, y, nx, ny, component) * Jx * Jy *
                 (*kx_shape_value_table)(kx_dof_index, k3_index, quad_no) *
                 (*ky_shape_value_table)(ky_dof_index, k3_index, quad_no);
        }
    }


    template <int dim,
              int spacedim,
              template <int, typename>
              typename KernelFunctionType,
              typename RangeNumberType>
    __device__ RangeNumberType
    KernelPulledbackToUnitCell<dim,
                               spacedim,
                               KernelFunctionType,
                               RangeNumberType>::
      value(const unsigned int                                   k3_index,
            const unsigned int                                   quad_no,
            const CUDABEMValues<dim, spacedim, RangeNumberType> &bem_values,
            const CUDAPairCellWiseScratchData<dim, spacedim, RangeNumberType>
                              &scratch_data,
            const unsigned int component) const
    {
      /**
       * N.B. The shape function value and their gradient value data tables are
       * related to the finite element objects. Because the values in these
       * tables are directly evaluated in the unit cell, which do not depend on
       * the real cells, i.e. when coming to a new cell, these values need not
       * be updated,
       * hence they are members of @p BEMValues instead of @p ScratchData.
       */
      const CUDATable<3, RangeNumberType> *kx_shape_value_table       = nullptr;
      const CUDATable<3, RangeNumberType> *ky_shape_value_table       = nullptr;
      const CUDATable<4, RangeNumberType> *kx_shape_grad_matrix_table = nullptr;
      const CUDATable<4, RangeNumberType> *ky_shape_grad_matrix_table = nullptr;

      /**
       * N.B. The covariant transformation matrix data tables are related to the
       * mapping objects instead of the finite element objects. This is natural
       * to understand, the covariant transformation is caused by the coordinate
       * mapping from the unit cell to the real cell.
       *
       * Because the mapping is dependent on real cells, these data should be
       * updated when coming to a new cell. Hence, they are members of
       * @p ScratchData instead of @p BEMValues.
       */
      const CUDATable<4, RangeNumberType> *kx_covariants_table = nullptr;
      const CUDATable<4, RangeNumberType> *ky_covariants_table = nullptr;

      Point<spacedim>                      x, y;
      RangeNumberType                      Jx = 0;
      RangeNumberType                      Jy = 0;
      Tensor<1, spacedim, RangeNumberType> nx, ny;

      /**
       * Select data tables according to the cell neighboring type.
       */
      switch (cell_neighboring_type)
        {
            case SamePanel: {
              kx_shape_value_table =
                &(bem_values.kx_shape_value_table_for_same_panel);
              ky_shape_value_table =
                &(bem_values.ky_shape_value_table_for_same_panel);

              /**
               * When the kernel type is regularized hyper singular, extract
               * covariant transformation matrices from @p ScratchData and
               * gradient of shape functions from @p BEMValues.
               */
              if (kernel_function.kernel_type == HyperSingularRegular)
                {
                  kx_shape_grad_matrix_table =
                    &(bem_values.kx_shape_grad_matrix_table_for_same_panel);
                  ky_shape_grad_matrix_table =
                    &(bem_values.ky_shape_grad_matrix_table_for_same_panel);
                  kx_covariants_table =
                    &(scratch_data.kx_covariants_same_panel);
                  ky_covariants_table =
                    &(scratch_data.ky_covariants_same_panel);
                }

              x  = scratch_data.kx_quad_points_same_panel(k3_index, quad_no);
              y  = scratch_data.ky_quad_points_same_panel(k3_index, quad_no);
              Jx = scratch_data.kx_jacobians_same_panel(k3_index, quad_no);
              Jy = scratch_data.ky_jacobians_same_panel(k3_index, quad_no);
              nx = scratch_data.kx_normals_same_panel(k3_index, quad_no);
              ny = scratch_data.ky_normals_same_panel(k3_index, quad_no);

              break;
            }
            case CommonEdge: {
              kx_shape_value_table =
                &(bem_values.kx_shape_value_table_for_common_edge);
              ky_shape_value_table =
                &(bem_values.ky_shape_value_table_for_common_edge);

              /**
               * When the kernel type is regularized hyper singular, extract
               * covariant transformation matrices from @p ScratchData and
               * gradient of shape functions from @p BEMValues.
               */
              if (kernel_function.kernel_type == HyperSingularRegular)
                {
                  kx_shape_grad_matrix_table =
                    &(bem_values.kx_shape_grad_matrix_table_for_common_edge);
                  ky_shape_grad_matrix_table =
                    &(bem_values.ky_shape_grad_matrix_table_for_common_edge);
                  kx_covariants_table =
                    &(scratch_data.kx_covariants_common_edge);
                  ky_covariants_table =
                    &(scratch_data.ky_covariants_common_edge);
                }

              x  = scratch_data.kx_quad_points_common_edge(k3_index, quad_no);
              y  = scratch_data.ky_quad_points_common_edge(k3_index, quad_no);
              Jx = scratch_data.kx_jacobians_common_edge(k3_index, quad_no);
              Jy = scratch_data.ky_jacobians_common_edge(k3_index, quad_no);
              nx = scratch_data.kx_normals_common_edge(k3_index, quad_no);
              ny = scratch_data.ky_normals_common_edge(k3_index, quad_no);

              break;
            }
            case CommonVertex: {
              kx_shape_value_table =
                &(bem_values.kx_shape_value_table_for_common_vertex);
              ky_shape_value_table =
                &(bem_values.ky_shape_value_table_for_common_vertex);

              /**
               * When the kernel type is regularized hyper singular, extract
               * covariant transformation matrices from @p ScratchData and
               * gradient of shape functions from @p BEMValues.
               */
              if (kernel_function.kernel_type == HyperSingularRegular)
                {
                  kx_shape_grad_matrix_table =
                    &(bem_values.kx_shape_grad_matrix_table_for_common_vertex);
                  ky_shape_grad_matrix_table =
                    &(bem_values.ky_shape_grad_matrix_table_for_common_vertex);
                  kx_covariants_table =
                    &(scratch_data.kx_covariants_common_vertex);
                  ky_covariants_table =
                    &(scratch_data.ky_covariants_common_vertex);
                }

              x  = scratch_data.kx_quad_points_common_vertex(k3_index, quad_no);
              y  = scratch_data.ky_quad_points_common_vertex(k3_index, quad_no);
              Jx = scratch_data.kx_jacobians_common_vertex(k3_index, quad_no);
              Jy = scratch_data.ky_jacobians_common_vertex(k3_index, quad_no);
              nx = scratch_data.kx_normals_common_vertex(k3_index, quad_no);
              ny = scratch_data.ky_normals_common_vertex(k3_index, quad_no);

              break;
            }
            case Regular: {
              kx_shape_value_table =
                &(bem_values.kx_shape_value_table_for_regular);
              ky_shape_value_table =
                &(bem_values.ky_shape_value_table_for_regular);

              /**
               * When the kernel type is regularized hyper singular, extract
               * covariant transformation matrices from @p ScratchData and
               * gradient of shape functions from @p BEMValues.
               */
              if (kernel_function.kernel_type == HyperSingularRegular)
                {
                  kx_shape_grad_matrix_table =
                    &(bem_values.kx_shape_grad_matrix_table_for_regular);
                  ky_shape_grad_matrix_table =
                    &(bem_values.ky_shape_grad_matrix_table_for_regular);
                  kx_covariants_table = &(scratch_data.kx_covariants_regular);
                  ky_covariants_table = &(scratch_data.ky_covariants_regular);
                }

              x  = scratch_data.kx_quad_points_regular(k3_index, quad_no);
              y  = scratch_data.ky_quad_points_regular(k3_index, quad_no);
              Jx = scratch_data.kx_jacobians_regular(k3_index, quad_no);
              Jy = scratch_data.ky_jacobians_regular(k3_index, quad_no);
              nx = scratch_data.kx_normals_regular(k3_index, quad_no);
              ny = scratch_data.ky_normals_regular(k3_index, quad_no);

              break;
            }
            default: {
              kx_shape_value_table = nullptr;
              ky_shape_value_table = nullptr;

              if (kernel_function.kernel_type == HyperSingularRegular)
                {
                  kx_shape_grad_matrix_table = nullptr;
                  ky_shape_grad_matrix_table = nullptr;
                  kx_covariants_table        = nullptr;
                  ky_covariants_table        = nullptr;
                }
              break;
            }
        }

      /**
       * Negate the normal vector in \f$K_y\f$ when the cell neighboring type is
       * common edge. This is because the cell \f$K_y\f$'s orientation has been
       * reversed.
       */
      if (cell_neighboring_type == CommonEdge)
        {
          ny = -ny;
        }

      if (kernel_function.kernel_type == HyperSingularRegular)
        {
          /**
           * Extract the gradient values of the current shape function at the
           * current quadrature point in the unit cell for \f$K_x\f$ as well as
           * \f$K_y\f$.
           */
          RangeNumberType             kx_shape_grad_in_unit_cell[dim];
          RangeNumberType             ky_shape_grad_in_unit_cell[dim];
          CUDAVector<RangeNumberType> kx_shape_grad_in_unit_cell_vector(
            kx_shape_grad_in_unit_cell, dim);
          CUDAVector<RangeNumberType> ky_shape_grad_in_unit_cell_vector(
            ky_shape_grad_in_unit_cell, dim);

#pragma unroll
          for (unsigned int i = 0; i < dim; i++)
            {
              kx_shape_grad_in_unit_cell[i] = (*kx_shape_grad_matrix_table)(
                k3_index, quad_no, i, kx_dof_index);
              ky_shape_grad_in_unit_cell[i] = (*ky_shape_grad_matrix_table)(
                k3_index, quad_no, i, ky_dof_index);
            }

          /**
           * Apply covariant transformation to the gradient tensors in the unit
           * cell.
           */
          RangeNumberType             kx_shape_grad_in_real_cell[spacedim];
          RangeNumberType             ky_shape_grad_in_real_cell[spacedim];
          CUDAVector<RangeNumberType> kx_shape_grad_in_real_cell_vector(
            kx_shape_grad_in_real_cell, spacedim);
          CUDAVector<RangeNumberType> ky_shape_grad_in_real_cell_vector(
            ky_shape_grad_in_real_cell, spacedim);

          CUDAFullMatrix<RangeNumberType> kx_covariant_matrix(
            const_cast<RangeNumberType *>(
              &((*kx_covariants_table)(k3_index, quad_no, 0, 0))),
            spacedim,
            dim);
          CUDAFullMatrix<RangeNumberType> ky_covariant_matrix(
            const_cast<RangeNumberType *>(
              &((*ky_covariants_table)(k3_index, quad_no, 0, 0))),
            spacedim,
            dim);

          kx_covariant_matrix.vmult(kx_shape_grad_in_real_cell_vector,
                                    kx_shape_grad_in_unit_cell_vector);
          ky_covariant_matrix.vmult(ky_shape_grad_in_real_cell_vector,
                                    ky_shape_grad_in_unit_cell_vector);

          /**
           * Calculate the surface gradient tensor of the shape functions, which
           * is the cross product of normal vector and the volume gradient
           * vector.
           *
           * \mynote{The cross product operation requires the input vectors be
           * transformed to tensors.}
           */
          Tensor<1, spacedim, RangeNumberType> kx_shape_surface_curl =
            cross_product_3d(nx, kx_shape_grad_in_real_cell_vector);
          Tensor<1, spacedim, RangeNumberType> ky_shape_surface_curl =
            cross_product_3d(ny, ky_shape_grad_in_real_cell_vector);

          return kernel_function.value(x, y, nx, ny, component) * Jx * Jy *
                 scalar_product(kx_shape_surface_curl, ky_shape_surface_curl);
        }
      else
        {
          /**
           * Evaluate the original kernel function at the specified pair of
           * points in the real cells with their normal vectors, the result of
           * which is then multiplied by the Jacobians and shape function
           * values.
           */
          return kernel_function.value(x, y, nx, ny, component) * Jx * Jy *
                 (*kx_shape_value_table)(kx_dof_index, k3_index, quad_no) *
                 (*ky_shape_value_table)(ky_dof_index, k3_index, quad_no);
        }
    }


    /**
     * Class for pullback the kernel function on the product of two unit cells
     * to Sauter's parametric space.
     */
    template <int dim,
              int spacedim,
              template <int, typename>
              typename KernelFunctionType,
              typename RangeNumberType = double>
    class KernelPulledbackToSauterSpace
    {
    public:
      const unsigned int n_components;

      /**
       * Constructor with @p BEMValues.
       *
       * @param kernel
       * @param cell_neighboring_type
       * @param bem_values
       */
      __host__ __device__
      KernelPulledbackToSauterSpace(
        const KernelPulledbackToUnitCell<dim,
                                         spacedim,
                                         KernelFunctionType,
                                         RangeNumberType> &kernel,
        const CellNeighboringType cell_neighboring_type);

      /**
       * Destructor.
       *
       * \mynote{Since this class has only references to other objects as its
       * members and their memory is not managed by this class, the destructor
       * provided by the compiler is adopted.}
       */
      __host__ __device__ ~KernelPulledbackToSauterSpace();

      /**
       * Assignment operator
       *
       * @param f
       * @return
       */
      __host__ __device__ KernelPulledbackToSauterSpace &
      operator=(const KernelPulledbackToSauterSpace &f);

      /**
       * Evaluate the pullback of the kernel function on the host on Sauter's
       * parametric space at the quad_no'th quadrature point under the given 4D
       * quadrature rule. This version runs on the CPU host.
       *
       * @param quad_no
       * @param bem_values
       * @param scratch_data
       * @param component
       * @return
       */
      __host__ RangeNumberType
      value(const unsigned int                               quad_no,
            const BEMValues<dim, spacedim, RangeNumberType> &bem_values,
            const PairCellWiseScratchData<dim, spacedim, RangeNumberType>
                              &scratch_data,
            const unsigned int component = 0) const;

      /**
       * Evaluate the pullback of kernel function on the device on Sauter's
       * parametric space at the quad_no'th quadrature point under the given 4D
       * quadrature rule. This version runs on the GPU device.
       *
       * @param quad_no quadrature point index
       * @param component
       * @return
       */
      __device__ RangeNumberType
      value(const unsigned int                                   quad_no,
            const CUDABEMValues<dim, spacedim, RangeNumberType> &bem_values,
            const CUDAPairCellWiseScratchData<dim, spacedim, RangeNumberType>
                              &scratch_data,
            const unsigned int component = 0) const;

    private:
      const KernelPulledbackToUnitCell<dim,
                                       spacedim,
                                       KernelFunctionType,
                                       RangeNumberType> &kernel_on_unit_cell;
      CellNeighboringType                                cell_neighboring_type;
    };


    template <int dim,
              int spacedim,
              template <int, typename>
              typename KernelFunctionType,
              typename RangeNumberType>
    __host__ __device__
    KernelPulledbackToSauterSpace<dim,
                                  spacedim,
                                  KernelFunctionType,
                                  RangeNumberType>::
      KernelPulledbackToSauterSpace(
        const KernelPulledbackToUnitCell<dim,
                                         spacedim,
                                         KernelFunctionType,
                                         RangeNumberType> &kernel,
        const CellNeighboringType cell_neighboring_type)
      : n_components(kernel.n_components)
      , kernel_on_unit_cell(kernel)
      , cell_neighboring_type(cell_neighboring_type)
    {}


    template <int dim,
              int spacedim,
              template <int, typename>
              typename KernelFunctionType,
              typename RangeNumberType>
    __host__ __device__ KernelPulledbackToSauterSpace<
      dim,
      spacedim,
      KernelFunctionType,
      RangeNumberType>::~KernelPulledbackToSauterSpace() = default;


    template <int dim,
              int spacedim,
              template <int, typename>
              typename KernelFunctionType,
              typename RangeNumberType>
    __host__ __device__ KernelPulledbackToSauterSpace<dim,
                                                      spacedim,
                                                      KernelFunctionType,
                                                      RangeNumberType>                     &
    KernelPulledbackToSauterSpace<
                          dim,
                          spacedim,
                          KernelFunctionType,
                          RangeNumberType>::operator=(const KernelPulledbackToSauterSpace &f)
    {
      assert(n_components == f.n_components);

      kernel_on_unit_cell   = f.kernel_on_unit_cell;
      cell_neighboring_type = f.cell_neighboring_type;

      return *this;
    }


    template <int dim,
              int spacedim,
              template <int, typename>
              typename KernelFunctionType,
              typename RangeNumberType>
    __host__ RangeNumberType
    KernelPulledbackToSauterSpace<dim,
                                  spacedim,
                                  KernelFunctionType,
                                  RangeNumberType>::
      value(const unsigned int                               quad_no,
            const BEMValues<dim, spacedim, RangeNumberType> &bem_values,
            const PairCellWiseScratchData<dim, spacedim, RangeNumberType>
                              &scratch_data,
            const unsigned int component) const
    {
      RangeNumberType kernel_value = 0.;

      switch (cell_neighboring_type)
        {
            case SamePanel: {
              // Current point in the Sauter's parametric space, at which the
              // pulled back kernel function is to be evaluated.
              const Point<dim * 2> &p =
                bem_values.quad_rule_for_same_panel.point(quad_no);
              double jacobian_det = p(0) * (1 - p(0)) * (1 - p(0) * p(1));

              for (unsigned int k3_index = 0; k3_index < 8; k3_index++)
                {
                  kernel_value += kernel_on_unit_cell.value(
                    k3_index, quad_no, bem_values, scratch_data, component);
                }

              kernel_value *= jacobian_det;

              break;
            }
            case CommonEdge: {
              // Current point in the Sauter's parametric space, at which the
              // pulled back kernel function is to be evaluated.
              const Point<dim * 2> &p =
                bem_values.quad_rule_for_common_edge.point(quad_no);
              double jacobian_det1 = p(0) * p(0) * (1 - p(0));
              double jacobian_det2 = p(0) * p(0) * (1 - p(0) * p(1));

              kernel_value =
                jacobian_det1 *
                  (kernel_on_unit_cell.value(
                     0, quad_no, bem_values, scratch_data, component) +
                   kernel_on_unit_cell.value(
                     1, quad_no, bem_values, scratch_data, component)) +
                jacobian_det2 *
                  (kernel_on_unit_cell.value(
                     2, quad_no, bem_values, scratch_data, component) +
                   kernel_on_unit_cell.value(
                     3, quad_no, bem_values, scratch_data, component) +
                   kernel_on_unit_cell.value(
                     4, quad_no, bem_values, scratch_data, component) +
                   kernel_on_unit_cell.value(
                     5, quad_no, bem_values, scratch_data, component));

              break;
            }
            case CommonVertex: {
              // Current point in the Sauter's parametric space, at which the
              // pulled back kernel function is to be evaluated.
              const Point<dim * 2> &p =
                bem_values.quad_rule_for_common_vertex.point(quad_no);
              double jacobian_det = dealii::Utilities::fixed_power<3>(p(0));

              for (unsigned int k3_index = 0; k3_index < 4; k3_index++)
                {
                  kernel_value += kernel_on_unit_cell.value(
                    k3_index, quad_no, bem_values, scratch_data, component);
                }

              kernel_value *= jacobian_det;

              break;
            }
            case Regular: {
              // There is no coordinate transformation for the regular case, so
              // directly evaluate the kernel function on the product of unit
              // cells.
              kernel_value = kernel_on_unit_cell.value(
                0, quad_no, bem_values, scratch_data, component);

              break;
            }
          default:
            Assert(false, ExcInternalError());
        }

      return kernel_value;
    }


    template <int dim,
              int spacedim,
              template <int, typename>
              typename KernelFunctionType,
              typename RangeNumberType>
    __device__ RangeNumberType
    KernelPulledbackToSauterSpace<dim,
                                  spacedim,
                                  KernelFunctionType,
                                  RangeNumberType>::
      value(const unsigned int                                   quad_no,
            const CUDABEMValues<dim, spacedim, RangeNumberType> &bem_values,
            const CUDAPairCellWiseScratchData<dim, spacedim, RangeNumberType>
                              &scratch_data,
            const unsigned int component) const
    {
      RangeNumberType kernel_value = 0.;

      switch (cell_neighboring_type)
        {
            case SamePanel: {
              /**
               * @internal Here we get the reference to the table of quadrature
               * points first. Then get the current quadrature point in the
               * Sauter's parametric space, at which the pulled back kernel
               * function is to be evaluated.
               */
              const CUDATable<2, double> &quad_points =
                bem_values.quad_rule_for_same_panel.get_points();
              double jacobian_det =
                quad_points(quad_no, 0) * (1 - quad_points(quad_no, 0)) *
                (1 - quad_points(quad_no, 0) * quad_points(quad_no, 1));

#pragma unroll
              for (unsigned int k3_index = 0; k3_index < 8; k3_index++)
                {
                  kernel_value += kernel_on_unit_cell.value(
                    k3_index, quad_no, bem_values, scratch_data, component);
                }

              kernel_value *= jacobian_det;

              break;
            }
            case CommonEdge: {
              /**
               * @internal Here we get the reference to the table of quadrature
               * points first. Then get the current quadrature point in the
               * Sauter's parametric space, at which the pulled back kernel
               * function is to be evaluated.
               */
              const CUDATable<2, double> &quad_points =
                bem_values.quad_rule_for_common_edge.get_points();
              double jacobian_det1 = quad_points(quad_no, 0) *
                                     quad_points(quad_no, 0) *
                                     (1 - quad_points(quad_no, 0));
              double jacobian_det2 =
                quad_points(quad_no, 0) * quad_points(quad_no, 0) *
                (1 - quad_points(quad_no, 0) * quad_points(quad_no, 1));

              kernel_value =
                jacobian_det1 *
                  (kernel_on_unit_cell.value(
                     0, quad_no, bem_values, scratch_data, component) +
                   kernel_on_unit_cell.value(
                     1, quad_no, bem_values, scratch_data, component)) +
                jacobian_det2 *
                  (kernel_on_unit_cell.value(
                     2, quad_no, bem_values, scratch_data, component) +
                   kernel_on_unit_cell.value(
                     3, quad_no, bem_values, scratch_data, component) +
                   kernel_on_unit_cell.value(
                     4, quad_no, bem_values, scratch_data, component) +
                   kernel_on_unit_cell.value(
                     5, quad_no, bem_values, scratch_data, component));

              break;
            }
            case CommonVertex: {
              /**
               * @internal Here we get the reference to the table of quadrature
               * points first. Then get the current quadrature point in the
               * Sauter's parametric space, at which the pulled back kernel
               * function is to be evaluated.
               */
              const CUDATable<2, double> &quad_points =
                bem_values.quad_rule_for_common_vertex.get_points();
              double jacobian_det =
                HierBEM::Utilities::CUDAWrappers::fixed_power<3>(
                  quad_points(quad_no, 0));

#pragma unroll
              for (unsigned int k3_index = 0; k3_index < 4; k3_index++)
                {
                  kernel_value += kernel_on_unit_cell.value(
                    k3_index, quad_no, bem_values, scratch_data, component);
                }

              kernel_value *= jacobian_det;

              break;
            }
            case Regular: {
              /**
               * @internal There is no coordinate transformation for the regular
               * case, so directly evaluate the kernel function on the product
               * of unit cells.
               */
              kernel_value = kernel_on_unit_cell.value(
                0, quad_no, bem_values, scratch_data, component);

              break;
            }
        }

      return kernel_value;
    }
  } // namespace CUDAWrappers
} // namespace HierBEM

#endif /* INCLUDE_BEM_KERNELS_HCU_ */
