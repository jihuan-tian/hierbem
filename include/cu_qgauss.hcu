/**
 * @file CUDAQGauss.hcu
 * @brief Introduction of cu_qgauss.hcu
 *
 * @date 2023-01-29
 * @author Jihuan Tian
 */
#ifndef INCLUDE_CU_QGAUSS_HCU_
#define INCLUDE_CU_QGAUSS_HCU_

#include <deal.II/base/table_indices.h>

#include <cuda_runtime.h>

#include <cmath>
#include <cstdio>
#include <cstdlib>

#include "cu_table.hcu"
#include "quadrature.templates.h"

namespace IdeoBEM
{
  using namespace dealii;

  namespace CUDAWrappers
  {
    template <int dim>
    class CUDAQGauss
    {
    public:
      // Declaration of friend functions.
      template <int dim1>
      friend __global__ void
      print_cuda_object(const CUDAQGauss<dim1> quad);

      /**
       * Allocate memory on the device from the host.
       *
       * @param n Total number of quadrature points, not the number of points
       * in a direction.
       */
      __host__ void
      allocate(const unsigned int n);

      /**
       * Assign values held within a deal.ii @p QGauss object on the host to
       * the device.
       *
       * \alert{The memory should preallocated before value assignment.}
       *
       * @param quad_cpu
       */
      __host__ void
      assign_from_host(const QGauss<dim> &quad_cpu);

      /**
       * Release the memory on the device.
       */
      __host__ void
      release();

      /**
       * Get the total number of quadrature points, not the number of points in
       * a direction.
       *
       * @return
       */
      __host__ __device__ unsigned int
      size() const;

      /**
       * Get the const reference to the table of quadrature points.
       *
       * @return
       */
      __host__ __device__ const CUDATable<2, double>                           &
      get_points() const;

      /**
       * Get the const pointer which is also pointer to const of the quadrature
       * weights.
       *
       * @return
       */
      __host__ __device__ const double *
      get_weights() const;

    private:
      unsigned int quad_num = 0;
      /**
       * Table of quadrature points. The first dimension is the quadrature point
       * index. The second dimension is coordinate index. Since @p CUDATable
       * adopts C style indexing, this memory configuration is consistent with
       * the quadrature point data held within @p QGauss, which is a vector of
       * @p Point objects.
       */
      CUDATable<2, double> points;
      double              *weights = nullptr;
    };


    template <int dim>
    __host__ void
    CUDAQGauss<dim>::allocate(const unsigned int n)
    {
      quad_num = n;
      points.allocate(TableIndices<2>(quad_num, dim));

      if (weights != nullptr)
        {
          cudaError_t error_code = cudaFree(weights);
          AssertCuda(error_code);
        }

      cudaError_t error_code =
        cudaMalloc((void **)&weights, sizeof(double) * quad_num);
      AssertCuda(error_code);
    }


    template <int dim>
    __host__ void
    CUDAQGauss<dim>::assign_from_host(const QGauss<dim> &quad_cpu)
    {
      AssertDimension(quad_num, quad_cpu.size());

      // Allocate memory for the table of quadrature points, which should be
      // accessed using the C style index. N.B. Here we explicitly cast the
      // pointer type <code>Point<dim> *</code> to <code>const double *</code>,
      // which is also the address of the first coordinate component of the
      // first quadrature point.
      points.assign_from_host((const double *)(quad_cpu.get_points().data()),
                              dim * quad_num);
      cudaError_t error_code = cudaMemcpy(weights,
                                          quad_cpu.get_weights().data(),
                                          quad_num * sizeof(double),
                                          cudaMemcpyHostToDevice);
      AssertCuda(error_code);
    }


    template <int dim>
    __host__ void
    CUDAQGauss<dim>::release()
    {
      quad_num = 0;

      points.release();
      if (weights != nullptr)
        {
          cudaError_t error_code = cudaFree(weights);
          AssertCuda(error_code);

          weights = nullptr;
        }
    }


    template <int dim>
    __host__ __device__ inline unsigned int
    CUDAQGauss<dim>::size() const
    {
      return quad_num;
    }


    template <int dim>
    __host__ __device__ inline const CUDATable<2, double>          &
    CUDAQGauss<dim>::get_points() const
    {
      return points;
    }


    template <int dim>
    __host__ __device__ inline const double *
    CUDAQGauss<dim>::get_weights() const
    {
      return weights;
    }


    template <int dim>
    __global__ void
    print_cuda_object(const CUDAQGauss<dim> quad)
    {
      const unsigned int idx        = (blockIdx.x * blockDim.x) + threadIdx.x;
      const unsigned int idy        = (blockIdx.y * blockDim.y) + threadIdx.y;
      const unsigned int thread_idx = (gridDim.x * blockDim.x) * idy + idx;

      if (thread_idx == 0)
        {
          for (unsigned int q = 0; q < quad.size(); q++)
            {
              printf("#%d: points=(", q);

              for (unsigned int i = 0; i < dim; i++)
                {
                  if (i == dim - 1)
                    {
                      printf("%f), weights=%f\n",
                             quad.get_points()[q * dim + i],
                             quad.get_weights()[q]);
                    }
                  else
                    {
                      printf("%f,", quad.get_points()[q * dim + i]);
                    }
                }
            }
        }
    }
  } // namespace CUDAWrappers
} // namespace IdeoBEM


#endif /* INCLUDE_CU_QGAUSS_HCU_ */
