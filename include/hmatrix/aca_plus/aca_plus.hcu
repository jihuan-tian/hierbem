/**
 * @file aca_plus.hcu
 * @brief Implement the ACA+ method proposed in Grasedyck, L. 2005. “Adaptive
 * Recompression of \f$\mathscr{H}\f$-Matrices for BEM.” Computing 74 (3):
 * 205–23.
 *
 * @date 2022-03-07
 * @author Jihuan Tian
 */
#ifndef HIERBEM_INCLUDE_HMATRIX_ACA_PLUS_ACA_PLUS_H_
#define HIERBEM_INCLUDE_HMATRIX_ACA_PLUS_ACA_PLUS_H_

#include <deal.II/base/logstream.h>
#include <deal.II/base/numbers.h>
#include <deal.II/base/parallel.h>
#include <deal.II/base/timer.h>
#include <deal.II/base/types.h>

#include <deal.II/fe/fe_update_flags.h>

#include <deal.II/lac/vector.h>

#include <cuda_runtime.h>
#include <tbb/tbb.h>

#include <algorithm>
#include <chrono>
#include <cmath>
#include <complex>
#include <condition_variable>
#include <forward_list>
#include <functional>
#include <iostream>
#include <iterator>
#include <mutex>
#include <random>
#include <thread>
#include <type_traits>
#include <vector>

#include "bem_kernels.hcu"
#include "bem_tools.h"
#include "config.h"
#include "cu_bem_values.hcu"
#include "cu_table.hcu"
#include "debug_tools.h"
#include "generic_functors.h"
#include "hmatrix/aca_plus/aca_config.h"
#include "hmatrix/hmatrix.h"
#include "lapack_full_matrix_ext.h"
#include "linalg.h"
#include "mapping/mapping_info.h"
#include "number_traits.h"
#include "sauter_quadrature.hcu"
#include "unary_template_arg_containers.h"

HBEM_NS_OPEN

using namespace dealii;

/**
 * Global declaration of the random number device and engine.
 */
#if RANDOM_ACA
extern std::random_device rd;
#endif

#ifdef DEAL_II_WITH_64BIT_INDICES
extern std::mt19937_64 rand_engine;
#else
extern std::mt19937 rand_engine;
#endif

/**
 * The type used for matrix row and column indices.
 */
using size_type = std::make_unsigned<types::blas_int>::type;

/**
 * Generate a random non-negative integer in the specified range \f$[a,b]\f$
 * using the global random number engine @p rand_engine.
 *
 * @param a
 * @param b
 * @return
 */
size_type
generate_random_index(const size_type a, const size_type b);

/**
 * Assemble a row vector by evaluating the Galerkin-BEM double integral with
 * respect to the kernel.
 *
 * \mynote{The memory for @p row_vector should be preallocated, since inside
 * the function there is no reinitialization of this vector anymore.}
 *
 * @param row_vector [out]
 * @param scratch
 * @param data
 * @param kernel
 * @param row_dof_index The current row DoF index.
 * @param column_dof_indices The list of column DoF indices.
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
assemble_kernel_row(
  Vector<RangeNumberType> &row_vector,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                             &kernel,
  const DeviceNumberType<KernelNumberType>    kernel_factor,
  const types::global_dof_index               row_dof_index,
  const std::vector<types::global_dof_index> &column_dof_indices,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &kx_dof_to_cell_topo,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const DoFHandler<dim, spacedim>                               &kx_dof_handler,
  const DoFHandler<dim, spacedim>                               &ky_dof_handler,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData<
    dim,
    spacedim,
    DeviceNumberType<KernelNumberType>>                    &scratch_data_gpu,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  AssertDimension(row_vector.size(), column_dof_indices.size());

  types::global_dof_index i_global_dof_index =
    (kx_map_from_local_to_full_dof_indices == nullptr) ?
      kx_dof_i2e_numbering[row_dof_index] :
      kx_map_from_local_to_full_dof_indices->at(
        kx_dof_i2e_numbering[row_dof_index]);
  types::global_dof_index j_global_dof_index;

  /**
   * Iterate over each column DoF index.
   */
  for (size_type j = 0; j < column_dof_indices.size(); j++)
    {
      j_global_dof_index = (ky_map_from_local_to_full_dof_indices == nullptr) ?
                             ky_dof_i2e_numbering[column_dof_indices[j]] :
                             ky_map_from_local_to_full_dof_indices->at(
                               ky_dof_i2e_numbering[column_dof_indices[j]]);

      row_vector(j) = sauter_quadrature_on_one_pair_of_far_field_dofs(
        kernel,
        kernel_factor,
        i_global_dof_index,
        j_global_dof_index,
        kx_dof_to_cell_topo,
        ky_dof_to_cell_topo,
        bem_values_gpu,
        kx_dof_handler,
        ky_dof_handler,
        mappings,
        material_id_to_mapping_index,
        normal_detector,
        scratch_data,
        scratch_data_gpu,
        copy_data);
    }
}


/**
 * Assemble a row vector by evaluating the Galerkin-BEM double integral with
 * respect to the kernel.
 *
 * \mynote{1. The memory for @p row_vector should be preallocated, since inside
 * the function there is no reinitialization of this vector anymore.
 * 2. This version is especially for assembling the regularized
 * hyper-singular matrix with the stabilization term.}
 *
 * @param row_vector
 * @param kernel
 * @param kernel_factor
 * @param mass_vmult_weq
 * @param stabilization_factor
 * @param row_dof_index
 * @param column_dof_indices
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param bem_values
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_dof_i2e_numbering
 * @param ky_dof_i2e_numbering
 * @param kx_mapping
 * @param ky_mapping
 * @param scratch_data
 * @param copy_data
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
assemble_kernel_row(
  Vector<RangeNumberType> &row_vector,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                              &kernel,
  const DeviceNumberType<KernelNumberType>     kernel_factor,
  const std::vector<Vector<KernelNumberType>> &mass_vmult_weq,
  const KernelNumberType                       stabilization_factor,
  const types::global_dof_index                row_dof_index,
  const std::vector<types::global_dof_index>  &column_dof_indices,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &kx_dof_to_cell_topo,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const DoFHandler<dim, spacedim>                               &kx_dof_handler,
  const DoFHandler<dim, spacedim>                               &ky_dof_handler,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData<
    dim,
    spacedim,
    DeviceNumberType<KernelNumberType>>                    &scratch_data_gpu,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  AssertDimension(row_vector.size(), column_dof_indices.size());

  types::global_dof_index i_global_dof_index =
    (kx_map_from_local_to_full_dof_indices == nullptr) ?
      kx_dof_i2e_numbering[row_dof_index] :
      kx_map_from_local_to_full_dof_indices->at(
        kx_dof_i2e_numbering[row_dof_index]);
  types::global_dof_index j_global_dof_index;

  /**
   * Iterate over each column DoF index.
   */
  for (size_type j = 0; j < column_dof_indices.size(); j++)
    {
      j_global_dof_index = (ky_map_from_local_to_full_dof_indices == nullptr) ?
                             ky_dof_i2e_numbering[column_dof_indices[j]] :
                             ky_map_from_local_to_full_dof_indices->at(
                               ky_dof_i2e_numbering[column_dof_indices[j]]);

      row_vector(j) = sauter_quadrature_on_one_pair_of_far_field_dofs(
        kernel,
        kernel_factor,
        i_global_dof_index,
        j_global_dof_index,
        kx_dof_to_cell_topo,
        ky_dof_to_cell_topo,
        bem_values_gpu,
        kx_dof_handler,
        ky_dof_handler,
        mappings,
        material_id_to_mapping_index,
        normal_detector,
        scratch_data,
        scratch_data_gpu,
        copy_data);

      for (const auto &vec : mass_vmult_weq)
        row_vector(j) += stabilization_factor * vec(row_dof_index) *
                         vec(column_dof_indices[j]);
    }
}


/**
 * Assemble a row vector by evaluating the Galerkin-BEM double integral with
 * respect to the kernel. This version parallelizes over each vector element.
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
assemble_kernel_row(
  HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector<
    dim,
    spacedim,
    DeviceNumberType<RangeNumberType>,
    DeviceNumberType<KernelNumberType>> &task_buffer,
  Vector<RangeNumberType>               &row_vector,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                             &kernel,
  const DeviceNumberType<KernelNumberType>    kernel_factor,
  const types::global_dof_index               row_dof_index,
  const std::vector<types::global_dof_index> &column_dof_indices,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &kx_dof_to_cell_topo,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  AssertDimension(row_vector.size(), column_dof_indices.size());

  task_buffer.reinit();

  /**
   * @internal Add all Sauter quadrature tasks to the buffer for assembling
   * the row or column vector.
   */
  types::global_dof_index i_global_dof_index =
    (kx_map_from_local_to_full_dof_indices == nullptr) ?
      kx_dof_i2e_numbering[row_dof_index] :
      kx_map_from_local_to_full_dof_indices->at(
        kx_dof_i2e_numbering[row_dof_index]);
  types::global_dof_index j_global_dof_index;

  /**
   * @internal Iterate over each column DoF index.
   */
  task_buffer.starting_task_indices_for_dof_pairs_cpu[0] = 0;
  for (size_type j = 0; j < column_dof_indices.size(); j++)
    {
      j_global_dof_index = (ky_map_from_local_to_full_dof_indices == nullptr) ?
                             ky_dof_i2e_numbering[column_dof_indices[j]] :
                             ky_map_from_local_to_full_dof_indices->at(
                               ky_dof_i2e_numbering[column_dof_indices[j]]);

      task_buffer.starting_task_indices_for_dof_pairs_cpu[j + 1] =
        task_buffer.starting_task_indices_for_dof_pairs_cpu[j] +
        HierBEM::CUDAWrappers::
          create_sauter_quadrature_tasks_on_one_pair_of_dofs(
            task_buffer,
            i_global_dof_index,
            j_global_dof_index,
            kx_dof_to_cell_topo,
            ky_dof_to_cell_topo,
            mappings,
            material_id_to_mapping_index,
            normal_detector,
            scratch_data,
            copy_data);
    }

  /**
   * @internal Process all Sauter quadrature tasks and generate the vector.
   */
  task_buffer.process_tasks(row_vector,
                            kernel,
                            kernel_factor,
                            bem_values_gpu,
                            128,
                            128,
                            scratch_data.cuda_stream_handle);
}


/**
 * Assemble a row vector by evaluating the Galerkin-BEM double integral with
 * respect to the kernel. This version regularizes the kernel and parallelizes
 * over each vector element.
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
assemble_kernel_row(
  HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector<
    dim,
    spacedim,
    DeviceNumberType<RangeNumberType>,
    DeviceNumberType<KernelNumberType>> &task_buffer,
  Vector<RangeNumberType>               &row_vector,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                              &kernel,
  const DeviceNumberType<KernelNumberType>     kernel_factor,
  const std::vector<Vector<KernelNumberType>> &mass_vmult_weq,
  const KernelNumberType                       stabilization_factor,
  const types::global_dof_index                row_dof_index,
  const std::vector<types::global_dof_index>  &column_dof_indices,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &kx_dof_to_cell_topo,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  assemble_kernel_row(task_buffer,
                      row_vector,
                      kernel,
                      kernel_factor,
                      row_dof_index,
                      column_dof_indices,
                      kx_dof_to_cell_topo,
                      ky_dof_to_cell_topo,
                      bem_values_gpu,
                      kx_map_from_local_to_full_dof_indices,
                      ky_map_from_local_to_full_dof_indices,
                      kx_dof_i2e_numbering,
                      ky_dof_i2e_numbering,
                      mappings,
                      material_id_to_mapping_index,
                      normal_detector,
                      scratch_data,
                      copy_data);

  for (size_type j = 0; j < column_dof_indices.size(); j++)
    {
      for (const auto &vec : mass_vmult_weq)
        row_vector(j) += stabilization_factor * vec(row_dof_index) *
                         vec(column_dof_indices[j]);
    }
}


/**
 * Assemble a column vector by evaluating the Galerkin-BEM double integral
 * with respect to the kernel.
 *
 * \mynote{The memory for @p col_vector should be preallocated, since inside
 * the function there is no reinitialization of this vector anymore.}
 *
 * @param col_vector
 * @param kernel
 * @param factor
 * @param row_dof_indices The list of row DoF indices in the global internal
 * DoF numbering.
 * @param col_dof_index The column DoF index in the global internal DoF
 * numbering.
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param bem_values
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_map_from_local_to_full_dof_indices
 * @param ky_map_from_local_to_full_dof_indices
 * @param kx_dof_i2e_numbering
 * @param ky_dof_i2e_numbering
 * @param kx_mapping
 * @param ky_mapping
 * @param scratch_data
 * @param copy_data
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
assemble_kernel_column(
  Vector<RangeNumberType> &col_vector,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                             &kernel,
  const DeviceNumberType<KernelNumberType>    kernel_factor,
  const std::vector<types::global_dof_index> &row_dof_indices,
  const types::global_dof_index               col_dof_index,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &kx_dof_to_cell_topo,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData<
    dim,
    spacedim,
    DeviceNumberType<KernelNumberType>>                    &scratch_data_gpu,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  AssertDimension(col_vector.size(), row_dof_indices.size());

  types::global_dof_index i_global_dof_index;
  types::global_dof_index j_global_dof_index =
    (ky_map_from_local_to_full_dof_indices == nullptr) ?
      ky_dof_i2e_numbering[col_dof_index] :
      ky_map_from_local_to_full_dof_indices->at(
        ky_dof_i2e_numbering[col_dof_index]);

  /**
   * Iterate over each row DoF index.
   */
  for (size_type i = 0; i < row_dof_indices.size(); i++)
    {
      i_global_dof_index = (kx_map_from_local_to_full_dof_indices == nullptr) ?
                             kx_dof_i2e_numbering[row_dof_indices[i]] :
                             kx_map_from_local_to_full_dof_indices->at(
                               kx_dof_i2e_numbering[row_dof_indices[i]]);

      col_vector(i) = sauter_quadrature_on_one_pair_of_far_field_dofs(
        kernel,
        kernel_factor,
        i_global_dof_index,
        j_global_dof_index,
        kx_dof_to_cell_topo,
        ky_dof_to_cell_topo,
        bem_values_gpu,
        mappings,
        material_id_to_mapping_index,
        normal_detector,
        scratch_data,
        scratch_data_gpu,
        copy_data);
    }
}


/**
 * Assemble a column vector by evaluating the Galerkin-BEM double integral
 * with respect to the kernel.
 *
 * \mynote{1. The memory for @p col_vector should be preallocated, since inside
 * the function there is no reinitialization of this vector anymore.
 * 2. This version is especially for assembling the regularized
 * hyper-singular matrix with the stabilization term.}
 *
 * @param col_vector
 * @param kernel
 * @param factor
 * @param mass_vmult_weq
 * @param row_dof_indices
 * @param col_dof_index
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param bem_values
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_dof_i2e_numbering
 * @param ky_dof_i2e_numbering
 * @param kx_mapping
 * @param ky_mapping
 * @param scratch_data
 * @param copy_data
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
assemble_kernel_column(
  Vector<RangeNumberType> &col_vector,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                              &kernel,
  const DeviceNumberType<KernelNumberType>     kernel_factor,
  const std::vector<Vector<KernelNumberType>> &mass_vmult_weq,
  const KernelNumberType                       stabilization_factor,
  const std::vector<types::global_dof_index>  &row_dof_indices,
  const types::global_dof_index                col_dof_index,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &kx_dof_to_cell_topo,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData<
    dim,
    spacedim,
    DeviceNumberType<KernelNumberType>>                    &scratch_data_gpu,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  AssertDimension(col_vector.size(), row_dof_indices.size());

  types::global_dof_index i_global_dof_index;
  types::global_dof_index j_global_dof_index =
    (ky_map_from_local_to_full_dof_indices == nullptr) ?
      ky_dof_i2e_numbering[col_dof_index] :
      ky_map_from_local_to_full_dof_indices->at(
        ky_dof_i2e_numbering[col_dof_index]);

  /**
   * Iterate over each row DoF index.
   */
  for (size_type i = 0; i < row_dof_indices.size(); i++)
    {
      i_global_dof_index = (kx_map_from_local_to_full_dof_indices == nullptr) ?
                             kx_dof_i2e_numbering[row_dof_indices[i]] :
                             kx_map_from_local_to_full_dof_indices->at(
                               kx_dof_i2e_numbering[row_dof_indices[i]]);

      col_vector(i) = sauter_quadrature_on_one_pair_of_far_field_dofs(
        kernel,
        kernel_factor,
        i_global_dof_index,
        j_global_dof_index,
        kx_dof_to_cell_topo,
        ky_dof_to_cell_topo,
        bem_values_gpu,
        mappings,
        material_id_to_mapping_index,
        normal_detector,
        scratch_data,
        scratch_data_gpu,
        copy_data);

      for (const auto &vec : mass_vmult_weq)
        col_vector(i) +=
          stabilization_factor * vec(row_dof_indices[i]) * vec(col_dof_index);
    }
}


/**
 * Assemble a column vector by evaluating the Galerkin-BEM double integral
 * with respect to the kernel. This version parallelizes over each vector
 * element.
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
assemble_kernel_column(
  HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector<
    dim,
    spacedim,
    DeviceNumberType<RangeNumberType>,
    DeviceNumberType<KernelNumberType>> &task_buffer,
  Vector<RangeNumberType>               &col_vector,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                             &kernel,
  const DeviceNumberType<KernelNumberType>    kernel_factor,
  const std::vector<types::global_dof_index> &row_dof_indices,
  const types::global_dof_index               col_dof_index,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &kx_dof_to_cell_topo,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  AssertDimension(col_vector.size(), row_dof_indices.size());

  task_buffer.reinit();

  types::global_dof_index i_global_dof_index;
  types::global_dof_index j_global_dof_index =
    (ky_map_from_local_to_full_dof_indices == nullptr) ?
      ky_dof_i2e_numbering[col_dof_index] :
      ky_map_from_local_to_full_dof_indices->at(
        ky_dof_i2e_numbering[col_dof_index]);

  /**
   * @internal Iterate over each row DoF index.
   */
  task_buffer.starting_task_indices_for_dof_pairs_cpu[0] = 0;
  for (size_type i = 0; i < row_dof_indices.size(); i++)
    {
      i_global_dof_index = (kx_map_from_local_to_full_dof_indices == nullptr) ?
                             kx_dof_i2e_numbering[row_dof_indices[i]] :
                             kx_map_from_local_to_full_dof_indices->at(
                               kx_dof_i2e_numbering[row_dof_indices[i]]);

      task_buffer.starting_task_indices_for_dof_pairs_cpu[i + 1] =
        task_buffer.starting_task_indices_for_dof_pairs_cpu[i] +
        HierBEM::CUDAWrappers::
          create_sauter_quadrature_tasks_on_one_pair_of_dofs(
            task_buffer,
            i_global_dof_index,
            j_global_dof_index,
            kx_dof_to_cell_topo,
            ky_dof_to_cell_topo,
            mappings,
            material_id_to_mapping_index,
            normal_detector,
            scratch_data,
            copy_data);
    }

  /**
   * @internal Process all Sauter quadrature tasks and generate the vector.
   */
  task_buffer.process_tasks(col_vector,
                            kernel,
                            kernel_factor,
                            bem_values_gpu,
                            128,
                            128,
                            scratch_data.cuda_stream_handle);
}


/**
 * Assemble a column vector by evaluating the Galerkin-BEM double integral
 * with respect to the kernel. This version regularizes the kernel and
 * parallelizes over each vector element.
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
assemble_kernel_column(
  HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector<
    dim,
    spacedim,
    DeviceNumberType<RangeNumberType>,
    DeviceNumberType<KernelNumberType>> &task_buffer,
  Vector<RangeNumberType>               &col_vector,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                              &kernel,
  const DeviceNumberType<KernelNumberType>     kernel_factor,
  const std::vector<Vector<KernelNumberType>> &mass_vmult_weq,
  const KernelNumberType                       stabilization_factor,
  const std::vector<types::global_dof_index>  &row_dof_indices,
  const types::global_dof_index                col_dof_index,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &kx_dof_to_cell_topo,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  assemble_kernel_column(task_buffer,
                         col_vector,
                         kernel,
                         kernel_factor,
                         row_dof_indices,
                         col_dof_index,
                         kx_dof_to_cell_topo,
                         ky_dof_to_cell_topo,
                         bem_values_gpu,
                         kx_map_from_local_to_full_dof_indices,
                         ky_map_from_local_to_full_dof_indices,
                         kx_dof_i2e_numbering,
                         ky_dof_i2e_numbering,
                         mappings,
                         material_id_to_mapping_index,
                         normal_detector,
                         scratch_data,
                         copy_data);

  for (size_type i = 0; i < row_dof_indices.size(); i++)
    {
      for (const auto &vec : mass_vmult_weq)
        col_vector(i) +=
          stabilization_factor * vec(row_dof_indices[i]) * vec(col_dof_index);
    }
}


/**
 * Randomly select a reference row index from the remaining row indices for
 * the next ACA step.
 *
 * \mynote{The data type for DoF index is @p types::global_dof_index, while
 * the data type for matrix row or column index is @p size_type, which is the
 * unsigned version of @p blas::int.}
 *
 * @param row_vector The selected reference row vector, the memory of which
 * should be preallocated in order to reduce the number of times for memory
 * allocation and releasing.
 * @param scratch
 * @param data
 * @param kernel
 * @param remaining_row_indices Remaining row indices to be checked and
 * selected from, which are stored in a @p std::forward_list.
 * @param current_ref_row_index The current reference row index
 * @param pass_the_end_ref_row_index When this function cannot select a new
 * reference row, return this invalid index.
 * @param row_dof_indices The list of DoF indices corresponding to the matrix
 * rows
 * @param col_dof_indices The list of DoF indices corresponding to the
 * matrix columns
 * @param dof_to_cell_topo DoF-to-cell topology
 * @param bem_values
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_mapping
 * @param ky_mapping
 * @return The selected reference row index
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
size_type
random_select_ref_row(
  Vector<RangeNumberType> &row_vector,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                             &kernel,
  const DeviceNumberType<KernelNumberType>    kernel_factor,
  std::forward_list<size_type>               &remaining_row_indices,
  const size_type                             current_ref_row_index,
  const size_type                             pass_the_end_ref_row_index,
  const std::vector<types::global_dof_index> &row_dof_indices,
  const std::vector<types::global_dof_index> &col_dof_indices,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &kx_dof_to_cell_topo,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData<
    dim,
    spacedim,
    DeviceNumberType<KernelNumberType>>                    &scratch_data_gpu,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  AssertDimension(row_vector.size(), col_dof_indices.size());

  /**
   * The array index used to access the @p std::forward_list
   * @p remaining_row_indices.
   */
  size_type next_ref_row_selection_index;
  /**
   * The reference row index to be selected for the next ACA step.
   */
  size_type next_ref_row_index(row_dof_indices.size());
  /**
   * The row DoF index corresponding to the selected reference row index for
   * the next ACA step.
   */
  types::global_dof_index next_ref_row_dof_index;

  while (!remaining_row_indices.empty())
    {
      next_ref_row_selection_index =
        generate_random_index(0, size(remaining_row_indices) - 1);
      next_ref_row_index =
        value_at(remaining_row_indices, next_ref_row_selection_index);
      next_ref_row_dof_index = row_dof_indices[next_ref_row_index];

      if (next_ref_row_index != current_ref_row_index)
        {
          /**
           * Get the @p next_ref_row_index'th row from the kernel evaluation.
           */
          assemble_kernel_row(row_vector,
                              kernel,
                              kernel_factor,
                              next_ref_row_dof_index,
                              col_dof_indices,
                              kx_dof_to_cell_topo,
                              ky_dof_to_cell_topo,
                              bem_values_gpu,
                              kx_map_from_local_to_full_dof_indices,
                              ky_map_from_local_to_full_dof_indices,
                              kx_dof_i2e_numbering,
                              ky_dof_i2e_numbering,
                              mappings,
                              material_id_to_mapping_index,
                              normal_detector,
                              scratch_data,
                              scratch_data_gpu,
                              copy_data);

          if (LinAlg::is_all_zero(row_vector))
            {
              /**
               * When the extracted row vector is zero-valued, remove the
               * corresponding row index from the @p remaining_row_indices
               * and continue another try.
               */
              erase_at(remaining_row_indices, next_ref_row_selection_index);

              continue;
            }
          else
            {
              /**
               * When the extracted row vector is not zero-valued, it is a
               * valid choice. Hence, return the selected row index.
               */
              return next_ref_row_index;
            }
        }
      else
        {
          if (size(remaining_row_indices) == 1)
            {
              /**
               * If there is only one row index left, there is no reference
               * row can be selected. Then return the invalid reference row
               * index.
               */
              return pass_the_end_ref_row_index;
            }
          else
            {
              /**
               * Because the selected row for the next step is the same as
               * the current reference row, try another valid selection.
               */
              continue;
            }
        }
    }

  return pass_the_end_ref_row_index;
}


/**
 * Randomly select a reference row index from the remaining row indices for
 * the next ACA step.
 *
 * \mynote{1. The data type for DoF index is @p types::global_dof_index, while
 * the data type for matrix row or column index is @p size_type, which is the
 * unsigned version of @p blas::int.
 * 2. This version is especially for assembling the regularized
 * hyper-singular matrix with the stabilization term.}
 *
 * @param row_vector
 * @param kernel
 * @param kernel_factor
 * @param mass_vmult_weq
 * @param stabilization_factor
 * @param remaining_row_indices
 * @param current_ref_row_index
 * @param pass_the_end_ref_row_index When this function cannot select a new
 * reference row, return this invalid index.
 * @param row_dof_indices
 * @param col_dof_indices
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param bem_values
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_dof_i2e_numbering
 * @param ky_dof_i2e_numbering
 * @param kx_mapping
 * @param ky_mapping
 * @param scratch_data
 * @param copy_data
 * @return
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
size_type
random_select_ref_row(
  Vector<RangeNumberType> &row_vector,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                              &kernel,
  const DeviceNumberType<KernelNumberType>     kernel_factor,
  const std::vector<Vector<KernelNumberType>> &mass_vmult_weq,
  const KernelNumberType                       stabilization_factor,
  std::forward_list<size_type>                &remaining_row_indices,
  const size_type                              current_ref_row_index,
  const size_type                              pass_the_end_ref_row_index,
  const std::vector<types::global_dof_index>  &row_dof_indices,
  const std::vector<types::global_dof_index>  &col_dof_indices,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &kx_dof_to_cell_topo,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData<
    dim,
    spacedim,
    DeviceNumberType<KernelNumberType>>                    &scratch_data_gpu,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  AssertDimension(row_vector.size(), col_dof_indices.size());

  /**
   * The array index used to access the @p std::forward_list
   * @p remaining_row_indices.
   */
  size_type next_ref_row_selection_index;
  /**
   * The reference row index to be selected for the next ACA step.
   */
  size_type next_ref_row_index(row_dof_indices.size());
  /**
   * The row DoF index corresponding to the selected reference row index for
   * the next ACA step.
   */
  types::global_dof_index next_ref_row_dof_index;

  while (!remaining_row_indices.empty())
    {
      next_ref_row_selection_index =
        generate_random_index(0, size(remaining_row_indices) - 1);
      next_ref_row_index =
        value_at(remaining_row_indices, next_ref_row_selection_index);
      next_ref_row_dof_index = row_dof_indices[next_ref_row_index];

      if (next_ref_row_index != current_ref_row_index)
        {
          /**
           * Get the @p next_ref_row_index'th row from the kernel evaluation.
           */
          assemble_kernel_row(row_vector,
                              kernel,
                              kernel_factor,
                              mass_vmult_weq,
                              stabilization_factor,
                              next_ref_row_dof_index,
                              col_dof_indices,
                              kx_dof_to_cell_topo,
                              ky_dof_to_cell_topo,
                              bem_values_gpu,
                              kx_map_from_local_to_full_dof_indices,
                              ky_map_from_local_to_full_dof_indices,
                              kx_dof_i2e_numbering,
                              ky_dof_i2e_numbering,
                              mappings,
                              material_id_to_mapping_index,
                              normal_detector,
                              scratch_data,
                              scratch_data_gpu,
                              copy_data);

          if (LinAlg::is_all_zero(row_vector))
            {
              /**
               * When the extracted row vector is zero-valued, remove the
               * corresponding row index from the @p remaining_row_indices
               * and continue another try.
               */
              erase_at(remaining_row_indices, next_ref_row_selection_index);

              continue;
            }
          else
            {
              /**
               * When the extracted row vector is not zero-valued, it is a
               * valid choice. Hence, return the selected row index.
               */
              return next_ref_row_index;
            }
        }
      else
        {
          if (size(remaining_row_indices) == 1)
            {
              /**
               * If there is only one row index left, there is no reference
               * row can be selected. Then return the invalid reference row
               * index.
               */
              return pass_the_end_ref_row_index;
            }
          else
            {
              /**
               * Because the selected row for the next step is the same as
               * the current reference row, try another valid selection.
               */
              continue;
            }
        }
    }

  return pass_the_end_ref_row_index;
}


template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
size_type
random_select_ref_row(
  HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector<
    dim,
    spacedim,
    DeviceNumberType<RangeNumberType>,
    DeviceNumberType<KernelNumberType>> &task_buffer,
  Vector<RangeNumberType>               &row_vector,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                             &kernel,
  const DeviceNumberType<KernelNumberType>    kernel_factor,
  std::forward_list<size_type>               &remaining_row_indices,
  const size_type                             current_ref_row_index,
  const size_type                             pass_the_end_ref_row_index,
  const std::vector<types::global_dof_index> &row_dof_indices,
  const std::vector<types::global_dof_index> &col_dof_indices,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &kx_dof_to_cell_topo,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  AssertDimension(row_vector.size(), col_dof_indices.size());

  /**
   * The array index used to access the @p std::forward_list
   * @p remaining_row_indices.
   */
  size_type next_ref_row_selection_index;
  /**
   * The reference row index to be selected for the next ACA step.
   */
  size_type next_ref_row_index(row_dof_indices.size());
  /**
   * The row DoF index corresponding to the selected reference row index for
   * the next ACA step.
   */
  types::global_dof_index next_ref_row_dof_index;

  while (!remaining_row_indices.empty())
    {
      next_ref_row_selection_index =
        generate_random_index(0, size(remaining_row_indices) - 1);
      next_ref_row_index =
        value_at(remaining_row_indices, next_ref_row_selection_index);
      next_ref_row_dof_index = row_dof_indices[next_ref_row_index];

      if (next_ref_row_index != current_ref_row_index)
        {
          /**
           * Get the @p next_ref_row_index'th row from the kernel evaluation.
           */
          assemble_kernel_row(task_buffer,
                              row_vector,
                              kernel,
                              kernel_factor,
                              next_ref_row_dof_index,
                              col_dof_indices,
                              kx_dof_to_cell_topo,
                              ky_dof_to_cell_topo,
                              bem_values_gpu,
                              kx_map_from_local_to_full_dof_indices,
                              ky_map_from_local_to_full_dof_indices,
                              kx_dof_i2e_numbering,
                              ky_dof_i2e_numbering,
                              mappings,
                              material_id_to_mapping_index,
                              normal_detector,
                              scratch_data,
                              copy_data);

          if (LinAlg::is_all_zero(row_vector))
            {
              /**
               * When the extracted row vector is zero-valued, remove the
               * corresponding row index from the @p remaining_row_indices
               * and continue another try.
               */
              erase_at(remaining_row_indices, next_ref_row_selection_index);

              continue;
            }
          else
            {
              /**
               * When the extracted row vector is not zero-valued, it is a
               * valid choice. Hence, return the selected row index.
               */
              return next_ref_row_index;
            }
        }
      else
        {
          if (size(remaining_row_indices) == 1)
            {
              /**
               * If there is only one row index left, there is no reference
               * row can be selected. Then return the invalid reference row
               * index.
               */
              return pass_the_end_ref_row_index;
            }
          else
            {
              /**
               * Because the selected row for the next step is the same as
               * the current reference row, try another valid selection.
               */
              continue;
            }
        }
    }

  return pass_the_end_ref_row_index;
}


template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
size_type
random_select_ref_row(
  HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector<
    dim,
    spacedim,
    DeviceNumberType<RangeNumberType>,
    DeviceNumberType<KernelNumberType>> &task_buffer,
  Vector<RangeNumberType>               &row_vector,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                              &kernel,
  const DeviceNumberType<KernelNumberType>     kernel_factor,
  const std::vector<Vector<KernelNumberType>> &mass_vmult_weq,
  const KernelNumberType                       stabilization_factor,
  std::forward_list<size_type>                &remaining_row_indices,
  const size_type                              current_ref_row_index,
  const size_type                              pass_the_end_ref_row_index,
  const std::vector<types::global_dof_index>  &row_dof_indices,
  const std::vector<types::global_dof_index>  &col_dof_indices,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &kx_dof_to_cell_topo,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  AssertDimension(row_vector.size(), col_dof_indices.size());

  /**
   * The array index used to access the @p std::forward_list
   * @p remaining_row_indices.
   */
  size_type next_ref_row_selection_index;
  /**
   * The reference row index to be selected for the next ACA step.
   */
  size_type next_ref_row_index(row_dof_indices.size());
  /**
   * The row DoF index corresponding to the selected reference row index for
   * the next ACA step.
   */
  types::global_dof_index next_ref_row_dof_index;

  while (!remaining_row_indices.empty())
    {
      next_ref_row_selection_index =
        generate_random_index(0, size(remaining_row_indices) - 1);
      next_ref_row_index =
        value_at(remaining_row_indices, next_ref_row_selection_index);
      next_ref_row_dof_index = row_dof_indices[next_ref_row_index];

      if (next_ref_row_index != current_ref_row_index)
        {
          /**
           * Get the @p next_ref_row_index'th row from the kernel evaluation.
           */
          assemble_kernel_row(task_buffer,
                              row_vector,
                              kernel,
                              kernel_factor,
                              mass_vmult_weq,
                              stabilization_factor,
                              next_ref_row_dof_index,
                              col_dof_indices,
                              kx_dof_to_cell_topo,
                              ky_dof_to_cell_topo,
                              bem_values_gpu,
                              kx_map_from_local_to_full_dof_indices,
                              ky_map_from_local_to_full_dof_indices,
                              kx_dof_i2e_numbering,
                              ky_dof_i2e_numbering,
                              mappings,
                              material_id_to_mapping_index,
                              normal_detector,
                              scratch_data,
                              copy_data);

          if (LinAlg::is_all_zero(row_vector))
            {
              /**
               * When the extracted row vector is zero-valued, remove the
               * corresponding row index from the @p remaining_row_indices
               * and continue another try.
               */
              erase_at(remaining_row_indices, next_ref_row_selection_index);

              continue;
            }
          else
            {
              /**
               * When the extracted row vector is not zero-valued, it is a
               * valid choice. Hence, return the selected row index.
               */
              return next_ref_row_index;
            }
        }
      else
        {
          if (size(remaining_row_indices) == 1)
            {
              /**
               * If there is only one row index left, there is no reference
               * row can be selected. Then return the invalid reference row
               * index.
               */
              return pass_the_end_ref_row_index;
            }
          else
            {
              /**
               * Because the selected row for the next step is the same as
               * the current reference row, try another valid selection.
               */
              continue;
            }
        }
    }

  return pass_the_end_ref_row_index;
}


/**
 * For debugging purpose: randomly select a reference row index from the
 * remaining row indices for the next ACA step.
 *
 * @param row_vector The extracted row vector, the memory of which should be
 * preallocated
 * @param A The full matrix for the current block, the rows of which are
 * extracted
 * @param remaining_row_indices
 * @param current_ref_row_index
 * @param pass_the_end_ref_row_index When this function cannot select a new
 * reference row, return this invalid index.
 * @param row_dof_indices
 * @param col_dof_indices
 * @return
 */
template <typename RangeNumberType = double>
size_type
random_select_ref_row(Vector<RangeNumberType>                    &row_vector,
                      const LAPACKFullMatrixExt<RangeNumberType> &A,
                      std::forward_list<size_type> &remaining_row_indices,
                      const size_type               current_ref_row_index,
                      const size_type               pass_the_end_ref_row_index)
{
  /**
   * The array index used to access the @p std::forward_list
   * @p remaining_row_indices.
   */
  size_type next_ref_row_selection_index;
  /**
   * The reference row index to be selected for the next ACA step.
   */
  size_type next_ref_row_index;

  while (!remaining_row_indices.empty())
    {
      next_ref_row_selection_index =
        generate_random_index(0, size(remaining_row_indices) - 1);
      next_ref_row_index =
        value_at(remaining_row_indices, next_ref_row_selection_index);

      if (next_ref_row_index != current_ref_row_index)
        {
          A.get_row(next_ref_row_index, row_vector);

          if (LinAlg::is_all_zero(row_vector))
            {
              /**
               * When the extracted row vector is zero-valued, remove the
               * corresponding row index from the @p remaining_row_indices
               * and continue another try.
               */
              erase_at(remaining_row_indices, next_ref_row_selection_index);

              continue;
            }
          else
            {
              /**
               * When the extracted row vector is not zero-valued, it is a
               * valid choice. Hence, return the selected row index.
               */
              return next_ref_row_index;
            }
        }
      else
        {
          if (size(remaining_row_indices) == 1)
            {
              /**
               * If there is only one row index left, there is no reference
               * row can be selected. Then return the invalid reference row
               * index.
               */
              return pass_the_end_ref_row_index;
            }
          else
            {
              /**
               * Because the selected row for the next step is the same as
               * the current reference row, try another valid selection.
               */
              continue;
            }
        }
    }

  return pass_the_end_ref_row_index;
}


/**
 * Randomly select a reference column index from the remaining column
 * indices for the next ACA step.
 *
 * \mynote{The data type for DoF index is @p types::global_dof_index, while
 * the data type for matrix row or column index is @p size_type, which is the
 * unsigned version of @p blas::int.}
 *
 * @param col_vector The selected reference column vector, the memory of which
 * should be preallocated in order to reduce the number of times for memory
 * allocation and releasing.
 * @param scratch
 * @param data
 * @param kernel
 * @param remaining_col_indices Remaining column indices to be checked and
 * selected from, which are stored in a @p std::forward_list.
 * @param current_ref_col_index The current reference column index
 * @param pass_the_end_ref_col_index When this function cannot select a new
 * reference column, return this invalid index.
 * @param row_dof_indices The list of DoF indices corresponding to the matrix
 * rows
 * @param col_dof_indices The list of DoF indices corresponding to the
 * matrix columns
 * @param dof_to_cell_topo DoF-to-cell topology
 * @param bem_values
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_mapping
 * @param ky_mapping
 * @return The selected reference column index
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
size_type
random_select_ref_column(
  Vector<RangeNumberType> &col_vector,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                             &kernel,
  const DeviceNumberType<KernelNumberType>    factor,
  std::forward_list<size_type>               &remaining_col_indices,
  const size_type                             current_ref_col_index,
  const size_type                             pass_the_end_ref_col_index,
  const std::vector<types::global_dof_index> &row_dof_indices,
  const std::vector<types::global_dof_index> &col_dof_indices,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &kx_dof_to_cell_topo,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData<
    dim,
    spacedim,
    DeviceNumberType<KernelNumberType>>                    &scratch_data_gpu,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  AssertDimension(col_vector.size(), row_dof_indices.size());

  /**
   * The array index used to access the @p std::forward_list
   * @p remaining_col_indices.
   */
  size_type next_ref_col_selection_index;
  /**
   * The reference column index to be selected for the next ACA step.
   */
  size_type next_ref_col_index(col_dof_indices.size());
  /**
   * The column DoF index corresponding to the selected reference column
   * index for the next ACA step.
   */
  types::global_dof_index next_ref_col_dof_index;

  while (!remaining_col_indices.empty())
    {
      next_ref_col_selection_index =
        generate_random_index(0, size(remaining_col_indices) - 1);
      next_ref_col_index =
        value_at(remaining_col_indices, next_ref_col_selection_index);
      next_ref_col_dof_index = col_dof_indices[next_ref_col_index];

      if (next_ref_col_index != current_ref_col_index)
        {
          /**
           * Get the @p next_ref_col_index'th column from the kernel evaluation.
           */
          assemble_kernel_column(col_vector,
                                 kernel,
                                 factor,
                                 row_dof_indices,
                                 next_ref_col_dof_index,
                                 kx_dof_to_cell_topo,
                                 ky_dof_to_cell_topo,
                                 bem_values_gpu,
                                 kx_map_from_local_to_full_dof_indices,
                                 ky_map_from_local_to_full_dof_indices,
                                 kx_dof_i2e_numbering,
                                 ky_dof_i2e_numbering,
                                 mappings,
                                 material_id_to_mapping_index,
                                 normal_detector,
                                 scratch_data,
                                 scratch_data_gpu,
                                 copy_data);

          if (LinAlg::is_all_zero(col_vector))
            {
              /**
               * When the extracted column vector is zero-valued, remove the
               * corresponding column index from the @p remaining_col_indices
               * and continue another try.
               */
              erase_at(remaining_col_indices, next_ref_col_selection_index);

              continue;
            }
          else
            {
              /**
               * When the extracted column vector is not zero-valued, it is
               * a valid choice. Hence, return the selected column index.
               */
              return next_ref_col_index;
            }
        }
      else
        {
          if (size(remaining_col_indices) == 1)
            {
              /**
               * If there is only one column index left, there is no
               * reference column can be selected. Then return the invalid
               * reference column index.
               */
              return pass_the_end_ref_col_index;
            }
          else
            {
              /**
               * Because the selected column for the next step is the same
               * as the current reference column, try another valid
               * selection.
               */
              continue;
            }
        }
    }

  return pass_the_end_ref_col_index;
}


/**
 * Randomly select a reference column index from the remaining column
 * indices for the next ACA step.
 *
 * \mynote{1. The data type for DoF index is @p types::global_dof_index, while
 * the data type for matrix row or column index is @p size_type, which is the
 * unsigned version of @p blas::int.
 * 2. This version is especially for assembling the regularized
 * hyper-singular matrix with the stabilization term.}
 *
 * @param col_vector
 * @param kernel
 * @param kernel_factor
 * @param mass_vmult_weq
 * @param stabilization_factor
 * @param remaining_col_indices
 * @param current_ref_col_index
 * @param pass_the_end_ref_col_index When this function cannot select a new
 * reference column, return this invalid index.
 * @param row_dof_indices
 * @param col_dof_indices
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param bem_values
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_dof_i2e_numbering
 * @param ky_dof_i2e_numbering
 * @param kx_mapping
 * @param ky_mapping
 * @param scratch_data
 * @param copy_data
 * @return
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
size_type
random_select_ref_column(
  Vector<RangeNumberType> &col_vector,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                              &kernel,
  const DeviceNumberType<KernelNumberType>     kernel_factor,
  const std::vector<Vector<KernelNumberType>> &mass_vmult_weq,
  const KernelNumberType                       stabilization_factor,
  std::forward_list<size_type>                &remaining_col_indices,
  const size_type                              current_ref_col_index,
  const size_type                              pass_the_end_ref_col_index,
  const std::vector<types::global_dof_index>  &row_dof_indices,
  const std::vector<types::global_dof_index>  &col_dof_indices,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &kx_dof_to_cell_topo,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData<
    dim,
    spacedim,
    DeviceNumberType<KernelNumberType>>                    &scratch_data_gpu,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  AssertDimension(col_vector.size(), row_dof_indices.size());

  /**
   * The array index used to access the @p std::forward_list
   * @p remaining_col_indices.
   */
  size_type next_ref_col_selection_index;
  /**
   * The reference column index to be selected for the next ACA step.
   */
  size_type next_ref_col_index(col_dof_indices.size());
  /**
   * The column DoF index corresponding to the selected reference column
   * index for the next ACA step.
   */
  types::global_dof_index next_ref_col_dof_index;

  while (!remaining_col_indices.empty())
    {
      next_ref_col_selection_index =
        generate_random_index(0, size(remaining_col_indices) - 1);
      next_ref_col_index =
        value_at(remaining_col_indices, next_ref_col_selection_index);
      next_ref_col_dof_index = col_dof_indices[next_ref_col_index];

      if (next_ref_col_index != current_ref_col_index)
        {
          /**
           * Get the @p next_ref_col_index'th column from the kernel evaluation.
           */
          assemble_kernel_column(col_vector,
                                 kernel,
                                 kernel_factor,
                                 mass_vmult_weq,
                                 stabilization_factor,
                                 row_dof_indices,
                                 next_ref_col_dof_index,
                                 kx_dof_to_cell_topo,
                                 ky_dof_to_cell_topo,
                                 bem_values_gpu,
                                 kx_map_from_local_to_full_dof_indices,
                                 ky_map_from_local_to_full_dof_indices,
                                 kx_dof_i2e_numbering,
                                 ky_dof_i2e_numbering,
                                 mappings,
                                 material_id_to_mapping_index,
                                 normal_detector,
                                 scratch_data,
                                 scratch_data_gpu,
                                 copy_data);

          if (LinAlg::is_all_zero(col_vector))
            {
              /**
               * When the extracted column vector is zero-valued, remove the
               * corresponding column index from the @p remaining_col_indices
               * and continue another try.
               */
              erase_at(remaining_col_indices, next_ref_col_selection_index);

              continue;
            }
          else
            {
              /**
               * When the extracted column vector is not zero-valued, it is
               * a valid choice. Hence, return the selected column index.
               */
              return next_ref_col_index;
            }
        }
      else
        {
          if (size(remaining_col_indices) == 1)
            {
              /**
               * If there is only one column index left, there is no
               * reference column can be selected. Then return the invalid
               * reference column index.
               */
              return pass_the_end_ref_col_index;
            }
          else
            {
              /**
               * Because the selected column for the next step is the same
               * as the current reference column, try another valid
               * selection.
               */
              continue;
            }
        }
    }

  return pass_the_end_ref_col_index;
}


template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
size_type
random_select_ref_column(
  HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector<
    dim,
    spacedim,
    DeviceNumberType<RangeNumberType>,
    DeviceNumberType<KernelNumberType>> &task_buffer,
  Vector<RangeNumberType>               &col_vector,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                             &kernel,
  const DeviceNumberType<KernelNumberType>    factor,
  std::forward_list<size_type>               &remaining_col_indices,
  const size_type                             current_ref_col_index,
  const size_type                             pass_the_end_ref_col_index,
  const std::vector<types::global_dof_index> &row_dof_indices,
  const std::vector<types::global_dof_index> &col_dof_indices,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &kx_dof_to_cell_topo,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  AssertDimension(col_vector.size(), row_dof_indices.size());

  /**
   * The array index used to access the @p std::forward_list
   * @p remaining_col_indices.
   */
  size_type next_ref_col_selection_index;
  /**
   * The reference column index to be selected for the next ACA step.
   */
  size_type next_ref_col_index(col_dof_indices.size());
  /**
   * The column DoF index corresponding to the selected reference column
   * index for the next ACA step.
   */
  types::global_dof_index next_ref_col_dof_index;

  while (!remaining_col_indices.empty())
    {
      next_ref_col_selection_index =
        generate_random_index(0, size(remaining_col_indices) - 1);
      next_ref_col_index =
        value_at(remaining_col_indices, next_ref_col_selection_index);
      next_ref_col_dof_index = col_dof_indices[next_ref_col_index];

      if (next_ref_col_index != current_ref_col_index)
        {
          /**
           * Get the @p next_ref_col_index'th column from the kernel evaluation.
           */
          assemble_kernel_column(task_buffer,
                                 col_vector,
                                 kernel,
                                 factor,
                                 row_dof_indices,
                                 next_ref_col_dof_index,
                                 kx_dof_to_cell_topo,
                                 ky_dof_to_cell_topo,
                                 bem_values_gpu,
                                 kx_map_from_local_to_full_dof_indices,
                                 ky_map_from_local_to_full_dof_indices,
                                 kx_dof_i2e_numbering,
                                 ky_dof_i2e_numbering,
                                 mappings,
                                 material_id_to_mapping_index,
                                 normal_detector,
                                 scratch_data,
                                 copy_data);

          if (LinAlg::is_all_zero(col_vector))
            {
              /**
               * When the extracted column vector is zero-valued, remove the
               * corresponding column index from the @p remaining_col_indices
               * and continue another try.
               */
              erase_at(remaining_col_indices, next_ref_col_selection_index);

              continue;
            }
          else
            {
              /**
               * When the extracted column vector is not zero-valued, it is
               * a valid choice. Hence, return the selected column index.
               */
              return next_ref_col_index;
            }
        }
      else
        {
          if (size(remaining_col_indices) == 1)
            {
              /**
               * If there is only one column index left, there is no
               * reference column can be selected. Then return the invalid
               * reference column index.
               */
              return pass_the_end_ref_col_index;
            }
          else
            {
              /**
               * Because the selected column for the next step is the same
               * as the current reference column, try another valid
               * selection.
               */
              continue;
            }
        }
    }

  return pass_the_end_ref_col_index;
}


template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
size_type
random_select_ref_column(
  HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector<
    dim,
    spacedim,
    DeviceNumberType<RangeNumberType>,
    DeviceNumberType<KernelNumberType>> &task_buffer,
  Vector<RangeNumberType>               &col_vector,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                              &kernel,
  const DeviceNumberType<KernelNumberType>     kernel_factor,
  const std::vector<Vector<KernelNumberType>> &mass_vmult_weq,
  const KernelNumberType                       stabilization_factor,
  std::forward_list<size_type>                &remaining_col_indices,
  const size_type                              current_ref_col_index,
  const size_type                              pass_the_end_ref_col_index,
  const std::vector<types::global_dof_index>  &row_dof_indices,
  const std::vector<types::global_dof_index>  &col_dof_indices,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &kx_dof_to_cell_topo,
  const std::vector<
    std::vector<const typename DoFHandler<dim, spacedim>::cell_iterator *>>
    &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      typename numbers::NumberTraits<RangeNumberType>::real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  AssertDimension(col_vector.size(), row_dof_indices.size());

  /**
   * The array index used to access the @p std::forward_list
   * @p remaining_col_indices.
   */
  size_type next_ref_col_selection_index;
  /**
   * The reference column index to be selected for the next ACA step.
   */
  size_type next_ref_col_index(col_dof_indices.size());
  /**
   * The column DoF index corresponding to the selected reference column
   * index for the next ACA step.
   */
  types::global_dof_index next_ref_col_dof_index;

  while (!remaining_col_indices.empty())
    {
      next_ref_col_selection_index =
        generate_random_index(0, size(remaining_col_indices) - 1);
      next_ref_col_index =
        value_at(remaining_col_indices, next_ref_col_selection_index);
      next_ref_col_dof_index = col_dof_indices[next_ref_col_index];

      if (next_ref_col_index != current_ref_col_index)
        {
          /**
           * Get the @p next_ref_col_index'th column from the kernel evaluation.
           */
          assemble_kernel_column(task_buffer,
                                 col_vector,
                                 kernel,
                                 kernel_factor,
                                 mass_vmult_weq,
                                 stabilization_factor,
                                 row_dof_indices,
                                 next_ref_col_dof_index,
                                 kx_dof_to_cell_topo,
                                 ky_dof_to_cell_topo,
                                 bem_values_gpu,
                                 kx_map_from_local_to_full_dof_indices,
                                 ky_map_from_local_to_full_dof_indices,
                                 kx_dof_i2e_numbering,
                                 ky_dof_i2e_numbering,
                                 mappings,
                                 material_id_to_mapping_index,
                                 normal_detector,
                                 scratch_data,
                                 copy_data);

          if (LinAlg::is_all_zero(col_vector))
            {
              /**
               * When the extracted column vector is zero-valued, remove the
               * corresponding column index from the @p remaining_col_indices
               * and continue another try.
               */
              erase_at(remaining_col_indices, next_ref_col_selection_index);

              continue;
            }
          else
            {
              /**
               * When the extracted column vector is not zero-valued, it is
               * a valid choice. Hence, return the selected column index.
               */
              return next_ref_col_index;
            }
        }
      else
        {
          if (size(remaining_col_indices) == 1)
            {
              /**
               * If there is only one column index left, there is no
               * reference column can be selected. Then return the invalid
               * reference column index.
               */
              return pass_the_end_ref_col_index;
            }
          else
            {
              /**
               * Because the selected column for the next step is the same
               * as the current reference column, try another valid
               * selection.
               */
              continue;
            }
        }
    }

  return pass_the_end_ref_col_index;
}


/**
 * For debugging purpose: randomly select a reference column index from the
 * remaining column indices for the next ACA step.
 *
 * @param col_vector The extracted column vector, the memory of which should
 * be preallocated
 * @param A The full matrix for the current block, the rows of which are
 * extracted
 * @param remaining_col_indices
 * @param current_ref_col_index
 * @param pass_the_end_ref_col_index When this function cannot select a new
 * reference column, return this invalid index.
 * @param row_dof_indices
 * @param col_dof_indices
 * @return
 */
template <typename RangeNumberType = double>
size_type
random_select_ref_column(Vector<RangeNumberType>                    &col_vector,
                         const LAPACKFullMatrixExt<RangeNumberType> &A,
                         std::forward_list<size_type> &remaining_col_indices,
                         const size_type               current_ref_col_index,
                         const size_type pass_the_end_ref_col_index)
{
  /**
   * The array index used to access the @p std::forward_list
   * @p remaining_col_indices.
   */
  size_type next_ref_col_selection_index;
  /**
   * The reference column index to be selected for the next ACA step.
   */
  size_type next_ref_col_index;

  while (!remaining_col_indices.empty())
    {
      next_ref_col_selection_index =
        generate_random_index(0, size(remaining_col_indices) - 1);
      next_ref_col_index =
        value_at(remaining_col_indices, next_ref_col_selection_index);

      if (next_ref_col_index != current_ref_col_index)
        {
          A.get_column(next_ref_col_index, col_vector);

          if (LinAlg::is_all_zero(col_vector))
            {
              /**
               * When the extracted column vector is zero-valued, remove the
               * corresponding column index from the @p remaining_col_indices
               * and continue another try.
               */
              erase_at(remaining_col_indices, next_ref_col_selection_index);
            }
          else
            {
              /**
               * When the extracted column vector is not zero-valued, it is
               * a valid choice. Hence, return the selected column index.
               */
              return next_ref_col_index;
            }
        }
      else
        {
          if (size(remaining_col_indices) == 1)
            {
              /**
               * If there is only one column index left, there is no
               * reference column can be selected. Then return the invalid
               * reference column index.
               */
              return pass_the_end_ref_col_index;
            }
          else
            {
              /**
               * Because the selected column for the next step is the same
               * as the current reference column, try another valid
               * selection.
               */
              continue;
            }
        }
    }

  return pass_the_end_ref_col_index;
}



/**
 * ACA+ algorithm
 *
 * \ref{Grasedyck, L. 2005. “Adaptive Recompression of
 * \f$\mathcal{H}\f$-Matrices for BEM.” Computing 74 (3): 205–23.}
 *
 * \mynote{At present, the simple convergence condition in this paper is
 * adopted instead of that in Bebendorf's book.}
 *
 * @param rkmat The rank-k matrix to be constructed for the current block,
 * the memory of which should be preallocated and the formal rank of which
 * should be the same as the maximum iteration number in @p aca_config.
 * @param aca_config
 * @param kernel
 * @param factor
 * @param row_dof_indices
 * @param col_dof_indices
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param bem_values
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_mapping
 * @param ky_mapping
 * @param scratch_data
 * @param copy_data
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
aca_plus_parallel_sauter_quad_for_vector_entry(
  RkMatrix<RangeNumberType> &rkmat,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
    &aca_config,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                               &kernel,
  const DeviceNumberType<KernelNumberType>      kernel_factor,
  const std::array<types::global_dof_index, 2> &row_dof_index_range,
  const std::array<types::global_dof_index, 2> &col_dof_index_range,
  const DoFToCellTopology<dim, spacedim>       &kx_dof_to_cell_topo,
  const DoFToCellTopology<dim, spacedim>       &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData<
    dim,
    spacedim,
    DeviceNumberType<KernelNumberType>>                    &scratch_data_gpu,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  /**
   * @internal Get the size of each dimension of the matrix block to be built.
   */
  const size_type m = row_dof_index_range[1] - row_dof_index_range[0];
  const size_type n = col_dof_index_range[1] - col_dof_index_range[0];

  AssertDimension(rkmat.get_m(), m);
  AssertDimension(rkmat.get_n(), n);

  /**
   * Adjust the maximum ACA+ iteration if is larger than the matrix
   * dimension.
   */
  unsigned int effective_max_iter = (aca_config.max_iter > std::min(m, n)) ?
                                      std::min(m, n) :
                                      aca_config.max_iter;

  /**
   * Generate lists of internal DoF indices (internal DoF numbering) from
   * corresponding index ranges.
   */
  std::vector<types::global_dof_index> row_dof_indices(m);
  std::vector<types::global_dof_index> col_dof_indices(n);
  gen_linear_indices<vector_uta, types::global_dof_index>(
    row_dof_indices, row_dof_index_range[0]);
  gen_linear_indices<vector_uta, types::global_dof_index>(
    col_dof_indices, col_dof_index_range[0]);

  /**
   * Create matrix references associated with the component matrices in the
   * rank-k matrix to be returned, which hold the row and column vectors in
   * the selected crosses during the ACA iteration. The number of columns
   * should be the same as the maximum iteration number in @p aca_config.
   */
  AssertDimension(rkmat.get_formal_rank(), aca_config.max_iter);
  LAPACKFullMatrixExt<RangeNumberType> &u_mat = rkmat.get_A();
  LAPACKFullMatrixExt<RangeNumberType> &v_mat = rkmat.get_B();
  u_mat                                       = RangeNumberType();
  v_mat                                       = RangeNumberType();

  /**
   * Generate two lists for storing remaining row indices and column indices
   * of the matrix block.
   */
  std::forward_list<size_type> remaining_row_indices(m);
  std::forward_list<size_type> remaining_col_indices(n);

  gen_linear_indices<forward_list_uta, size_type>(remaining_row_indices);
  gen_linear_indices<forward_list_uta, size_type>(remaining_col_indices);

  /**
   * Select the initial reference row and column vectors and return their
   * matrix indices.
   */
  Vector<RangeNumberType> vr(n);
  Vector<RangeNumberType> uc(m);

  size_type r = random_select_ref_row(vr,
                                      kernel,
                                      kernel_factor,
                                      remaining_row_indices,
                                      m,
                                      m,
                                      row_dof_indices,
                                      col_dof_indices,
                                      kx_dof_to_cell_topo.topology,
                                      ky_dof_to_cell_topo.topology,
                                      bem_values_gpu,
                                      kx_map_from_local_to_full_dof_indices,
                                      ky_map_from_local_to_full_dof_indices,
                                      kx_dof_i2e_numbering,
                                      ky_dof_i2e_numbering,
                                      mappings,
                                      material_id_to_mapping_index,
                                      normal_detector,
                                      scratch_data,
                                      scratch_data_gpu,
                                      copy_data);

  if (r == m)
    {
      // When there is no reference row can be selected, the current matrix
      // block is purely zero. Then return a zero rank-k matrix.
      rkmat.reinit(m, n, 0);
      return;
    }

  size_type c = random_select_ref_column(uc,
                                         kernel,
                                         kernel_factor,
                                         remaining_col_indices,
                                         n,
                                         n,
                                         row_dof_indices,
                                         col_dof_indices,
                                         kx_dof_to_cell_topo.topology,
                                         ky_dof_to_cell_topo.topology,
                                         bem_values_gpu,
                                         kx_map_from_local_to_full_dof_indices,
                                         ky_map_from_local_to_full_dof_indices,
                                         kx_dof_i2e_numbering,
                                         ky_dof_i2e_numbering,
                                         mappings,
                                         material_id_to_mapping_index,
                                         normal_detector,
                                         scratch_data,
                                         scratch_data_gpu,
                                         copy_data);

  if (c == n)
    {
      // When there is no reference column can be selected, the current
      // matrix block is purely zero. Then return a zero rank-k matrix.
      rkmat.reinit(m, n, 0);
      return;
    }

  /**
   * The absolute values for the reference row and column vectors.
   */
  Vector<real_type> vr_abs(n);
  Vector<real_type> uc_abs(m);

  /**
   * Calculate the absolute values for the reference row and column
   * vectors.
   *
   * \mynote{In the following, we use @p static_cast to explicitly
   * specify which version of @p std::abs to call.}
   */
  std::transform(vr.begin(),
                 vr.end(),
                 vr_abs.begin(),
                 static_cast<real_type (*)(RangeNumberType)>(std::abs));
  std::transform(uc.begin(),
                 uc.end(),
                 uc_abs.begin(),
                 static_cast<real_type (*)(RangeNumberType)>(std::abs));

  /**
   * Row and column indices for the \f$k\f$'th step. The corresponding row
   * and column vectors comprise the cross.
   */
  size_type ik, jk;

  /**
   * Temporary row and column vectors for the current step \f$k\f$.
   */
  Vector<RangeNumberType> vk(n);
  Vector<RangeNumberType> uk(m);

  /**
   * The absolute values for the temporary row and column vectors for the
   * current step \f$k\f$.
   */
  Vector<real_type> vk_abs(n);
  Vector<real_type> uk_abs(m);

  /**
   * Temporary row and column vectors for the previous step \f$l\f$.
   */
  Vector<RangeNumberType> vl(n);
  Vector<RangeNumberType> ul(m);

  /**
   * The error threshold as the stopping condition.
   */
  real_type error_threshold = 0.;

  /**
   * Start the ACA+ iteration from \f$k=1\f$.
   */
  for (unsigned int k = 1; k <= effective_max_iter; k++)
    {
      /**
       * Select the row index from the maximizer of the reference column.
       */
      // N.B. The function @p std::max_element return the iterator pointing
      // to the maximum element in the list.
      size_type i_star =
        std::distance(uc_abs.begin(),
                      std::max_element(uc_abs.begin(), uc_abs.end()));

      /**
       * Select the column index from the maximizer of the reference row.
       */
      size_type j_star =
        std::distance(vr_abs.begin(),
                      std::max_element(vr_abs.begin(), vr_abs.end()));

      if (uc_abs(i_star) > vr_abs(j_star))
        {
          /**
           * Select \f$i^*\f$ as the current row index \f$i_k\f$.
           */
          ik = i_star;

          /**
           * Extract the \f$i_k\f$'th row of \f$A\f$.
           */
          assemble_kernel_row(vk,
                              kernel,
                              kernel_factor,
                              row_dof_indices[ik],
                              col_dof_indices,
                              kx_dof_to_cell_topo.topology,
                              ky_dof_to_cell_topo.topology,
                              bem_values_gpu,
                              kx_map_from_local_to_full_dof_indices,
                              ky_map_from_local_to_full_dof_indices,
                              kx_dof_i2e_numbering,
                              ky_dof_i2e_numbering,
                              mappings,
                              material_id_to_mapping_index,
                              normal_detector,
                              scratch_data,
                              scratch_data_gpu,
                              copy_data);

          /**
           * \mynote{Here the counter \f$l\f$ iterates over all the previous
           * steps before \f$k\f$. For each step, the row and column vectors
           * comprising the cross have been stored as column vectors into
           * @p v_mat and @p u_mat respectively. Hence, the index for
           * extracting vectors from @p v_mat or @p u_mat should be
           * \f$l-1\f$.}
           */
          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              vk.add(-ul(ik), vl);
            }

          /**
           * Select the column index from the maximizer of the absolute
           * values of \f$\widetilde{v}_k\f$.
           */
          std::transform(vk.begin(),
                         vk.end(),
                         vk_abs.begin(),
                         static_cast<real_type (*)(RangeNumberType)>(std::abs));
          jk = std::distance(vk_abs.begin(),
                             std::max_element(vk_abs.begin(), vk_abs.end()));

          /**
           * Scale the vector \f$\widetilde{v}_k\f$.
           */
          RangeNumberType value_at_cross = vk(jk);
          vk /= value_at_cross;

          /**
           * Extract the \f$j_k\f$'th column from \f$A\f$.
           */
          assemble_kernel_column(uk,
                                 kernel,
                                 kernel_factor,
                                 row_dof_indices,
                                 col_dof_indices[jk],
                                 kx_dof_to_cell_topo.topology,
                                 ky_dof_to_cell_topo.topology,
                                 bem_values_gpu,
                                 kx_map_from_local_to_full_dof_indices,
                                 ky_map_from_local_to_full_dof_indices,
                                 kx_dof_i2e_numbering,
                                 ky_dof_i2e_numbering,
                                 mappings,
                                 material_id_to_mapping_index,
                                 normal_detector,
                                 scratch_data,
                                 scratch_data_gpu,
                                 copy_data);

          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              uk.add(-vl(jk), ul);
            }
        }
      else
        {
          /**
           * Select \f$j^*\f$ as the current column index \f$j_k\f$.
           */
          jk = j_star;

          /**
           * Extract the \f$j_k\f$'th column from the matrix \f$A\f$.
           */
          assemble_kernel_column(uk,
                                 kernel,
                                 kernel_factor,
                                 row_dof_indices,
                                 col_dof_indices[jk],
                                 kx_dof_to_cell_topo.topology,
                                 ky_dof_to_cell_topo.topology,
                                 bem_values_gpu,
                                 kx_map_from_local_to_full_dof_indices,
                                 ky_map_from_local_to_full_dof_indices,
                                 kx_dof_i2e_numbering,
                                 ky_dof_i2e_numbering,
                                 mappings,
                                 material_id_to_mapping_index,
                                 normal_detector,
                                 scratch_data,
                                 scratch_data_gpu,
                                 copy_data);

          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              uk.add(-vl(jk), ul);
            }

          /**
           * Select the row index as the maximizer of the absolute values of
           * \f$u_k\f$.
           */
          std::transform(uk.begin(),
                         uk.end(),
                         uk_abs.begin(),
                         static_cast<real_type (*)(RangeNumberType)>(std::abs));
          ik = std::distance(uk_abs.begin(),
                             std::max_element(uk_abs.begin(), uk_abs.end()));

          /**
           * Extract the \f$i_k\f$'th row from \f$A\f$.
           */
          assemble_kernel_row(vk,
                              kernel,
                              kernel_factor,
                              row_dof_indices[ik],
                              col_dof_indices,
                              kx_dof_to_cell_topo.topology,
                              ky_dof_to_cell_topo.topology,
                              bem_values_gpu,
                              kx_map_from_local_to_full_dof_indices,
                              ky_map_from_local_to_full_dof_indices,
                              kx_dof_i2e_numbering,
                              ky_dof_i2e_numbering,
                              mappings,
                              material_id_to_mapping_index,
                              normal_detector,
                              scratch_data,
                              scratch_data_gpu,
                              copy_data);

          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              vk.add(-ul(ik), vl);
            }

          /**
           * Scale the vector \f$\widetilde{v}_k\f$.
           */
          RangeNumberType value_at_cross = vk(jk);
          vk /= value_at_cross;
        }

      /**
       * Update the matrices storing row and column vectors comprising the
       * cross.
       */
      u_mat.fill_col(k - 1, uk, false);
      v_mat.fill_col(k - 1, vk, false);

      if (k == 1)
        {
          /**
           * Calculate the error threshold only in the first step.
           */
          error_threshold = aca_config.epsilon * rkmat.frobenius_norm(1);
        }

      remaining_row_indices.remove(ik);
      remaining_col_indices.remove(jk);

      if (ik == r)
        {
          /**
           * When the index of the selected row is the same as that of the
           * reference row, reselect a reference row.
           */
          r = random_select_ref_row(vr,
                                    kernel,
                                    kernel_factor,
                                    remaining_row_indices,
                                    r,
                                    m,
                                    row_dof_indices,
                                    col_dof_indices,
                                    kx_dof_to_cell_topo.topology,
                                    ky_dof_to_cell_topo.topology,
                                    bem_values_gpu,
                                    kx_map_from_local_to_full_dof_indices,
                                    ky_map_from_local_to_full_dof_indices,
                                    kx_dof_i2e_numbering,
                                    ky_dof_i2e_numbering,
                                    mappings,
                                    material_id_to_mapping_index,
                                    normal_detector,
                                    scratch_data,
                                    scratch_data_gpu,
                                    copy_data);

          if (r == m)
            {
              // When there is no reference row can be selected, the ACA+
              // iteration should stop here.
              if (k < aca_config.max_iter)
                {
                  /**
                   * If the number of ACA+ iterations is less than the
                   * allowed
                   * maximum value, the @p rkmat should be truncated to its
                   * actual rank.
                   */
                  rkmat.keep_first_n_columns(k);
                }

              /**
               * Apply complex conjugation to the component matrix @p B, when
               * we're dealing with complex values, because the rank-k matrix
               * should take the form \f$M=AB^{\mathrm{H}}\f$.
               */
              if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
                v_mat.conjugate();

              return;
            }
          else
            {
              for (unsigned int l = 1; l <= k; l++)
                {
                  /**
                   * Extract the previous cross.
                   */
                  u_mat.get_column(l - 1, ul);
                  v_mat.get_column(l - 1, vl);

                  vr.add(-ul(r), vl);
                }
            }
        }
      else
        {
          /**
           * Otherwise, update the values of the reference row vector.
           */
          vr.add(-uk(r), vk);
        }

      /**
       * Update the vector of absolute values for @p vr.
       */
      std::transform(vr.begin(),
                     vr.end(),
                     vr_abs.begin(),
                     static_cast<real_type (*)(RangeNumberType)>(std::abs));

      if (jk == c)
        {
          /**
           * When the index of the selected column is the same as that of
           * the reference column, reselect a reference column.
           */
          c = random_select_ref_column(uc,
                                       kernel,
                                       kernel_factor,
                                       remaining_col_indices,
                                       c,
                                       n,
                                       row_dof_indices,
                                       col_dof_indices,
                                       kx_dof_to_cell_topo.topology,
                                       ky_dof_to_cell_topo.topology,
                                       bem_values_gpu,
                                       kx_map_from_local_to_full_dof_indices,
                                       ky_map_from_local_to_full_dof_indices,
                                       kx_dof_i2e_numbering,
                                       ky_dof_i2e_numbering,
                                       mappings,
                                       material_id_to_mapping_index,
                                       normal_detector,
                                       scratch_data,
                                       scratch_data_gpu,
                                       copy_data);

          if (c == n)
            {
              // When there is no reference column can be selected, the ACA+
              // iteration should stop here.
              if (k < aca_config.max_iter)
                {
                  /**
                   * If the number of ACA+ iterations is less than the
                   * allowed
                   * maximum value, the @p rkmat should be truncated to its
                   * actual rank.
                   */
                  rkmat.keep_first_n_columns(k);
                }

              /**
               * Apply complex conjugation to the component matrix @p B, when
               * we're dealing with complex values, because the rank-k matrix
               * should take the form \f$M=AB^{\mathrm{H}}\f$.
               */
              if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
                v_mat.conjugate();

              return;
            }
          else
            {
              for (unsigned int l = 1; l <= k; l++)
                {
                  /**
                   * Extract the previous cross.
                   */
                  u_mat.get_column(l - 1, ul);
                  v_mat.get_column(l - 1, vl);

                  uc.add(-vl(c), ul);
                }
            }
        }
      else
        {
          /**
           * Otherwise, update the values of the reference column vector.
           */
          uc.add(-vk(c), uk);
        }

      /**
       * Update the vector of absolute values for @p uc.
       */
      std::transform(uc.begin(),
                     uc.end(),
                     uc_abs.begin(),
                     static_cast<real_type (*)(RangeNumberType)>(std::abs));

      /**
       * Check the convergence condition.
       */
      if ((k > 1) && (uk.l2_norm() * vk.l2_norm() <= error_threshold))
        {
          if (k < aca_config.max_iter)
            {
              /**
               * If the number of ACA+ iterations is less than the allowed
               * maximum value, the @p rkmat should be truncated to its
               * actual rank.
               */
              rkmat.keep_first_n_columns(k);
            }

          /**
           * Apply complex conjugation to the component matrix @p B, when
           * we're dealing with complex values, because the rank-k matrix
           * should take the form \f$M=AB^{\mathrm{H}}\f$.
           */
          if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
            v_mat.conjugate();

          return;
        }
      else
        {
          if (size(remaining_row_indices) == 0)
            {
              if (k < aca_config.max_iter)
                {
                  /**
                   * If the number of ACA+ iterations is less than the
                   * allowed
                   * maximum value, the @p rkmat should be truncated to its
                   * actual rank.
                   */
                  rkmat.keep_first_n_columns(k);
                }

              /**
               * Apply complex conjugation to the component matrix @p B, when
               * we're dealing with complex values, because the rank-k matrix
               * should take the form \f$M=AB^{\mathrm{H}}\f$.
               */
              if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
                v_mat.conjugate();

              return;
            }
        }
    }

  Assert(false, ExcMessage("ACA+ should not exit from here!"));
}


/**
 * ACA+ algorithm
 *
 * \ref{Grasedyck, L. 2005. “Adaptive Recompression of
 * \f$\mathcal{H}\f$-Matrices for BEM.” Computing 74 (3): 205–23.}
 *
 * \mynote{1. At present, the simple convergence condition in this paper is
 * adopted instead of that in Bebendorf's book.
 * 2. This version is especially for assembling the regularized
 * hyper-singular matrix with the stabilization term.}
 *
 * @param rkmat
 * @param aca_config
 * @param kernel
 * @param factor
 * @param mass_vmult_weq
 * @param stabilization_factor
 * @param row_dof_index_range
 * @param col_dof_index_range
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param bem_values
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_dof_i2e_numbering
 * @param ky_dof_i2e_numbering
 * @param kx_mapping
 * @param ky_mapping
 * @param scratch_data
 * @param copy_data
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
aca_plus_parallel_sauter_quad_for_vector_entry(
  RkMatrix<RangeNumberType> &rkmat,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
                                                       &aca_config,
  const KernelFunctionType<spacedim, KernelNumberType> &kernel,
  const KernelNumberType                                kernel_factor,
  const std::vector<Vector<KernelNumberType>>          &mass_vmult_weq,
  const KernelNumberType                                stabilization_factor,
  const std::array<types::global_dof_index, 2>         &row_dof_index_range,
  const std::array<types::global_dof_index, 2>         &col_dof_index_range,
  const DoFToCellTopology<dim, spacedim>               &kx_dof_to_cell_topo,
  const DoFToCellTopology<dim, spacedim>               &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  HierBEM::CUDAWrappers::
    CUDAPairCellWiseScratchData<dim, spacedim, KernelNumberType>
                                                           &scratch_data_gpu,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  /**
   * Get the size of each dimension of the matrix block to be built.
   */
  const size_type m = row_dof_index_range[1] - row_dof_index_range[0];
  const size_type n = col_dof_index_range[1] - col_dof_index_range[0];

  AssertDimension(rkmat.get_m(), m);
  AssertDimension(rkmat.get_n(), n);

  /**
   * Adjust the maximum ACA+ iteration if is larger than the matrix
   * dimension.
   */
  unsigned int effective_max_iter = (aca_config.max_iter > std::min(m, n)) ?
                                      std::min(m, n) :
                                      aca_config.max_iter;

  /**
   * Generate lists of internal DoF indices (internal DoF numbering) from
   * corresponding index ranges.
   */
  std::vector<types::global_dof_index> row_dof_indices(m);
  std::vector<types::global_dof_index> col_dof_indices(n);
  gen_linear_indices<vector_uta, types::global_dof_index>(
    row_dof_indices, row_dof_index_range[0]);
  gen_linear_indices<vector_uta, types::global_dof_index>(
    col_dof_indices, col_dof_index_range[0]);

  /**
   * Create matrix references associated with the component matrices in the
   * rank-k matrix to be returned, which hold the row and column vectors in
   * the selected crosses during the ACA iteration. The number of columns
   * should be the same as the maximum iteration number in @p aca_config.
   */
  AssertDimension(rkmat.get_formal_rank(), aca_config.max_iter);
  LAPACKFullMatrixExt<RangeNumberType> &u_mat = rkmat.get_A();
  LAPACKFullMatrixExt<RangeNumberType> &v_mat = rkmat.get_B();
  u_mat                                       = RangeNumberType();
  v_mat                                       = RangeNumberType();

  /**
   * Generate two lists for storing remaining row indices and column indices
   * of the matrix block.
   */
  std::forward_list<size_type> remaining_row_indices(m);
  std::forward_list<size_type> remaining_col_indices(n);

  gen_linear_indices<forward_list_uta, size_type>(remaining_row_indices);
  gen_linear_indices<forward_list_uta, size_type>(remaining_col_indices);

  /**
   * Select the initial reference row and column vectors and return their
   * matrix indices.
   */
  Vector<RangeNumberType> vr(n);
  Vector<RangeNumberType> uc(m);

  size_type r = random_select_ref_row(vr,
                                      kernel,
                                      kernel_factor,
                                      mass_vmult_weq,
                                      stabilization_factor,
                                      remaining_row_indices,
                                      m,
                                      m,
                                      row_dof_indices,
                                      col_dof_indices,
                                      kx_dof_to_cell_topo.topology,
                                      ky_dof_to_cell_topo.topology,
                                      bem_values_gpu,
                                      kx_map_from_local_to_full_dof_indices,
                                      ky_map_from_local_to_full_dof_indices,
                                      kx_dof_i2e_numbering,
                                      ky_dof_i2e_numbering,
                                      mappings,
                                      material_id_to_mapping_index,
                                      normal_detector,
                                      scratch_data,
                                      scratch_data_gpu,
                                      copy_data);

  if (r == m)
    {
      // When there is no reference row can be selected, the current matrix
      // block is purely zero. Then return a zero rank-k matrix.
      rkmat.reinit(m, n, 0);
      return;
    }

  size_type c = random_select_ref_column(uc,
                                         kernel,
                                         kernel_factor,
                                         mass_vmult_weq,
                                         stabilization_factor,
                                         remaining_col_indices,
                                         n,
                                         n,
                                         row_dof_indices,
                                         col_dof_indices,
                                         kx_dof_to_cell_topo.topology,
                                         ky_dof_to_cell_topo.topology,
                                         bem_values_gpu,
                                         kx_map_from_local_to_full_dof_indices,
                                         ky_map_from_local_to_full_dof_indices,
                                         kx_dof_i2e_numbering,
                                         ky_dof_i2e_numbering,
                                         mappings,
                                         material_id_to_mapping_index,
                                         normal_detector,
                                         scratch_data,
                                         scratch_data_gpu,
                                         copy_data);

  if (c == n)
    {
      // When there is no reference column can be selected, the current
      // matrix block is purely zero. Then return a zero rank-k matrix.
      rkmat.reinit(m, n, 0);
      return;
    }

  /**
   * The absolute values for the reference row and column vectors.
   */
  Vector<real_type> vr_abs(n);
  Vector<real_type> uc_abs(m);

  /**
   * Calculate the absolute values for the reference row and column
   * vectors.
   *
   * \mynote{In the following, we use @p static_cast to explicitly
   * specify which version of @p std::abs to call.}
   */
  std::transform(vr.begin(),
                 vr.end(),
                 vr_abs.begin(),
                 static_cast<real_type (*)(RangeNumberType)>(std::abs));
  std::transform(uc.begin(),
                 uc.end(),
                 uc_abs.begin(),
                 static_cast<real_type (*)(RangeNumberType)>(std::abs));

  /**
   * Row and column indices for the \f$k\f$'th step. The corresponding row
   * and column vectors comprise the cross.
   */
  size_type ik, jk;

  /**
   * Temporary row and column vectors for the current step \f$k\f$.
   */
  Vector<RangeNumberType> vk(n);
  Vector<RangeNumberType> uk(m);

  /**
   * The absolute values for the temporary row and column vectors for the
   * current step \f$k\f$.
   */
  Vector<real_type> vk_abs(n);
  Vector<real_type> uk_abs(m);

  /**
   * Temporary row and column vectors for the previous step \f$l\f$.
   */
  Vector<RangeNumberType> vl(n);
  Vector<RangeNumberType> ul(m);

  /**
   * The error threshold as the stopping condition.
   */
  real_type error_threshold = 0.;

  /**
   * Start the ACA+ iteration from \f$k=1\f$.
   */
  for (unsigned int k = 1; k <= effective_max_iter; k++)
    {
      /**
       * Select the row index from the maximizer of the reference column.
       */
      // N.B. The function @p std::max_element return the iterator pointing
      // to the maximum element in the list.
      size_type i_star =
        std::distance(uc_abs.begin(),
                      std::max_element(uc_abs.begin(), uc_abs.end()));

      /**
       * Select the column index from the maximizer of the reference row.
       */
      size_type j_star =
        std::distance(vr_abs.begin(),
                      std::max_element(vr_abs.begin(), vr_abs.end()));

      if (uc_abs(i_star) > vr_abs(j_star))
        {
          /**
           * Select \f$i^*\f$ as the current row index \f$i_k\f$.
           */
          ik = i_star;

          /**
           * Extract the \f$i_k\f$'th row of \f$A\f$.
           */
          assemble_kernel_row(vk,
                              kernel,
                              kernel_factor,
                              mass_vmult_weq,
                              stabilization_factor,
                              row_dof_indices[ik],
                              col_dof_indices,
                              kx_dof_to_cell_topo.topology,
                              ky_dof_to_cell_topo.topology,
                              bem_values_gpu,
                              kx_map_from_local_to_full_dof_indices,
                              ky_map_from_local_to_full_dof_indices,
                              kx_dof_i2e_numbering,
                              ky_dof_i2e_numbering,
                              mappings,
                              material_id_to_mapping_index,
                              normal_detector,
                              scratch_data,
                              scratch_data_gpu,
                              copy_data);

          /**
           * \mynote{Here the counter \f$l\f$ iterates over all the previous
           * steps before \f$k\f$. For each step, the row and column vectors
           * comprising the cross have been stored as column vectors into
           * @p v_mat and @p u_mat respectively. Hence, the index for
           * extracting vectors from @p v_mat or @p u_mat should be
           * \f$l-1\f$.}
           */
          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              vk.add(-ul(ik), vl);
            }

          /**
           * Select the column index from the maximizer of the absolute
           * values of \f$\widetilde{v}_k\f$.
           */
          std::transform(vk.begin(),
                         vk.end(),
                         vk_abs.begin(),
                         static_cast<real_type (*)(RangeNumberType)>(std::abs));
          jk = std::distance(vk_abs.begin(),
                             std::max_element(vk_abs.begin(), vk_abs.end()));

          /**
           * Scale the vector \f$\widetilde{v}_k\f$.
           */
          RangeNumberType value_at_cross = vk(jk);
          vk /= value_at_cross;

          /**
           * Extract the \f$j_k\f$'th column from \f$A\f$.
           */
          assemble_kernel_column(uk,
                                 kernel,
                                 kernel_factor,
                                 mass_vmult_weq,
                                 stabilization_factor,
                                 row_dof_indices,
                                 col_dof_indices[jk],
                                 kx_dof_to_cell_topo.topology,
                                 ky_dof_to_cell_topo.topology,
                                 bem_values_gpu,
                                 kx_map_from_local_to_full_dof_indices,
                                 ky_map_from_local_to_full_dof_indices,
                                 kx_dof_i2e_numbering,
                                 ky_dof_i2e_numbering,
                                 mappings,
                                 material_id_to_mapping_index,
                                 normal_detector,
                                 scratch_data,
                                 scratch_data_gpu,
                                 copy_data);

          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              uk.add(-vl(jk), ul);
            }
        }
      else
        {
          /**
           * Select \f$j^*\f$ as the current column index \f$j_k\f$.
           */
          jk = j_star;

          /**
           * Extract the \f$j_k\f$'th column from the matrix \f$A\f$.
           */
          assemble_kernel_column(uk,
                                 kernel,
                                 kernel_factor,
                                 mass_vmult_weq,
                                 stabilization_factor,
                                 row_dof_indices,
                                 col_dof_indices[jk],
                                 kx_dof_to_cell_topo.topology,
                                 ky_dof_to_cell_topo.topology,
                                 bem_values_gpu,
                                 kx_map_from_local_to_full_dof_indices,
                                 ky_map_from_local_to_full_dof_indices,
                                 kx_dof_i2e_numbering,
                                 ky_dof_i2e_numbering,
                                 mappings,
                                 material_id_to_mapping_index,
                                 normal_detector,
                                 scratch_data,
                                 scratch_data_gpu,
                                 copy_data);

          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              uk.add(-vl(jk), ul);
            }

          /**
           * Select the row index as the maximizer of the absolute values of
           * \f$u_k\f$.
           */
          std::transform(uk.begin(),
                         uk.end(),
                         uk_abs.begin(),
                         static_cast<real_type (*)(RangeNumberType)>(std::abs));
          ik = std::distance(uk_abs.begin(),
                             std::max_element(uk_abs.begin(), uk_abs.end()));

          /**
           * Extract the \f$i_k\f$'th row from \f$A\f$.
           */
          assemble_kernel_row(vk,
                              kernel,
                              kernel_factor,
                              mass_vmult_weq,
                              stabilization_factor,
                              row_dof_indices[ik],
                              col_dof_indices,
                              kx_dof_to_cell_topo.topology,
                              ky_dof_to_cell_topo.topology,
                              bem_values_gpu,
                              kx_map_from_local_to_full_dof_indices,
                              ky_map_from_local_to_full_dof_indices,
                              kx_dof_i2e_numbering,
                              ky_dof_i2e_numbering,
                              mappings,
                              material_id_to_mapping_index,
                              normal_detector,
                              scratch_data,
                              scratch_data_gpu,
                              copy_data);

          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              vk.add(-ul(ik), vl);
            }

          /**
           * Scale the vector \f$\widetilde{v}_k\f$.
           */
          RangeNumberType value_at_cross = vk(jk);
          vk /= value_at_cross;
        }

      /**
       * Update the matrices storing row and column vectors comprising the
       * cross.
       */
      u_mat.fill_col(k - 1, uk, false);
      v_mat.fill_col(k - 1, vk, false);

      if (k == 1)
        {
          /**
           * Calculate the error threshold only in the first step.
           */
          error_threshold = aca_config.epsilon * rkmat.frobenius_norm(1);
        }

      remaining_row_indices.remove(ik);
      remaining_col_indices.remove(jk);

      if (ik == r)
        {
          /**
           * When the index of the selected row is the same as that of the
           * reference row, reselect a reference row.
           */
          r = random_select_ref_row(vr,
                                    kernel,
                                    kernel_factor,
                                    mass_vmult_weq,
                                    stabilization_factor,
                                    remaining_row_indices,
                                    r,
                                    m,
                                    row_dof_indices,
                                    col_dof_indices,
                                    kx_dof_to_cell_topo.topology,
                                    ky_dof_to_cell_topo.topology,
                                    bem_values_gpu,
                                    kx_map_from_local_to_full_dof_indices,
                                    ky_map_from_local_to_full_dof_indices,
                                    kx_dof_i2e_numbering,
                                    ky_dof_i2e_numbering,
                                    mappings,
                                    material_id_to_mapping_index,
                                    normal_detector,
                                    scratch_data,
                                    scratch_data_gpu,
                                    copy_data);

          if (r == m)
            {
              // When there is no reference row can be selected, the ACA+
              // iteration should stop here.
              if (k < aca_config.max_iter)
                {
                  /**
                   * If the number of ACA+ iterations is less than the
                   * allowed
                   * maximum value, the @p rkmat should be truncated to its
                   * actual rank.
                   */
                  rkmat.keep_first_n_columns(k);
                }

              /**
               * Apply complex conjugation to the component matrix @p B, when
               * we're dealing with complex values, because the rank-k matrix
               * should take the form \f$M=AB^{\mathrm{H}}\f$.
               */
              if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
                v_mat.conjugate();

              return;
            }
          else
            {
              for (unsigned int l = 1; l <= k; l++)
                {
                  /**
                   * Extract the previous cross.
                   */
                  u_mat.get_column(l - 1, ul);
                  v_mat.get_column(l - 1, vl);

                  vr.add(-ul(r), vl);
                }
            }
        }
      else
        {
          /**
           * Otherwise, update the values of the reference row vector.
           */
          vr.add(-uk(r), vk);
        }

      /**
       * Update the vector of absolute values for @p vr.
       */
      std::transform(vr.begin(),
                     vr.end(),
                     vr_abs.begin(),
                     static_cast<real_type (*)(RangeNumberType)>(std::abs));

      if (jk == c)
        {
          /**
           * When the index of the selected column is the same as that of
           * the reference column, reselect a reference column.
           */
          c = random_select_ref_column(uc,
                                       kernel,
                                       kernel_factor,
                                       mass_vmult_weq,
                                       stabilization_factor,
                                       remaining_col_indices,
                                       c,
                                       n,
                                       row_dof_indices,
                                       col_dof_indices,
                                       kx_dof_to_cell_topo.topology,
                                       ky_dof_to_cell_topo.topology,
                                       bem_values_gpu,
                                       kx_map_from_local_to_full_dof_indices,
                                       ky_map_from_local_to_full_dof_indices,
                                       kx_dof_i2e_numbering,
                                       ky_dof_i2e_numbering,
                                       mappings,
                                       material_id_to_mapping_index,
                                       normal_detector,
                                       scratch_data,
                                       scratch_data_gpu,
                                       copy_data);

          if (c == n)
            {
              // When there is no reference column can be selected, the ACA+
              // iteration should stop here.
              if (k < aca_config.max_iter)
                {
                  /**
                   * If the number of ACA+ iterations is less than the
                   * allowed
                   * maximum value, the @p rkmat should be truncated to its
                   * actual rank.
                   */
                  rkmat.keep_first_n_columns(k);
                }

              /**
               * Apply complex conjugation to the component matrix @p B, when
               * we're dealing with complex values, because the rank-k matrix
               * should take the form \f$M=AB^{\mathrm{H}}\f$.
               */
              if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
                v_mat.conjugate();

              return;
            }
          else
            {
              for (unsigned int l = 1; l <= k; l++)
                {
                  /**
                   * Extract the previous cross.
                   */
                  u_mat.get_column(l - 1, ul);
                  v_mat.get_column(l - 1, vl);

                  uc.add(-vl(c), ul);
                }
            }
        }
      else
        {
          /**
           * Otherwise, update the values of the reference column vector.
           */
          uc.add(-vk(c), uk);
        }

      /**
       * Update the vector of absolute values for @p uc.
       */
      std::transform(uc.begin(),
                     uc.end(),
                     uc_abs.begin(),
                     static_cast<real_type (*)(RangeNumberType)>(std::abs));

      /**
       * Check the convergence condition.
       */
      if ((k > 1) && (uk.l2_norm() * vk.l2_norm() <= error_threshold))
        {
          if (k < aca_config.max_iter)
            {
              /**
               * If the number of ACA+ iterations is less than the allowed
               * maximum value, the @p rkmat should be truncated to its
               * actual rank.
               */
              rkmat.keep_first_n_columns(k);
            }

          /**
           * Apply complex conjugation to the component matrix @p B, when
           * we're dealing with complex values, because the rank-k matrix
           * should take the form \f$M=AB^{\mathrm{H}}\f$.
           */
          if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
            v_mat.conjugate();

          return;
        }
      else
        {
          if (size(remaining_row_indices) == 0)
            {
              if (k < aca_config.max_iter)
                {
                  /**
                   * If the number of ACA+ iterations is less than the
                   * allowed
                   * maximum value, the @p rkmat should be truncated to its
                   * actual rank.
                   */
                  rkmat.keep_first_n_columns(k);
                }

              /**
               * Apply complex conjugation to the component matrix @p B, when
               * we're dealing with complex values, because the rank-k matrix
               * should take the form \f$M=AB^{\mathrm{H}}\f$.
               */
              if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
                v_mat.conjugate();

              return;
            }
        }
    }

  Assert(false, ExcMessage("ACA+ should not exit from here!"));
}


template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
aca_plus_parallel_sauter_quad_for_whole_vector(
  RkMatrix<RangeNumberType> &rkmat,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
    &aca_config,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                               &kernel,
  const DeviceNumberType<KernelNumberType>      kernel_factor,
  const std::array<types::global_dof_index, 2> &row_dof_index_range,
  const std::array<types::global_dof_index, 2> &col_dof_index_range,
  const DoFToCellTopology<dim, spacedim>       &kx_dof_to_cell_topo,
  const DoFToCellTopology<dim, spacedim>       &ky_dof_to_cell_topo,
  const BEMValues<dim,
                  spacedim,
                  typename numbers::NumberTraits<RangeNumberType>::real_type>
    &bem_values,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  using CUDARangeNumberType  = DeviceNumberType<RangeNumberType>;
  using CUDAKernelNumberType = DeviceNumberType<KernelNumberType>;
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  /**
   * @internal Get the size of each dimension of the matrix block to be built.
   */
  const size_type m = row_dof_index_range[1] - row_dof_index_range[0];
  const size_type n = col_dof_index_range[1] - col_dof_index_range[0];

  AssertDimension(rkmat.get_m(), m);
  AssertDimension(rkmat.get_n(), n);

  /**
   * @internal Create Sauter task buffers for assembling row vectors and
   * column vectors.
   */
  HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector<
    dim,
    spacedim,
    CUDARangeNumberType,
    CUDAKernelNumberType>
    sauter_task_buffer_for_row_vector(n,
                                      kx_dof_to_cell_topo.max_cells_per_dof,
                                      ky_dof_to_cell_topo.max_cells_per_dof,
                                      bem_values,
                                      scratch_data.cuda_stream_handle);
  HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector<
    dim,
    spacedim,
    CUDARangeNumberType,
    CUDAKernelNumberType>
    sauter_task_buffer_for_col_vector(m,
                                      kx_dof_to_cell_topo.max_cells_per_dof,
                                      ky_dof_to_cell_topo.max_cells_per_dof,
                                      bem_values,
                                      scratch_data.cuda_stream_handle);

  /**
   * Adjust the maximum ACA+ iteration if is larger than the matrix
   * dimension.
   */
  unsigned int effective_max_iter = (aca_config.max_iter > std::min(m, n)) ?
                                      std::min(m, n) :
                                      aca_config.max_iter;

  /**
   * Generate lists of internal DoF indices (internal DoF numbering) from
   * corresponding index ranges.
   */
  std::vector<types::global_dof_index> row_dof_indices(m);
  std::vector<types::global_dof_index> col_dof_indices(n);
  gen_linear_indices<vector_uta, types::global_dof_index>(
    row_dof_indices, row_dof_index_range[0]);
  gen_linear_indices<vector_uta, types::global_dof_index>(
    col_dof_indices, col_dof_index_range[0]);

  /**
   * Create matrix references associated with the component matrices in the
   * rank-k matrix to be returned, which hold the row and column vectors in
   * the selected crosses during the ACA iteration. The number of columns
   * should be the same as the maximum iteration number in @p aca_config.
   */
  AssertDimension(rkmat.get_formal_rank(), aca_config.max_iter);
  LAPACKFullMatrixExt<RangeNumberType> &u_mat = rkmat.get_A();
  LAPACKFullMatrixExt<RangeNumberType> &v_mat = rkmat.get_B();
  u_mat                                       = RangeNumberType();
  v_mat                                       = RangeNumberType();

  /**
   * Generate two lists for storing remaining row indices and column indices
   * of the matrix block.
   */
  std::forward_list<size_type> remaining_row_indices(m);
  std::forward_list<size_type> remaining_col_indices(n);

  gen_linear_indices<forward_list_uta, size_type>(remaining_row_indices);
  gen_linear_indices<forward_list_uta, size_type>(remaining_col_indices);

  /**
   * Select the initial reference row and column vectors and return their
   * matrix indices.
   */
  Vector<RangeNumberType> vr(n);
  Vector<RangeNumberType> uc(m);

  AssertCuda(
    cudaHostRegister((void *)(vr.data()), sizeof(RangeNumberType) * n, 0));
  AssertCuda(
    cudaHostRegister((void *)(uc.data()), sizeof(RangeNumberType) * m, 0));

  size_type r = random_select_ref_row(sauter_task_buffer_for_row_vector,
                                      vr,
                                      kernel,
                                      kernel_factor,
                                      remaining_row_indices,
                                      m,
                                      m,
                                      row_dof_indices,
                                      col_dof_indices,
                                      kx_dof_to_cell_topo.topology,
                                      ky_dof_to_cell_topo.topology,
                                      bem_values_gpu,
                                      kx_map_from_local_to_full_dof_indices,
                                      ky_map_from_local_to_full_dof_indices,
                                      kx_dof_i2e_numbering,
                                      ky_dof_i2e_numbering,
                                      mappings,
                                      material_id_to_mapping_index,
                                      normal_detector,
                                      scratch_data,
                                      copy_data);

  if (r == m)
    {
      // When there is no reference row can be selected, the current matrix
      // block is purely zero. Then return a zero rank-k matrix.
      rkmat.reinit(m, n, 0);

      AssertCuda(cudaHostUnregister((void *)(vr.data())));
      AssertCuda(cudaHostUnregister((void *)(uc.data())));

      return;
    }

  size_type c = random_select_ref_column(sauter_task_buffer_for_col_vector,
                                         uc,
                                         kernel,
                                         kernel_factor,
                                         remaining_col_indices,
                                         n,
                                         n,
                                         row_dof_indices,
                                         col_dof_indices,
                                         kx_dof_to_cell_topo.topology,
                                         ky_dof_to_cell_topo.topology,
                                         bem_values_gpu,
                                         kx_map_from_local_to_full_dof_indices,
                                         ky_map_from_local_to_full_dof_indices,
                                         kx_dof_i2e_numbering,
                                         ky_dof_i2e_numbering,
                                         mappings,
                                         material_id_to_mapping_index,
                                         normal_detector,
                                         scratch_data,
                                         copy_data);

  if (c == n)
    {
      // When there is no reference column can be selected, the current
      // matrix block is purely zero. Then return a zero rank-k matrix.
      rkmat.reinit(m, n, 0);

      AssertCuda(cudaHostUnregister((void *)(vr.data())));
      AssertCuda(cudaHostUnregister((void *)(uc.data())));

      return;
    }

  /**
   * The absolute values for the reference row and column vectors.
   */
  Vector<real_type> vr_abs(n);
  Vector<real_type> uc_abs(m);

  /**
   * Calculate the absolute values for the reference row and column
   * vectors.
   *
   * \mynote{In the following, we use @p static_cast to explicitly
   * specify which version of @p std::abs to call.}
   */
  std::transform(vr.begin(),
                 vr.end(),
                 vr_abs.begin(),
                 [](const RangeNumberType &val) -> real_type {
                   return std::abs(val);
                 });
  std::transform(uc.begin(),
                 uc.end(),
                 uc_abs.begin(),
                 [](const RangeNumberType &val) -> real_type {
                   return std::abs(val);
                 });

  /**
   * Row and column indices for the \f$k\f$'th step. The corresponding row
   * and column vectors comprise the cross.
   */
  size_type ik, jk;

  /**
   * Temporary row and column vectors for the current step \f$k\f$.
   */
  Vector<RangeNumberType> vk(n);
  Vector<RangeNumberType> uk(m);

  AssertCuda(
    cudaHostRegister((void *)(vk.data()), sizeof(RangeNumberType) * n, 0));
  AssertCuda(
    cudaHostRegister((void *)(uk.data()), sizeof(RangeNumberType) * m, 0));

  /**
   * The absolute values for the temporary row and column vectors for the
   * current step \f$k\f$.
   */
  Vector<real_type> vk_abs(n);
  Vector<real_type> uk_abs(m);

  /**
   * Temporary row and column vectors for the previous step \f$l\f$.
   */
  Vector<RangeNumberType> vl(n);
  Vector<RangeNumberType> ul(m);

  /**
   * The error threshold as the stopping condition.
   */
  real_type error_threshold = 0.;

  /**
   * Start the ACA+ iteration from \f$k=1\f$.
   */
  for (unsigned int k = 1; k <= effective_max_iter; k++)
    {
      /**
       * Select the row index from the maximizer of the reference column.
       */
      // N.B. The function @p std::max_element return the iterator pointing
      // to the maximum element in the list.
      size_type i_star =
        std::distance(uc_abs.begin(),
                      std::max_element(uc_abs.begin(), uc_abs.end()));

      /**
       * Select the column index from the maximizer of the reference row.
       */
      size_type j_star =
        std::distance(vr_abs.begin(),
                      std::max_element(vr_abs.begin(), vr_abs.end()));

      if (uc_abs(i_star) > vr_abs(j_star))
        {
          /**
           * Select \f$i^*\f$ as the current row index \f$i_k\f$.
           */
          ik = i_star;

          /**
           * Extract the \f$i_k\f$'th row of \f$A\f$.
           */
          assemble_kernel_row(sauter_task_buffer_for_row_vector,
                              vk,
                              kernel,
                              kernel_factor,
                              row_dof_indices[ik],
                              col_dof_indices,
                              kx_dof_to_cell_topo.topology,
                              ky_dof_to_cell_topo.topology,
                              bem_values_gpu,
                              kx_map_from_local_to_full_dof_indices,
                              ky_map_from_local_to_full_dof_indices,
                              kx_dof_i2e_numbering,
                              ky_dof_i2e_numbering,
                              mappings,
                              material_id_to_mapping_index,
                              normal_detector,
                              scratch_data,
                              copy_data);

          /**
           * \mynote{Here the counter \f$l\f$ iterates over all the previous
           * steps before \f$k\f$. For each step, the row and column vectors
           * comprising the cross have been stored as column vectors into
           * @p v_mat and @p u_mat respectively. Hence, the index for
           * extracting vectors from @p v_mat or @p u_mat should be
           * \f$l-1\f$.}
           */
          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              vk.add(-ul(ik), vl);
            }

          /**
           * Select the column index from the maximizer of the absolute
           * values of \f$\widetilde{v}_k\f$.
           */
          std::transform(vk.begin(),
                         vk.end(),
                         vk_abs.begin(),
                         [](const RangeNumberType &val) -> real_type {
                           return std::abs(val);
                         });
          jk = std::distance(vk_abs.begin(),
                             std::max_element(vk_abs.begin(), vk_abs.end()));

          /**
           * Scale the vector \f$\widetilde{v}_k\f$.
           */
          RangeNumberType value_at_cross = vk(jk);
          vk /= value_at_cross;

          /**
           * Extract the \f$j_k\f$'th column from \f$A\f$.
           */
          assemble_kernel_column(sauter_task_buffer_for_col_vector,
                                 uk,
                                 kernel,
                                 kernel_factor,
                                 row_dof_indices,
                                 col_dof_indices[jk],
                                 kx_dof_to_cell_topo.topology,
                                 ky_dof_to_cell_topo.topology,
                                 bem_values_gpu,
                                 kx_map_from_local_to_full_dof_indices,
                                 ky_map_from_local_to_full_dof_indices,
                                 kx_dof_i2e_numbering,
                                 ky_dof_i2e_numbering,
                                 mappings,
                                 material_id_to_mapping_index,
                                 normal_detector,
                                 scratch_data,
                                 copy_data);

          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              uk.add(-vl(jk), ul);
            }
        }
      else
        {
          /**
           * Select \f$j^*\f$ as the current column index \f$j_k\f$.
           */
          jk = j_star;

          /**
           * Extract the \f$j_k\f$'th column from the matrix \f$A\f$.
           */
          assemble_kernel_column(sauter_task_buffer_for_col_vector,
                                 uk,
                                 kernel,
                                 kernel_factor,
                                 row_dof_indices,
                                 col_dof_indices[jk],
                                 kx_dof_to_cell_topo.topology,
                                 ky_dof_to_cell_topo.topology,
                                 bem_values_gpu,
                                 kx_map_from_local_to_full_dof_indices,
                                 ky_map_from_local_to_full_dof_indices,
                                 kx_dof_i2e_numbering,
                                 ky_dof_i2e_numbering,
                                 mappings,
                                 material_id_to_mapping_index,
                                 normal_detector,
                                 scratch_data,
                                 copy_data);

          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              uk.add(-vl(jk), ul);
            }

          /**
           * Select the row index as the maximizer of the absolute values of
           * \f$u_k\f$.
           */
          std::transform(uk.begin(),
                         uk.end(),
                         uk_abs.begin(),
                         [](const RangeNumberType &val) -> real_type {
                           return std::abs(val);
                         });
          ik = std::distance(uk_abs.begin(),
                             std::max_element(uk_abs.begin(), uk_abs.end()));

          /**
           * Extract the \f$i_k\f$'th row from \f$A\f$.
           */
          assemble_kernel_row(sauter_task_buffer_for_row_vector,
                              vk,
                              kernel,
                              kernel_factor,
                              row_dof_indices[ik],
                              col_dof_indices,
                              kx_dof_to_cell_topo.topology,
                              ky_dof_to_cell_topo.topology,
                              bem_values_gpu,
                              kx_map_from_local_to_full_dof_indices,
                              ky_map_from_local_to_full_dof_indices,
                              kx_dof_i2e_numbering,
                              ky_dof_i2e_numbering,
                              mappings,
                              material_id_to_mapping_index,
                              normal_detector,
                              scratch_data,
                              copy_data);

          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              vk.add(-ul(ik), vl);
            }

          /**
           * Scale the vector \f$\widetilde{v}_k\f$.
           */
          RangeNumberType value_at_cross = vk(jk);
          vk /= value_at_cross;
        }

      /**
       * Update the matrices storing row and column vectors comprising the
       * cross.
       */
      u_mat.fill_col(k - 1, uk, false);
      v_mat.fill_col(k - 1, vk, false);

      if (k == 1)
        {
          /**
           * Calculate the error threshold only in the first step.
           */
          error_threshold = aca_config.epsilon * rkmat.frobenius_norm(1);
        }

      remaining_row_indices.remove(ik);
      remaining_col_indices.remove(jk);

      if (ik == r)
        {
          /**
           * When the index of the selected row is the same as that of the
           * reference row, reselect a reference row.
           */
          r = random_select_ref_row(sauter_task_buffer_for_row_vector,
                                    vr,
                                    kernel,
                                    kernel_factor,
                                    remaining_row_indices,
                                    r,
                                    m,
                                    row_dof_indices,
                                    col_dof_indices,
                                    kx_dof_to_cell_topo.topology,
                                    ky_dof_to_cell_topo.topology,
                                    bem_values_gpu,
                                    kx_map_from_local_to_full_dof_indices,
                                    ky_map_from_local_to_full_dof_indices,
                                    kx_dof_i2e_numbering,
                                    ky_dof_i2e_numbering,
                                    mappings,
                                    material_id_to_mapping_index,
                                    normal_detector,
                                    scratch_data,
                                    copy_data);

          if (r == m)
            {
              // When there is no reference row can be selected, the ACA+
              // iteration should stop here.
              if (k < aca_config.max_iter)
                {
                  /**
                   * If the number of ACA+ iterations is less than the
                   * allowed
                   * maximum value, the @p rkmat should be truncated to its
                   * actual rank.
                   */
                  rkmat.keep_first_n_columns(k);
                }

              AssertCuda(cudaHostUnregister((void *)(vr.data())));
              AssertCuda(cudaHostUnregister((void *)(uc.data())));
              AssertCuda(cudaHostUnregister((void *)(vk.data())));
              AssertCuda(cudaHostUnregister((void *)(uk.data())));

              /**
               * Apply complex conjugation to the component matrix @p B, when
               * we're dealing with complex values, because the rank-k matrix
               * should take the form \f$M=AB^{\mathrm{H}}\f$.
               */
              if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
                v_mat.conjugate();

              return;
            }
          else
            {
              for (unsigned int l = 1; l <= k; l++)
                {
                  /**
                   * Extract the previous cross.
                   */
                  u_mat.get_column(l - 1, ul);
                  v_mat.get_column(l - 1, vl);

                  vr.add(-ul(r), vl);
                }
            }
        }
      else
        {
          /**
           * Otherwise, update the values of the reference row vector.
           */
          vr.add(-uk(r), vk);
        }

      /**
       * Update the vector of absolute values for @p vr.
       */
      std::transform(vr.begin(),
                     vr.end(),
                     vr_abs.begin(),
                     [](const RangeNumberType &val) -> real_type {
                       return std::abs(val);
                     });

      if (jk == c)
        {
          /**
           * When the index of the selected column is the same as that of
           * the reference column, reselect a reference column.
           */
          c = random_select_ref_column(sauter_task_buffer_for_col_vector,
                                       uc,
                                       kernel,
                                       kernel_factor,
                                       remaining_col_indices,
                                       c,
                                       n,
                                       row_dof_indices,
                                       col_dof_indices,
                                       kx_dof_to_cell_topo.topology,
                                       ky_dof_to_cell_topo.topology,
                                       bem_values_gpu,
                                       kx_map_from_local_to_full_dof_indices,
                                       ky_map_from_local_to_full_dof_indices,
                                       kx_dof_i2e_numbering,
                                       ky_dof_i2e_numbering,
                                       mappings,
                                       material_id_to_mapping_index,
                                       normal_detector,
                                       scratch_data,
                                       copy_data);

          if (c == n)
            {
              // When there is no reference column can be selected, the ACA+
              // iteration should stop here.
              if (k < aca_config.max_iter)
                {
                  /**
                   * If the number of ACA+ iterations is less than the
                   * allowed
                   * maximum value, the @p rkmat should be truncated to its
                   * actual rank.
                   */
                  rkmat.keep_first_n_columns(k);
                }

              AssertCuda(cudaHostUnregister((void *)(vr.data())));
              AssertCuda(cudaHostUnregister((void *)(uc.data())));
              AssertCuda(cudaHostUnregister((void *)(vk.data())));
              AssertCuda(cudaHostUnregister((void *)(uk.data())));

              /**
               * Apply complex conjugation to the component matrix @p B, when
               * we're dealing with complex values, because the rank-k matrix
               * should take the form \f$M=AB^{\mathrm{H}}\f$.
               */
              if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
                v_mat.conjugate();

              return;
            }
          else
            {
              for (unsigned int l = 1; l <= k; l++)
                {
                  /**
                   * Extract the previous cross.
                   */
                  u_mat.get_column(l - 1, ul);
                  v_mat.get_column(l - 1, vl);

                  uc.add(-vl(c), ul);
                }
            }
        }
      else
        {
          /**
           * Otherwise, update the values of the reference column vector.
           */
          uc.add(-vk(c), uk);
        }

      /**
       * Update the vector of absolute values for @p uc.
       */
      std::transform(uc.begin(),
                     uc.end(),
                     uc_abs.begin(),
                     [](const RangeNumberType &val) -> real_type {
                       return std::abs(val);
                     });

      /**
       * Check the convergence condition.
       */
      if ((k > 1) && (uk.l2_norm() * vk.l2_norm() <= error_threshold))
        {
          if (k < aca_config.max_iter)
            {
              /**
               * If the number of ACA+ iterations is less than the allowed
               * maximum value, the @p rkmat should be truncated to its
               * actual rank.
               */
              rkmat.keep_first_n_columns(k);
            }

          AssertCuda(cudaHostUnregister((void *)(vr.data())));
          AssertCuda(cudaHostUnregister((void *)(uc.data())));
          AssertCuda(cudaHostUnregister((void *)(vk.data())));
          AssertCuda(cudaHostUnregister((void *)(uk.data())));

          /**
           * Apply complex conjugation to the component matrix @p B, when
           * we're dealing with complex values, because the rank-k matrix
           * should take the form \f$M=AB^{\mathrm{H}}\f$.
           */
          if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
            v_mat.conjugate();

          return;
        }
      else
        {
          if (size(remaining_row_indices) == 0)
            {
              if (k < aca_config.max_iter)
                {
                  /**
                   * If the number of ACA+ iterations is less than the
                   * allowed
                   * maximum value, the @p rkmat should be truncated to its
                   * actual rank.
                   */
                  rkmat.keep_first_n_columns(k);
                }

              AssertCuda(cudaHostUnregister((void *)(vr.data())));
              AssertCuda(cudaHostUnregister((void *)(uc.data())));
              AssertCuda(cudaHostUnregister((void *)(vk.data())));
              AssertCuda(cudaHostUnregister((void *)(uk.data())));

              /**
               * Apply complex conjugation to the component matrix @p B, when
               * we're dealing with complex values, because the rank-k matrix
               * should take the form \f$M=AB^{\mathrm{H}}\f$.
               */
              if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
                v_mat.conjugate();

              return;
            }
        }
    }

  AssertCuda(cudaHostUnregister((void *)(vr.data())));
  AssertCuda(cudaHostUnregister((void *)(uc.data())));
  AssertCuda(cudaHostUnregister((void *)(vk.data())));
  AssertCuda(cudaHostUnregister((void *)(uk.data())));

  Assert(false, ExcMessage("ACA+ should not exit from here!"));
}


template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
aca_plus_parallel_sauter_quad_for_whole_vector(
  RkMatrix<RangeNumberType> &rkmat,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
                                                       &aca_config,
  const KernelFunctionType<spacedim, KernelNumberType> &kernel,
  const KernelNumberType                                kernel_factor,
  const std::vector<Vector<KernelNumberType>>          &mass_vmult_weq,
  const KernelNumberType                                stabilization_factor,
  const std::array<types::global_dof_index, 2>         &row_dof_index_range,
  const std::array<types::global_dof_index, 2>         &col_dof_index_range,
  const DoFToCellTopology<dim, spacedim>               &kx_dof_to_cell_topo,
  const DoFToCellTopology<dim, spacedim>               &ky_dof_to_cell_topo,
  const BEMValues<dim,
                  spacedim,
                  typename numbers::NumberTraits<RangeNumberType>::real_type>
    &bem_values,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  using CUDARangeNumberType  = DeviceNumberType<RangeNumberType>;
  using CUDAKernelNumberType = DeviceNumberType<KernelNumberType>;
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  /**
   * Get the size of each dimension of the matrix block to be built.
   */
  const size_type m = row_dof_index_range[1] - row_dof_index_range[0];
  const size_type n = col_dof_index_range[1] - col_dof_index_range[0];

  AssertDimension(rkmat.get_m(), m);
  AssertDimension(rkmat.get_n(), n);

  /**
   * @internal Create Sauter task buffers for assembling row vectors and
   * column vectors.
   */
  HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector<
    dim,
    spacedim,
    CUDARangeNumberType,
    CUDAKernelNumberType>
    sauter_task_buffer_for_row_vector(n,
                                      kx_dof_to_cell_topo.max_cells_per_dof,
                                      ky_dof_to_cell_topo.max_cells_per_dof,
                                      bem_values,
                                      scratch_data.cuda_stream_handle);
  HierBEM::CUDAWrappers::SauterQuadratureTaskBufferForVector<
    dim,
    spacedim,
    CUDARangeNumberType,
    CUDAKernelNumberType>
    sauter_task_buffer_for_col_vector(m,
                                      kx_dof_to_cell_topo.max_cells_per_dof,
                                      ky_dof_to_cell_topo.max_cells_per_dof,
                                      bem_values,
                                      scratch_data.cuda_stream_handle);

  /**
   * Adjust the maximum ACA+ iteration if is larger than the matrix
   * dimension.
   */
  unsigned int effective_max_iter = (aca_config.max_iter > std::min(m, n)) ?
                                      std::min(m, n) :
                                      aca_config.max_iter;

  /**
   * Generate lists of internal DoF indices (internal DoF numbering) from
   * corresponding index ranges.
   */
  std::vector<types::global_dof_index> row_dof_indices(m);
  std::vector<types::global_dof_index> col_dof_indices(n);
  gen_linear_indices<vector_uta, types::global_dof_index>(
    row_dof_indices, row_dof_index_range[0]);
  gen_linear_indices<vector_uta, types::global_dof_index>(
    col_dof_indices, col_dof_index_range[0]);

  /**
   * Create matrix references associated with the component matrices in the
   * rank-k matrix to be returned, which hold the row and column vectors in
   * the selected crosses during the ACA iteration. The number of columns
   * should be the same as the maximum iteration number in @p aca_config.
   */
  AssertDimension(rkmat.get_formal_rank(), aca_config.max_iter);
  LAPACKFullMatrixExt<RangeNumberType> &u_mat = rkmat.get_A();
  LAPACKFullMatrixExt<RangeNumberType> &v_mat = rkmat.get_B();
  u_mat                                       = RangeNumberType();
  v_mat                                       = RangeNumberType();

  /**
   * Generate two lists for storing remaining row indices and column indices
   * of the matrix block.
   */
  std::forward_list<size_type> remaining_row_indices(m);
  std::forward_list<size_type> remaining_col_indices(n);

  gen_linear_indices<forward_list_uta, size_type>(remaining_row_indices);
  gen_linear_indices<forward_list_uta, size_type>(remaining_col_indices);

  /**
   * Select the initial reference row and column vectors and return their
   * matrix indices.
   */
  Vector<RangeNumberType> vr(n);
  Vector<RangeNumberType> uc(m);

  AssertCuda(
    cudaHostRegister((void *)(vr.data()), sizeof(RangeNumberType) * n, 0));
  AssertCuda(
    cudaHostRegister((void *)(uc.data()), sizeof(RangeNumberType) * m, 0));

  size_type r = random_select_ref_row(sauter_task_buffer_for_row_vector,
                                      vr,
                                      kernel,
                                      kernel_factor,
                                      mass_vmult_weq,
                                      stabilization_factor,
                                      remaining_row_indices,
                                      m,
                                      m,
                                      row_dof_indices,
                                      col_dof_indices,
                                      kx_dof_to_cell_topo.topology,
                                      ky_dof_to_cell_topo.topology,
                                      bem_values_gpu,
                                      kx_map_from_local_to_full_dof_indices,
                                      ky_map_from_local_to_full_dof_indices,
                                      kx_dof_i2e_numbering,
                                      ky_dof_i2e_numbering,
                                      mappings,
                                      material_id_to_mapping_index,
                                      normal_detector,
                                      scratch_data,
                                      copy_data);

  if (r == m)
    {
      // When there is no reference row can be selected, the current matrix
      // block is purely zero. Then return a zero rank-k matrix.
      rkmat.reinit(m, n, 0);

      AssertCuda(cudaHostUnregister((void *)(vr.data())));
      AssertCuda(cudaHostUnregister((void *)(uc.data())));

      return;
    }

  size_type c = random_select_ref_column(sauter_task_buffer_for_col_vector,
                                         uc,
                                         kernel,
                                         kernel_factor,
                                         mass_vmult_weq,
                                         stabilization_factor,
                                         remaining_col_indices,
                                         n,
                                         n,
                                         row_dof_indices,
                                         col_dof_indices,
                                         kx_dof_to_cell_topo.topology,
                                         ky_dof_to_cell_topo.topology,
                                         bem_values_gpu,
                                         kx_map_from_local_to_full_dof_indices,
                                         ky_map_from_local_to_full_dof_indices,
                                         kx_dof_i2e_numbering,
                                         ky_dof_i2e_numbering,
                                         mappings,
                                         material_id_to_mapping_index,
                                         normal_detector,
                                         scratch_data,
                                         copy_data);

  if (c == n)
    {
      // When there is no reference column can be selected, the current
      // matrix block is purely zero. Then return a zero rank-k matrix.
      rkmat.reinit(m, n, 0);

      AssertCuda(cudaHostUnregister((void *)(vr.data())));
      AssertCuda(cudaHostUnregister((void *)(uc.data())));

      return;
    }

  /**
   * The absolute values for the reference row and column vectors.
   */
  Vector<real_type> vr_abs(n);
  Vector<real_type> uc_abs(m);

  /**
   * Calculate the absolute values for the reference row and column
   * vectors.
   *
   * \mynote{In the following, we use @p static_cast to explicitly
   * specify which version of @p std::abs to call.}
   */
  std::transform(vr.begin(),
                 vr.end(),
                 vr_abs.begin(),
                 [](const RangeNumberType &val) -> real_type {
                   return std::abs(val);
                 });
  std::transform(uc.begin(),
                 uc.end(),
                 uc_abs.begin(),
                 [](const RangeNumberType &val) -> real_type {
                   return std::abs(val);
                 });

  /**
   * Row and column indices for the \f$k\f$'th step. The corresponding row
   * and column vectors comprise the cross.
   */
  size_type ik, jk;

  /**
   * Temporary row and column vectors for the current step \f$k\f$.
   */
  Vector<RangeNumberType> vk(n);
  Vector<RangeNumberType> uk(m);

  AssertCuda(
    cudaHostRegister((void *)(vk.data()), sizeof(RangeNumberType) * n, 0));
  AssertCuda(
    cudaHostRegister((void *)(uk.data()), sizeof(RangeNumberType) * m, 0));

  /**
   * The absolute values for the temporary row and column vectors for the
   * current step \f$k\f$.
   */
  Vector<real_type> vk_abs(n);
  Vector<real_type> uk_abs(m);

  /**
   * Temporary row and column vectors for the previous step \f$l\f$.
   */
  Vector<RangeNumberType> vl(n);
  Vector<RangeNumberType> ul(m);

  /**
   * The error threshold as the stopping condition.
   */
  real_type error_threshold = 0.;

  /**
   * Start the ACA+ iteration from \f$k=1\f$.
   */
  for (unsigned int k = 1; k <= effective_max_iter; k++)
    {
      /**
       * Select the row index from the maximizer of the reference column.
       */
      // N.B. The function @p std::max_element return the iterator pointing
      // to the maximum element in the list.
      size_type i_star =
        std::distance(uc_abs.begin(),
                      std::max_element(uc_abs.begin(), uc_abs.end()));

      /**
       * Select the column index from the maximizer of the reference row.
       */
      size_type j_star =
        std::distance(vr_abs.begin(),
                      std::max_element(vr_abs.begin(), vr_abs.end()));

      if (uc_abs(i_star) > vr_abs(j_star))
        {
          /**
           * Select \f$i^*\f$ as the current row index \f$i_k\f$.
           */
          ik = i_star;

          /**
           * Extract the \f$i_k\f$'th row of \f$A\f$.
           */
          assemble_kernel_row(sauter_task_buffer_for_row_vector,
                              vk,
                              kernel,
                              kernel_factor,
                              mass_vmult_weq,
                              stabilization_factor,
                              row_dof_indices[ik],
                              col_dof_indices,
                              kx_dof_to_cell_topo.topology,
                              ky_dof_to_cell_topo.topology,
                              bem_values_gpu,
                              kx_map_from_local_to_full_dof_indices,
                              ky_map_from_local_to_full_dof_indices,
                              kx_dof_i2e_numbering,
                              ky_dof_i2e_numbering,
                              mappings,
                              material_id_to_mapping_index,
                              normal_detector,
                              scratch_data,
                              copy_data);

          /**
           * \mynote{Here the counter \f$l\f$ iterates over all the previous
           * steps before \f$k\f$. For each step, the row and column vectors
           * comprising the cross have been stored as column vectors into
           * @p v_mat and @p u_mat respectively. Hence, the index for
           * extracting vectors from @p v_mat or @p u_mat should be
           * \f$l-1\f$.}
           */
          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              vk.add(-ul(ik), vl);
            }

          /**
           * Select the column index from the maximizer of the absolute
           * values of \f$\widetilde{v}_k\f$.
           */
          std::transform(vk.begin(),
                         vk.end(),
                         vk_abs.begin(),
                         [](const RangeNumberType &val) -> real_type {
                           return std::abs(val);
                         });
          jk = std::distance(vk_abs.begin(),
                             std::max_element(vk_abs.begin(), vk_abs.end()));

          /**
           * Scale the vector \f$\widetilde{v}_k\f$.
           */
          RangeNumberType value_at_cross = vk(jk);
          vk /= value_at_cross;

          /**
           * Extract the \f$j_k\f$'th column from \f$A\f$.
           */
          assemble_kernel_column(sauter_task_buffer_for_col_vector,
                                 uk,
                                 kernel,
                                 kernel_factor,
                                 mass_vmult_weq,
                                 stabilization_factor,
                                 row_dof_indices,
                                 col_dof_indices[jk],
                                 kx_dof_to_cell_topo.topology,
                                 ky_dof_to_cell_topo.topology,
                                 bem_values_gpu,
                                 kx_map_from_local_to_full_dof_indices,
                                 ky_map_from_local_to_full_dof_indices,
                                 kx_dof_i2e_numbering,
                                 ky_dof_i2e_numbering,
                                 mappings,
                                 material_id_to_mapping_index,
                                 normal_detector,
                                 scratch_data,
                                 copy_data);

          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              uk.add(-vl(jk), ul);
            }
        }
      else
        {
          /**
           * Select \f$j^*\f$ as the current column index \f$j_k\f$.
           */
          jk = j_star;

          /**
           * Extract the \f$j_k\f$'th column from the matrix \f$A\f$.
           */
          assemble_kernel_column(sauter_task_buffer_for_col_vector,
                                 uk,
                                 kernel,
                                 kernel_factor,
                                 mass_vmult_weq,
                                 stabilization_factor,
                                 row_dof_indices,
                                 col_dof_indices[jk],
                                 kx_dof_to_cell_topo.topology,
                                 ky_dof_to_cell_topo.topology,
                                 bem_values_gpu,
                                 kx_map_from_local_to_full_dof_indices,
                                 ky_map_from_local_to_full_dof_indices,
                                 kx_dof_i2e_numbering,
                                 ky_dof_i2e_numbering,
                                 mappings,
                                 material_id_to_mapping_index,
                                 normal_detector,
                                 scratch_data,
                                 copy_data);

          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              uk.add(-vl(jk), ul);
            }

          /**
           * Select the row index as the maximizer of the absolute values of
           * \f$u_k\f$.
           */
          std::transform(uk.begin(),
                         uk.end(),
                         uk_abs.begin(),
                         [](const RangeNumberType &val) -> real_type {
                           return std::abs(val);
                         });
          ik = std::distance(uk_abs.begin(),
                             std::max_element(uk_abs.begin(), uk_abs.end()));

          /**
           * Extract the \f$i_k\f$'th row from \f$A\f$.
           */
          assemble_kernel_row(sauter_task_buffer_for_row_vector,
                              vk,
                              kernel,
                              kernel_factor,
                              mass_vmult_weq,
                              stabilization_factor,
                              row_dof_indices[ik],
                              col_dof_indices,
                              kx_dof_to_cell_topo.topology,
                              ky_dof_to_cell_topo.topology,
                              bem_values_gpu,
                              kx_map_from_local_to_full_dof_indices,
                              ky_map_from_local_to_full_dof_indices,
                              kx_dof_i2e_numbering,
                              ky_dof_i2e_numbering,
                              mappings,
                              material_id_to_mapping_index,
                              normal_detector,
                              scratch_data,
                              copy_data);

          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              vk.add(-ul(ik), vl);
            }

          /**
           * Scale the vector \f$\widetilde{v}_k\f$.
           */
          RangeNumberType value_at_cross = vk(jk);
          vk /= value_at_cross;
        }

      /**
       * Update the matrices storing row and column vectors comprising the
       * cross.
       */
      u_mat.fill_col(k - 1, uk, false);
      v_mat.fill_col(k - 1, vk, false);

      if (k == 1)
        {
          /**
           * Calculate the error threshold only in the first step.
           */
          error_threshold = aca_config.epsilon * rkmat.frobenius_norm(1);
        }

      remaining_row_indices.remove(ik);
      remaining_col_indices.remove(jk);

      if (ik == r)
        {
          /**
           * When the index of the selected row is the same as that of the
           * reference row, reselect a reference row.
           */
          r = random_select_ref_row(sauter_task_buffer_for_row_vector,
                                    vr,
                                    kernel,
                                    kernel_factor,
                                    mass_vmult_weq,
                                    stabilization_factor,
                                    remaining_row_indices,
                                    r,
                                    m,
                                    row_dof_indices,
                                    col_dof_indices,
                                    kx_dof_to_cell_topo.topology,
                                    ky_dof_to_cell_topo.topology,
                                    bem_values_gpu,
                                    kx_map_from_local_to_full_dof_indices,
                                    ky_map_from_local_to_full_dof_indices,
                                    kx_dof_i2e_numbering,
                                    ky_dof_i2e_numbering,
                                    mappings,
                                    material_id_to_mapping_index,
                                    normal_detector,
                                    scratch_data,
                                    copy_data);

          if (r == m)
            {
              // When there is no reference row can be selected, the ACA+
              // iteration should stop here.
              if (k < aca_config.max_iter)
                {
                  /**
                   * If the number of ACA+ iterations is less than the
                   * allowed
                   * maximum value, the @p rkmat should be truncated to its
                   * actual rank.
                   */
                  rkmat.keep_first_n_columns(k);
                }

              AssertCuda(cudaHostUnregister((void *)(vr.data())));
              AssertCuda(cudaHostUnregister((void *)(uc.data())));
              AssertCuda(cudaHostUnregister((void *)(vk.data())));
              AssertCuda(cudaHostUnregister((void *)(uk.data())));

              /**
               * Apply complex conjugation to the component matrix @p B, when
               * we're dealing with complex values, because the rank-k matrix
               * should take the form \f$M=AB^{\mathrm{H}}\f$.
               */
              if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
                v_mat.conjugate();

              return;
            }
          else
            {
              for (unsigned int l = 1; l <= k; l++)
                {
                  /**
                   * Extract the previous cross.
                   */
                  u_mat.get_column(l - 1, ul);
                  v_mat.get_column(l - 1, vl);

                  vr.add(-ul(r), vl);
                }
            }
        }
      else
        {
          /**
           * Otherwise, update the values of the reference row vector.
           */
          vr.add(-uk(r), vk);
        }

      /**
       * Update the vector of absolute values for @p vr.
       */
      std::transform(vr.begin(),
                     vr.end(),
                     vr_abs.begin(),
                     [](const RangeNumberType &val) -> real_type {
                       return std::abs(val);
                     });

      if (jk == c)
        {
          /**
           * When the index of the selected column is the same as that of
           * the reference column, reselect a reference column.
           */
          c = random_select_ref_column(sauter_task_buffer_for_col_vector,
                                       uc,
                                       kernel,
                                       kernel_factor,
                                       mass_vmult_weq,
                                       stabilization_factor,
                                       remaining_col_indices,
                                       c,
                                       n,
                                       row_dof_indices,
                                       col_dof_indices,
                                       kx_dof_to_cell_topo.topology,
                                       ky_dof_to_cell_topo.topology,
                                       bem_values_gpu,
                                       kx_map_from_local_to_full_dof_indices,
                                       ky_map_from_local_to_full_dof_indices,
                                       kx_dof_i2e_numbering,
                                       ky_dof_i2e_numbering,
                                       mappings,
                                       material_id_to_mapping_index,
                                       normal_detector,
                                       scratch_data,
                                       copy_data);

          if (c == n)
            {
              // When there is no reference column can be selected, the ACA+
              // iteration should stop here.
              if (k < aca_config.max_iter)
                {
                  /**
                   * If the number of ACA+ iterations is less than the
                   * allowed
                   * maximum value, the @p rkmat should be truncated to its
                   * actual rank.
                   */
                  rkmat.keep_first_n_columns(k);
                }

              AssertCuda(cudaHostUnregister((void *)(vr.data())));
              AssertCuda(cudaHostUnregister((void *)(uc.data())));
              AssertCuda(cudaHostUnregister((void *)(vk.data())));
              AssertCuda(cudaHostUnregister((void *)(uk.data())));

              /**
               * Apply complex conjugation to the component matrix @p B, when
               * we're dealing with complex values, because the rank-k matrix
               * should take the form \f$M=AB^{\mathrm{H}}\f$.
               */
              if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
                v_mat.conjugate();

              return;
            }
          else
            {
              for (unsigned int l = 1; l <= k; l++)
                {
                  /**
                   * Extract the previous cross.
                   */
                  u_mat.get_column(l - 1, ul);
                  v_mat.get_column(l - 1, vl);

                  uc.add(-vl(c), ul);
                }
            }
        }
      else
        {
          /**
           * Otherwise, update the values of the reference column vector.
           */
          uc.add(-vk(c), uk);
        }

      /**
       * Update the vector of absolute values for @p uc.
       */
      std::transform(uc.begin(),
                     uc.end(),
                     uc_abs.begin(),
                     [](const RangeNumberType &val) -> real_type {
                       return std::abs(val);
                     });

      /**
       * Check the convergence condition.
       */
      if ((k > 1) && (uk.l2_norm() * vk.l2_norm() <= error_threshold))
        {
          if (k < aca_config.max_iter)
            {
              /**
               * If the number of ACA+ iterations is less than the allowed
               * maximum value, the @p rkmat should be truncated to its
               * actual rank.
               */
              rkmat.keep_first_n_columns(k);
            }

          AssertCuda(cudaHostUnregister((void *)(vr.data())));
          AssertCuda(cudaHostUnregister((void *)(uc.data())));
          AssertCuda(cudaHostUnregister((void *)(vk.data())));
          AssertCuda(cudaHostUnregister((void *)(uk.data())));

          /**
           * Apply complex conjugation to the component matrix @p B, when
           * we're dealing with complex values, because the rank-k matrix
           * should take the form \f$M=AB^{\mathrm{H}}\f$.
           */
          if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
            v_mat.conjugate();

          return;
        }
      else
        {
          if (size(remaining_row_indices) == 0)
            {
              if (k < aca_config.max_iter)
                {
                  /**
                   * If the number of ACA+ iterations is less than the
                   * allowed
                   * maximum value, the @p rkmat should be truncated to its
                   * actual rank.
                   */
                  rkmat.keep_first_n_columns(k);
                }

              AssertCuda(cudaHostUnregister((void *)(vr.data())));
              AssertCuda(cudaHostUnregister((void *)(uc.data())));
              AssertCuda(cudaHostUnregister((void *)(vk.data())));
              AssertCuda(cudaHostUnregister((void *)(uk.data())));

              /**
               * Apply complex conjugation to the component matrix @p B, when
               * we're dealing with complex values, because the rank-k matrix
               * should take the form \f$M=AB^{\mathrm{H}}\f$.
               */
              if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
                v_mat.conjugate();

              return;
            }
        }
    }

  AssertCuda(cudaHostUnregister((void *)(vr.data())));
  AssertCuda(cudaHostUnregister((void *)(uc.data())));
  AssertCuda(cudaHostUnregister((void *)(vk.data())));
  AssertCuda(cudaHostUnregister((void *)(uk.data())));

  Assert(false, ExcMessage("ACA+ should not exit from here!"));
}


/**
 * ACA+ algorithm for verification purpose. The matrix for the current block
 * is passed in as a full matrix without kernel function evaluation.
 *
 * \ref{Grasedyck, L. 2005. “Adaptive Recompression of
 * \f$\mathcal{H}\f$-Matrices for BEM.” Computing 74 (3): 205–23.}
 *
 * @param rkmat The rank-k matrix to be constructed for the current block,
 * the memory of which should be preallocated and the formal rank of which
 * should be the same as the maximum iteration number in @p aca_config.
 * @param aca_config
 * @param A The full matrix to be approximated
 */
template <typename RangeNumberType = double>
void
aca_plus(
  RkMatrix<RangeNumberType> &rkmat,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
                                             &aca_config,
  const LAPACKFullMatrixExt<RangeNumberType> &A)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;

  AssertDimension(rkmat.get_m(), A.m());
  AssertDimension(rkmat.get_n(), A.n());

  /**
   * Get the size of each dimension of the matrix block to be built.
   */
  const size_type m = A.m();
  const size_type n = A.n();

  /**
   * Create matrix references associated with the component matrices in the
   * rank-k matrix to be returned, which hold the row and column vectors in
   * the selected crosses during the ACA iteration. The number of columns
   * should be the same as the maximum iteration number in @p aca_config.
   */
  AssertDimension(rkmat.get_formal_rank(), aca_config.max_iter);
  LAPACKFullMatrixExt<RangeNumberType> &u_mat = rkmat.get_A();
  LAPACKFullMatrixExt<RangeNumberType> &v_mat = rkmat.get_B();
  u_mat                                       = RangeNumberType();
  v_mat                                       = RangeNumberType();

  /**
   * Generate two lists for storing remaining row indices and column indices
   * of the matrix block.
   */
  std::forward_list<size_type> remaining_row_indices(m);
  std::forward_list<size_type> remaining_col_indices(n);

  gen_linear_indices<forward_list_uta, size_type>(remaining_row_indices);
  gen_linear_indices<forward_list_uta, size_type>(remaining_col_indices);

  /**
   * Select the initial reference row and column vectors and return their
   * matrix indices.
   */
  Vector<RangeNumberType> vr(n);
  Vector<RangeNumberType> uc(m);

  size_type r = random_select_ref_row(vr, A, remaining_row_indices, m, m);

  if (r == m)
    {
      // When there is no reference row can be selected, the current matrix
      // block is purely zero. Then return a zero rank-k matrix.
      rkmat.reinit(m, n, 0);
      return;
    }

  size_type c = random_select_ref_column(uc, A, remaining_col_indices, n, n);

  if (c == n)
    {
      // When there is no reference column can be selected, the current
      // matrix block is purely zero. Then return a zero rank-k matrix.
      rkmat.reinit(m, n, 0);
      return;
    }

  /**
   * The absolute values for the reference row and column vectors.
   */
  Vector<real_type> vr_abs(n);
  Vector<real_type> uc_abs(m);

  /**
   * Calculate the absolute values for the reference row and column
   * vectors.
   *
   * \mynote{In the following, we use @p static_cast to explicitly
   * specify which version of @p std::abs to call.}
   */
  std::transform(vr.begin(),
                 vr.end(),
                 vr_abs.begin(),
                 [](const RangeNumberType &val) -> real_type {
                   return std::abs(val);
                 });
  std::transform(uc.begin(),
                 uc.end(),
                 uc_abs.begin(),
                 [](const RangeNumberType &val) -> real_type {
                   return std::abs(val);
                 });

  /**
   * Row and column indices for the \f$k\f$'th step. The corresponding row
   * and column vectors comprise the cross.
   */
  size_type ik, jk;

  /**
   * Temporary row and column vectors for the current step \f$k\f$.
   */
  Vector<RangeNumberType> vk(n);
  Vector<RangeNumberType> uk(m);

  /**
   * The absolute values for the temporary row and column vectors for the
   * current step \f$k\f$.
   */
  Vector<real_type> vk_abs(n);
  Vector<real_type> uk_abs(m);

  /**
   * Temporary row and column vectors for the previous step \f$l\f$.
   */
  Vector<RangeNumberType> vl(n);
  Vector<RangeNumberType> ul(m);

  /**
   * Start the ACA+ iteration from \f$k=1\f$.
   */
  for (unsigned int k = 1; k <= aca_config.max_iter; k++)
    {
      /**
       * Select the row index from the maximizer of the reference column.
       */
      // N.B. The function @p std::max_element return the iterator pointing
      // to the maximum element in the list.
      size_type i_star =
        std::distance(uc_abs.begin(),
                      std::max_element(uc_abs.begin(), uc_abs.end()));

      /**
       * Select the column index from the maximizer of the reference row.
       */
      size_type j_star =
        std::distance(vr_abs.begin(),
                      std::max_element(vr_abs.begin(), vr_abs.end()));

      if (uc_abs(i_star) > vr_abs(j_star))
        {
          /**
           * Select \f$i^*\f$ as the current row index \f$i_k\f$.
           */
          ik = i_star;

          /**
           * Extract the \f$i_k\f$'th row of \f$A\f$.
           */
          A.get_row(ik, vk);

          /**
           * \mynote{Here the counter \f$l\f$ iterates over all the previous
           * steps before \f$k\f$. For each step, the row and column vectors
           * comprising the cross have been stored as column vectors into
           * @p v_mat and @p u_mat respectively. Hence, the index for
           * extracting vectors from @p v_mat or @p u_mat should be
           * \f$l-1\f$.}
           */
          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              vk.add(-ul(ik), vl);
            }

          /**
           * Select the column index from the maximizer of the absolute
           * values of \f$\widetilde{v}_k\f$.
           */
          std::transform(vk.begin(),
                         vk.end(),
                         vk_abs.begin(),
                         [](const RangeNumberType &val) -> real_type {
                           return std::abs(val);
                         });
          jk = std::distance(vk_abs.begin(),
                             std::max_element(vk_abs.begin(), vk_abs.end()));

          /**
           * Scale the vector \f$\widetilde{v}_k\f$.
           */
          RangeNumberType value_at_cross = vk(jk);
          vk /= value_at_cross;

          /**
           * Extract the \f$j_k\f$'th column from \f$A\f$.
           */
          A.get_column(jk, uk);

          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              uk.add(-vl(jk), ul);
            }
        }
      else
        {
          /**
           * Select \f$j^*\f$ as the current column index \f$j_k\f$.
           */
          jk = j_star;

          /**
           * Extract the \f$j_k\f$'th column from the matrix \f$A\f$.
           */
          A.get_column(jk, uk);

          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              uk.add(-vl(jk), ul);
            }

          /**
           * Select the row index as the maximizer of the absolute values of
           * \f$u_k\f$.
           */
          std::transform(uk.begin(),
                         uk.end(),
                         uk_abs.begin(),
                         [](const RangeNumberType &val) -> real_type {
                           return std::abs(val);
                         });
          ik = std::distance(uk_abs.begin(),
                             std::max_element(uk_abs.begin(), uk_abs.end()));

          /**
           * Extract the \f$i_k\f$'th row from \f$A\f$.
           */
          A.get_row(ik, vk);

          for (size_type l = 1; l < k; l++)
            {
              /**
               * Extract the previous cross.
               */
              u_mat.get_column(l - 1, ul);
              v_mat.get_column(l - 1, vl);

              vk.add(-ul(ik), vl);
            }

          /**
           * Scale the vector \f$\widetilde{v}_k\f$.
           */
          RangeNumberType value_at_cross = vk(jk);
          vk /= value_at_cross;
        }

      /**
       * Update the matrices storing row and column vectors comprising the
       * cross.
       */
      u_mat.fill_col(k - 1, uk, false);
      v_mat.fill_col(k - 1, vk, false);

      remaining_row_indices.remove(ik);
      remaining_col_indices.remove(jk);

      if (ik == r)
        {
          /**
           * When the index of the selected row is the same as that of the
           * reference row, reselect a reference row.
           */
          r = random_select_ref_row(vr, A, remaining_row_indices, r, m);

          if (r == m)
            {
              // When there is no reference row can be selected, the ACA+
              // iteration should stop here.
              if (k < aca_config.max_iter)
                {
                  /**
                   * If the number of ACA+ iterations is less than the
                   * allowed
                   * maximum value, the @p rkmat should be truncated to its
                   * actual rank.
                   */
                  rkmat.keep_first_n_columns(k);
                }

              /**
               * Apply complex conjugation to the component matrix @p B, when
               * we're dealing with complex values, because the rank-k matrix
               * should take the form \f$M=AB^{\mathrm{H}}\f$.
               */
              if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
                v_mat.conjugate();

              return;
            }
          else
            {
              for (unsigned int l = 1; l <= k; l++)
                {
                  /**
                   * Extract the previous cross.
                   */
                  u_mat.get_column(l - 1, ul);
                  v_mat.get_column(l - 1, vl);

                  vr.add(-ul(r), vl);
                }
            }
        }
      else
        {
          /**
           * Otherwise, update the values of the reference row vector.
           */
          vr.add(-uk(r), vk);
        }

      /**
       * Update the vector of absolute values for @p vr.
       */
      std::transform(vr.begin(),
                     vr.end(),
                     vr_abs.begin(),
                     [](const RangeNumberType &val) -> real_type {
                       return std::abs(val);
                     });

      if (jk == c)
        {
          /**
           * When the index of the selected column is the same as that of
           * the reference column, reselect a reference column.
           */
          c = random_select_ref_column(uc, A, remaining_col_indices, c, n);

          if (c == n)
            {
              // When there is no reference column can be selected, the ACA+
              // iteration should stop here.
              if (k < aca_config.max_iter)
                {
                  /**
                   * If the number of ACA+ iterations is less than the
                   * allowed
                   * maximum value, the @p rkmat should be truncated to its
                   * actual rank.
                   */
                  rkmat.keep_first_n_columns(k);
                }

              /**
               * Apply complex conjugation to the component matrix @p B, when
               * we're dealing with complex values, because the rank-k matrix
               * should take the form \f$M=AB^{\mathrm{H}}\f$.
               */
              if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
                v_mat.conjugate();

              return;
            }
          else
            {
              for (unsigned int l = 1; l <= k; l++)
                {
                  /**
                   * Extract the previous cross.
                   */
                  u_mat.get_column(l - 1, ul);
                  v_mat.get_column(l - 1, vl);

                  uc.add(-vl(c), ul);
                }
            }
        }
      else
        {
          /**
           * Otherwise, update the values of the reference column vector.
           */
          uc.add(-vk(c), uk);
        }

      /**
       * Update the vector of absolute values for @p uc.
       */
      std::transform(uc.begin(),
                     uc.end(),
                     uc_abs.begin(),
                     [](const RangeNumberType &val) -> real_type {
                       return std::abs(val);
                     });

      /**
       * Check the convergence condition.
       */
      real_type error_threshold = 0.;
      // DEBUG
      if (k > 1)
        {
          if (aca_config.eta >= 1.0)
            {
              error_threshold = aca_config.epsilon * rkmat.frobenius_norm(1);
            }
          else
            {
              error_threshold = aca_config.epsilon * (1.0 - aca_config.eta) /
                                (1.0 + aca_config.epsilon) *
                                rkmat.frobenius_norm(k - 1);
            }

          deallog << "uk.l2_norm() * vk.l2_norm(): "
                  << uk.l2_norm() * vk.l2_norm() << "\n"
                  << "error_threshold: " << error_threshold << std::endl;
        }
      else
        {
          deallog << "uk.l2_norm() * vk.l2_norm(): "
                  << uk.l2_norm() * vk.l2_norm() << std::endl;
        }

      if ((k > 1) && (uk.l2_norm() * vk.l2_norm() <= error_threshold))
        {
          if (k < aca_config.max_iter)
            {
              /**
               * If the number of ACA+ iterations is less than the allowed
               * maximum value, the @p rkmat should be truncated to its
               * actual rank.
               */
              rkmat.keep_first_n_columns(k);
              // DEBUG
              deallog << "Early successful return from ACA+!" << std::endl;
            }

          /**
           * Apply complex conjugation to the component matrix @p B, when
           * we're dealing with complex values, because the rank-k matrix
           * should take the form \f$M=AB^{\mathrm{H}}\f$.
           */
          if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
            v_mat.conjugate();

          return;
        }
      else
        {
          if (size(remaining_row_indices) == 0)
            {
              if (k < aca_config.max_iter)
                {
                  /**
                   * If the number of ACA+ iterations is less than the
                   * allowed
                   * maximum value, the @p rkmat should be truncated to its
                   * actual rank.
                   */
                  rkmat.keep_first_n_columns(k);
                }

              /**
               * Apply complex conjugation to the component matrix @p B, when
               * we're dealing with complex values, because the rank-k matrix
               * should take the form \f$M=AB^{\mathrm{H}}\f$.
               */
              if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
                v_mat.conjugate();

              return;
            }
        }
    }

  Assert(false, ExcMessage("ACA+ should not exit from here!"));
}


/**
 * @brief Fill a single leaf node of the \hmatrix using ACA+. If the matrix
 * type is
 * @p RkMatrixType, the memory for the full or rank-k matrix in the leaf node
 * has been allocated.
 *
 * For the near field matrix, full matrices will be built whose elements
 * will be obtained from the evaluation of the double integral in
 * Galerkin-BEM. For the far field admissible matrix, rank-k matrices will
 * be built using ACA+.
 *
 * \mynote{1. This is used as the work function for parallel \hmatrix
 * construction using ACA+.
 * 2. For near field matrix assembly, the producer-consumer model is not
 * adopted. GPU parallelization with 2D thread grid is distributed over each
 * quadrature point in the X direction and each k3 term in the Y direction.}
 *
 * @tparam dim
 * @tparam spacedim
 * @tparam KernelFunctionType
 * @tparam RangeNumberType
 * @tparam KernelNumberType
 * @tparam SurfaceNormalDetector
 * @param leaf_mat
 * @param aca_config
 * @param kernel
 * @param kernel_factor
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param bem_values_gpu
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_map_from_local_to_full_dof_indices
 * @param ky_map_from_local_to_full_dof_indices
 * @param kx_dof_i2e_numbering
 * @param ky_dof_i2e_numbering
 * @param mappings
 * @param material_id_to_mapping_index
 * @param normal_detector
 * @param scratch_data
 * @param scratch_data_gpu
 * @param copy_data
 * @param enable_build_symmetric_hmat
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
fill_hmatrix_leaf_node_with_aca_plus(
  HMatrix<spacedim, RangeNumberType> *leaf_mat,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
    &aca_config,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                          &kernel,
  const DeviceNumberType<KernelNumberType> kernel_factor,
  const DoFToCellTopology<dim, spacedim>  &kx_dof_to_cell_topo,
  const DoFToCellTopology<dim, spacedim>  &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const DoFHandler<dim, spacedim>                               &kx_dof_handler,
  const DoFHandler<dim, spacedim>                               &ky_dof_handler,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData<
    dim,
    spacedim,
    DeviceNumberType<KernelNumberType>>                    &scratch_data_gpu,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data,
  const bool enable_build_symmetric_hmat = false)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

#if ENABLE_NVTX == 1
  HierBEM::CUDAWrappers::NVTXRange nvtx_range(
    "fill_hmatrix_leaf_node_with_aca_plus");
#endif

  /**
   * @internal Row and column index ranges in the internal DoF numbering.
   */
  const std::array<types::global_dof_index, 2> *row_index_range =
    leaf_mat->get_row_index_range();
  const std::array<types::global_dof_index, 2> *col_index_range =
    leaf_mat->get_col_index_range();

  /**
   * @internal Global DoF indices in the external numbering for the current
   * matrix entry.
   */
  types::global_dof_index i_global_dof_index;
  types::global_dof_index j_global_dof_index;

  switch (leaf_mat->get_type())
    {
        case FullMatrixType: {
          LAPACKFullMatrixExt<RangeNumberType> *fullmat =
            leaf_mat->get_fullmatrix();

          if (enable_build_symmetric_hmat && kernel.is_symmetric())
            {
              /**
               * When the flag @p enable_build_symmetric_hmat is true and the
               * kernel function is symmetric, try to build a symmetric
               * \hmatrix. Otherwise, the whole full matrix will be built.
               */
              switch (leaf_mat->get_block_type())
                {
                    case HMatrixSupport::BlockType::diagonal_block: {
                      /**
                       * A diagonal \hmatrix block as well as its associated
                       * full matrix should be symmetric.
                       */
                      Assert(leaf_mat->get_property() ==
                               HMatrixSupport::Property::symmetric,
                             ExcInvalidHMatrixProperty(
                               leaf_mat->get_property()));
                      Assert(fullmat->get_property() ==
                               LAPACKSupport::Property::symmetric,
                             ExcInvalidLAPACKFullMatrixProperty(
                               fullmat->get_property()));

                      /**
                       * Only evaluate the diagonal and lower triangular
                       * elements in the full matrix.
                       */
                      for (size_t i = 0; i < fullmat->m(); i++)
                        {
                          i_global_dof_index =
                            (kx_map_from_local_to_full_dof_indices == nullptr) ?
                              kx_dof_i2e_numbering[(*row_index_range)[0] + i] :
                              kx_map_from_local_to_full_dof_indices->at(
                                kx_dof_i2e_numbering[(*row_index_range)[0] +
                                                     i]);

                          for (size_t j = 0; j <= i; j++)
                            {
                              j_global_dof_index =
                                (ky_map_from_local_to_full_dof_indices ==
                                 nullptr) ?
                                  ky_dof_i2e_numbering[(*col_index_range)[0] +
                                                       j] :
                                  ky_map_from_local_to_full_dof_indices->at(
                                    ky_dof_i2e_numbering[(*col_index_range)[0] +
                                                         j]);

                              (*fullmat)(i, j) =
                                sauter_quadrature_on_one_pair_of_dofs(
                                  kernel,
                                  kernel_factor,
                                  i_global_dof_index,
                                  j_global_dof_index,
                                  kx_dof_to_cell_topo.topology,
                                  ky_dof_to_cell_topo.topology,
                                  bem_values_gpu,
                                  mappings,
                                  material_id_to_mapping_index,
                                  normal_detector,
                                  scratch_data,
                                  scratch_data_gpu,
                                  copy_data);
                            }
                        }

                      break;
                    }
                    case HMatrixSupport::BlockType::upper_triangular_block: {
                      /**
                       * Do not build \hmatrix block belonging to the upper
                       * triangular part.
                       */

                      break;
                    }
                    case HMatrixSupport::BlockType::lower_triangular_block: {
                      /**
                       * When the current \hmatrix block belongs to the
                       * lower triangular part, evaluate all of its elements
                       * as usual.
                       */
                      for (size_t i = 0; i < fullmat->m(); i++)
                        {
                          i_global_dof_index =
                            (kx_map_from_local_to_full_dof_indices == nullptr) ?
                              kx_dof_i2e_numbering[(*row_index_range)[0] + i] :
                              kx_map_from_local_to_full_dof_indices->at(
                                kx_dof_i2e_numbering[(*row_index_range)[0] +
                                                     i]);

                          for (size_t j = 0; j < fullmat->n(); j++)
                            {
                              j_global_dof_index =
                                (ky_map_from_local_to_full_dof_indices ==
                                 nullptr) ?
                                  ky_dof_i2e_numbering[(*col_index_range)[0] +
                                                       j] :
                                  ky_map_from_local_to_full_dof_indices->at(
                                    ky_dof_i2e_numbering[(*col_index_range)[0] +
                                                         j]);

                              (*fullmat)(i, j) =
                                sauter_quadrature_on_one_pair_of_dofs(
                                  kernel,
                                  kernel_factor,
                                  i_global_dof_index,
                                  j_global_dof_index,
                                  kx_dof_to_cell_topo.topology,
                                  ky_dof_to_cell_topo.topology,
                                  bem_values_gpu,
                                  mappings,
                                  material_id_to_mapping_index,
                                  normal_detector,
                                  scratch_data,
                                  scratch_data_gpu,
                                  copy_data);
                            }
                        }

                      break;
                    }
                    case HMatrixSupport::BlockType::undefined_block: {
                      Assert(false,
                             ExcInvalidHMatrixBlockType(
                               leaf_mat->get_block_type()));

                      break;
                    }
                }
            }
          else
            {
              /**
               * Evaluate the whole full matrix.
               */
              for (size_t i = 0; i < fullmat->m(); i++)
                {
                  i_global_dof_index =
                    (kx_map_from_local_to_full_dof_indices == nullptr) ?
                      kx_dof_i2e_numbering[(*row_index_range)[0] + i] :
                      kx_map_from_local_to_full_dof_indices->at(
                        kx_dof_i2e_numbering[(*row_index_range)[0] + i]);

                  for (size_t j = 0; j < fullmat->n(); j++)
                    {
                      j_global_dof_index =
                        (ky_map_from_local_to_full_dof_indices == nullptr) ?
                          ky_dof_i2e_numbering[(*col_index_range)[0] + j] :
                          ky_map_from_local_to_full_dof_indices->at(
                            ky_dof_i2e_numbering[(*col_index_range)[0] + j]);

                      (*fullmat)(i, j) = sauter_quadrature_on_one_pair_of_dofs(
                        kernel,
                        kernel_factor,
                        i_global_dof_index,
                        j_global_dof_index,
                        kx_dof_to_cell_topo.topology,
                        ky_dof_to_cell_topo.topology,
                        bem_values_gpu,
                        mappings,
                        material_id_to_mapping_index,
                        normal_detector,
                        scratch_data,
                        scratch_data_gpu,
                        copy_data);
                    }
                }
            }

          break;
        }
        case RkMatrixType: {
          /**
           * When the \hmatrix block type is rank-k matrix, when the top
           * level \hmatrix is symmetric and the flag
           * @p enable_build_symmetric_hmat is true, only those matrix blocks
           * belong to the lower triangular part will be computed.
           * Otherwise, the rank-k matrix block will always be computed.
           * ACA+ will be used for building the rank-k matrix.
           */
          RkMatrix<RangeNumberType> *rkmat = leaf_mat->get_rkmatrix();

          if (enable_build_symmetric_hmat && kernel.is_symmetric())
            {
              switch (leaf_mat->get_block_type())
                {
                    case HMatrixSupport::BlockType::lower_triangular_block: {
                      /**
                       * Build the \hmatrix block when it belongs to the
                       * lower triangular part using ACA+.
                       */
                      aca_plus_parallel_sauter_quad_for_vector_entry(
                        (*rkmat),
                        aca_config,
                        kernel,
                        kernel_factor,
                        *row_index_range,
                        *col_index_range,
                        kx_dof_to_cell_topo,
                        ky_dof_to_cell_topo,
                        bem_values_gpu,
                        kx_map_from_local_to_full_dof_indices,
                        ky_map_from_local_to_full_dof_indices,
                        kx_dof_i2e_numbering,
                        ky_dof_i2e_numbering,
                        mappings,
                        material_id_to_mapping_index,
                        normal_detector,
                        scratch_data,
                        scratch_data_gpu,
                        copy_data);

                      break;
                    }
                    case HMatrixSupport::BlockType::upper_triangular_block: {
                      /**
                       * Do not build \hmatrix block belonging to the upper
                       * triangular part.
                       */

                      break;
                    }
                    case HMatrixSupport::BlockType::diagonal_block: {
                      /**
                       * An rank-k matrix cannot belong to the diagonal part.
                       */
                      Assert(false,
                             ExcInvalidHMatrixBlockType(
                               leaf_mat->get_block_type()));

                      break;
                    }
                    case HMatrixSupport::BlockType::undefined_block: {
                      Assert(false,
                             ExcInvalidHMatrixBlockType(
                               leaf_mat->get_block_type()));

                      break;
                    }
                }
            }
          else
            {
              aca_plus_parallel_sauter_quad_for_vector_entry(
                (*rkmat),
                aca_config,
                kernel,
                kernel_factor,
                (*row_index_range),
                (*col_index_range),
                kx_dof_to_cell_topo,
                ky_dof_to_cell_topo,
                bem_values_gpu,
                kx_dof_handler,
                ky_dof_handler,
                kx_map_from_local_to_full_dof_indices,
                ky_map_from_local_to_full_dof_indices,
                kx_dof_i2e_numbering,
                ky_dof_i2e_numbering,
                mappings,
                material_id_to_mapping_index,
                normal_detector,
                scratch_data,
                scratch_data_gpu,
                copy_data);
            }

          break;
        }
        default: {
          Assert(false, ExcInvalidHMatrixType(leaf_mat->get_type()));
          break;
        }
    }
}


/**
 * @brief Fill a single leaf node of the \hmatrix using ACA+. If the matrix
 * type is
 * @p RkMatrixType, the memory for the full or rank-k matrix in the leaf node
 * has been allocated.
 *
 * For the near field matrix, full matrices will be built whose elements
 * will be obtained from the evaluation of the double integral in
 * Galerkin-BEM. For the far field admissible matrix, rank-k matrices will
 * be built using ACA+.
 *
 * \mynote{
 * 1. This is used as the work function for parallel \hmatrix
 * construction using ACA+.
 * 2. For near field matrix assembly, the producer-consumer model is not
 * adopted. GPU parallelization with 2D thread grid is distributed over each
 * quadrature point in the X direction and each k3 term in the Y direction.
 * 3. This version is especially for assembling the regularized
 * hyper-singular matrix appended with the stabilization term. The
 * stabilization term in the variational equation is
 *   \f[
 *   \alpha\langle \gamma_0^{\rm ext}u, \omega_{\rm eq} \rangle \cdot \langle
 * v, \omega_{\rm eq} \rangle_{\Gamma}. \f]
 *
 *   The stabilization term in the discretized form is
 *   \f[
 *   \alpha M [\omega_{\rm eq}] \cdot \left[ M [\omega_{\rm eq}] \right]^{\rm
 * T} \cdot [\gamma_0^{\rm ext}u], \f] which is actually an outer-product
 * representation. The argument
 *   @p mass_vmult_weq passed to this function is just the vector
 *   \f$M [\omega_{\rm eq}]\f$.}
 *
 * @tparam dim
 * @tparam spacedim
 * @tparam KernelFunctionType
 * @tparam RangeNumberType
 * @tparam KernelNumberType
 * @tparam SurfaceNormalDetector
 * @param leaf_mat
 * @param aca_config
 * @param kernel
 * @param kernel_factor
 * @param mass_vmult_weq This is the multiplication of the mass matrix and
 * natural density vector. When in the mixed boundary value problem, because
 * it produces an intermediate result, the DoF indices associated with the
 * result vector are the local DoF indices, which does not need the
 * application of the internal-to-external map (which is caused by the
 * renumbering due to cluster tree construction), nor the external
 * local-to-full Dirichlet DoF index map (which is caused by selecting a
 * subset of DoFs from the Dirichlet space.).
 * @param stabilization_factor
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param bem_values_gpu
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_map_from_local_to_full_dof_indices
 * @param ky_map_from_local_to_full_dof_indices
 * @param kx_dof_i2e_numbering
 * @param ky_dof_i2e_numbering
 * @param mappings
 * @param material_id_to_mapping_index
 * @param normal_detector
 * @param scratch_data
 * @param scratch_data_gpu
 * @param copy_data
 * @param enable_build_symmetric_hmat
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
fill_hmatrix_leaf_node_with_aca_plus(
  HMatrix<spacedim, RangeNumberType> *leaf_mat,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
    &aca_config,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                              &kernel,
  const DeviceNumberType<KernelNumberType>     kernel_factor,
  const std::vector<Vector<KernelNumberType>> &mass_vmult_weq,
  const KernelNumberType                       stabilization_factor,
  const DoFToCellTopology<dim, spacedim>      &kx_dof_to_cell_topo,
  const DoFToCellTopology<dim, spacedim>      &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const DoFHandler<dim, spacedim>                               &kx_dof_handler,
  const DoFHandler<dim, spacedim>                               &ky_dof_handler,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData<
    dim,
    spacedim,
    DeviceNumberType<KernelNumberType>>                    &scratch_data_gpu,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data,
  const bool enable_build_symmetric_hmat = false)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

#if ENABLE_NVTX == 1
  HierBEM::CUDAWrappers::NVTXRange nvtx_range(
    "fill_hmatrix_leaf_node_with_aca_plus for hypersingular");
#endif

  const std::array<types::global_dof_index, 2> *row_index_range =
    leaf_mat->get_row_index_range();
  const std::array<types::global_dof_index, 2> *col_index_range =
    leaf_mat->get_col_index_range();

  types::global_dof_index i_global_dof_index;
  types::global_dof_index j_global_dof_index;

  switch (leaf_mat->get_type())
    {
        case FullMatrixType: {
          LAPACKFullMatrixExt<RangeNumberType> *fullmat =
            leaf_mat->get_fullmatrix();

          if (enable_build_symmetric_hmat && kernel.is_symmetric())
            {
              /**
               * When the flag @p enable_build_symmetric_hmat is true and the
               * kernel function is symmetric, try to build a symmetric
               * \hmatrix. Otherwise, the whole full matrix will be built.
               */
              switch (leaf_mat->get_block_type())
                {
                    case HMatrixSupport::BlockType::diagonal_block: {
                      /**
                       * A diagonal \hmatrix block as well as its associated
                       * full matrix should be symmetric.
                       */
                      Assert(leaf_mat->get_property() ==
                               HMatrixSupport::Property::symmetric,
                             ExcInvalidHMatrixProperty(
                               leaf_mat->get_property()));
                      Assert(fullmat->get_property() ==
                               LAPACKSupport::Property::symmetric,
                             ExcInvalidLAPACKFullMatrixProperty(
                               fullmat->get_property()));

                      /**
                       * Only evaluate the diagonal and lower triangular
                       * elements in the full matrix.
                       */
                      for (size_t i = 0; i < fullmat->m(); i++)
                        {
                          i_global_dof_index =
                            (kx_map_from_local_to_full_dof_indices == nullptr) ?
                              kx_dof_i2e_numbering[(*row_index_range)[0] + i] :
                              kx_map_from_local_to_full_dof_indices->at(
                                kx_dof_i2e_numbering[(*row_index_range)[0] +
                                                     i]);

                          for (size_t j = 0; j <= i; j++)
                            {
                              j_global_dof_index =
                                (ky_map_from_local_to_full_dof_indices ==
                                 nullptr) ?
                                  ky_dof_i2e_numbering[(*col_index_range)[0] +
                                                       j] :
                                  ky_map_from_local_to_full_dof_indices->at(
                                    ky_dof_i2e_numbering[(*col_index_range)[0] +
                                                         j]);

                              (*fullmat)(i, j) =
                                sauter_quadrature_on_one_pair_of_dofs(
                                  kernel,
                                  kernel_factor,
                                  i_global_dof_index,
                                  j_global_dof_index,
                                  kx_dof_to_cell_topo.topology,
                                  ky_dof_to_cell_topo.topology,
                                  bem_values_gpu,
                                  mappings,
                                  material_id_to_mapping_index,
                                  normal_detector,
                                  scratch_data,
                                  scratch_data_gpu,
                                  copy_data);

                              // N.B. The internal and local DoF indices are
                              // used directly to access the result vector
                              // of \f$M w_{\rm eq}\f$.
                              for (const auto &vec : mass_vmult_weq)
                                (*fullmat)(i, j) +=
                                  stabilization_factor *
                                  vec((*row_index_range)[0] + i) *
                                  vec((*col_index_range)[0] + j);
                            }
                        }

                      break;
                    }
                    case HMatrixSupport::BlockType::upper_triangular_block: {
                      /**
                       * Do not build \hmatrix block belonging to the upper
                       * triangular part.
                       */

                      break;
                    }
                    case HMatrixSupport::BlockType::lower_triangular_block: {
                      /**
                       * When the current \hmatrix block belongs to the
                       * lower triangular part, evaluate all of its elements
                       * as usual.
                       */
                      for (size_t i = 0; i < fullmat->m(); i++)
                        {
                          i_global_dof_index =
                            (kx_map_from_local_to_full_dof_indices == nullptr) ?
                              kx_dof_i2e_numbering[(*row_index_range)[0] + i] :
                              kx_map_from_local_to_full_dof_indices->at(
                                kx_dof_i2e_numbering[(*row_index_range)[0] +
                                                     i]);

                          for (size_t j = 0; j < fullmat->n(); j++)
                            {
                              j_global_dof_index =
                                (ky_map_from_local_to_full_dof_indices ==
                                 nullptr) ?
                                  ky_dof_i2e_numbering[(*col_index_range)[0] +
                                                       j] :
                                  ky_map_from_local_to_full_dof_indices->at(
                                    ky_dof_i2e_numbering[(*col_index_range)[0] +
                                                         j]);

                              (*fullmat)(i, j) =
                                sauter_quadrature_on_one_pair_of_dofs(
                                  kernel,
                                  kernel_factor,
                                  i_global_dof_index,
                                  j_global_dof_index,
                                  kx_dof_to_cell_topo.topology,
                                  ky_dof_to_cell_topo.topology,
                                  bem_values_gpu,
                                  mappings,
                                  material_id_to_mapping_index,
                                  normal_detector,
                                  scratch_data,
                                  scratch_data_gpu,
                                  copy_data);

                              // N.B. The internal and local DoF indices are
                              // used directly to access the result vector
                              // of \f$M w_{\rm eq}\f$.
                              for (const auto &vec : mass_vmult_weq)
                                (*fullmat)(i, j) +=
                                  stabilization_factor *
                                  vec((*row_index_range)[0] + i) *
                                  vec((*col_index_range)[0] + j);
                            }
                        }

                      break;
                    }
                    case HMatrixSupport::BlockType::undefined_block: {
                      Assert(false,
                             ExcInvalidHMatrixBlockType(
                               leaf_mat->get_block_type()));

                      break;
                    }
                }
            }
          else
            {
              /**
               * Evaluate the whole full matrix.
               */
              for (size_t i = 0; i < fullmat->m(); i++)
                {
                  i_global_dof_index =
                    (kx_map_from_local_to_full_dof_indices == nullptr) ?
                      kx_dof_i2e_numbering[(*row_index_range)[0] + i] :
                      kx_map_from_local_to_full_dof_indices->at(
                        kx_dof_i2e_numbering[(*row_index_range)[0] + i]);

                  for (size_t j = 0; j < fullmat->n(); j++)
                    {
                      j_global_dof_index =
                        (ky_map_from_local_to_full_dof_indices == nullptr) ?
                          ky_dof_i2e_numbering[(*col_index_range)[0] + j] :
                          ky_map_from_local_to_full_dof_indices->at(
                            ky_dof_i2e_numbering[(*col_index_range)[0] + j]);

                      (*fullmat)(i, j) = sauter_quadrature_on_one_pair_of_dofs(
                        kernel,
                        kernel_factor,
                        i_global_dof_index,
                        j_global_dof_index,
                        kx_dof_to_cell_topo.topology,
                        ky_dof_to_cell_topo.topology,
                        bem_values_gpu,
                        mappings,
                        material_id_to_mapping_index,
                        normal_detector,
                        scratch_data,
                        scratch_data_gpu,
                        copy_data);

                      // N.B. The internal and local DoF indices are
                      // used directly to access the result vector of
                      // \f$M w_{\rm eq}\f$.
                      for (const auto &vec : mass_vmult_weq)
                        (*fullmat)(i, j) += stabilization_factor *
                                            vec((*row_index_range)[0] + i) *
                                            vec((*col_index_range)[0] + j);
                    }
                }
            }

          break;
        }
        case RkMatrixType: {
          /**
           * When the \hmatrix block type is rank-k matrix, when the top
           * level \hmatrix is symmetric and the flag
           * @p enable_build_symmetric_hmat is true, only those matrix blocks
           * belong to the lower triangular part will be computed.
           * Otherwise, the rank-k matrix block will always be computed.
           * ACA+ will be used for building the rank-k matrix.
           */
          RkMatrix<RangeNumberType> *rkmat = leaf_mat->get_rkmatrix();

          if (enable_build_symmetric_hmat && kernel.is_symmetric())
            {
              switch (leaf_mat->get_block_type())
                {
                    case HMatrixSupport::BlockType::lower_triangular_block: {
                      /**
                       * Build the \hmatrix block when it belongs to the
                       * lower triangular part using ACA+.
                       */
                      aca_plus_parallel_sauter_quad_for_vector_entry(
                        (*rkmat),
                        aca_config,
                        kernel,
                        kernel_factor,
                        mass_vmult_weq,
                        stabilization_factor,
                        *row_index_range,
                        *col_index_range,
                        kx_dof_to_cell_topo,
                        ky_dof_to_cell_topo,
                        bem_values_gpu,
                        kx_map_from_local_to_full_dof_indices,
                        ky_map_from_local_to_full_dof_indices,
                        kx_dof_i2e_numbering,
                        ky_dof_i2e_numbering,
                        mappings,
                        material_id_to_mapping_index,
                        normal_detector,
                        scratch_data,
                        scratch_data_gpu,
                        copy_data);

                      break;
                    }
                    case HMatrixSupport::BlockType::upper_triangular_block: {
                      /**
                       * Do not build \hmatrix block belonging to the upper
                       * triangular part.
                       */

                      break;
                    }
                  case HMatrixSupport::BlockType::diagonal_block:
                    /**
                     * An rank-k matrix cannot belong to the diagonal part.
                     */
                    case HMatrixSupport::BlockType::undefined_block: {
                      Assert(false,
                             ExcInvalidHMatrixBlockType(
                               leaf_mat->get_block_type()));

                      break;
                    }
                }
            }
          else
            {
              aca_plus_parallel_sauter_quad_for_vector_entry(
                (*rkmat),
                aca_config,
                kernel,
                kernel_factor,
                mass_vmult_weq,
                stabilization_factor,
                (*row_index_range),
                (*col_index_range),
                kx_dof_to_cell_topo,
                ky_dof_to_cell_topo,
                bem_values_gpu,
                kx_map_from_local_to_full_dof_indices,
                ky_map_from_local_to_full_dof_indices,
                kx_dof_i2e_numbering,
                ky_dof_i2e_numbering,
                mappings,
                material_id_to_mapping_index,
                normal_detector,
                scratch_data,
                scratch_data_gpu,
                copy_data);
            }

          break;
        }
        default: {
          Assert(false, ExcInvalidHMatrixType(leaf_mat->get_type()));
          break;
        }
    }
}


/**
 * @brief Fill a single leaf node of the \hmatrix using ACA+.
 *
 * In the mean time, the FEM mass matrix multiplied by a factor will be
 * added to the near field matrix block.
 *
 * If the matrix type is @p RkMatrixType, the memory for the full or rank-k
 * matrix in the leaf node has been allocated.
 *
 * For the near field matrix, full matrices will be built whose elements
 * will be obtained from the evaluation of the double integral in
 * Galerkin-BEM. For the far field admissible matrix, rank-k matrices will
 * be built using ACA+.
 *
 * \mynote{1. This is used as the work function for parallel \hmatrix
 * construction using ACA+.
 * 2. For near field matrix assembly, the producer-consumer model is not
 * adopted. GPU parallelization with 2D thread grid is distributed over each
 * quadrature point in the X direction and each k3 term in the Y direction.}
 *
 * @tparam dim
 * @tparam spacedim
 * @tparam KernelFunctionType
 * @tparam RangeNumberType
 * @tparam KernelNumberType
 * @tparam SurfaceNormalDetector
 * @param leaf_mat
 * @param aca_config
 * @param kernel
 * @param kernel_factor
 * @param mass_matrix_factor
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param bem_values_gpu
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_map_from_local_to_full_dof_indices
 * @param ky_map_from_local_to_full_dof_indices
 * @param kx_dof_i2e_numbering
 * @param ky_dof_i2e_numbering
 * @param mappings
 * @param material_id_to_mapping_index
 * @param normal_detector
 * @param mass_matrix_scratch_data
 * @param scratch_data
 * @param scratch_data_gpu
 * @param copy_data
 * @param enable_build_symmetric_hmat
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
fill_hmatrix_leaf_node_with_aca_plus(
  HMatrix<spacedim, RangeNumberType> *leaf_mat,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
    &aca_config,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                          &kernel,
  const DeviceNumberType<KernelNumberType> kernel_factor,
  const typename numbers::NumberTraits<RangeNumberType>::real_type
                                          mass_matrix_factor,
  const DoFToCellTopology<dim, spacedim> &kx_dof_to_cell_topo,
  const DoFToCellTopology<dim, spacedim> &ky_dof_to_cell_topo,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const DoFHandler<dim, spacedim>                               &kx_dof_handler,
  const DoFHandler<dim, spacedim>                               &ky_dof_handler,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                                                  &material_id_to_mapping_index,
  const SurfaceNormalDetector                     &normal_detector,
  CellWiseScratchDataForMassMatrix<dim, spacedim> &mass_matrix_scratch_data,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  HierBEM::CUDAWrappers::CUDAPairCellWiseScratchData<
    dim,
    spacedim,
    DeviceNumberType<KernelNumberType>>                    &scratch_data_gpu,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data,
  const bool enable_build_symmetric_hmat = false)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

#if ENABLE_NVTX == 1
  HierBEM::CUDAWrappers::NVTXRange nvtx_range(
    "fill_hmatrix_leaf_node_with_aca_plus with mass matrix");
#endif

  const std::array<types::global_dof_index, 2> *row_index_range =
    leaf_mat->get_row_index_range();
  const std::array<types::global_dof_index, 2> *col_index_range =
    leaf_mat->get_col_index_range();

  types::global_dof_index i_global_dof_index;
  types::global_dof_index j_global_dof_index;

  switch (leaf_mat->get_type())
    {
        case FullMatrixType: {
          LAPACKFullMatrixExt<RangeNumberType> *fullmat =
            leaf_mat->get_fullmatrix();

          if (enable_build_symmetric_hmat && kernel.is_symmetric())
            {
              /**
               * When the flag @p enable_build_symmetric_hmat is true and the
               * kernel function is symmetric, try to build a symmetric
               * \hmatrix. Otherwise, the whole full matrix will be built.
               */
              switch (leaf_mat->get_block_type())
                {
                    case HMatrixSupport::BlockType::diagonal_block: {
                      /**
                       * A diagonal \hmatrix block as well as its associated
                       * full matrix should be symmetric.
                       */
                      Assert(leaf_mat->get_property() ==
                               HMatrixSupport::Property::symmetric,
                             ExcInvalidHMatrixProperty(
                               leaf_mat->get_property()));
                      Assert(fullmat->get_property() ==
                               LAPACKSupport::Property::symmetric,
                             ExcInvalidLAPACKFullMatrixProperty(
                               fullmat->get_property()));

                      /**
                       * Only evaluate the diagonal and lower triangular
                       * elements in the full matrix.
                       */
                      for (size_t i = 0; i < fullmat->m(); i++)
                        {
                          i_global_dof_index =
                            (kx_map_from_local_to_full_dof_indices == nullptr) ?
                              kx_dof_i2e_numbering[(*row_index_range)[0] + i] :
                              kx_map_from_local_to_full_dof_indices->at(
                                kx_dof_i2e_numbering[(*row_index_range)[0] +
                                                     i]);

                          for (size_t j = 0; j <= i; j++)
                            {
                              j_global_dof_index =
                                (ky_map_from_local_to_full_dof_indices ==
                                 nullptr) ?
                                  ky_dof_i2e_numbering[(*col_index_range)[0] +
                                                       j] :
                                  ky_map_from_local_to_full_dof_indices->at(
                                    ky_dof_i2e_numbering[(*col_index_range)[0] +
                                                         j]);

                              (*fullmat)(i, j) =
                                sauter_quadrature_on_one_pair_of_dofs(
                                  kernel,
                                  kernel_factor,
                                  mass_matrix_factor,
                                  i_global_dof_index,
                                  j_global_dof_index,
                                  kx_dof_to_cell_topo.topology,
                                  ky_dof_to_cell_topo.topology,
                                  bem_values_gpu,
                                  mappings,
                                  material_id_to_mapping_index,
                                  normal_detector,
                                  mass_matrix_scratch_data,
                                  scratch_data,
                                  scratch_data_gpu,
                                  copy_data);
                            }
                        }

                      break;
                    }
                    case HMatrixSupport::BlockType::upper_triangular_block: {
                      /**
                       * Do not build \hmatrix block belonging to the upper
                       * triangular part.
                       */

                      break;
                    }
                    case HMatrixSupport::BlockType::lower_triangular_block: {
                      /**
                       * When the current \hmatrix block belongs to the
                       * lower triangular part, evaluate all of its elements
                       * as usual.
                       */
                      for (size_t i = 0; i < fullmat->m(); i++)
                        {
                          i_global_dof_index =
                            (kx_map_from_local_to_full_dof_indices == nullptr) ?
                              kx_dof_i2e_numbering[(*row_index_range)[0] + i] :
                              kx_map_from_local_to_full_dof_indices->at(
                                kx_dof_i2e_numbering[(*row_index_range)[0] +
                                                     i]);

                          for (size_t j = 0; j < fullmat->n(); j++)
                            {
                              j_global_dof_index =
                                (ky_map_from_local_to_full_dof_indices ==
                                 nullptr) ?
                                  ky_dof_i2e_numbering[(*col_index_range)[0] +
                                                       j] :
                                  ky_map_from_local_to_full_dof_indices->at(
                                    ky_dof_i2e_numbering[(*col_index_range)[0] +
                                                         j]);

                              (*fullmat)(i, j) =
                                sauter_quadrature_on_one_pair_of_dofs(
                                  kernel,
                                  kernel_factor,
                                  mass_matrix_factor,
                                  i_global_dof_index,
                                  j_global_dof_index,
                                  kx_dof_to_cell_topo.topology,
                                  ky_dof_to_cell_topo.topology,
                                  bem_values_gpu,
                                  mappings,
                                  material_id_to_mapping_index,
                                  normal_detector,
                                  mass_matrix_scratch_data,
                                  scratch_data,
                                  scratch_data_gpu,
                                  copy_data);
                            }
                        }

                      break;
                    }
                    case HMatrixSupport::BlockType::undefined_block: {
                      Assert(false,
                             ExcInvalidHMatrixBlockType(
                               leaf_mat->get_block_type()));

                      break;
                    }
                }
            }
          else
            {
              for (size_t i = 0; i < fullmat->m(); i++)
                {
                  i_global_dof_index =
                    (kx_map_from_local_to_full_dof_indices == nullptr) ?
                      kx_dof_i2e_numbering[(*row_index_range)[0] + i] :
                      kx_map_from_local_to_full_dof_indices->at(
                        kx_dof_i2e_numbering[(*row_index_range)[0] + i]);

                  for (size_t j = 0; j < fullmat->n(); j++)
                    {
                      j_global_dof_index =
                        (ky_map_from_local_to_full_dof_indices == nullptr) ?
                          ky_dof_i2e_numbering[(*col_index_range)[0] + j] :
                          ky_map_from_local_to_full_dof_indices->at(
                            ky_dof_i2e_numbering[(*col_index_range)[0] + j]);

                      (*fullmat)(i, j) = sauter_quadrature_on_one_pair_of_dofs(
                        kernel,
                        kernel_factor,
                        mass_matrix_factor,
                        i_global_dof_index,
                        j_global_dof_index,
                        kx_dof_to_cell_topo.topology,
                        ky_dof_to_cell_topo.topology,
                        bem_values_gpu,
                        mappings,
                        material_id_to_mapping_index,
                        normal_detector,
                        mass_matrix_scratch_data,
                        scratch_data,
                        scratch_data_gpu,
                        copy_data);
                    }
                }
            }

          break;
        }
        case RkMatrixType: {
          RkMatrix<RangeNumberType> *rkmat = leaf_mat->get_rkmatrix();

          if (enable_build_symmetric_hmat && kernel.is_symmetric())
            {
              switch (leaf_mat->get_block_type())
                {
                    case HMatrixSupport::BlockType::lower_triangular_block: {
                      /**
                       * Build the \hmatrix block when it belongs to the
                       * lower triangular part using ACA+.
                       */
                      aca_plus_parallel_sauter_quad_for_vector_entry(
                        (*rkmat),
                        aca_config,
                        kernel,
                        kernel_factor,
                        *row_index_range,
                        *col_index_range,
                        kx_dof_to_cell_topo,
                        ky_dof_to_cell_topo,
                        bem_values_gpu,
                        kx_map_from_local_to_full_dof_indices,
                        ky_map_from_local_to_full_dof_indices,
                        kx_dof_i2e_numbering,
                        ky_dof_i2e_numbering,
                        mappings,
                        material_id_to_mapping_index,
                        normal_detector,
                        scratch_data,
                        scratch_data_gpu,
                        copy_data);

                      break;
                    }
                    case HMatrixSupport::BlockType::upper_triangular_block: {
                      /**
                       * Do not build \hmatrix block belonging to the upper
                       * triangular part.
                       */

                      break;
                    }
                  case HMatrixSupport::BlockType::diagonal_block:
                    /**
                     * An rank-k matrix cannot belong to the diagonal part.
                     */
                    case HMatrixSupport::BlockType::undefined_block: {
                      Assert(false,
                             ExcInvalidHMatrixBlockType(
                               leaf_mat->get_block_type()));

                      break;
                    }
                }
            }
          else
            {
              aca_plus_parallel_sauter_quad_for_vector_entry(
                (*rkmat),
                aca_config,
                kernel,
                kernel_factor,
                *row_index_range,
                *col_index_range,
                kx_dof_to_cell_topo,
                ky_dof_to_cell_topo,
                bem_values_gpu,
                kx_map_from_local_to_full_dof_indices,
                ky_map_from_local_to_full_dof_indices,
                kx_dof_i2e_numbering,
                ky_dof_i2e_numbering,
                mappings,
                material_id_to_mapping_index,
                normal_detector,
                scratch_data,
                scratch_data_gpu,
                copy_data);
            }

          break;
        }
        default: {
          Assert(false, ExcInvalidHMatrixType(leaf_mat->get_type()));
          break;
        }
    }
}


template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
fill_far_field_hmatrix_leaf_node_with_aca_plus(
  HMatrix<spacedim, RangeNumberType> *leaf_mat,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
    &aca_config,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                          &kernel,
  const DeviceNumberType<KernelNumberType> kernel_factor,
  const DoFToCellTopology<dim, spacedim>  &kx_dof_to_cell_topo,
  const DoFToCellTopology<dim, spacedim>  &ky_dof_to_cell_topo,
  const BEMValues<dim,
                  spacedim,
                  typename numbers::NumberTraits<RangeNumberType>::real_type>
    &bem_values,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data,
  const bool enable_build_symmetric_hmat = false)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

#if ENABLE_NVTX == 1
  HierBEM::CUDAWrappers::NVTXRange nvtx_range(
    "fill_far_field_hmatrix_leaf_node_with_aca_plus");
#endif

  /**
   * @internal Row and column index ranges in the internal DoF numbering.
   */
  const std::array<types::global_dof_index, 2> *row_index_range =
    leaf_mat->get_row_index_range();
  const std::array<types::global_dof_index, 2> *col_index_range =
    leaf_mat->get_col_index_range();

  switch (leaf_mat->get_type())
    {
        case FullMatrixType: {
          Assert(false, ExcInvalidHMatrixType(FullMatrixType));

          break;
        }
        case RkMatrixType: {
          /**
           * When the \hmatrix block type is rank-k matrix, when the top
           * level \hmatrix is symmetric and the flag
           * @p enable_build_symmetric_hmat is true, only those matrix blocks
           * belong to the lower triangular part will be computed.
           * Otherwise, the rank-k matrix block will always be computed.
           * ACA+ will be used for building the rank-k matrix.
           */
          RkMatrix<RangeNumberType> *rkmat = leaf_mat->get_rkmatrix();

          if (enable_build_symmetric_hmat && kernel.is_symmetric())
            {
              switch (leaf_mat->get_block_type())
                {
                    case HMatrixSupport::BlockType::lower_triangular_block: {
                      /**
                       * Build the \hmatrix block when it belongs to the
                       * lower triangular part using ACA+.
                       */
                      aca_plus_parallel_sauter_quad_for_whole_vector(
                        (*rkmat),
                        aca_config,
                        kernel,
                        kernel_factor,
                        *row_index_range,
                        *col_index_range,
                        kx_dof_to_cell_topo,
                        ky_dof_to_cell_topo,
                        bem_values,
                        bem_values_gpu,
                        kx_map_from_local_to_full_dof_indices,
                        ky_map_from_local_to_full_dof_indices,
                        kx_dof_i2e_numbering,
                        ky_dof_i2e_numbering,
                        mappings,
                        material_id_to_mapping_index,
                        normal_detector,
                        scratch_data,
                        copy_data);

                      break;
                    }
                    case HMatrixSupport::BlockType::upper_triangular_block: {
                      /**
                       * Do not build \hmatrix block belonging to the upper
                       * triangular part.
                       */

                      break;
                    }
                    case HMatrixSupport::BlockType::diagonal_block: {
                      /**
                       * An rank-k matrix cannot belong to the diagonal part.
                       */
                      Assert(false,
                             ExcInvalidHMatrixBlockType(
                               leaf_mat->get_block_type()));

                      break;
                    }
                    case HMatrixSupport::BlockType::undefined_block: {
                      Assert(false,
                             ExcInvalidHMatrixBlockType(
                               leaf_mat->get_block_type()));

                      break;
                    }
                }
            }
          else
            {
              aca_plus_parallel_sauter_quad_for_whole_vector(
                (*rkmat),
                aca_config,
                kernel,
                kernel_factor,
                (*row_index_range),
                (*col_index_range),
                kx_dof_to_cell_topo,
                ky_dof_to_cell_topo,
                bem_values,
                bem_values_gpu,
                kx_map_from_local_to_full_dof_indices,
                ky_map_from_local_to_full_dof_indices,
                kx_dof_i2e_numbering,
                ky_dof_i2e_numbering,
                mappings,
                material_id_to_mapping_index,
                normal_detector,
                scratch_data,
                copy_data);
            }

          break;
        }
        default: {
          Assert(false, ExcInvalidHMatrixType(leaf_mat->get_type()));
          break;
        }
    }
}


template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
fill_far_field_hmatrix_leaf_node_with_aca_plus(
  HMatrix<spacedim, RangeNumberType> *leaf_mat,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
    &aca_config,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                              &kernel,
  const DeviceNumberType<KernelNumberType>     kernel_factor,
  const std::vector<Vector<KernelNumberType>> &mass_vmult_weq,
  const KernelNumberType                       stabilization_factor,
  const DoFToCellTopology<dim, spacedim>      &kx_dof_to_cell_topo,
  const DoFToCellTopology<dim, spacedim>      &ky_dof_to_cell_topo,
  const BEMValues<dim,
                  spacedim,
                  typename numbers::NumberTraits<RangeNumberType>::real_type>
    &bem_values,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> &scratch_data,
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> &copy_data,
  const bool enable_build_symmetric_hmat = false)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

#if ENABLE_NVTX == 1
  HierBEM::CUDAWrappers::NVTXRange nvtx_range(
    "fill_far_field_hmatrix_leaf_node_with_aca_plus for hypersingular");
#endif

  const std::array<types::global_dof_index, 2> *row_index_range =
    leaf_mat->get_row_index_range();
  const std::array<types::global_dof_index, 2> *col_index_range =
    leaf_mat->get_col_index_range();

  switch (leaf_mat->get_type())
    {
        case FullMatrixType: {
          Assert(false, ExcInvalidHMatrixType(FullMatrixType));

          break;
        }
        case RkMatrixType: {
          /**
           * When the \hmatrix block type is rank-k matrix, when the top
           * level \hmatrix is symmetric and the flag
           * @p enable_build_symmetric_hmat is true, only those matrix blocks
           * belong to the lower triangular part will be computed.
           * Otherwise, the rank-k matrix block will always be computed.
           * ACA+ will be used for building the rank-k matrix.
           */
          RkMatrix<RangeNumberType> *rkmat = leaf_mat->get_rkmatrix();

          if (enable_build_symmetric_hmat && kernel.is_symmetric())
            {
              switch (leaf_mat->get_block_type())
                {
                    case HMatrixSupport::BlockType::lower_triangular_block: {
                      /**
                       * Build the \hmatrix block when it belongs to the
                       * lower triangular part using ACA+.
                       */
                      aca_plus_parallel_sauter_quad_for_whole_vector(
                        (*rkmat),
                        aca_config,
                        kernel,
                        kernel_factor,
                        mass_vmult_weq,
                        stabilization_factor,
                        *row_index_range,
                        *col_index_range,
                        kx_dof_to_cell_topo,
                        ky_dof_to_cell_topo,
                        bem_values,
                        bem_values_gpu,
                        kx_map_from_local_to_full_dof_indices,
                        ky_map_from_local_to_full_dof_indices,
                        kx_dof_i2e_numbering,
                        ky_dof_i2e_numbering,
                        mappings,
                        material_id_to_mapping_index,
                        normal_detector,
                        scratch_data,
                        copy_data);

                      break;
                    }
                    case HMatrixSupport::BlockType::upper_triangular_block: {
                      /**
                       * Do not build \hmatrix block belonging to the upper
                       * triangular part.
                       */

                      break;
                    }
                  case HMatrixSupport::BlockType::diagonal_block:
                    /**
                     * An rank-k matrix cannot belong to the diagonal part.
                     */
                    case HMatrixSupport::BlockType::undefined_block: {
                      Assert(false,
                             ExcInvalidHMatrixBlockType(
                               leaf_mat->get_block_type()));

                      break;
                    }
                }
            }
          else
            {
              aca_plus_parallel_sauter_quad_for_whole_vector(
                (*rkmat),
                aca_config,
                kernel,
                kernel_factor,
                mass_vmult_weq,
                stabilization_factor,
                (*row_index_range),
                (*col_index_range),
                kx_dof_to_cell_topo,
                ky_dof_to_cell_topo,
                bem_values,
                bem_values_gpu,
                kx_map_from_local_to_full_dof_indices,
                ky_map_from_local_to_full_dof_indices,
                kx_dof_i2e_numbering,
                ky_dof_i2e_numbering,
                mappings,
                material_id_to_mapping_index,
                normal_detector,
                scratch_data,
                copy_data);
            }

          break;
        }
        default: {
          Assert(false, ExcInvalidHMatrixType(leaf_mat->get_type()));
          break;
        }
    }
}


/**
 * Fill the leaf nodes in a subrange of an \hmatrix using ACA+.
 *
 * \mynote{This function is to be used for TBB parallelization.}
 *
 * @param range
 * @param aca_config
 * @param kernel
 * @param kernel_factor
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param bem_values
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_mapping
 * @param ky_mapping
 * @param enable_build_symmetric_hmat Flag indicating whether symmetric
 * \hmatrix will be built when the kernel function is symmetric.
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
fill_far_field_hmatrix_leaf_node_subrange_with_aca_plus(
  const tbb::blocked_range<
    typename std::vector<HMatrix<spacedim, RangeNumberType> *>::iterator>
    &range,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
    &aca_config,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                          &kernel,
  const DeviceNumberType<KernelNumberType> kernel_factor,
  const DoFToCellTopology<dim, spacedim>  &kx_dof_to_cell_topo,
  const DoFToCellTopology<dim, spacedim>  &ky_dof_to_cell_topo,
  const BEMValues<dim,
                  spacedim,
                  typename numbers::NumberTraits<RangeNumberType>::real_type>
    &bem_values,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const DoFHandler<dim, spacedim>                               &kx_dof_handler,
  const DoFHandler<dim, spacedim>                               &ky_dof_handler,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  const bool                   enable_build_symmetric_hmat = false)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  const std::thread::id current_thread_id = std::this_thread::get_id();
  deallog << "WorkStream " << current_thread_id << " starts..." << std::endl;

  /**
   * Define @p PairCellWiseScratchData and @p PairCellWisePerTaskData which
   * are local to the current working thread. This is mandatory because
   * each current working thread should have its own copy of these data.
   */
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> scratch_data(
    current_thread_id,
    kx_dof_handler.get_fe(),
    ky_dof_handler.get_fe(),
    mappings,
    bem_values);
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> copy_data(
    kx_dof_handler.get_fe(), ky_dof_handler.get_fe());

  for (typename std::vector<HMatrix<spacedim, RangeNumberType> *>::iterator
         iter = range.begin();
       iter != range.end();
       iter++)
    {
      fill_far_field_hmatrix_leaf_node_with_aca_plus(
        (*iter),
        aca_config,
        kernel,
        kernel_factor,
        kx_dof_to_cell_topo,
        ky_dof_to_cell_topo,
        bem_values,
        bem_values_gpu,
        kx_map_from_local_to_full_dof_indices,
        ky_map_from_local_to_full_dof_indices,
        kx_dof_i2e_numbering,
        ky_dof_i2e_numbering,
        mappings,
        material_id_to_mapping_index,
        normal_detector,
        scratch_data,
        copy_data,
        enable_build_symmetric_hmat);
    }

  /**
   * Release pair cell wise scratch and copy data.
   */
  scratch_data.release();
  copy_data.release();

  deallog << "WorkStream " << current_thread_id << " exits..." << std::endl;
}


/**
 * Fill the leaf nodes in a subrange of an \hmatrix using ACA+.
 *
 * \mynote{1. This function is to be used for TBB parallelization.
 * 2. This version is especially for assembling the regularized
 * hyper-singular matrix with the stabilization term.}
 *
 * @param range
 * @param aca_config
 * @param kernel
 * @param kernel_factor
 * @param mass_vmult_weq
 * @param stabilization_factor
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param bem_values
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_dof_i2e_numbering
 * @param ky_dof_i2e_numbering
 * @param kx_mapping
 * @param ky_mapping
 * @param enable_build_symmetric_hmat
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
fill_far_field_hmatrix_leaf_node_subrange_with_aca_plus(
  const tbb::blocked_range<
    typename std::vector<HMatrix<spacedim, RangeNumberType> *>::iterator>
    &range,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
    &aca_config,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                              &kernel,
  const DeviceNumberType<KernelNumberType>     kernel_factor,
  const std::vector<Vector<KernelNumberType>> &mass_vmult_weq,
  const KernelNumberType                       stabilization_factor,
  const DoFToCellTopology<dim, spacedim>      &kx_dof_to_cell_topo,
  const DoFToCellTopology<dim, spacedim>      &ky_dof_to_cell_topo,
  const BEMValues<dim,
                  spacedim,
                  typename numbers::NumberTraits<RangeNumberType>::real_type>
    &bem_values,
  const HierBEM::CUDAWrappers::CUDABEMValues<
    dim,
    spacedim,
    typename numbers::NumberTraits<RangeNumberType>::real_type> &bem_values_gpu,
  const DoFHandler<dim, spacedim>                               &kx_dof_handler,
  const DoFHandler<dim, spacedim>                               &ky_dof_handler,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  const bool                   enable_build_symmetric_hmat = false)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  const std::thread::id current_thread_id = std::this_thread::get_id();
  deallog << "WorkStream " << current_thread_id << " starts..." << std::endl;

  /**
   * Define @p PairCellWiseScratchData and @p PairCellWisePerTaskData which
   * are local to the current working thread. This is mandatory because
   * each current working thread should have its own copy of these data.
   */
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> scratch_data(
    current_thread_id,
    kx_dof_handler.get_fe(),
    ky_dof_handler.get_fe(),
    mappings,
    bem_values);
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> copy_data(
    kx_dof_handler.get_fe(), ky_dof_handler.get_fe());

  for (typename std::vector<HMatrix<spacedim, RangeNumberType> *>::iterator
         iter = range.begin();
       iter != range.end();
       iter++)
    {
      fill_far_field_hmatrix_leaf_node_with_aca_plus(
        (*iter),
        aca_config,
        kernel,
        kernel_factor,
        mass_vmult_weq,
        stabilization_factor,
        kx_dof_to_cell_topo,
        ky_dof_to_cell_topo,
        bem_values,
        bem_values_gpu,
        kx_map_from_local_to_full_dof_indices,
        ky_map_from_local_to_full_dof_indices,
        kx_dof_i2e_numbering,
        ky_dof_i2e_numbering,
        mappings,
        material_id_to_mapping_index,
        normal_detector,
        scratch_data,
        copy_data,
        enable_build_symmetric_hmat);
    }

  /**
   * Release pair cell wise scratch and copy data.
   */
  scratch_data.release();
  copy_data.release();

  deallog << "WorkStream " << current_thread_id << " exits..." << std::endl;
}


/**
 * Add the stabilization matrix for the bilinear form of the hyper-singular
 * kernel to the range of near field matrices. The stabilization matrix is
 * \f$\alpha a a^T\f$, where \f$a = M w_{\rm eq}\f$ as a column vector is the
 * multiplication of FEM mass matrix and the natural density.
 *
 * @tparam spacedim
 * @tparam RangeNumberType
 * @param range
 * @param mass_vmult_weq
 * @param stabilization_factor
 * @param enable_build_symmetric_hmat
 */
template <int spacedim, typename RangeNumberType, typename KernelNumberType>
void
stabilize_near_field_hmatrices_for_hypersingular_kernel(
  const tbb::blocked_range<
    typename std::vector<HMatrix<spacedim, RangeNumberType> *>::iterator>
                                              &range,
  const std::vector<Vector<KernelNumberType>> &mass_vmult_weq,
  const KernelNumberType                       stabilization_factor,
  const bool enable_build_symmetric_hmat = true)
{
  for (typename std::vector<HMatrix<spacedim, RangeNumberType> *>::iterator
         iter = range.begin();
       iter != range.end();
       iter++)
    {
      HMatrix<spacedim, RangeNumberType> *leaf_mat = (*iter);
      Assert(leaf_mat->get_type() == HMatrixType::FullMatrixType,
             ExcInternalError());

      const std::array<types::global_dof_index, 2> *row_index_range =
        leaf_mat->get_row_index_range();
      const std::array<types::global_dof_index, 2> *col_index_range =
        leaf_mat->get_col_index_range();

      LAPACKFullMatrixExt<RangeNumberType> *fullmat =
        leaf_mat->get_fullmatrix();

      if (enable_build_symmetric_hmat)
        {
          /**
           * @internal When the leaf \hmatrix node is symmetric, different
           * operations will be adopted for different block types.
           */
          switch (leaf_mat->get_block_type())
            {
                case HMatrixSupport::BlockType::diagonal_block: {
                  /**
                   * @internal Only evaluate the diagonal and lower triangular
                   * elements in the full matrix.
                   */
                  Assert(leaf_mat->get_property() ==
                           HMatrixSupport::Property::symmetric,
                         ExcInvalidHMatrixProperty(leaf_mat->get_property()));
                  Assert(fullmat->get_property() ==
                           LAPACKSupport::Property::symmetric,
                         ExcInvalidLAPACKFullMatrixProperty(
                           fullmat->get_property()));

                  for (size_t i = 0; i < fullmat->m(); i++)
                    {
                      for (size_t j = 0; j <= i; j++)
                        {
                          /**
                           * @internal The vector \f$a = M w_{\rm eq}\f$ is
                           * accessed using the global DoF indices in the
                           * internal numbering.
                           */
                          for (const auto &vec : mass_vmult_weq)
                            (*fullmat)(i, j) += stabilization_factor *
                                                vec((*row_index_range)[0] + i) *
                                                vec((*col_index_range)[0] + j);
                        }
                    }

                  break;
                }
                case HMatrixSupport::BlockType::upper_triangular_block: {
                  /**
                   * @internal Do not build \hmatrix block belonging to the
                   * upper triangular part.
                   */

                  break;
                }
                case HMatrixSupport::BlockType::lower_triangular_block: {
                  /**
                   * @internal When the current \hmatrix block belongs to the
                   * lower triangular part, evaluate all of its elements
                   * as usual.
                   */
                  for (size_t i = 0; i < fullmat->m(); i++)
                    {
                      for (size_t j = 0; j < fullmat->n(); j++)
                        {
                          for (const auto &vec : mass_vmult_weq)
                            (*fullmat)(i, j) += stabilization_factor *
                                                vec((*row_index_range)[0] + i) *
                                                vec((*col_index_range)[0] + j);
                        }
                    }

                  break;
                }
                case HMatrixSupport::BlockType::undefined_block: {
                  Assert(false,
                         ExcInvalidHMatrixBlockType(
                           leaf_mat->get_block_type()));

                  break;
                }
            }
        }
      else
        {
          /**
           * @internal All matrix entries should be computed without
           * consideration of the symmetry of the hypersingular kernel.
           */
          for (size_t i = 0; i < fullmat->m(); i++)
            {
              for (size_t j = 0; j < fullmat->n(); j++)
                {
                  for (const auto &vec : mass_vmult_weq)
                    (*fullmat)(i, j) += stabilization_factor *
                                        vec((*row_index_range)[0] + i) *
                                        vec((*col_index_range)[0] + j);
                }
            }
        }
    }
}


/**
 * @brief Fill the leaf set of the \hmatrix using ACA+, where the hierarchical
 * structure of the \hmatrix has been built with respect to a block cluster
 * tree and the memory for the matrices in the leaf set has been allocated.
 *
 * For the near field matrices in the leaf set, full matrices will be built
 * whose elements will be obtained from the evaluation of the double
 * integral in Galerkin-BEM. For the far field admissible matrices in the
 * leaf set, rank-k matrices will be built using ACA+.
 *
 * \mynote{This version processes each \hmatnode in the leaf set
 * one-by-one without partitioning the leaf set using TBB.}
 *
 * @tparam dim
 * @tparam spacedim
 * @tparam KernelFunctionType
 * @tparam RangeNumberType
 * @tparam KernelNumberType
 * @tparam SurfaceNormalDetector
 * @param hmat
 * @param aca_config
 * @param kernel
 * @param kernel_factor
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param sauter_quad_rule
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_map_from_local_to_full_dof_indices
 * @param ky_map_from_local_to_full_dof_indices
 * @param kx_dof_i2e_numbering
 * @param ky_dof_i2e_numbering
 * @param mappings
 * @param material_id_to_mapping_index
 * @param normal_detector
 * @param enable_build_symmetric_hmat
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
fill_hmatrix_with_aca_plus_serial(
  HMatrix<spacedim, RangeNumberType> &hmat,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
                                                       &aca_config,
  const KernelFunctionType<spacedim, KernelNumberType> &kernel,
  const KernelNumberType                                kernel_factor,
  const DoFToCellTopology<dim, spacedim>               &kx_dof_to_cell_topo,
  const DoFToCellTopology<dim, spacedim>               &ky_dof_to_cell_topo,
  const SauterQuadratureRule<dim>                      &sauter_quad_rule,
  const DoFHandler<dim, spacedim>                      &kx_dof_handler,
  const DoFHandler<dim, spacedim>                      &ky_dof_handler,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  const bool                   enable_build_symmetric_hmat = false)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  /**
   * Precalculate data tables for shape values at quadrature points.
   *
   * \mynote{Precalculate shape function values and their gradient values
   * at each quadrature point. N.B.
   * 1. The data tables for shape function values and their gradient
   * values should be calculated for both function space on \f$K_x\f$ and
   * function space on \f$K_y\f$.
   * 2. Being different from the integral in FEM, the integral in BEM
   * handled by Sauter's quadrature rule has multiple parts of \f$k_3\f$
   * (except the regular cell neighboring type), each of which should be
   * evaluated at a different set of quadrature points in the unit cell
   * after coordinate transformation from the parametric space. Therefore,
   * a dimension with respect to \f$k_3\f$ term index should be added to
   * the data table compared to the usual FEValues and this brings about
   * the class @p BEMValues.}
   */
  BEMValues<dim, spacedim, real_type> bem_values(
    kx_dof_handler.get_fe(),
    ky_dof_handler.get_fe(),
    mappings,
    sauter_quad_rule.quad_rule_for_same_panel,
    sauter_quad_rule.quad_rule_for_common_edge,
    sauter_quad_rule.quad_rule_for_common_vertex,
    sauter_quad_rule.quad_rule_for_regular);

  bem_values.fill_shape_function_value_tables();

  /**
   * Copy the precalculated BEM values to the GPU device.
   */
  HierBEM::CUDAWrappers::CUDABEMValues<dim, spacedim, real_type> bem_values_gpu;
  bem_values_gpu.allocate_and_assign_from_host(bem_values);

  /**
   * Define @p PairCellWiseScratchData and @p PairCellWisePerTaskData which
   * are local to the current working thread. This is mandatory because
   * each current working thread should have its own copy of these data.
   */
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> scratch_data(
    kx_dof_handler.get_fe(), ky_dof_handler.get_fe(), mappings, bem_values);
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> copy_data(
    kx_dof_handler.get_fe(), ky_dof_handler.get_fe());

  /**
   * Create pair cell wise scratch data and task data on GPU device.
   */
  HierBEM::CUDAWrappers::
    CUDAPairCellWiseScratchData<dim, spacedim, KernelNumberType>
      scratch_data_gpu;
  scratch_data_gpu.allocate(scratch_data);

  for (HMatrix<spacedim, RangeNumberType> *leaf_mat : hmat.get_leaf_set())
    {
      fill_hmatrix_leaf_node_with_aca_plus(
        leaf_mat,
        aca_config,
        kernel,
        kernel_factor,
        kx_dof_to_cell_topo,
        ky_dof_to_cell_topo,
        bem_values_gpu,
        kx_dof_handler,
        ky_dof_handler,
        kx_map_from_local_to_full_dof_indices,
        ky_map_from_local_to_full_dof_indices,
        kx_dof_i2e_numbering,
        ky_dof_i2e_numbering,
        mappings,
        material_id_to_mapping_index,
        normal_detector,
        scratch_data,
        scratch_data_gpu,
        copy_data,
        enable_build_symmetric_hmat);
    }

  /**
   * Release BEM values on the GPU device.
   */
  bem_values_gpu.release();

  /**
   * Release pair cell wise scratch and copy data on the GPU device.
   */
  scratch_data.release();
  scratch_data_gpu.release(scratch_data.cuda_stream_handle);
  copy_data.release();
}


/**
 * @brief Fill the leaf set of the \hmatrix using ACA+, where the hierarchical
 * structure of the \hmatrix has been built with respect to a block cluster
 * tree and the memory for the matrices in the leaf set has been allocated.
 *
 * For the near field matrices in the leaf set, full matrices will be built
 * whose elements will be obtained from the evaluation of the double
 * integral in Galerkin-BEM. For the far field admissible matrices in the
 * leaf set, rank-k matrices will be built using ACA+.
 *
 * \mynote{
 * 1. This version processes each \hmatnode in the leaf set
 * one-by-one without partitioning the leaf set using TBB.
 * 2. This version is especially for assembling the regularized
 * hyper-singular matrix appended with the stabilization term. The
 * stabilization term in the variational equation is
 *   \f[
 *   \alpha\langle \gamma_0^{\rm ext}u, \omega_{\rm eq} \rangle \cdot \langle
 * v, \omega_{\rm eq} \rangle_{\Gamma}. \f]
 *
 *   The stabilization term in the discretized form is
 *   \f[
 *   \alpha M [\omega_{\rm eq}] \cdot \left[ M [\omega_{\rm eq}] \right]^{\rm
 * T} \cdot [\gamma_0^{\rm ext}u], \f] which is actually an outer-product
 * representation. The argument
 *   @p mass_vmult_weq passed to this function is just the vector
 *   \f$M [\omega_{\rm eq}]\f$.}
 *
 * @tparam dim
 * @tparam spacedim
 * @tparam KernelFunctionType
 * @tparam RangeNumberType
 * @tparam KernelNumberType
 * @tparam SurfaceNormalDetector
 * @param hmat
 * @param aca_config
 * @param kernel
 * @param kernel_factor
 * @param mass_vmult_weq
 * @param stabilization_factor
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param sauter_quad_rule
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_map_from_local_to_full_dof_indices
 * @param ky_map_from_local_to_full_dof_indices
 * @param kx_dof_i2e_numbering
 * @param ky_dof_i2e_numbering
 * @param mappings
 * @param material_id_to_mapping_index
 * @param normal_detector
 * @param enable_build_symmetric_hmat
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
fill_hmatrix_with_aca_plus_serial(
  HMatrix<spacedim, RangeNumberType> &hmat,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
                                                       &aca_config,
  const KernelFunctionType<spacedim, KernelNumberType> &kernel,
  const KernelNumberType                                kernel_factor,
  const std::vector<Vector<KernelNumberType>>          &mass_vmult_weq,
  const KernelNumberType                                stabilization_factor,
  const DoFToCellTopology<dim, spacedim>               &kx_dof_to_cell_topo,
  const DoFToCellTopology<dim, spacedim>               &ky_dof_to_cell_topo,
  const SauterQuadratureRule<dim>                      &sauter_quad_rule,
  const DoFHandler<dim, spacedim>                      &kx_dof_handler,
  const DoFHandler<dim, spacedim>                      &ky_dof_handler,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  const bool                   enable_build_symmetric_hmat = false)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  /**
   * Precalculate data tables for shape values at quadrature points.
   *
   * \mynote{Precalculate shape function values and their gradient values
   * at each quadrature point. N.B.
   * 1. The data tables for shape function values and their gradient
   * values should be calculated for both function space on \f$K_x\f$ and
   * function space on \f$K_y\f$.
   * 2. Being different from the integral in FEM, the integral in BEM
   * handled by Sauter's quadrature rule has multiple parts of \f$k_3\f$
   * (except the regular cell neighboring type), each of which should be
   * evaluated at a different set of quadrature points in the unit cell
   * after coordinate transformation from the parametric space. Therefore,
   * a dimension with respect to \f$k_3\f$ term index should be added to
   * the data table compared to the usual FEValues and this brings about
   * the class @p BEMValues.}
   */
  BEMValues<dim, spacedim, real_type> bem_values(
    kx_dof_handler.get_fe(),
    ky_dof_handler.get_fe(),
    mappings,
    sauter_quad_rule.quad_rule_for_same_panel,
    sauter_quad_rule.quad_rule_for_common_edge,
    sauter_quad_rule.quad_rule_for_common_vertex,
    sauter_quad_rule.quad_rule_for_regular);

  bem_values.fill_shape_function_value_tables();

  /**
   * Copy the precalculated BEM values to the GPU device.
   */
  HierBEM::CUDAWrappers::CUDABEMValues<dim, spacedim, real_type> bem_values_gpu;
  bem_values_gpu.allocate_and_assign_from_host(bem_values);

  /**
   * Define @p PairCellWiseScratchData and @p PairCellWisePerTaskData which
   * are local to the current working thread. This is mandatory because
   * each current working thread should have its own copy of these data.
   */
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> scratch_data(
    kx_dof_handler.get_fe(), ky_dof_handler.get_fe(), mappings, bem_values);
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> copy_data(
    kx_dof_handler.get_fe(), ky_dof_handler.get_fe());

  /**
   * Create pair cell wise scratch data and task data on GPU device.
   */
  HierBEM::CUDAWrappers::
    CUDAPairCellWiseScratchData<dim, spacedim, KernelNumberType>
      scratch_data_gpu;
  scratch_data_gpu.allocate(scratch_data);

  for (HMatrix<spacedim, RangeNumberType> *leaf_mat : hmat.get_leaf_set())
    {
      fill_hmatrix_leaf_node_with_aca_plus(
        leaf_mat,
        aca_config,
        kernel,
        kernel_factor,
        mass_vmult_weq,
        stabilization_factor,
        kx_dof_to_cell_topo,
        ky_dof_to_cell_topo,
        bem_values_gpu,
        kx_dof_handler,
        ky_dof_handler,
        kx_map_from_local_to_full_dof_indices,
        ky_map_from_local_to_full_dof_indices,
        kx_dof_i2e_numbering,
        ky_dof_i2e_numbering,
        mappings,
        material_id_to_mapping_index,
        normal_detector,
        scratch_data,
        scratch_data_gpu,
        copy_data,
        enable_build_symmetric_hmat);
    }

  /**
   * Release BEM values on the GPU device.
   */
  bem_values_gpu.release();

  /**
   * Release pair cell wise scratch and copy data.
   */
  scratch_data.release();
  scratch_data_gpu.release(scratch_data.cuda_stream_handle);
  copy_data.release();
}


/**
 * @brief Fill the leaf set of the \hmatrix using ACA+, where the hierarchical
 * structure of the \hmatrix has been built with respect to a block cluster
 * tree and the memory for the matrices in the leaf set has been allocated.
 *
 * For the near field matrices in the leaf set, full matrices will be built
 * whose elements will be obtained from the evaluation of the double
 * integral in Galerkin-BEM. For the far field admissible matrices in the
 * leaf set, rank-k matrices will be built using ACA+.
 *
 * \mynote{1. This version processes each \hmatnode in the leaf set
 * one-by-one without partitioning the leaf set using TBB.
 * 2. The mass matrix scaled with a factor is appended to the near field leaf
 * node.}
 *
 * @tparam dim
 * @tparam spacedim
 * @tparam KernelFunctionType
 * @tparam RangeNumberType
 * @tparam KernelNumberType
 * @tparam SurfaceNormalDetector
 * @param hmat
 * @param aca_config
 * @param kernel
 * @param kernel_factor
 * @param mass_matrix_factor
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param sauter_quad_rule
 * @param mass_matrix_quadrature_formula
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_map_from_local_to_full_dof_indices
 * @param ky_map_from_local_to_full_dof_indices
 * @param kx_dof_i2e_numbering
 * @param ky_dof_i2e_numbering
 * @param mappings
 * @param material_id_to_mapping_index
 * @param normal_detector
 * @param enable_build_symmetric_hmat
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
fill_hmatrix_with_aca_plus_serial(
  HMatrix<spacedim, RangeNumberType> &hmat,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
                                                       &aca_config,
  const KernelFunctionType<spacedim, KernelNumberType> &kernel,
  const KernelNumberType                                kernel_factor,
  const typename numbers::NumberTraits<RangeNumberType>::real_type
                                          mass_matrix_factor,
  const DoFToCellTopology<dim, spacedim> &kx_dof_to_cell_topo,
  const DoFToCellTopology<dim, spacedim> &ky_dof_to_cell_topo,
  const SauterQuadratureRule<dim>        &sauter_quad_rule,
  const QGauss<dim>                      &mass_matrix_quadrature_formula,
  const DoFHandler<dim, spacedim>        &kx_dof_handler,
  const DoFHandler<dim, spacedim>        &ky_dof_handler,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  const bool                   enable_build_symmetric_hmat = false)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  /**
   * Precalculate data tables for shape values at quadrature points.
   *
   * \mynote{Precalculate shape function values and their gradient values
   * at each quadrature point. N.B.
   * 1. The data tables for shape function values and their gradient
   * values should be calculated for both function space on \f$K_x\f$ and
   * function space on \f$K_y\f$.
   * 2. Being different from the integral in FEM, the integral in BEM
   * handled by Sauter's quadrature rule has multiple parts of \f$k_3\f$
   * (except the regular cell neighboring type), each of which should be
   * evaluated at a different set of quadrature points in the unit cell
   * after coordinate transformation from the parametric space. Therefore,
   * a dimension with respect to \f$k_3\f$ term index should be added to
   * the data table compared to the usual FEValues and this brings about
   * the class @p BEMValues.}
   */
  BEMValues<dim, spacedim, real_type> bem_values(
    kx_dof_handler.get_fe(),
    ky_dof_handler.get_fe(),
    mappings,
    sauter_quad_rule.quad_rule_for_same_panel,
    sauter_quad_rule.quad_rule_for_common_edge,
    sauter_quad_rule.quad_rule_for_common_vertex,
    sauter_quad_rule.quad_rule_for_regular);

  bem_values.fill_shape_function_value_tables();

  /**
   * Copy the precalculated BEM values to the GPU device.
   */
  HierBEM::CUDAWrappers::CUDABEMValues<dim, spacedim, real_type> bem_values_gpu;
  bem_values_gpu.allocate_and_assign_from_host(bem_values);

  /**
   * Define @p CellWiseScratchDataForMassMatrix which is local to current
   * working thread.
   */
  CellWiseScratchDataForMassMatrix<dim, spacedim> mass_matrix_scratch_data(
    kx_dof_handler.get_fe(),
    ky_dof_handler.get_fe(),
    mass_matrix_quadrature_formula,
    update_values | update_JxW_values);

  /**
   * Define @p PairCellWiseScratchData and @p PairCellWisePerTaskData which
   * are local to the current working thread. This is mandatory because
   * each current working thread should have its own copy of these data.
   */
  PairCellWiseScratchData<dim, spacedim, KernelNumberType> scratch_data(
    kx_dof_handler.get_fe(), ky_dof_handler.get_fe(), mappings, bem_values);
  PairCellWisePerTaskData<dim, spacedim, KernelNumberType> copy_data(
    kx_dof_handler.get_fe(), ky_dof_handler.get_fe());

  /**
   * Create pair cell wise scratch data and task data on GPU device.
   */
  HierBEM::CUDAWrappers::
    CUDAPairCellWiseScratchData<dim, spacedim, KernelNumberType>
      scratch_data_gpu;
  scratch_data_gpu.allocate(scratch_data);

  for (HMatrix<spacedim, RangeNumberType> *leaf_mat : hmat.get_leaf_set())
    {
      fill_hmatrix_leaf_node_with_aca_plus(
        leaf_mat,
        aca_config,
        kernel,
        kernel_factor,
        mass_matrix_factor,
        kx_dof_to_cell_topo,
        ky_dof_to_cell_topo,
        bem_values_gpu,
        kx_dof_handler,
        ky_dof_handler,
        kx_map_from_local_to_full_dof_indices,
        ky_map_from_local_to_full_dof_indices,
        kx_dof_i2e_numbering,
        ky_dof_i2e_numbering,
        mappings,
        material_id_to_mapping_index,
        normal_detector,
        mass_matrix_scratch_data,
        scratch_data,
        scratch_data_gpu,
        copy_data,
        enable_build_symmetric_hmat);
    }

  /**
   * Release BEM values on the GPU device.
   */
  bem_values_gpu.release();

  /**
   * Release pair cell wise scratch and copy data.
   */
  scratch_data.release();
  scratch_data_gpu.release(scratch_data.cuda_stream_handle);
  copy_data.release();
}


/**
 * @brief Fill the leaf set of the \hmatrix using ACA+, where the hierarchical
 * structure of the \hmatrix has been built with respect to a block cluster
 * tree and the memory for the matrices in the leaf set has been allocated.
 *
 * For the near field matrices in the leaf set, full matrices will be built
 * whose elements will be obtained from the evaluation of the double
 * integral in Galerkin-BEM. For the far field admissible matrices in the
 * leaf set, rank-k matrices will be built using ACA+.
 *
 * \mynote{
 * 1. For the near field leaf set, GPU parallelization is realized in a
 * producer-consumer model. GPU 1D thread grid is distributed over each Sauter
 * quadrature task in the ring buffer.
 * 2. For the far field leaf set, GPU 2D thread grid is distributed over each
 * Sauter quadrature task in the X direction and each quadrature point in the
 * Y direction. The quadrature tasks collected in the buffer are used to build
 * a row or column vector.}
 *
 * @tparam dim
 * @tparam spacedim
 * @tparam KernelFunctionType
 * @tparam RangeNumberType
 * @tparam KernelNumberType
 * @tparam SurfaceNormalDetector
 * @param thread_num
 * @param hmat
 * @param aca_config
 * @param kernel
 * @param kernel_factor
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param sauter_quad_rule
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_map_from_local_to_full_dof_indices
 * @param ky_map_from_local_to_full_dof_indices
 * @param kx_dof_i2e_numbering
 * @param ky_dof_i2e_numbering
 * @param mappings
 * @param material_id_to_mapping_index
 * @param normal_detector
 * @param enable_build_symmetric_hmat
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
fill_hmatrix_with_aca_plus_smp(
  const unsigned int                  thread_num,
  HMatrix<spacedim, RangeNumberType> &hmat,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
    &aca_config,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                          &kernel,
  const DeviceNumberType<KernelNumberType> kernel_factor,
  const DoFToCellTopology<dim, spacedim>  &kx_dof_to_cell_topo,
  const DoFToCellTopology<dim, spacedim>  &ky_dof_to_cell_topo,
  const SauterQuadratureRule<dim>         &sauter_quad_rule,
  const DoFHandler<dim, spacedim>         &kx_dof_handler,
  const DoFHandler<dim, spacedim>         &ky_dof_handler,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  const bool                   enable_build_symmetric_hmat = false)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  LogStream::Prefix prefix_string("build_hmatrix_aca");
#if ENABLE_NVTX == 1
  HierBEM::CUDAWrappers::NVTXRange nvtx_range("build_hmatrix_aca");
#endif

  Timer timer;

  /**
   * Precalculate shape function values and their gradient values
   * at each quadrature point.
   *
   * 1. The data tables for shape function values and their gradient
   * values should be calculated for both function space on \f$K_x\f$ and
   * function space on \f$K_y\f$.
   * 2. Being different from the integral in FEM, the integral in BEM
   * handled by Sauter's quadrature rule has multiple parts of \f$k_3\f$
   * (except the regular cell neighboring type), each of which should be
   * evaluated at a different set of quadrature points in the unit cell
   * after coordinate transformation from the parametric space. Therefore,
   * a dimension with respect to \f$k_3\f$ term index should be added to
   * the data table compared to the usual FEValues and this brings about
   * the class @p BEMValues.}
   */
  BEMValues<dim, spacedim, real_type> bem_values(
    kx_dof_handler.get_fe(),
    ky_dof_handler.get_fe(),
    mappings,
    sauter_quad_rule.quad_rule_for_same_panel,
    sauter_quad_rule.quad_rule_for_common_edge,
    sauter_quad_rule.quad_rule_for_common_vertex,
    sauter_quad_rule.quad_rule_for_regular);

  bem_values.fill_shape_function_value_tables();

  /**
   * Copy the precalculated BEM values to the GPU device.
   */
  HierBEM::CUDAWrappers::CUDABEMValues<dim, spacedim, real_type> bem_values_gpu;
  bem_values_gpu.allocate_and_assign_from_host(bem_values);

  timer.stop();
  print_wall_time(deallog, timer, "compute BEM values");

  /**
   * @internal First stage: fill near field \hmatrix nodes using the
   * parallel producer-consumer model.
   */
  timer.start();

  const unsigned int block_size          = 256;
  const unsigned int block_num           = 8;
  const unsigned int batch_size          = block_size * block_num;
  const unsigned int capacity            = batch_size * 8 + 1;
  unsigned int       producer_thread_num = 4;

  HierBEM::CUDAWrappers::SauterQuadratureTaskRingBuffer<capacity,
                                                        dim,
                                                        spacedim,
                                                        RangeNumberType,
                                                        KernelNumberType>
    ring_buffer_for_same_panel;
  ring_buffer_for_same_panel.allocate(CellNeighboringType::SamePanel,
                                      batch_size,
                                      bem_values);
  HierBEM::CUDAWrappers::SauterQuadratureTaskRingBuffer<capacity,
                                                        dim,
                                                        spacedim,
                                                        RangeNumberType,
                                                        KernelNumberType>
    ring_buffer_for_common_edge;
  ring_buffer_for_common_edge.allocate(CellNeighboringType::CommonEdge,
                                       batch_size,
                                       bem_values);
  HierBEM::CUDAWrappers::SauterQuadratureTaskRingBuffer<capacity,
                                                        dim,
                                                        spacedim,
                                                        RangeNumberType,
                                                        KernelNumberType>
    ring_buffer_for_common_vertex;
  ring_buffer_for_common_vertex.allocate(CellNeighboringType::CommonVertex,
                                         batch_size,
                                         bem_values);
  HierBEM::CUDAWrappers::SauterQuadratureTaskRingBuffer<capacity,
                                                        dim,
                                                        spacedim,
                                                        RangeNumberType,
                                                        KernelNumberType>
    ring_buffer_for_regular;
  ring_buffer_for_regular.allocate(CellNeighboringType::Regular,
                                   batch_size,
                                   bem_values);

  std::mutex result_lock;

  std::vector<HMatrix<spacedim, RangeNumberType> *> &near_field_leaf_set =
    hmat.get_near_field_leaf_set();
  const unsigned int near_field_set_size = near_field_leaf_set.size();

  Assert(near_field_set_size > 0, ExcLowerRange(near_field_set_size, 1));

  if (near_field_set_size < producer_thread_num)
    {
      producer_thread_num = near_field_set_size;
    }

  std::vector<std::thread> producers;
  producers.reserve(producer_thread_num);

  const unsigned int number_of_hmat_nodes_per_thread =
    std::ceil(static_cast<double>(near_field_set_size) /
              static_cast<double>(producer_thread_num));

  /**
   * @internal Start the producer threads.
   */
  for (unsigned int i = 0; i < producer_thread_num; i++)
    {
      producers.emplace_back([&, i]() {
        HierBEM::CUDAWrappers::
          sauter_quadrature_for_near_field_matrix_entries_producer(
            near_field_leaf_set,
            i * number_of_hmat_nodes_per_thread,
            (i + 1) * number_of_hmat_nodes_per_thread > near_field_set_size ?
              near_field_set_size :
              (i + 1) * number_of_hmat_nodes_per_thread,
            ring_buffer_for_same_panel,
            ring_buffer_for_common_edge,
            ring_buffer_for_common_vertex,
            ring_buffer_for_regular,
            kx_dof_to_cell_topo.topology,
            ky_dof_to_cell_topo.topology,
            bem_values,
            kx_dof_handler,
            ky_dof_handler,
            kx_map_from_local_to_full_dof_indices,
            ky_map_from_local_to_full_dof_indices,
            kx_dof_i2e_numbering,
            ky_dof_i2e_numbering,
            mappings,
            material_id_to_mapping_index,
            normal_detector,
            kernel.is_symmetric(),
            enable_build_symmetric_hmat);
      });
    }

  /**
   * @internal Start the consumer threads.
   */
  std::vector<std::thread> consumers;
  const unsigned int       consumer_multiplicity = 1;
  consumers.reserve(4 * consumer_multiplicity);

  for (unsigned int m = 0; m < consumer_multiplicity; m++)
    {
      consumers.emplace_back([&]() {
        HierBEM::CUDAWrappers::
          sauter_quadrature_for_near_field_matrix_entries_consumer(
            kernel,
            kernel_factor,
            ring_buffer_for_same_panel,
            bem_values_gpu,
            result_lock,
            block_size);
      });

      consumers.emplace_back([&]() {
        HierBEM::CUDAWrappers::
          sauter_quadrature_for_near_field_matrix_entries_consumer(
            kernel,
            kernel_factor,
            ring_buffer_for_common_edge,
            bem_values_gpu,
            result_lock,
            block_size);
      });

      consumers.emplace_back([&]() {
        HierBEM::CUDAWrappers::
          sauter_quadrature_for_near_field_matrix_entries_consumer(
            kernel,
            kernel_factor,
            ring_buffer_for_common_vertex,
            bem_values_gpu,
            result_lock,
            block_size);
      });

      consumers.emplace_back([&]() {
        HierBEM::CUDAWrappers::
          sauter_quadrature_for_near_field_matrix_entries_consumer(
            kernel,
            kernel_factor,
            ring_buffer_for_regular,
            bem_values_gpu,
            result_lock,
            block_size);
      });
    }

  /**
   * @internal Wait for all producer and consumer threads to exit.
   */
  for (auto &producer : producers)
    producer.join();

  {
    std::lock_guard<std::mutex> lg(ring_buffer_for_same_panel.buffer_lock);
    ring_buffer_for_same_panel.if_all_near_field_hmat_entries_added = true;
  }
  ring_buffer_for_same_panel.batch_task_ready.notify_all();

  {
    std::lock_guard<std::mutex> lg(ring_buffer_for_common_edge.buffer_lock);
    ring_buffer_for_common_edge.if_all_near_field_hmat_entries_added = true;
  }
  ring_buffer_for_common_edge.batch_task_ready.notify_all();

  {
    std::lock_guard<std::mutex> lg(ring_buffer_for_common_vertex.buffer_lock);
    ring_buffer_for_common_vertex.if_all_near_field_hmat_entries_added = true;
  }
  ring_buffer_for_common_vertex.batch_task_ready.notify_all();

  {
    std::lock_guard<std::mutex> lg(ring_buffer_for_regular.buffer_lock);
    ring_buffer_for_regular.if_all_near_field_hmat_entries_added = true;
  }
  ring_buffer_for_regular.batch_task_ready.notify_all();

  for (auto &consumer : consumers)
    consumer.join();

  /**
   * @internal Release all ring buffers.
   */
  ring_buffer_for_same_panel.release();
  ring_buffer_for_common_edge.release();
  ring_buffer_for_common_vertex.release();
  ring_buffer_for_regular.release();

  timer.stop();
  print_wall_time(deallog, timer, "build near field H-matrix nodes");

  /**
   * @internal Second stage: fill far field \hmatrix nodes by applying the
   * parallelization only to applying Sauter quadrature.
   */
  timer.start();

  std::vector<HMatrix<spacedim, RangeNumberType> *> &far_field_leaf_set =
    hmat.get_far_field_leaf_set();

  if (far_field_leaf_set.size() > 0)
    {
#if ENABLE_NVTX == 1
      HierBEM::CUDAWrappers::NVTXRange nvtx_range(
        "build far field hmatrix nodes");
#endif

      /**
       * Estimate the grain size.
       */
      unsigned int grain_size = far_field_leaf_set.size() / thread_num;
      if (grain_size == 0)
        grain_size = 1;

      parallel::internal::parallel_for(
        far_field_leaf_set.begin(),
        far_field_leaf_set.end(),
        [&](const tbb::blocked_range<typename std::vector<
              HMatrix<spacedim, RangeNumberType> *>::iterator> &range) {
          fill_far_field_hmatrix_leaf_node_subrange_with_aca_plus<
            dim,
            spacedim,
            KernelFunctionType,
            RangeNumberType,
            KernelNumberType,
            SurfaceNormalDetector>(range,
                                   aca_config,
                                   kernel,
                                   kernel_factor,
                                   kx_dof_to_cell_topo,
                                   ky_dof_to_cell_topo,
                                   bem_values,
                                   bem_values_gpu,
                                   kx_dof_handler,
                                   ky_dof_handler,
                                   kx_map_from_local_to_full_dof_indices,
                                   ky_map_from_local_to_full_dof_indices,
                                   kx_dof_i2e_numbering,
                                   ky_dof_i2e_numbering,
                                   mappings,
                                   material_id_to_mapping_index,
                                   normal_detector,
                                   enable_build_symmetric_hmat);
        },
        grain_size);
    }

  timer.stop();
  print_wall_time(deallog, timer, "build far field H-matrix nodes");

  /**
   * Release BEM values on the GPU device.
   */
  bem_values_gpu.release();
}


/**
 * @brief Fill the leaf set of the \hmatrix using ACA+, where the hierarchical
 * structure of the \hmatrix has been built with respect to a block cluster
 * tree and the memory for the matrices in the leaf set has been allocated.
 *
 * For the near field matrices in the leaf set, full matrices will be built
 * whose elements will be obtained from the evaluation of the double
 * integral in Galerkin-BEM. For the far field admissible matrices in the
 * leaf set, rank-k matrices will be built using ACA+.
 *
 * This version is used for assembling the regularized hyper-singular matrix
 * with the stabilization term.
 *
 * \mynote{
 * 1. For the near field leaf set, GPU parallelization is realized in a
 * producer-consumer model. GPU 1D thread grid is distributed over each Sauter
 * quadrature task in the ring buffer.
 * 2. For the far field leaf set, GPU 2D thread grid is distributed over each
 * Sauter quadrature task in the X direction and each quadrature point in the
 * Y direction. The quadrature tasks collected in the buffer are used to build
 * a row or column vector.}
 *
 * @tparam dim
 * @tparam spacedim
 * @tparam KernelFunctionType
 * @tparam RangeNumberType
 * @tparam KernelNumberType
 * @tparam SurfaceNormalDetector
 * @param thread_num
 * @param hmat
 * @param aca_config
 * @param kernel
 * @param kernel_factor
 * @param mass_vmult_weq
 * @param stabilization_factor
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param sauter_quad_rule
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_map_from_local_to_full_dof_indices
 * @param ky_map_from_local_to_full_dof_indices
 * @param kx_dof_i2e_numbering
 * @param ky_dof_i2e_numbering
 * @param mappings
 * @param material_id_to_mapping_index
 * @param normal_detector
 * @param enable_build_symmetric_hmat
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
fill_hmatrix_with_aca_plus_smp(
  const unsigned int                  thread_num,
  HMatrix<spacedim, RangeNumberType> &hmat,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
    &aca_config,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                              &kernel,
  const DeviceNumberType<KernelNumberType>     kernel_factor,
  const std::vector<Vector<KernelNumberType>> &mass_vmult_weq,
  const KernelNumberType                       stabilization_factor,
  const DoFToCellTopology<dim, spacedim>      &kx_dof_to_cell_topo,
  const DoFToCellTopology<dim, spacedim>      &ky_dof_to_cell_topo,
  const SauterQuadratureRule<dim>             &sauter_quad_rule,
  const DoFHandler<dim, spacedim>             &kx_dof_handler,
  const DoFHandler<dim, spacedim>             &ky_dof_handler,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  const bool                   enable_build_symmetric_hmat = false)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  LogStream::Prefix prefix_string("build_hmatrix_aca with stabilization");
#if ENABLE_NVTX == 1
  HierBEM::CUDAWrappers::NVTXRange nvtx_range(
    "build_hmatrix_aca with stabilization");
#endif

  Timer timer;

  /**
   * Precalculate data tables for shape values at quadrature points.
   *
   * \mynote{Precalculate shape function values and their gradient values
   * at each quadrature point. N.B.
   * 1. The data tables for shape function values and their gradient
   * values should be calculated for both function space on \f$K_x\f$ and
   * function space on \f$K_y\f$.
   * 2. Being different from the integral in FEM, the integral in BEM
   * handled by Sauter's quadrature rule has multiple parts of \f$k_3\f$
   * (except the regular cell neighboring type), each of which should be
   * evaluated at a different set of quadrature points in the unit cell
   * after coordinate transformation from the parametric space. Therefore,
   * a dimension with respect to \f$k_3\f$ term index should be added to
   * the data table compared to the usual FEValues and this brings about
   * the class @p BEMValues.}
   */
  BEMValues<dim, spacedim, real_type> bem_values(
    kx_dof_handler.get_fe(),
    ky_dof_handler.get_fe(),
    mappings,
    sauter_quad_rule.quad_rule_for_same_panel,
    sauter_quad_rule.quad_rule_for_common_edge,
    sauter_quad_rule.quad_rule_for_common_vertex,
    sauter_quad_rule.quad_rule_for_regular);

  bem_values.fill_shape_function_value_tables();

  /**
   * Copy the precalculated BEM values to the GPU device.
   */
  HierBEM::CUDAWrappers::CUDABEMValues<dim, spacedim, real_type> bem_values_gpu;
  bem_values_gpu.allocate_and_assign_from_host(bem_values);

  timer.stop();
  print_wall_time(deallog, timer, "compute BEM values");

  /**
   * @internal First stage: fill near field \hmatrix nodes using the
   * parallel producer-consumer model.
   */
  timer.start();

  const unsigned int block_size          = 256;
  const unsigned int block_num           = 8;
  const unsigned int batch_size          = block_size * block_num;
  const unsigned int capacity            = batch_size * 8 + 1;
  unsigned int       producer_thread_num = 4;

  HierBEM::CUDAWrappers::SauterQuadratureTaskRingBuffer<capacity,
                                                        dim,
                                                        spacedim,
                                                        RangeNumberType,
                                                        KernelNumberType>
    ring_buffer_for_same_panel;
  ring_buffer_for_same_panel.allocate(CellNeighboringType::SamePanel,
                                      batch_size,
                                      bem_values);
  HierBEM::CUDAWrappers::SauterQuadratureTaskRingBuffer<capacity,
                                                        dim,
                                                        spacedim,
                                                        RangeNumberType,
                                                        KernelNumberType>
    ring_buffer_for_common_edge;
  ring_buffer_for_common_edge.allocate(CellNeighboringType::CommonEdge,
                                       batch_size,
                                       bem_values);
  HierBEM::CUDAWrappers::SauterQuadratureTaskRingBuffer<capacity,
                                                        dim,
                                                        spacedim,
                                                        RangeNumberType,
                                                        KernelNumberType>
    ring_buffer_for_common_vertex;
  ring_buffer_for_common_vertex.allocate(CellNeighboringType::CommonVertex,
                                         batch_size,
                                         bem_values);
  HierBEM::CUDAWrappers::SauterQuadratureTaskRingBuffer<capacity,
                                                        dim,
                                                        spacedim,
                                                        RangeNumberType,
                                                        KernelNumberType>
    ring_buffer_for_regular;
  ring_buffer_for_regular.allocate(CellNeighboringType::Regular,
                                   batch_size,
                                   bem_values);

  std::mutex result_lock;

  std::vector<HMatrix<spacedim, RangeNumberType> *> &near_field_leaf_set =
    hmat.get_near_field_leaf_set();
  const unsigned int near_field_set_size = near_field_leaf_set.size();

  Assert(near_field_set_size > 0, ExcLowerRange(near_field_set_size, 1));

  if (near_field_set_size < producer_thread_num)
    {
      producer_thread_num = near_field_set_size;
    }

  std::vector<std::thread> producers;
  producers.reserve(producer_thread_num);

  const unsigned int number_of_hmat_nodes_per_thread =
    std::ceil(static_cast<double>(near_field_set_size) /
              static_cast<double>(producer_thread_num));

  /**
   * @internal Start the producer threads.
   */
  for (unsigned int i = 0; i < producer_thread_num; i++)
    {
      producers.emplace_back([&, i]() {
        HierBEM::CUDAWrappers::
          sauter_quadrature_for_near_field_matrix_entries_producer(
            near_field_leaf_set,
            i * number_of_hmat_nodes_per_thread,
            (i + 1) * number_of_hmat_nodes_per_thread > near_field_set_size ?
              near_field_set_size :
              (i + 1) * number_of_hmat_nodes_per_thread,
            ring_buffer_for_same_panel,
            ring_buffer_for_common_edge,
            ring_buffer_for_common_vertex,
            ring_buffer_for_regular,
            kx_dof_to_cell_topo.topology,
            ky_dof_to_cell_topo.topology,
            bem_values,
            kx_dof_handler,
            ky_dof_handler,
            kx_map_from_local_to_full_dof_indices,
            ky_map_from_local_to_full_dof_indices,
            kx_dof_i2e_numbering,
            ky_dof_i2e_numbering,
            mappings,
            material_id_to_mapping_index,
            normal_detector,
            kernel.is_symmetric(),
            enable_build_symmetric_hmat);
      });
    }

  /**
   * @internal Start the consumer threads.
   */
  std::vector<std::thread> consumers;
  const unsigned int       consumer_multiplicity = 1;
  consumers.reserve(4 * consumer_multiplicity);

  for (unsigned int m = 0; m < consumer_multiplicity; m++)
    {
      consumers.emplace_back([&]() {
        HierBEM::CUDAWrappers::
          sauter_quadrature_for_near_field_matrix_entries_consumer(
            kernel,
            kernel_factor,
            ring_buffer_for_same_panel,
            bem_values_gpu,
            result_lock,
            block_size);
      });

      consumers.emplace_back([&]() {
        HierBEM::CUDAWrappers::
          sauter_quadrature_for_near_field_matrix_entries_consumer(
            kernel,
            kernel_factor,
            ring_buffer_for_common_edge,
            bem_values_gpu,
            result_lock,
            block_size);
      });

      consumers.emplace_back([&]() {
        HierBEM::CUDAWrappers::
          sauter_quadrature_for_near_field_matrix_entries_consumer(
            kernel,
            kernel_factor,
            ring_buffer_for_common_vertex,
            bem_values_gpu,
            result_lock,
            block_size);
      });

      consumers.emplace_back([&]() {
        HierBEM::CUDAWrappers::
          sauter_quadrature_for_near_field_matrix_entries_consumer(
            kernel,
            kernel_factor,
            ring_buffer_for_regular,
            bem_values_gpu,
            result_lock,
            block_size);
      });
    }

  /**
   * @internal Wait for all producer and consumer threads to exit.
   */
  for (auto &producer : producers)
    producer.join();

  {
    std::lock_guard<std::mutex> lg(ring_buffer_for_same_panel.buffer_lock);
    ring_buffer_for_same_panel.if_all_near_field_hmat_entries_added = true;
  }
  ring_buffer_for_same_panel.batch_task_ready.notify_all();

  {
    std::lock_guard<std::mutex> lg(ring_buffer_for_common_edge.buffer_lock);
    ring_buffer_for_common_edge.if_all_near_field_hmat_entries_added = true;
  }
  ring_buffer_for_common_edge.batch_task_ready.notify_all();

  {
    std::lock_guard<std::mutex> lg(ring_buffer_for_common_vertex.buffer_lock);
    ring_buffer_for_common_vertex.if_all_near_field_hmat_entries_added = true;
  }
  ring_buffer_for_common_vertex.batch_task_ready.notify_all();

  {
    std::lock_guard<std::mutex> lg(ring_buffer_for_regular.buffer_lock);
    ring_buffer_for_regular.if_all_near_field_hmat_entries_added = true;
  }
  ring_buffer_for_regular.batch_task_ready.notify_all();

  for (auto &consumer : consumers)
    consumer.join();

  /**
   * @internal Release all ring buffers.
   */
  ring_buffer_for_same_panel.release();
  ring_buffer_for_common_edge.release();
  ring_buffer_for_common_vertex.release();
  ring_buffer_for_regular.release();

  /**
   * @internal Perform stabilization to the kernel.
   */
  unsigned int grain_size = near_field_set_size / thread_num;
  if (grain_size == 0)
    grain_size = 1;

  {
#if ENABLE_NVTX == 1
    HierBEM::CUDAWrappers::NVTXRange nvtx_range(
      "regularize hypersingular kernel");
#endif

    parallel::internal::parallel_for(
      near_field_leaf_set.begin(),
      near_field_leaf_set.end(),
      [&](const tbb::blocked_range<typename std::vector<
            HMatrix<spacedim, RangeNumberType> *>::iterator> &range) {
        stabilize_near_field_hmatrices_for_hypersingular_kernel<
          spacedim,
          RangeNumberType,
          KernelNumberType>(range,
                            mass_vmult_weq,
                            stabilization_factor,
                            enable_build_symmetric_hmat);
      },
      grain_size);
  }

  timer.stop();
  print_wall_time(deallog, timer, "build near field H-matrix nodes");

  /**
   * @internal Second stage: fill far field \hmatrix nodes by applying the
   * parallelization only to applying Sauter quadrature.
   */
  timer.start();

  std::vector<HMatrix<spacedim, RangeNumberType> *> &far_field_leaf_set =
    hmat.get_far_field_leaf_set();

  if (far_field_leaf_set.size() > 0)
    {
#if ENABLE_NVTX == 1
      HierBEM::CUDAWrappers::NVTXRange nvtx_range(
        "build far field hmatrix nodes");
#endif

      unsigned int grain_size = far_field_leaf_set.size() / thread_num;
      if (grain_size == 0)
        grain_size = 1;

      parallel::internal::parallel_for(
        far_field_leaf_set.begin(),
        far_field_leaf_set.end(),
        [&](const tbb::blocked_range<typename std::vector<
              HMatrix<spacedim, RangeNumberType> *>::iterator> &range) {
          fill_far_field_hmatrix_leaf_node_subrange_with_aca_plus<
            dim,
            spacedim,
            KernelFunctionType,
            RangeNumberType,
            KernelNumberType,
            SurfaceNormalDetector>(range,
                                   aca_config,
                                   kernel,
                                   kernel_factor,
                                   mass_vmult_weq,
                                   stabilization_factor,
                                   kx_dof_to_cell_topo,
                                   ky_dof_to_cell_topo,
                                   bem_values,
                                   bem_values_gpu,
                                   kx_dof_handler,
                                   ky_dof_handler,
                                   kx_map_from_local_to_full_dof_indices,
                                   ky_map_from_local_to_full_dof_indices,
                                   kx_dof_i2e_numbering,
                                   ky_dof_i2e_numbering,
                                   mappings,
                                   material_id_to_mapping_index,
                                   normal_detector,
                                   enable_build_symmetric_hmat);
        },
        grain_size);
    }

  timer.stop();
  print_wall_time(deallog, timer, "build far field H-matrix nodes");

  /**
   * Release BEM values on the GPU device.
   */
  bem_values_gpu.release();
}


/**
 * @brief Fill the leaf set of the \hmatrix using ACA+, where the hierarchical
 * structure of the \hmatrix has been built with respect to a block cluster
 * tree and the memory for the matrices in the leaf set has been allocated.
 *
 * In the mean time, the FEM mass matrix multiplied by a factor will be
 * added to the near field matrix block.
 *
 * For the near field matrices in the leaf set, full matrices will be built
 * whose elements will be obtained from the evaluation of the double
 * integral in Galerkin-BEM. For the far field admissible matrices in the
 * leaf set, rank-k matrices will be built using ACA+.
 *
 * \mynote{
 * 1. For the near field leaf set, GPU parallelization is realized in a
 * producer-consumer model. GPU 1D thread grid is distributed over each Sauter
 * quadrature task in the ring buffer.
 * 2. For the far field leaf set, GPU 2D thread grid is distributed over each
 * Sauter quadrature task in the X direction and each quadrature point in the
 * Y direction. The quadrature tasks collected in the buffer are used to build
 * a row or column vector.}
 *
 * @tparam dim
 * @tparam spacedim
 * @tparam KernelFunctionType
 * @tparam RangeNumberType
 * @tparam KernelNumberType
 * @tparam SurfaceNormalDetector
 * @param thread_num
 * @param hmat
 * @param aca_config
 * @param kernel
 * @param kernel_factor
 * @param mass_matrix_factor
 * @param kx_dof_to_cell_topo
 * @param ky_dof_to_cell_topo
 * @param sauter_quad_rule
 * @param mass_matrix_quadrature_formula
 * @param kx_dof_handler
 * @param ky_dof_handler
 * @param kx_map_from_local_to_full_dof_indices
 * @param ky_map_from_local_to_full_dof_indices
 * @param kx_dof_i2e_numbering
 * @param ky_dof_i2e_numbering
 * @param mappings
 * @param material_id_to_mapping_index
 * @param normal_detector
 * @param enable_build_symmetric_hmat
 */
template <int dim,
          int spacedim,
          template <int, typename> typename KernelFunctionType,
          typename RangeNumberType,
          typename KernelNumberType,
          typename SurfaceNormalDetector>
void
fill_hmatrix_with_aca_plus_smp(
  const unsigned int                  thread_num,
  HMatrix<spacedim, RangeNumberType> &hmat,
  const ACAConfig<typename numbers::NumberTraits<RangeNumberType>::real_type>
    &aca_config,
  const KernelFunctionType<spacedim, DeviceNumberType<KernelNumberType>>
                                          &kernel,
  const DeviceNumberType<KernelNumberType> kernel_factor,
  const typename numbers::NumberTraits<RangeNumberType>::real_type
                                          mass_matrix_factor,
  const DoFToCellTopology<dim, spacedim> &kx_dof_to_cell_topo,
  const DoFToCellTopology<dim, spacedim> &ky_dof_to_cell_topo,
  const SauterQuadratureRule<dim>        &sauter_quad_rule,
  const QGauss<dim>                      &mass_matrix_quadrature_formula,
  const DoFHandler<dim, spacedim>        &kx_dof_handler,
  const DoFHandler<dim, spacedim>        &ky_dof_handler,
  const std::vector<types::global_dof_index>
    *kx_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>
    *ky_map_from_local_to_full_dof_indices,
  const std::vector<types::global_dof_index>      &kx_dof_i2e_numbering,
  const std::vector<types::global_dof_index>      &ky_dof_i2e_numbering,
  const std::vector<MappingInfo<dim, spacedim> *> &mappings,
  const std::map<types::material_id, unsigned int>
                              &material_id_to_mapping_index,
  const SurfaceNormalDetector &normal_detector,
  const bool                   enable_build_symmetric_hmat = false)
{
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  static_assert(is_number_larger_or_equal<RangeNumberType, KernelNumberType>());
  static_assert(
    std::is_same<
      real_type,
      typename numbers::NumberTraits<KernelNumberType>::real_type>::value);

  LogStream::Prefix prefix_string("build_hmatrix_aca with mass matrix");
#if ENABLE_NVTX == 1
  HierBEM::CUDAWrappers::NVTXRange nvtx_range(
    "build_hmatrix_aca with mass matrix");
#endif

  Timer timer;

  /**
   * Precalculate data tables for shape values at quadrature points.
   *
   * \mynote{Precalculate shape function values and their gradient values
   * at each quadrature point. N.B.
   * 1. The data tables for shape function values and their gradient
   * values should be calculated for both function space on \f$K_x\f$ and
   * function space on \f$K_y\f$.
   * 2. Being different from the integral in FEM, the integral in BEM
   * handled by Sauter's quadrature rule has multiple parts of \f$k_3\f$
   * (except the regular cell neighboring type), each of which should be
   * evaluated at a different set of quadrature points in the unit cell
   * after coordinate transformation from the parametric space. Therefore,
   * a dimension with respect to \f$k_3\f$ term index should be added to
   * the data table compared to the usual FEValues and this brings about
   * the class @p BEMValues.}
   */
  BEMValues<dim, spacedim, real_type> bem_values(
    kx_dof_handler.get_fe(),
    ky_dof_handler.get_fe(),
    mappings,
    sauter_quad_rule.quad_rule_for_same_panel,
    sauter_quad_rule.quad_rule_for_common_edge,
    sauter_quad_rule.quad_rule_for_common_vertex,
    sauter_quad_rule.quad_rule_for_regular);

  bem_values.fill_shape_function_value_tables();

  /**
   * Copy the precalculated BEM values to the GPU device.
   */
  HierBEM::CUDAWrappers::CUDABEMValues<dim, spacedim, real_type> bem_values_gpu;
  bem_values_gpu.allocate_and_assign_from_host(bem_values);

  timer.stop();
  print_wall_time(deallog, timer, "compute BEM values");

  /**
   * @internal First stage: fill near field \hmatrix nodes using the
   * parallel producer-consumer model.
   */
  timer.start();

  const unsigned int block_size          = 256;
  const unsigned int block_num           = 8;
  const unsigned int batch_size          = block_size * block_num;
  const unsigned int capacity            = batch_size * 8 + 1;
  unsigned int       producer_thread_num = 4;

  HierBEM::CUDAWrappers::SauterQuadratureTaskRingBuffer<capacity,
                                                        dim,
                                                        spacedim,
                                                        RangeNumberType,
                                                        KernelNumberType>
    ring_buffer_for_same_panel;
  ring_buffer_for_same_panel.allocate(CellNeighboringType::SamePanel,
                                      batch_size,
                                      bem_values);
  HierBEM::CUDAWrappers::SauterQuadratureTaskRingBuffer<capacity,
                                                        dim,
                                                        spacedim,
                                                        RangeNumberType,
                                                        KernelNumberType>
    ring_buffer_for_common_edge;
  ring_buffer_for_common_edge.allocate(CellNeighboringType::CommonEdge,
                                       batch_size,
                                       bem_values);
  HierBEM::CUDAWrappers::SauterQuadratureTaskRingBuffer<capacity,
                                                        dim,
                                                        spacedim,
                                                        RangeNumberType,
                                                        KernelNumberType>
    ring_buffer_for_common_vertex;
  ring_buffer_for_common_vertex.allocate(CellNeighboringType::CommonVertex,
                                         batch_size,
                                         bem_values);
  HierBEM::CUDAWrappers::SauterQuadratureTaskRingBuffer<capacity,
                                                        dim,
                                                        spacedim,
                                                        RangeNumberType,
                                                        KernelNumberType>
    ring_buffer_for_regular;
  ring_buffer_for_regular.allocate(CellNeighboringType::Regular,
                                   batch_size,
                                   bem_values);

  std::mutex result_lock;

  std::vector<HMatrix<spacedim, RangeNumberType> *> &near_field_leaf_set =
    hmat.get_near_field_leaf_set();
  const unsigned int near_field_set_size = near_field_leaf_set.size();

  Assert(near_field_set_size > 0, ExcLowerRange(near_field_set_size, 1));

  if (near_field_set_size < producer_thread_num)
    {
      producer_thread_num = near_field_set_size;
    }

  std::vector<std::thread> producers;
  producers.reserve(producer_thread_num);

  const unsigned int number_of_hmat_nodes_per_thread =
    std::ceil(static_cast<double>(near_field_set_size) /
              static_cast<double>(producer_thread_num));

  /**
   * @internal Start the producer threads.
   */
  for (unsigned int i = 0; i < producer_thread_num; i++)
    {
      producers.emplace_back([&, i]() {
        HierBEM::CUDAWrappers::
          sauter_quadrature_for_near_field_matrix_entries_producer(
            near_field_leaf_set,
            i * number_of_hmat_nodes_per_thread,
            (i + 1) * number_of_hmat_nodes_per_thread > near_field_set_size ?
              near_field_set_size :
              (i + 1) * number_of_hmat_nodes_per_thread,
            ring_buffer_for_same_panel,
            ring_buffer_for_common_edge,
            ring_buffer_for_common_vertex,
            ring_buffer_for_regular,
            mass_matrix_factor,
            kx_dof_to_cell_topo.topology,
            ky_dof_to_cell_topo.topology,
            bem_values,
            mass_matrix_quadrature_formula,
            kx_dof_handler,
            ky_dof_handler,
            kx_map_from_local_to_full_dof_indices,
            ky_map_from_local_to_full_dof_indices,
            kx_dof_i2e_numbering,
            ky_dof_i2e_numbering,
            mappings,
            material_id_to_mapping_index,
            normal_detector,
            kernel.is_symmetric(),
            enable_build_symmetric_hmat);
      });
    }

  /**
   * @internal Start the consumer threads.
   */
  std::vector<std::thread> consumers;
  const unsigned int       consumer_multiplicity = 1;
  consumers.reserve(4 * consumer_multiplicity);

  for (unsigned int m = 0; m < consumer_multiplicity; m++)
    {
      consumers.emplace_back([&]() {
        HierBEM::CUDAWrappers::
          sauter_quadrature_for_near_field_matrix_entries_consumer(
            kernel,
            kernel_factor,
            ring_buffer_for_same_panel,
            bem_values_gpu,
            result_lock,
            block_size);
      });

      consumers.emplace_back([&]() {
        HierBEM::CUDAWrappers::
          sauter_quadrature_for_near_field_matrix_entries_consumer(
            kernel,
            kernel_factor,
            ring_buffer_for_common_edge,
            bem_values_gpu,
            result_lock,
            block_size);
      });

      consumers.emplace_back([&]() {
        HierBEM::CUDAWrappers::
          sauter_quadrature_for_near_field_matrix_entries_consumer(
            kernel,
            kernel_factor,
            ring_buffer_for_common_vertex,
            bem_values_gpu,
            result_lock,
            block_size);
      });

      consumers.emplace_back([&]() {
        HierBEM::CUDAWrappers::
          sauter_quadrature_for_near_field_matrix_entries_consumer(
            kernel,
            kernel_factor,
            ring_buffer_for_regular,
            bem_values_gpu,
            result_lock,
            block_size);
      });
    }

  /**
   * @internal Wait for all producer and consumer threads to exit.
   */
  for (auto &producer : producers)
    producer.join();

  {
    std::lock_guard<std::mutex> lg(ring_buffer_for_same_panel.buffer_lock);
    ring_buffer_for_same_panel.if_all_near_field_hmat_entries_added = true;
  }
  ring_buffer_for_same_panel.batch_task_ready.notify_all();

  {
    std::lock_guard<std::mutex> lg(ring_buffer_for_common_edge.buffer_lock);
    ring_buffer_for_common_edge.if_all_near_field_hmat_entries_added = true;
  }
  ring_buffer_for_common_edge.batch_task_ready.notify_all();

  {
    std::lock_guard<std::mutex> lg(ring_buffer_for_common_vertex.buffer_lock);
    ring_buffer_for_common_vertex.if_all_near_field_hmat_entries_added = true;
  }
  ring_buffer_for_common_vertex.batch_task_ready.notify_all();

  {
    std::lock_guard<std::mutex> lg(ring_buffer_for_regular.buffer_lock);
    ring_buffer_for_regular.if_all_near_field_hmat_entries_added = true;
  }
  ring_buffer_for_regular.batch_task_ready.notify_all();

  for (auto &consumer : consumers)
    consumer.join();

  /**
   * @internal Release all ring buffers.
   */
  ring_buffer_for_same_panel.release();
  ring_buffer_for_common_edge.release();
  ring_buffer_for_common_vertex.release();
  ring_buffer_for_regular.release();

  timer.stop();
  print_wall_time(deallog, timer, "build near field H-matrix nodes");

  /**
   * @internal Second stage: fill far field \hmatrix nodes by applying the
   * parallelization only to applying Sauter quadrature.
   */
  timer.start();

  std::vector<HMatrix<spacedim, RangeNumberType> *> &far_field_leaf_set =
    hmat.get_far_field_leaf_set();

  if (far_field_leaf_set.size() > 0)
    {
#if ENABLE_NVTX == 1
      HierBEM::CUDAWrappers::NVTXRange nvtx_range(
        "build far field hmatrix nodes");
#endif

      /**
       * Estimate the grain size.
       */
      unsigned int grain_size = far_field_leaf_set.size() / thread_num;
      if (grain_size == 0)
        grain_size = 1;

      parallel::internal::parallel_for(
        far_field_leaf_set.begin(),
        far_field_leaf_set.end(),
        [&](const tbb::blocked_range<typename std::vector<
              HMatrix<spacedim, RangeNumberType> *>::iterator> &range) {
          fill_far_field_hmatrix_leaf_node_subrange_with_aca_plus<
            dim,
            spacedim,
            KernelFunctionType,
            RangeNumberType,
            KernelNumberType,
            SurfaceNormalDetector>(range,
                                   aca_config,
                                   kernel,
                                   kernel_factor,
                                   kx_dof_to_cell_topo,
                                   ky_dof_to_cell_topo,
                                   bem_values,
                                   bem_values_gpu,
                                   kx_dof_handler,
                                   ky_dof_handler,
                                   kx_map_from_local_to_full_dof_indices,
                                   ky_map_from_local_to_full_dof_indices,
                                   kx_dof_i2e_numbering,
                                   ky_dof_i2e_numbering,
                                   mappings,
                                   material_id_to_mapping_index,
                                   normal_detector,
                                   enable_build_symmetric_hmat);
        },
        grain_size);
    }

  timer.stop();
  print_wall_time(deallog, timer, "build far field H-matrix nodes");

  /**
   * Release BEM values on the GPU device.
   */
  bem_values_gpu.release();
}

HBEM_NS_CLOSE

#endif /* HIERBEM_INCLUDE_HMATRIX_ACA_PLUS_ACA_PLUS_H_ */
