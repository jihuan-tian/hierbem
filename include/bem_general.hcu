/**
 * @file bem_general.h
 * @brief Introduction of bem_general.h
 *
 * @date 2022-03-04
 * @author Jihuan Tian
 */
#ifndef INCLUDE_BEM_GENERAL_H_
#define INCLUDE_BEM_GENERAL_H_

#include <deal.II/base/quadrature.h>
#include <deal.II/base/work_stream.h>

#include <deal.II/dofs/dof_handler.h>

#include <functional>
#include <map>
#include <utility>
#include <vector>

#include "bem_kernels.hcu"
#include "bem_values.hcu"
#include "mapping/mapping_info.h"
#include "sauter_quadrature.hcu"

namespace HierBEM
{
  using namespace dealii;
  using namespace BEMTools;

  /**
   * Assemble the mass matrix in FEM on one cell.
   *
   * The results is stored in a local cellwise matrix in the copy data.
   *
   * @pre
   * @post
   * @tparam dim
   * @tparam spacedim
   * @tparam RangeNumberType
   * @param factor
   * @param iterator_for_cell_iterator_pairs
   * @param scratch_data
   * @param copy_data
   */
  template <int dim, int spacedim, typename RangeNumberType>
  void
  assemble_fem_scaled_mass_matrix_on_one_cell(
    const RangeNumberType factor,
    const typename std::vector<std::pair<
      typename DoFHandler<dim, spacedim>::active_cell_iterator,
      typename DoFHandler<dim, spacedim>::active_cell_iterator>>::const_iterator
      &iterator_for_cell_iterator_pairs,
    CellWiseScratchDataForMassMatrix<dim, spacedim>               &scratch_data,
    CellWiseCopyDataForMassMatrix<dim, spacedim, RangeNumberType> &copy_data)
  {
    /**
     * Clear the local matrix in case that it is reused from another finished
     * task. N.B. Its memory has already been allocated in the constructor of
     * @p CellWisePerTaskData.
     */
    copy_data.local_matrix.reinit(
      copy_data.local_dof_indices_for_test_space.size(),
      copy_data.local_dof_indices_for_trial_space.size());

    /**
     * N.B. The construction of the object <code>scratch.fe_values</code> is
     * carried out in the constructor of <code>CellWiseScratchData</code>.
     *
     * \comment{2022-06-27 I added a @p const keyword at the front to protect
     * the internal data in the cell. Since the vector of cell iterator pairs
     * persists at least in this function, I create references to the two cell
     * iterators instead of making copies.}
     */
    const typename DoFHandler<dim, spacedim>::active_cell_iterator &
      cell_iter_for_test_space_domain = iterator_for_cell_iterator_pairs->first;
    const typename DoFHandler<dim, spacedim>::active_cell_iterator
      &cell_iter_for_trial_space_domain =
        iterator_for_cell_iterator_pairs->second;

    /**
     * Reinitialize the @p FEValues objects for test space and trial space
     * for the current cell.
     */
    scratch_data.fe_values_for_test_space.reinit(
      cell_iter_for_test_space_domain);
    scratch_data.fe_values_for_trial_space.reinit(
      cell_iter_for_trial_space_domain);

    AssertDimension(
      scratch_data.fe_values_for_test_space.get_quadrature().size(),
      scratch_data.fe_values_for_trial_space.get_quadrature().size());
    const unsigned int n_q_points =
      scratch_data.fe_values_for_test_space.get_quadrature().size();

    const unsigned int dofs_per_cell_for_test_space =
      scratch_data.fe_values_for_test_space.get_fe().dofs_per_cell;
    const unsigned int dofs_per_cell_for_trial_space =
      scratch_data.fe_values_for_trial_space.get_fe().dofs_per_cell;

    /**
     * Calculate the local mass matrix multiplied by a factor in the
     * current cell.
     */
    for (unsigned int q = 0; q < n_q_points; q++)
      {
        Assert(
          scratch_data.fe_values_for_test_space.JxW(q) ==
            scratch_data.fe_values_for_trial_space.JxW(q),
          ExcMessage(
            "The JxW values in test space domain and trial space domain should be the same!"));

        /**
         * Iterate over test function DoFs.
         */
        for (unsigned int i = 0; i < dofs_per_cell_for_test_space; i++)
          {
            /**
             * Iterate over trial function DoFs.
             */
            for (unsigned int j = 0; j < dofs_per_cell_for_trial_space; j++)
              {
                copy_data.local_matrix(i, j) +=
                  factor *
                  scratch_data.fe_values_for_test_space.shape_value(i, q) *
                  scratch_data.fe_values_for_trial_space.shape_value(j, q) *
                  scratch_data.fe_values_for_test_space.JxW(q);
              }
          }
      }

    /**
     *  Extract the DoF indices. N.B. Before calling
     * <code>get_dof_indices</code>, the memory for the argument vector should
     * have been allocated. Here, the memory for
     * <code>data.local_dof_indices</code> has been allocated in the
     * constructor of <code>CellWisePerTaskData</code>.
     */
    cell_iter_for_test_space_domain->get_dof_indices(
      copy_data.local_dof_indices_for_test_space);
    cell_iter_for_trial_space_domain->get_dof_indices(
      copy_data.local_dof_indices_for_trial_space);
  }

  template <int dim,
            int spacedim,
            typename RangeNumberType,
            typename MatrixType>
  void
  copy_cell_local_to_global_for_fem_matrix(
    const CellWiseCopyDataForMassMatrix<dim, spacedim, RangeNumberType> &data,
    MatrixType &target_full_matrix)
  {
    const unsigned int dofs_per_cell_for_test_space  = data.local_matrix.m();
    const unsigned int dofs_per_cell_for_trial_space = data.local_matrix.n();

    for (unsigned int i = 0; i < dofs_per_cell_for_test_space; i++)
      {
        for (unsigned int j = 0; j < dofs_per_cell_for_trial_space; j++)
          {
            target_full_matrix.add(data.local_dof_indices_for_test_space[i],
                                   data.local_dof_indices_for_trial_space[j],
                                   data.local_matrix(i, j));
          }
      }
  }



  template <int dim,
            int spacedim,
            typename RangeNumberType,
            typename VectorType>
  void
  assemble_fem_mass_matrix_vmult_on_one_cell(
    const VectorType &v,
    const typename std::vector<std::pair<
      typename DoFHandler<dim, spacedim>::active_cell_iterator,
      typename DoFHandler<dim, spacedim>::active_cell_iterator>>::const_iterator
      &iterator_for_cell_iterator_pairs,
    CellWiseScratchDataForMassMatrix<dim, spacedim> &scratch_data,
    CellWiseCopyDataForMassMatrixVmult<dim, spacedim, RangeNumberType>
      &copy_data)
  {
    /**
     * Clear the local matrix in case that it is reused from another finished
     * task. N.B. Its memory has already been allocated in the constructor of
     * @p CellWisePerTaskData.
     */
    copy_data.local_matrix.reinit(
      copy_data.local_dof_indices_for_test_space.size(),
      copy_data.local_dof_indices_for_trial_space.size());

    /**
     * N.B. The construction of the object <code>scratch.fe_values</code> is
     * carried out in the constructor of <code>CellWiseScratchData</code>.
     *
     * \comment{2022-06-27 I added a @p const keyword at the front to protect
     * the internal data in the cell. Since the vector of cell iterator pairs
     * persists at least in this function, I create references to the two cell
     * iterators instead of making copies.}
     */
    const typename DoFHandler<dim, spacedim>::active_cell_iterator &
      cell_iter_for_test_space_domain = iterator_for_cell_iterator_pairs->first;
    const typename DoFHandler<dim, spacedim>::active_cell_iterator
      &cell_iter_for_trial_space_domain =
        iterator_for_cell_iterator_pairs->second;

    /**
     * Reinitialize the @p FEValues objects for test space and trial space
     * for the current cell.
     */
    scratch_data.fe_values_for_test_space.reinit(
      cell_iter_for_test_space_domain);
    scratch_data.fe_values_for_trial_space.reinit(
      cell_iter_for_trial_space_domain);

    AssertDimension(
      scratch_data.fe_values_for_test_space.get_quadrature().size(),
      scratch_data.fe_values_for_trial_space.get_quadrature().size());
    const unsigned int n_q_points =
      scratch_data.fe_values_for_test_space.get_quadrature().size();

    const unsigned int dofs_per_cell_for_test_space =
      scratch_data.fe_values_for_test_space.get_fe().dofs_per_cell;
    const unsigned int dofs_per_cell_for_trial_space =
      scratch_data.fe_values_for_trial_space.get_fe().dofs_per_cell;

    /**
     *  Extract the DoF indices. N.B. Before calling
     * <code>get_dof_indices</code>, the memory for the argument vector should
     * have been allocated. Here, the memory for
     * <code>data.local_dof_indices</code> has been allocated in the
     * constructor of <code>CellWisePerTaskData</code>.
     */
    cell_iter_for_test_space_domain->get_dof_indices(
      copy_data.local_dof_indices_for_test_space);
    cell_iter_for_trial_space_domain->get_dof_indices(
      copy_data.local_dof_indices_for_trial_space);

    /**
     * Calculate the local mass matrix in the current cell.
     */
    for (unsigned int q = 0; q < n_q_points; q++)
      {
        Assert(
          scratch_data.fe_values_for_test_space.JxW(q) ==
            scratch_data.fe_values_for_trial_space.JxW(q),
          ExcMessage(
            "The JxW values in test space domain and trial space domain should be the same!"));

        /**
         * Iterate over test function DoFs.
         */
        for (unsigned int i = 0; i < dofs_per_cell_for_test_space; i++)
          {
            /**
             * Iterate over trial function DoFs.
             */
            for (unsigned int j = 0; j < dofs_per_cell_for_trial_space; j++)
              {
                copy_data.local_matrix(i, j) +=
                  scratch_data.fe_values_for_test_space.shape_value(i, q) *
                  scratch_data.fe_values_for_trial_space.shape_value(j, q) *
                  scratch_data.fe_values_for_test_space.JxW(q);
              }
          }
      }

    /**
     * Extract local vector from \f$v\f$ in the current cell.
     */
    for (unsigned int j = 0; j < dofs_per_cell_for_trial_space; j++)
      {
        copy_data.local_v(j) =
          v(copy_data.local_dof_indices_for_trial_space[j]);
      }

    /**
     * Perform the multiplication \f$u=Mv\f$.
     */
    copy_data.local_matrix.vmult(copy_data.local_u, copy_data.local_v);
  }


  template <int dim,
            int spacedim,
            typename RangeNumberType,
            typename VectorType>
  void
  copy_cell_local_to_global_for_fem_matrix_vmult(
    const CellWiseCopyDataForMassMatrixVmult<dim, spacedim, RangeNumberType>
               &copy_data,
    VectorType &target_vector)
  {
    AssertDimension(copy_data.local_dof_indices_for_test_space.size(),
                    copy_data.local_u.size());

    target_vector.add(copy_data.local_dof_indices_for_test_space,
                      copy_data.local_u);
  }


  /**
   * Initialize the cell iterator pointer pairs for the DoFHandlers
   * associated with test space and trial space. N.B. The test space comes
   * before the trial space.
   *
   * \mynote{This function is to assist the assembly of the FEM mass matrix.
   * For Dirichlet problem, it is \f$\mathcal{I}\f$ on \f$\left(
   * H^{-\frac{1}{2}+s}(\Gamma_{\rm D}), H^{\frac{1}{2}+s}(\Gamma_{\rm D})
   * \right) \f$.
   *
   * For mixed boundary value problem, they are
   * 1. \f$\mathcal{I}_1\f$ on \f$\left( H^{-\frac{1}{2}+s}(\Gamma_{\rm D}),
   * H^{\frac{1}{2}+s}(\Gamma_{\rm D}) \right) \f$
   * 2. \f$\mathcal{I}_2\f$ on \f$\left( H^{\frac{1}{2}+s}(\Gamma_{\rm N}),
   * H^{-\frac{1}{2}+s}(\Gamma_{\rm N}) \right)\f$
   *
   * It can be seen that for the mass matrices, the test space and trial
   * space are situated on a same triangulation.}
   *
   * @param dof_handler_for_test_space
   * @param dof_handler_for_trial_space
   * @param cell_iterator_pairs_for_mass_matrix
   */
  template <int dim, int spacedim>
  void
  initialize_cell_iterator_pairs_for_mass_matrix(
    const DoFHandler<dim, spacedim> &dof_handler_for_test_space,
    const DoFHandler<dim, spacedim> &dof_handler_for_trial_space,
    std::vector<
      std::pair<typename DoFHandler<dim, spacedim>::active_cell_iterator,
                typename DoFHandler<dim, spacedim>::active_cell_iterator>>
      &cell_iterator_pairs_for_mass_matrix)
  {
    /**
     * Because the two spaces are associated with a same triangulation, the
     * number of cells inferred from the two DoFHandlers should be the same.
     */
    AssertDimension(
      dof_handler_for_test_space.get_triangulation().n_active_cells(),
      dof_handler_for_trial_space.get_triangulation().n_active_cells());

    /**
     * The memory for the result vector should be preallocated.
     */
    AssertDimension(
      dof_handler_for_test_space.get_triangulation().n_active_cells(),
      cell_iterator_pairs_for_mass_matrix.size());

    typename DoFHandler<dim, spacedim>::active_cell_iterator
      cell_iterator_for_test_space = dof_handler_for_test_space.begin_active();
    typename DoFHandler<dim, spacedim>::active_cell_iterator
      cell_iterator_for_trial_space =
        dof_handler_for_trial_space.begin_active();

    std::size_t counter = 0;
    for (; cell_iterator_for_test_space != dof_handler_for_test_space.end();
         cell_iterator_for_test_space++,
         cell_iterator_for_trial_space++,
         counter++)
      {
        /**
         * \mynote{N.B. The cell iterator for the test space appears before
         * that for the trial space in the pair.}
         */
        cell_iterator_pairs_for_mass_matrix[counter].first =
          cell_iterator_for_test_space;
        cell_iterator_pairs_for_mass_matrix[counter].second =
          cell_iterator_for_trial_space;
      }
  }


  /**
   * Assemble the mass matrix in FEM.
   *
   * \mynote{We should bear in mind the following points.
   * 1. The test and ansatz function spaces related to the mass matrix may
   * be two different function spaces but residing on a same triangulation;
   * 2. Unlike a full matrix involved in BEM, a non-zero cellwise integration
   * for the assembly of the mass matrix requires the test and ansatz basis
   * functions have overlapping supports.
   * 3. Since the two function spaces on a same triangulation are different
   * spaces, there are two DoF handlers and two cell iterators. And the two cell
   * iterators should step forward synchronously. Therefore, in this function,
   * there is the definition of cell iterator pair.}
   *
   * @param dof_handler_for_test_space
   * @param dof_handler_for_trial_space
   * @param factor
   * @param quad_rule
   * @param target_full_matrix
   */
  template <int dim,
            int spacedim,
            typename RangeNumberType,
            typename MatrixType>
  void
  assemble_fem_scaled_mass_matrix(
    const DoFHandler<dim, spacedim> &dof_handler_for_test_space,
    const DoFHandler<dim, spacedim> &dof_handler_for_trial_space,
    const RangeNumberType            factor,
    const Quadrature<dim>           &quad_rule,
    MatrixType                      &target_full_matrix)
  {
    // Because the test and ansatz function spaces related to the mass matrix
    // are on a same spatial domain, here we make an assertion about the
    // equality of the number of cells in their respective triangulations.
    AssertDimension(
      dof_handler_for_test_space.get_triangulation().n_active_cells(),
      dof_handler_for_trial_space.get_triangulation().n_active_cells());

    std::vector<
      std::pair<typename DoFHandler<dim, spacedim>::active_cell_iterator,
                typename DoFHandler<dim, spacedim>::active_cell_iterator>>
      cell_iterator_pairs_for_mass_matrix(
        dof_handler_for_test_space.get_triangulation().n_active_cells());

    initialize_cell_iterator_pairs_for_mass_matrix(
      dof_handler_for_test_space,
      dof_handler_for_trial_space,
      cell_iterator_pairs_for_mass_matrix);

    WorkStream::run(
      cell_iterator_pairs_for_mass_matrix.begin(),
      cell_iterator_pairs_for_mass_matrix.end(),
      std::bind(&assemble_fem_scaled_mass_matrix_on_one_cell<dim,
                                                             spacedim,
                                                             RangeNumberType>,
                factor,
                std::placeholders::_1,
                std::placeholders::_2,
                std::placeholders::_3),
      std::bind(&copy_cell_local_to_global_for_fem_matrix<dim,
                                                          spacedim,
                                                          RangeNumberType,
                                                          MatrixType>,

                std::placeholders::_1,
                std::ref(target_full_matrix)),
      CellWiseScratchDataForMassMatrix<dim, spacedim>(
        dof_handler_for_test_space.get_fe(),
        dof_handler_for_trial_space.get_fe(),
        quad_rule,
        update_values | update_JxW_values),
      CellWiseCopyDataForMassMatrix<dim, spacedim, RangeNumberType>(
        dof_handler_for_test_space.get_fe(),
        dof_handler_for_trial_space.get_fe()));
  }


  /**
   * Assemble the mass matrix in FEM in a single thread.
   *
   * @pre
   * @post
   * @tparam dim
   * @tparam spacedim
   * @tparam RangeNumberType
   * @tparam MatrixType
   * @param dof_handler_for_test_space
   * @param dof_handler_for_trial_space
   * @param factor
   * @param quad_rule
   * @param target_full_matrix
   */
  template <int dim,
            int spacedim,
            typename RangeNumberType,
            typename MatrixType>
  void
  assemble_fem_scaled_mass_matrix_serial(
    const DoFHandler<dim, spacedim> &dof_handler_for_test_space,
    const DoFHandler<dim, spacedim> &dof_handler_for_trial_space,
    const RangeNumberType            factor,
    const Quadrature<dim>           &quad_rule,
    MatrixType                      &target_full_matrix)
  {
    // Because the test and ansatz function spaces related to the mass matrix
    // are on a same spatial domain, here we make an assertion about the
    // equality of the number of cells in their respective triangulations.
    AssertDimension(
      dof_handler_for_test_space.get_triangulation().n_active_cells(),
      dof_handler_for_trial_space.get_triangulation().n_active_cells());

    std::vector<
      std::pair<typename DoFHandler<dim, spacedim>::active_cell_iterator,
                typename DoFHandler<dim, spacedim>::active_cell_iterator>>
      cell_iterator_pairs_for_mass_matrix(
        dof_handler_for_test_space.get_triangulation().n_active_cells());

    initialize_cell_iterator_pairs_for_mass_matrix(
      dof_handler_for_test_space,
      dof_handler_for_trial_space,
      cell_iterator_pairs_for_mass_matrix);

    CellWiseScratchDataForMassMatrix<dim, spacedim> scratch_data(
      dof_handler_for_test_space.get_fe(),
      dof_handler_for_trial_space.get_fe(),
      quad_rule,
      update_values | update_JxW_values);

    CellWiseCopyDataForMassMatrix<dim, spacedim, RangeNumberType> copy_data(
      dof_handler_for_test_space.get_fe(),
      dof_handler_for_trial_space.get_fe());

    for (auto cell_pair_iter = cell_iterator_pairs_for_mass_matrix.begin();
         cell_pair_iter != cell_iterator_pairs_for_mass_matrix.end();
         cell_pair_iter++)
      {
        assemble_fem_scaled_mass_matrix_on_one_cell(factor,
                                                    cell_pair_iter,
                                                    scratch_data,
                                                    copy_data);

        copy_cell_local_to_global_for_fem_matrix(copy_data, target_full_matrix);
      }
  }


  /**
   * Calculate the mass matrix for the test space and trial space, then multiply
   * it with the input vector and a new vector is returned.
   *
   * @param dof_handler_for_test_space
   * @param dof_handler_for_trial_space
   * @param v
   * @param quad_rule
   * @param target_vector
   */
  template <int dim,
            int spacedim,
            typename RangeNumberType,
            typename VectorType>
  void
  assemble_fem_mass_matrix_vmult(
    const DoFHandler<dim, spacedim> &dof_handler_for_test_space,
    const DoFHandler<dim, spacedim> &dof_handler_for_trial_space,
    const VectorType                &v,
    const Quadrature<dim>           &quad_rule,
    VectorType                      &target_vector)
  {
    // Because the test and ansatz function spaces related to the mass matrix
    // are on a same spatial domain, here we make an assertion about the
    // equality of the number of cells in their respective triangulations.
    AssertDimension(
      dof_handler_for_test_space.get_triangulation().n_active_cells(),
      dof_handler_for_trial_space.get_triangulation().n_active_cells());

    std::vector<
      std::pair<typename DoFHandler<dim, spacedim>::active_cell_iterator,
                typename DoFHandler<dim, spacedim>::active_cell_iterator>>
      cell_iterator_pairs_for_mass_matrix(
        dof_handler_for_test_space.get_triangulation().n_active_cells());

    initialize_cell_iterator_pairs_for_mass_matrix(
      dof_handler_for_test_space,
      dof_handler_for_trial_space,
      cell_iterator_pairs_for_mass_matrix);

    WorkStream::run(
      cell_iterator_pairs_for_mass_matrix.begin(),
      cell_iterator_pairs_for_mass_matrix.end(),
      std::bind(&assemble_fem_mass_matrix_vmult_on_one_cell<dim,
                                                            spacedim,
                                                            RangeNumberType,
                                                            VectorType>,
                std::cref(v),
                std::placeholders::_1,
                std::placeholders::_2,
                std::placeholders::_3),
      std::bind(&copy_cell_local_to_global_for_fem_matrix_vmult<dim,
                                                                spacedim,
                                                                RangeNumberType,
                                                                VectorType>,

                std::placeholders::_1,
                std::ref(target_vector)),
      CellWiseScratchDataForMassMatrix<dim, spacedim>(
        dof_handler_for_test_space.get_fe(),
        dof_handler_for_trial_space.get_fe(),
        quad_rule,
        update_values | update_JxW_values),
      CellWiseCopyDataForMassMatrixVmult<dim, spacedim, RangeNumberType>(
        dof_handler_for_test_space.get_fe(),
        dof_handler_for_trial_space.get_fe()));
  }


  template <int dim,
            int spacedim,
            typename RangeNumberType,
            typename MatrixType>
  void
  copy_pair_of_cells_local_to_global_for_bem_full_matrix(
    const PairCellWisePerTaskData<dim, spacedim, RangeNumberType> &data,
    MatrixType &target_full_matrix)
  {
    const unsigned int kx_dofs_per_cell = data.local_pair_cell_matrix.m();
    const unsigned int ky_dofs_per_cell = data.local_pair_cell_matrix.n();

    for (unsigned int i = 0; i < kx_dofs_per_cell; i++)
      {
        for (unsigned int j = 0; j < ky_dofs_per_cell; j++)
          {
            target_full_matrix.add(data.kx_local_dof_indices_permuted[i],
                                   data.ky_local_dof_indices_permuted[j],
                                   data.local_pair_cell_matrix(i, j));
          }
      }
  }



  /**
   * Assemble a full matrix for a bilinear form in BEM.
   *
   * @param kernel
   * @param factor
   * @param dof_handler_for_test_space
   * @param dof_handler_for_trial_space
   * @param kx_mapping
   * @param ky_mapping
   * @param kx_mapping_data
   * @param ky_mapping_data
   * @param sauter_quad_rule
   * @param target_full_matrix
   */
  template <int dim,
            int spacedim,
            template <int, typename>
            typename KernelFunctionType,
            typename RangeNumberType,
            typename SurfaceNormalDetector,
            typename MatrixType>
  void
  assemble_bem_full_matrix(
    const KernelFunctionType<spacedim, RangeNumberType> &kernel,
    const RangeNumberType                                factor,
    const DoFHandler<dim, spacedim> &dof_handler_for_test_space,
    const DoFHandler<dim, spacedim> &dof_handler_for_trial_space,
    const std::vector<MappingInfo<dim, spacedim> *> &mappings,
    const std::map<types::material_id, unsigned int>
                                    &material_id_to_mapping_index,
    const SurfaceNormalDetector     &normal_detector,
    const SauterQuadratureRule<dim> &sauter_quad_rule,
    MatrixType                      &target_full_matrix)
  {
    /**
     * Precalculate data tables for shape values at quadrature points.
     *
     * \mynote{Precalculate shape function values and their gradient
     * values at each quadrature point. N.B.
     * 1. The data tables for shape function values and their gradient
     * values should be calculated for both function space on
     * \f$K_x\f$ and function space on \f$K_y\f$.
     * 2. Being different from the integral in FEM, the integral in
     * BEM handled by Sauter's quadrature rule has multiple parts of
     * \f$k_3\f$ (except the regular cell neighboring type), each of
     * which should be evaluated at a different set of quadrature
     * points in the unit cell after coordinate transformation from
     * the parametric space. Therefore, an additional dimension with respect to
     * \f$k_3\f$ term index should be added to the data table compared
     * to the usual FEValues and this brings about
     * the class @p BEMValues.
     * 3. In Galerkin BEM, finite elements for the Dirichlet domain
     * and Neumann domain are different. For SLP BEM matrix, both the
     * test function space, to which \f$K_x\f$ belongs, space and the
     * trial function space, to which \f$K_y\f$ belongs, is @p FE_DGQ.
     * For DLP BEM matrix and the mass matrix, the test function space
     * is @p FE_DGQ and the trial function space is @p FE_Q.}
     */
    BEMValues<dim, spacedim, RangeNumberType> bem_values(
      dof_handler_for_test_space.get_fe(),
      dof_handler_for_trial_space.get_fe(),
      mappings,
      sauter_quad_rule.quad_rule_for_same_panel,
      sauter_quad_rule.quad_rule_for_common_edge,
      sauter_quad_rule.quad_rule_for_common_vertex,
      sauter_quad_rule.quad_rule_for_regular);

    bem_values.fill_shape_function_value_tables();

    /**
     * Create data structure for parallel matrix assembly.
     *
     * \alert{Since @p scratch_data and @p per_task_data should be copied into
     * each thread and will further be modified in the working
     * function @p assemble_on_one_pair_of_cells, they should be passed by value.}
     */
    PairCellWiseScratchData<dim, spacedim, RangeNumberType> scratch_data(
      dof_handler_for_test_space.get_fe(),
      dof_handler_for_trial_space.get_fe(),
      mappings,
      bem_values);
    PairCellWisePerTaskData<dim, spacedim, RangeNumberType> per_task_data(
      dof_handler_for_test_space.get_fe(),
      dof_handler_for_trial_space.get_fe());

    for (const auto &e : dof_handler_for_test_space.active_cell_iterators())
      {
        /**
         * Calculate Kx related data so that they won't be redundantly
         * calculated within @p sauter_quadrature_on_one_pair_of_cells.
         */
        const unsigned int kx_mapping_index =
          material_id_to_mapping_index.at(e->material_id());
        MappingInfo<dim, spacedim> &kx_mapping_info =
          *mappings[kx_mapping_index];

        kx_mapping_info.get_mapping().compute_mapping_support_points(e);
        scratch_data.kx_mapping_support_points_in_default_order =
          kx_mapping_info.get_mapping().get_support_points();
        e->get_dof_indices(
          scratch_data.kx_local_dof_indices_in_default_dof_order);

        /**
         * Apply parallelization to the inner loop.
         *
         * \alert{@p bem_values will not be modified inside the working
         * function, so it is safe to pass it by const reference in the call of
         * @p std::bind.}
         */
        WorkStream::run(
          dof_handler_for_trial_space.begin_active(),
          dof_handler_for_trial_space.end(),
          std::bind(
            static_cast<void (*)(
              const KernelFunctionType<spacedim, RangeNumberType> &,
              const RangeNumberType,
              const typename DoFHandler<dim, spacedim>::active_cell_iterator &,
              const typename DoFHandler<dim, spacedim>::active_cell_iterator &,
              const std::vector<MappingInfo<dim, spacedim> *> &,
              const std::map<types::material_id, unsigned int> &,
              const MappingInfo<dim, spacedim> &,
              const BEMValues<dim, spacedim, RangeNumberType> &,
              const SurfaceNormalDetector &,
              PairCellWiseScratchData<dim, spacedim, RangeNumberType> &,
              PairCellWisePerTaskData<dim, spacedim, RangeNumberType> &,
              const bool)>(
              sauter_quadrature_on_one_pair_of_cells_parallel_over_ky),
            std::cref(kernel),
            factor,
            std::cref(e),
            std::placeholders::_1,
            std::cref(mappings),
            std::cref(material_id_to_mapping_index),
            std::cref(kx_mapping_info),
            std::cref(bem_values),
            std::cref(normal_detector),
            std::placeholders::_2,
            std::placeholders::_3,
            true),
          std::bind(&copy_pair_of_cells_local_to_global_for_bem_full_matrix<
                      dim,
                      spacedim,
                      RangeNumberType,
                      MatrixType>,
                    std::placeholders::_1,
                    std::ref(target_full_matrix)),
          scratch_data,
          per_task_data);
      }

    scratch_data.release();
    per_task_data.release();
  }


  /**
   * Assemble a BEM full matrix in a single thread.
   *
   * @pre
   * @post
   * @tparam dim
   * @tparam spacedim
   * @tparam KernelFunctionType
   * @tparam RangeNumberType
   * @tparam MatrixType
   * @param kernel
   * @param factor
   * @param dof_handler_for_test_space
   * @param dof_handler_for_trial_space
   * @param mappings
   * @param sauter_quad_rule
   * @param target_full_matrix
   */
  template <int dim,
            int spacedim,
            template <int, typename>
            typename KernelFunctionType,
            typename RangeNumberType,
            typename SurfaceNormalDetector,
            typename MatrixType>
  void
  assemble_bem_full_matrix_serial(
    const KernelFunctionType<spacedim, RangeNumberType> &kernel,
    const RangeNumberType                                factor,
    const DoFHandler<dim, spacedim> &dof_handler_for_test_space,
    const DoFHandler<dim, spacedim> &dof_handler_for_trial_space,
    const std::vector<MappingInfo<dim, spacedim> *> &mappings,
    const std::map<types::material_id, unsigned int>
                                    &material_id_to_mapping_index,
    const SurfaceNormalDetector     &normal_detector,
    const SauterQuadratureRule<dim> &sauter_quad_rule,
    MatrixType                      &target_full_matrix)
  {
    /**
     * Precalculate data tables for shape values at quadrature points.
     *
     * \mynote{Precalculate shape function values and their gradient
     * values at each quadrature point. N.B.
     * 1. The data tables for shape function values and their gradient
     * values should be calculated for both function space on
     * \f$K_x\f$ and function space on \f$K_y\f$.
     * 2. Being different from the integral in FEM, the integral in
     * BEM handled by Sauter's quadrature rule has multiple parts of
     * \f$k_3\f$ (except the regular cell neighboring type), each of
     * which should be evaluated at a different set of quadrature
     * points in the unit cell after coordinate transformation from
     * the parametric space. Therefore, an additional dimension with respect to
     * \f$k_3\f$ term index should be added to the data table compared
     * to the usual FEValues and this brings about
     * the class @p BEMValues.
     * 3. In Galerkin BEM, finite elements for the Dirichlet domain
     * and Neumann domain are different. For SLP BEM matrix, both the
     * test function space, to which \f$K_x\f$ belongs, space and the
     * trial function space, to which \f$K_y\f$ belongs, is @p FE_DGQ.
     * For DLP BEM matrix and the mass matrix, the test function space
     * is @p FE_DGQ and the trial function space is @p FE_Q.}
     */
    BEMValues<dim, spacedim, RangeNumberType> bem_values(
      dof_handler_for_test_space.get_fe(),
      dof_handler_for_trial_space.get_fe(),
      mappings,
      sauter_quad_rule.quad_rule_for_same_panel,
      sauter_quad_rule.quad_rule_for_common_edge,
      sauter_quad_rule.quad_rule_for_common_vertex,
      sauter_quad_rule.quad_rule_for_regular);

    bem_values.fill_shape_function_value_tables();

    /**
     * Create data structure for parallel matrix assembly.
     *
     * \alert{Since @p scratch_data and @p per_task_data should be copied into
     * each thread and will further be modified in the working
     * function @p assemble_on_one_pair_of_cells, they should be passed by value.}
     */
    PairCellWiseScratchData<dim, spacedim, RangeNumberType> scratch_data(
      dof_handler_for_test_space.get_fe(),
      dof_handler_for_trial_space.get_fe(),
      mappings,
      bem_values);
    PairCellWisePerTaskData<dim, spacedim, RangeNumberType> per_task_data(
      dof_handler_for_test_space.get_fe(),
      dof_handler_for_trial_space.get_fe());

    for (const auto &e : dof_handler_for_test_space.active_cell_iterators())
      {
        /**
         * Calculate Kx related data so that they won't be redundantly
         * calculated within @p sauter_quadrature_on_one_pair_of_cells.
         */
        const unsigned int kx_mapping_index =
          material_id_to_mapping_index.at(e->material_id());
        MappingInfo<dim, spacedim> &kx_mapping_info =
          *mappings[kx_mapping_index];

        kx_mapping_info.get_mapping().compute_mapping_support_points(e);
        scratch_data.kx_mapping_support_points_in_default_order =
          kx_mapping_info.get_mapping().get_support_points();
        e->get_dof_indices(
          scratch_data.kx_local_dof_indices_in_default_dof_order);

        for (const auto &f :
             dof_handler_for_trial_space.active_cell_iterators())
          {
            const unsigned int ky_mapping_index =
              material_id_to_mapping_index.at(f->material_id());
            MappingInfo<dim, spacedim> &ky_mapping_info =
              *mappings[ky_mapping_index];

            sauter_quadrature_on_one_pair_of_cells(kernel,
                                                   factor,
                                                   e,
                                                   f,
                                                   kx_mapping_info,
                                                   ky_mapping_info,
                                                   bem_values,
                                                   normal_detector,
                                                   scratch_data,
                                                   per_task_data,
                                                   true);

            copy_pair_of_cells_local_to_global_for_bem_full_matrix(
              per_task_data, target_full_matrix);
          }
      }

    scratch_data.release();
    per_task_data.release();
  }


  /**
   * @p ScratchData for assembling the right hand side vector related to a
   * linear form, i.e. \f$\left\langle f, v \right\rangle\f$, where \f$f\f$ is a
   * linear operator and \f$v\f$ is the test function.
   */
  template <int dim, int spacedim = dim>
  struct CellWiseScratchDataForRHSLinearForm
  {
    FEValues<dim, spacedim> fe_values_for_test_space;

    /**
     * Constructor
     *
     * @param fe_for_test_space
     * @param quadrature
     * @param update_flags
     */
    CellWiseScratchDataForRHSLinearForm(
      const FiniteElement<dim, spacedim> &fe_for_test_space,
      const Quadrature<dim>              &quadrature,
      const UpdateFlags                   update_flags)
      : fe_values_for_test_space(fe_for_test_space, quadrature, update_flags)
    {}

    /**
     * Copy constructor
     *
     * \mynote{@p FEValues class itself does not have a copy constructor, thus
     * it cannot be copied but should be reconstructed from the input object.}
     *
     * @param scratch_data
     */
    CellWiseScratchDataForRHSLinearForm(
      const CellWiseScratchDataForRHSLinearForm<dim, spacedim> &scratch_data)
      : fe_values_for_test_space(
          scratch_data.fe_values_for_test_space.get_fe(),
          scratch_data.fe_values_for_test_space.get_quadrature(),
          scratch_data.fe_values_for_test_space.get_update_flags())
    {}
  };


  /**
   * @p CopyData for assembling the right hand side vector related to a linear
   * form, i.e. \f$\left\langle f, v \right\rangle\f$, where \f$f\f$ is a linear
   * operator and \f$v\f$ is the test function.
   */
  template <int dim, int spacedim = dim, typename RangeNumberType = double>
  struct CellWiseCopyDataForRHSLinearForm
  {
    /**
     * The local right hand side vector related to the DoFs in the current cell.
     */
    Vector<RangeNumberType> local_rhs_vector;

    /**
     * \mynote{Memory should be preallocated for this vector before calling
     * <code>get_dof_indices</code>.}
     */
    std::vector<types::global_dof_index> local_dof_indices_for_test_space;

    /**
     * Constructor
     *
     * @param fe_for_test_space
     */
    CellWiseCopyDataForRHSLinearForm(
      const FiniteElement<dim, spacedim> &fe_for_test_space)
      : local_rhs_vector(fe_for_test_space.dofs_per_cell)
      , local_dof_indices_for_test_space(fe_for_test_space.dofs_per_cell)
    {}

    /**
     * Copy constructor
     *
     * @param copy_data
     */
    CellWiseCopyDataForRHSLinearForm(
      const CellWiseCopyDataForRHSLinearForm<dim, spacedim, RangeNumberType>
        &copy_data)
      : local_rhs_vector(copy_data.local_rhs_vector)
      , local_dof_indices_for_test_space(
          copy_data.local_dof_indices_for_test_space)
    {}
  };


  /**
   * Assemble the RHS linear form vector on a local cell, which will be the
   * working function in the parallel assembly process. This version computes
   * the quadrature points in the real cell, at which the linear operator is to
   * be evaluated.
   *
   * @param f The linear operator on the right hand side
   * @param cell_iter
   * @param scratch_data
   * @param copy_data
   */
  template <int dim, int spacedim = dim, typename RangeNumberType = double>
  void
  local_assemble_rhs_linear_form_vector(
    const Function<spacedim, RangeNumberType>                      &f,
    const typename DoFHandler<dim, spacedim>::active_cell_iterator &cell_iter,
    CellWiseScratchDataForRHSLinearForm<dim, spacedim> &scratch_data,
    CellWiseCopyDataForRHSLinearForm<dim, spacedim, RangeNumberType> &copy_data)
  {
    scratch_data.fe_values_for_test_space.reinit(cell_iter);

    const unsigned int n_q_points =
      scratch_data.fe_values_for_test_space.get_quadrature().size();

    const unsigned int dofs_per_cell =
      scratch_data.fe_values_for_test_space.get_fe().dofs_per_cell;

    copy_data.local_rhs_vector.reinit(dofs_per_cell);

    for (unsigned int q = 0; q < n_q_points; q++)
      {
        for (unsigned int i = 0; i < dofs_per_cell; i++)
          {
            copy_data.local_rhs_vector(i) +=
              scratch_data.fe_values_for_test_space.shape_value(i, q) *
              f(scratch_data.fe_values_for_test_space.quadrature_point(q)) *
              scratch_data.fe_values_for_test_space.JxW(q);
          }
      }

    cell_iter->get_dof_indices(copy_data.local_dof_indices_for_test_space);
  }


  /**
   * Assemble the RHS linear form vector on a local cell, which will be the
   * working function in the parallel assembly process. In this version, the
   * linear functional \f$f\f$ is a constant, which does not need computation of
   * the quadrature point coordinates in the real cell.
   *
   * @param f The value of the constant function
   * @param cell_iter
   * @param scratch_data
   * @param copy_data
   */
  template <int dim, int spacedim = dim, typename RangeNumberType = double>
  void
  local_assemble_const_rhs_linear_form_vector(
    const RangeNumberType                                           f,
    const typename DoFHandler<dim, spacedim>::active_cell_iterator &cell_iter,
    CellWiseScratchDataForRHSLinearForm<dim, spacedim> &scratch_data,
    CellWiseCopyDataForRHSLinearForm<dim, spacedim, RangeNumberType> &copy_data)
  {
    scratch_data.fe_values_for_test_space.reinit(cell_iter);

    const unsigned int n_q_points =
      scratch_data.fe_values_for_test_space.get_quadrature().size();

    const unsigned int dofs_per_cell =
      scratch_data.fe_values_for_test_space.get_fe().dofs_per_cell;

    copy_data.local_rhs_vector.reinit(dofs_per_cell);

    for (unsigned int q = 0; q < n_q_points; q++)
      {
        for (unsigned int i = 0; i < dofs_per_cell; i++)
          {
            copy_data.local_rhs_vector(i) +=
              scratch_data.fe_values_for_test_space.shape_value(i, q) * f *
              scratch_data.fe_values_for_test_space.JxW(q);
          }
      }

    cell_iter->get_dof_indices(copy_data.local_dof_indices_for_test_space);
  }


  /**
   * Copy the RHS linear form vector on a local cell to the global vector.
   *
   * @param copy_data
   * @param rhs_vector
   */
  template <int dim,
            int spacedim,
            typename RangeNumberType,
            typename VectorType>
  void
  copy_cell_local_to_global_rhs_linear_form_vector(
    const CellWiseCopyDataForRHSLinearForm<dim, spacedim, RangeNumberType>
               &copy_data,
    VectorType &rhs_vector)
  {
    AssertDimension(copy_data.local_dof_indices_for_test_space.size(),
                    copy_data.local_rhs_vector.size());

    rhs_vector.add(copy_data.local_dof_indices_for_test_space,
                   copy_data.local_rhs_vector);
  }


  /**
   * Assemble the RHS linear form vector with respect to the linear operator
   * \f$f\f$. This version computes the quadrature points in the real cell, at
   * which the linear operator \f$f\f$ is to be evaluated.
   *
   * @param f
   * @param dof_handler_for_test_space
   * @param quad_rule
   * @param rhs_vector
   */
  template <int dim,
            int spacedim,
            typename RangeNumberType,
            typename VectorType>
  void
  assemble_rhs_linear_form_vector(
    const Function<spacedim, RangeNumberType> &f,
    const DoFHandler<dim, spacedim>           &dof_handler_for_test_space,
    const Quadrature<dim>                     &quad_rule,
    VectorType                                &rhs_vector)
  {
    WorkStream::run(
      dof_handler_for_test_space.begin_active(),
      dof_handler_for_test_space.end(),
      std::bind(
        &local_assemble_rhs_linear_form_vector<dim, spacedim, RangeNumberType>,
        f,
        std::placeholders::_1,
        std::placeholders::_2,
        std::placeholders::_3),
      std::bind(&copy_cell_local_to_global_rhs_linear_form_vector,
                std::placeholders::_1,
                std::ref(rhs_vector)),
      CellWiseScratchDataForRHSLinearForm<dim, spacedim>(
        dof_handler_for_test_space.get_fe(),
        quad_rule,
        update_values | update_JxW_values | update_quadrature_points),
      CellWiseCopyDataForRHSLinearForm<dim, spacedim, RangeNumberType>(
        dof_handler_for_test_space.get_fe()));
  }


  /**
   * Assemble the RHS linear form vector with respect to the linear operator
   * \f$f\f$. In this version, the linear functional \f$f\f$ is a constant,
   * which does not need computation of the quadrature point coordinates in the
   * real cell.
   *
   * @param f
   * @param dof_handler_for_test_space
   * @param quad_rule
   * @param rhs_vector
   */
  template <int dim,
            int spacedim,
            typename RangeNumberType,
            typename VectorType>
  void
  assemble_rhs_linear_form_vector(
    const RangeNumberType            f,
    const DoFHandler<dim, spacedim> &dof_handler_for_test_space,
    const Quadrature<dim>           &quad_rule,
    VectorType                      &rhs_vector)
  {
    WorkStream::run(
      dof_handler_for_test_space.begin_active(),
      dof_handler_for_test_space.end(),
      std::bind(&local_assemble_const_rhs_linear_form_vector<dim,
                                                             spacedim,
                                                             RangeNumberType>,
                f,
                std::placeholders::_1,
                std::placeholders::_2,
                std::placeholders::_3),
      std::bind(&copy_cell_local_to_global_rhs_linear_form_vector<
                  dim,
                  spacedim,
                  RangeNumberType,
                  Vector<RangeNumberType>>,
                std::placeholders::_1,
                std::ref(rhs_vector)),
      CellWiseScratchDataForRHSLinearForm<dim, spacedim>(
        dof_handler_for_test_space.get_fe(),
        quad_rule,
        update_values | update_JxW_values),
      CellWiseCopyDataForRHSLinearForm<dim, spacedim, RangeNumberType>(
        dof_handler_for_test_space.get_fe()));
  }


  /**
   * Evaluate the integral of the product of the given kernel function and the
   * list of basis functions on the current cell.
   *
   * @param kernel
   * @param target_point
   * @param factor
   * @param cell_iter
   * @param mapping
   * @param is_normal_vector_negated
   * @param scratch
   * @param data
   */
  template <int dim,
            int spacedim,
            template <int, typename>
            typename KernelFunctionType,
            typename RangeNumberType>
  void
  evaluate_potential_on_one_cell(
    const KernelFunctionType<spacedim, RangeNumberType> &kernel,
    const Point<spacedim, RangeNumberType>              &target_point,
    const RangeNumberType                                factor,
    const typename DoFHandler<dim, spacedim>::active_cell_iterator &cell_iter,
    const bool is_normal_vector_negated,
    CellWiseScratchDataForPotentialEval<dim, spacedim, RangeNumberType>
      &scratch,
    CellWisePerTaskDataForPotentialEval<dim, spacedim, RangeNumberType> &data)
  {
    /**
     * Clear the local result vector.
     */
    data.local_vector.reinit(data.local_dof_indices_for_trial_space.size());

    /**
     * Reinitialize the @p FEValues object for the trial space on the current
     * cell.
     */
    scratch.fe_values_for_trial_space.reinit(cell_iter);

    const unsigned int n_q_points =
      scratch.fe_values_for_trial_space.get_quadrature().size();

    const unsigned int dofs_per_cell =
      scratch.fe_values_for_trial_space.get_fe().dofs_per_cell;

    /**
     * Iterate over each quadrature point.
     */
    for (unsigned int q = 0; q < n_q_points; q++)
      {
        /**
         * Evaluate the kernel function at the target point (for \f$x\f$) and
         * the current quadrature point (for \f$y\f$), i.e. only the \f$y\f$
         * coordinates are pulled back to the unit cell.
         *
         * \mynote{When calculating the potential at a target point, only the
         * normal vector on \f$K_y\f$ is needed. Therefore, the normal vector
         * on \f$K_x\f$ passed to the kernel function can be arbitrary.}
         */
        RangeNumberType scaled_kernel_value =
          kernel.value(target_point,
                       scratch.fe_values_for_trial_space.quadrature_point(q),
                       Tensor<1, spacedim>(),
                       (is_normal_vector_negated ? -1.0 : 1.0) *
                         scratch.fe_values_for_trial_space.normal_vector(q)) *
          factor;

        /**
         * Iterate over each shape function.
         */
        for (unsigned int i = 0; i < dofs_per_cell; i++)
          {
            data.local_vector(i) +=
              scaled_kernel_value *
              scratch.fe_values_for_trial_space.shape_value(i, q) *
              scratch.fe_values_for_trial_space.JxW(q);
          }
      }

    /**
     * Extract DoF indices on the cell.
     */
    cell_iter->get_dof_indices(data.local_dof_indices_for_trial_space);
  }


  template <int dim,
            int spacedim,
            typename RangeNumberType,
            typename VectorType>
  void
  copy_cell_local_to_global_for_potential_eval(
    const CellWisePerTaskDataForPotentialEval<dim, spacedim, RangeNumberType>
               &copy_data,
    VectorType &result_vector)
  {
    AssertDimension(copy_data.local_dof_indices_for_trial_space.size(),
                    copy_data.local_vector.size());

    result_vector.add(copy_data.local_dof_indices_for_trial_space,
                      copy_data.local_vector);
  }


  /**
   * Evaluate the potential values in the spatial domain at a list of target
   * points using the representation formula derived from the direct method.
   *
   * \f[
   * u(x) = -\int_{\Gamma} \widetilde{\gamma}_{1,y} G(x,y) \gamma_0^{\rm int}
   * u(y) \intd s_y + \int_{\Gamma} G(x,y) \widetilde{\gamma}_{1,y} u(y) \intd
   * s_y
   * \]
   *
   * @param kernel
   * @param factor
   * @param dof_handler_for_trial_space DoF handler related to either the
   * Dirichlet data or Neumann data on the boundary.
   * @param dof_values_in_trial_space DoF values related to either the
   * Dirichlet data or Neumann data on the boundary.
   * @param mapping
   * @param is_normal_vector_negated When the boundary surface mesh is
   * extracted from a volume mesh and an exterior problem is solved, this flag
   * should be true.
   * @param point_list
   * @param potential_values
   */
  template <int dim,
            int spacedim,
            template <int, typename>
            typename KernelFunctionType,
            typename RangeNumberType,
            typename VectorType>
  void
  evaluate_potential_at_points(
    const KernelFunctionType<spacedim, RangeNumberType> &kernel,
    const RangeNumberType                                factor,
    const DoFHandler<dim, spacedim> &dof_handler_for_trial_space,
    const VectorType                &dof_values_in_trial_space,
    const bool                       is_normal_vector_negated,
    const std::vector<Point<spacedim, RangeNumberType>> &target_point_list,
    VectorType                                          &potential_values)
  {
    AssertDimension(target_point_list.size(), potential_values.size());

    const FiniteElement<dim, spacedim> &fe =
      dof_handler_for_trial_space.get_fe();

    const types::global_dof_index n_dofs = dof_handler_for_trial_space.n_dofs();
    VectorType                    kernel_evaluation_discretized_to_dofs(n_dofs);

    QGauss<dim> quad_rule(fe.degree + 1);

    /**
     * Iterate over each target point.
     */
    const unsigned int n_target_points = target_point_list.size();

    for (unsigned int i = 0; i < n_target_points; i++)
      {
        kernel_evaluation_discretized_to_dofs.reinit(n_dofs);

        WorkStream::run(
          dof_handler_for_trial_space.begin_active(),
          dof_handler_for_trial_space.end(),
          std::bind(
            &evaluate_potential_on_one_cell<dim, spacedim, RangeNumberType>,
            std::cref(kernel),
            std::cref(target_point_list[i]),
            factor,
            std::placeholders::_1,
            is_normal_vector_negated,
            std::placeholders::_2,
            std::placeholders::_3),
          std::bind(
            &copy_cell_local_to_global_for_potential_eval<dim,
                                                          spacedim,
                                                          RangeNumberType,
                                                          VectorType>,
            std::placeholders::_1,
            std::ref(kernel_evaluation_discretized_to_dofs)),
          CellWiseScratchDataForPotentialEval<dim, spacedim, RangeNumberType>(
            fe,
            quad_rule,
            update_quadrature_points | update_values | update_JxW_values |
              update_normal_vectors),
          CellWisePerTaskDataForPotentialEval<dim, spacedim, RangeNumberType>(
            fe));

        /**
         * Calculate the inner product of the kernel evaluation and DoF values.
         * N.B. The implementation here appends the results to the result
         * vector, so that a single vector can accumulate the contribution from
         * both the single layer and double layer potentials.
         */
        potential_values(i) +=
          kernel_evaluation_discretized_to_dofs * dof_values_in_trial_space;
      }
  }
} // namespace HierBEM


#endif /* INCLUDE_BEM_GENERAL_H_ */
