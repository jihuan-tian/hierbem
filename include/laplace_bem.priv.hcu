#ifndef HIERBEM_INCLUDE_LAPLACE_BEM_PRIV_H_
#define HIERBEM_INCLUDE_LAPLACE_BEM_PRIV_H_

#include <deal.II/base/exceptions.h>
#include <deal.II/base/function.h>
#include <deal.II/base/logstream.h>
#include <deal.II/base/memory_consumption.h>
#include <deal.II/base/numbers.h>
#include <deal.II/base/point.h>
#include <deal.II/base/quadrature_lib.h>
#include <deal.II/base/subscriptor.h>
#include <deal.II/base/table_handler.h>
#include <deal.II/base/timer.h>
#include <deal.II/base/types.h>

#include <deal.II/dofs/dof_accessor.h>
#include <deal.II/dofs/dof_handler.h>

#include <deal.II/fe/fe.h>
#include <deal.II/fe/fe_data.h>
#include <deal.II/fe/fe_dgq.h>
#include <deal.II/fe/fe_q.h>
#include <deal.II/fe/fe_tools.h>
#include <deal.II/fe/fe_values.h>

#include <deal.II/grid/grid_generator.h>
#include <deal.II/grid/grid_in.h>
#include <deal.II/grid/grid_out.h>
#include <deal.II/grid/manifold_lib.h>
#include <deal.II/grid/tria.h>

#include <deal.II/lac/dynamic_sparsity_pattern.h>
#include <deal.II/lac/full_matrix.templates.h>
#include <deal.II/lac/precondition.h>
#include <deal.II/lac/sparse_matrix.h>
#include <deal.II/lac/sparsity_pattern.h>
#include <deal.II/lac/vector_operations_internal.h>

#include <deal.II/numerics/data_out.h>
#include <deal.II/numerics/vector_tools.h>
#include <deal.II/numerics/vector_tools_interpolate.templates.h>

#include <algorithm>
#include <array>
#include <cmath>
#include <iostream>
#include <iterator>
#include <set>
#include <type_traits>
#include <vector>

#include "bem_general.hcu"
#include "bem_tools.h"
#include "bem_values.hcu"
#include "block_cluster_tree.h"
#include "cluster_tree.h"
#include "config.h"
#include "cu_profile.hcu"
#include "cuda_complex.hcu"
#include "data_out_ext.h"
#include "debug_tools.h"
#include "gmsh_manipulation.h"
#include "grid_out_ext.h"
#include "hmatrix/aca_plus/aca_config.h"
#include "hmatrix/aca_plus/aca_plus.hcu"
#include "hmatrix/hblockmatrix_skew_symm.h"
#include "hmatrix/hmatrix.h"
#include "hmatrix/hmatrix_parameters.h"
#include "hmatrix/preconditioner/hblockmatrix_skew_symm_preconditioner.h"
#include "hmatrix/preconditioner/hmatrix_symm_preconditioner.h"
#include "laplace_bem.h"
#include "linalg.h"
#include "mapping/mapping_info.h"
#include "platform_shared/laplace_kernels.h"
#include "preconditioners/preconditioner_for_laplace_dirichlet.h"
#include "preconditioners/preconditioner_for_laplace_neumann.h"
#include "quadrature.templates.h"
#include "read_octave_data.h"
#include "solvers/solve_hblockmatrix_skew_symm.h"
#include "solvers/solver_bicgstab_general.h"
#include "solvers/solver_cg_general.h"
#include "subdomain_topology.h"
#include "triangulation_tools.h"
#include "unary_template_arg_containers.h"

HBEM_NS_OPEN

using namespace dealii;

template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
class LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv
{
public:
  using real_type = typename numbers::NumberTraits<RangeNumberType>::real_type;
  // Here we define number types to be used on the device. When the original
  // number types are real values, they are the same on the device. When the
  // number types are complex values, we use our own complex type instead of
  // @p std::complex .
  using CUDAKernelNumberType =
    std::conditional_t<std::is_floating_point_v<KernelNumberType>,
                       KernelNumberType,
                       complex<real_type>>;

#pragma region == == Internal class ctor and dtor decls == ==
  Priv();
  Priv(unsigned int fe_order_for_dirichlet_space,
       unsigned int fe_order_for_neumann_space,
       ProblemType  problem_type,
       bool         is_interior_problem,
       unsigned int thread_num);
  Priv(unsigned int fe_order_for_dirichlet_space,
       unsigned int fe_order_for_neumann_space,
       ProblemType  problem_type,
       bool         is_interior_problem,
       unsigned int n_min_for_ct,
       unsigned int n_min_for_bct,
       real_type    eta,
       unsigned int max_hmat_rank,
       real_type    aca_relative_error,
       real_type    eta_for_preconditioner,
       unsigned int max_hmat_rank_for_preconditioner,
       real_type    aca_relative_error_for_preconditioner,
       unsigned int thread_num);
  ~Priv();

#pragma endregion

#pragma region == == Internal class public member function decls == ==
  /*
  The actual implementations of LaplaceBEM public member functions are placed
  here instead of in the LaplaceBEM class itself, in order to prevent redudant
  indirect reference of private members through the private pointer.

  The corresponding public member functions in the LaplaceBEM class are just
  wrappers to call the actual implementations in this class.
  */

  void
  extract_surface_triangulation(
    const Triangulation<dim + 1, spacedim> &volume_triangulation,
    Triangulation<dim, spacedim>          &&surf_tria,
    const bool                              debug = false);

  void
  setup_system();

  void
  assign_dirichlet_bc(Function<spacedim, RangeNumberType> &f,
                      const EntityTag                      surface_tag = -1);

  void
  assign_dirichlet_bc(Function<spacedim, RangeNumberType> &f,
                      const std::vector<EntityTag>        &surface_tags);

  void
  assign_neumann_bc(Function<spacedim, RangeNumberType> &f,
                    const EntityTag                      surface_tag = -1);

  void
  assign_neumann_bc(Function<spacedim, RangeNumberType> &f,
                    const std::vector<EntityTag>        &surface_tags);

  bool
  validate_subdomain_topology() const;

  void
  initialize_manifolds_from_manifold_description();

  void
  initialize_mappings();

  void
  interpolate_dirichlet_bc();

  void
  interpolate_neumann_bc();

  void
  assemble_full_matrix_system();

  void
  assemble_hmatrix_system();

  void
  assemble_hmatrix_preconditioner();

  void
  solve();

  void
  output_results() const;

  void
  output_potential_at_target_points() const;

  void
  run();

  void
  print_memory_consumption_table(std::ostream &out) const;

#pragma endregion

private:
#pragma region == == Internal class private member function decls == ==

  void
  collect_cell_iterators();

  /**
   * Compute the stabilization vectors and factor for the full matrix of the
   * hypersingular operator D.
   *
   * Procedures
   * 1. Build the mass matrix which maps from the Neumann to Dirichlet
   * space.
   * 2. Solve the natural density. In the complex valued case, the
   * natural density will be conjugated.
   * 3. Compute the stabilization factor.
   * 4. Compute the stabilization vectors in the internal DoF numbering. Each
   * stabilization vector is the product of the mass matrix and a natural
   * density vector. The formal outer (without complex conjugation) product of
   * each stabilization vector with itself will be appended into the Galerkin
   * matrix for the hypersingular operator.
   */
  void
  compute_stabilization_terms_for_D1_fullmat();

  /**
   * Compute the stabilization vectors and factor for the H-matrix of the
   * hypersingular operator D.
   *
   * Procedures
   * 1. Build the mass matrix which maps from the Neumann to Dirichlet
   * space.
   * 2. Solve the natural density. In the complex valued case, the
   * natural density will be conjugated.
   * 3. Compute the stabilization factor.
   * 4. Compute the stabilization vectors in the internal DoF numbering. Each
   * stabilization vector is the product of the mass matrix and a natural
   * density vector. The formal outer (without complex conjugation) product of
   * each stabilization vector with itself will be appended into the Galerkin
   * matrix for the hypersingular operator.
   */
  void
  compute_stabilization_terms_for_D1_hmat();

  /**
   * Initialize the header string for each column.
   */
  void
  initialize_memory_consumption_table_headers();

  /**
   * Add a row to the memory consumption table.
   *
   * Memory consumption is measured in MB.
   *
   * @param name
   * @param obj
   */
  template <typename T>
  void
  add_memory_consumption_row(const std::string &name,
                             const T           &obj,
                             const std::string &comment = std::string(""));
#pragma endregion

#pragma region == == Internal class private member variable decls == ==
  friend class LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>;

  std::string project_name_;

  /**
   * Finite element order for the Dirichlet space.
   */
  unsigned int fe_order_for_dirichlet_space_;

  /**
   * Finite element order for the Neumann space.
   */
  unsigned int fe_order_for_neumann_space_;

  /**
   * Laplace problem type to be solved.
   */
  ProblemType problem_type_;

  /**
   * Whether the problem is interior or exterior.
   */
  bool is_interior_problem_;

  /**
   * Number of threads
   */
  unsigned int thread_num_;

  /**
   * Triangulation for the surface mesh.
   */
  Triangulation<dim, spacedim> tria_;

  /**
   * Multigrid triangulation used in operator preconditioners.
   */
  Triangulation<dim, spacedim> mg_tria_for_preconditioner_;

  /**
   * A list of mapping objects from 1st to 3rd order.
   */
  std::vector<MappingInfo<dim, spacedim> *> mappings_;

  /**
   * Map surface entity tag to manifold id. At the moment, the material for
   * each surface is the same as the entity tag in Gmsh.
   */
  std::map<EntityTag, types::manifold_id> manifold_description_;

  /**
   * Map @p manifold_id to the pointer of a Manifold object.
   */
  std::map<types::manifold_id, Manifold<dim, spacedim> *> manifolds_;

  /**
   * Map @p manifold_id to mapping order.
   */
  std::map<types::manifold_id, unsigned int> manifold_id_to_mapping_order_;

  /**
   * Map @p material_id to mapping index.
   */
  std::map<types::material_id, unsigned int> material_id_to_mapping_index_;

  /**
   * Surface-to-volume and volume-to-surface relationship.
   */
  SubdomainTopology<dim, spacedim> subdomain_topology_;

  /**
   * Finite element \f$H^{\frac{1}{2}+s}\f$ for the Dirichlet space. At
   * present, it is implemented as a continuous Lagrange space.
   */
  FE_Q<dim, spacedim> fe_for_dirichlet_space_;
  /**
   * Finite element \f$H^{-\frac{1}{2}+s}\f$ for the Neumann space. At
   * present, it is implemented as a discontinuous Lagrange space.
   */
  FE_DGQ<dim, spacedim> fe_for_neumann_space_;

  /**
   * Definition of DoFHandlers for a series of combination of finite element
   * spaces and triangulations.
   */
  DoFHandler<dim, spacedim> dof_handler_for_dirichlet_space_;
  DoFHandler<dim, spacedim> dof_handler_for_neumann_space_;

  /**
   * Map from the selected DoF indices to the complete indices in the DoF
   * handler for the Dirichlet space. Only effective
   * in the mixed boundary value problem.
   */
  std::vector<types::global_dof_index>
    local_to_full_dirichlet_dof_indices_on_dirichlet_domain_;

  /**
   * Map from the selected DoF indices to the complete indices in the DoF
   * handler for the Dirichlet space. Only effective
   * in the mixed boundary value problem.
   */
  std::vector<types::global_dof_index>
    local_to_full_dirichlet_dof_indices_on_neumann_domain_;

  std::vector<types::global_dof_index>
    local_to_full_neumann_dof_indices_on_dirichlet_domain_;

  std::vector<types::global_dof_index>
    local_to_full_neumann_dof_indices_on_neumann_domain_;

  /**
   * A list of Boolean flags indicating if each DoF is selected in the
   * Dirichlet space on the Dirichlet domain.
   */
  std::vector<bool> dof_selectors_for_dirichlet_space_on_dirichlet_domain_;

  /**
   * A list of Boolean flags indicating if each DoF is selected in the
   * Dirichlet space on the Neumann domain.
   */
  std::vector<bool> dof_selectors_for_dirichlet_space_on_neumann_domain_;
  std::vector<bool> dof_selectors_for_neumann_space_on_dirichlet_domain_;
  std::vector<bool> dof_selectors_for_neumann_space_on_neumann_domain_;

  /**
   * Map from external DoF indices to internal indices and from internal
   * indices to external indices.
   */
  const std::vector<types::global_dof_index>
    *dof_e2i_numbering_for_dirichlet_space_on_dirichlet_domain_;
  const std::vector<types::global_dof_index>
    *dof_i2e_numbering_for_dirichlet_space_on_dirichlet_domain_;
  const std::vector<types::global_dof_index>
    *dof_e2i_numbering_for_dirichlet_space_on_neumann_domain_;
  const std::vector<types::global_dof_index>
    *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_;
  const std::vector<types::global_dof_index>
    *dof_e2i_numbering_for_neumann_space_on_dirichlet_domain_;
  const std::vector<types::global_dof_index>
    *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_;
  const std::vector<types::global_dof_index>
    *dof_e2i_numbering_for_neumann_space_on_neumann_domain_;
  const std::vector<types::global_dof_index>
    *dof_i2e_numbering_for_neumann_space_on_neumann_domain_;

  std::vector<typename DoFHandler<dim, spacedim>::cell_iterator>
    cell_iterators_for_dirichlet_space_;
  std::vector<typename DoFHandler<dim, spacedim>::cell_iterator>
    cell_iterators_for_neumann_space_;

  /**
   * DoF-to-cell topologies for various DoF handlers, which are used for
   * matrix assembly on a pair of DoFs.
   */
  DoFToCellTopology<dim, spacedim> dof_to_cell_topo_for_dirichlet_space_;
  DoFToCellTopology<dim, spacedim> dof_to_cell_topo_for_neumann_space_;

  /**
   * Kernel function for the single layer potential on the host.
   */
  PlatformShared::LaplaceKernel::SingleLayerKernel<spacedim, KernelNumberType>
    single_layer_kernel_cpu_;
  /**
   * Kernel function for the double layer potential on the host.
   */
  PlatformShared::LaplaceKernel::DoubleLayerKernel<spacedim, KernelNumberType>
    double_layer_kernel_cpu_;
  /**
   * Kernel function for the adjoint double layer potential on the host.
   */
  PlatformShared::LaplaceKernel::AdjointDoubleLayerKernel<spacedim,
                                                          KernelNumberType>
    adjoint_double_layer_kernel_cpu_;
  /**
   * Kernel function for the hyper-singular potential on the host.
   */
  PlatformShared::LaplaceKernel::HyperSingularKernelRegular<spacedim,
                                                            KernelNumberType>
    hyper_singular_kernel_cpu_;

  /**
   * Kernel function for the single layer potential on the device.
   */
  PlatformShared::LaplaceKernel::SingleLayerKernel<spacedim,
                                                   CUDAKernelNumberType>
    single_layer_kernel_gpu_;
  /**
   * Kernel function for the double layer potential on the device.
   */
  PlatformShared::LaplaceKernel::DoubleLayerKernel<spacedim,
                                                   CUDAKernelNumberType>
    double_layer_kernel_gpu_;
  /**
   * Kernel function for the adjoint double layer potential on the device.
   */
  PlatformShared::LaplaceKernel::AdjointDoubleLayerKernel<spacedim,
                                                          CUDAKernelNumberType>
    adjoint_double_layer_kernel_gpu_;
  /**
   * Kernel function for the hyper-singular potential on the device.
   */
  PlatformShared::LaplaceKernel::
    HyperSingularKernelRegular<spacedim, CUDAKernelNumberType>
      hyper_singular_kernel_gpu_;

  /**
   * Full matrices for verification purpose.
   */
  LAPACKFullMatrixExt<RangeNumberType> V1_matrix_;
  LAPACKFullMatrixExt<RangeNumberType> K1_matrix_;
  LAPACKFullMatrixExt<RangeNumberType> K_prime1_matrix_;
  LAPACKFullMatrixExt<RangeNumberType> D1_matrix_;
  LAPACKFullMatrixExt<RangeNumberType> K2_matrix_with_mass_matrix_;
  LAPACKFullMatrixExt<RangeNumberType> V2_matrix_;
  LAPACKFullMatrixExt<RangeNumberType> D2_matrix_;
  LAPACKFullMatrixExt<RangeNumberType> K_prime2_matrix_with_mass_matrix_;

  /**
   * Whether \hmatrix is used.
   */
  bool use_hmat_;

  /**
   * Whether run in a single thread on CPU.
   */
  bool cpu_serial_;

  /**
   * Cluster trees
   */
  ClusterTree<spacedim, real_type> ct_for_dirichlet_space_on_dirichlet_domain_;
  ClusterTree<spacedim, real_type> ct_for_neumann_space_on_dirichlet_domain_;
  ClusterTree<spacedim, real_type> ct_for_dirichlet_space_on_neumann_domain_;
  ClusterTree<spacedim, real_type> ct_for_neumann_space_on_neumann_domain_;

  /**
   * Block cluster trees corresponding to discretized bilinear forms in
   * the mixed boundary value problem, which contain all possible cases.
   * \f[
   * \begin{equation}
   * \begin{pmatrix}
   *  -\mathscr{V} & \mathscr{K} \\ \mathscr{K}' & \mathscr{D} \end{pmatrix}
   * \begin{pmatrix}
   *  t \big\vert_{\Gamma_{\rm D}} \\ u \big\vert_{\Gamma_{\rm N}}
   * \end{pmatrix}= \begin{pmatrix}
   *  -\frac{1}{2}\mathscr{I} - \mathscr{K} & \mathscr{V} \\ \mathscr{-D} &
   * \frac{1}{2}\mathscr{I} - \mathscr{K}' \end{pmatrix} \begin{pmatrix} g_D
   * \\ g_N \end{pmatrix} \end{equation} \f]
   * @p V1, @p K1, @p K_prime1 and @p D1 correspond to matrix blocks on the
   * left. @p K2, @p V2, @p D2 and @p K_prime2 correspond to matrix blocks
   * on the right.
   */
  BlockClusterTree<spacedim, real_type> bct_for_bilinear_form_V1_;
  BlockClusterTree<spacedim, real_type> bct_for_bilinear_form_K1_;
  BlockClusterTree<spacedim, real_type> bct_for_bilinear_form_K_prime1_;
  BlockClusterTree<spacedim, real_type> bct_for_bilinear_form_D1_;
  BlockClusterTree<spacedim, real_type> bct_for_bilinear_form_V2_;
  BlockClusterTree<spacedim, real_type> bct_for_bilinear_form_K2_;
  BlockClusterTree<spacedim, real_type> bct_for_bilinear_form_K_prime2_;
  BlockClusterTree<spacedim, real_type> bct_for_bilinear_form_D2_;

  /**
   * \hmatrices corresponding to discretized bilinear forms in the
   * mixed boundary value problem, which contain all possible cases.
   */
  HMatrix<spacedim, RangeNumberType> V1_hmat_;
  HMatrix<spacedim, RangeNumberType> K1_hmat_;
  HMatrix<spacedim, RangeNumberType> K_prime1_hmat_;
  HMatrix<spacedim, RangeNumberType> D1_hmat_;
  HMatrix<spacedim, RangeNumberType> V2_hmat_;
  HMatrix<spacedim, RangeNumberType> K2_hmat_with_mass_matrix_;
  HMatrix<spacedim, RangeNumberType> K_prime2_hmat_with_mass_matrix_;
  HMatrix<spacedim, RangeNumberType> D2_hmat_;
  HBlockMatrixSkewSymm<spacedim, RangeNumberType> M_hmat_;

  /**
   * Preconditioners
   */
  HMatrixSymmPreconditioner<spacedim, RangeNumberType> V1_hmat_preconditioner_;
  HMatrixSymmPreconditioner<spacedim, RangeNumberType> D1_hmat_preconditioner_;
  HMatrix<spacedim, RangeNumberType>                   M11_in_preconditioner_;
  HMatrix<spacedim, RangeNumberType>                   M12_in_preconditioner_;
  HMatrix<spacedim, RangeNumberType>                   M22_in_preconditioner_;
  HBlockMatrixSkewSymmPreconditioner<spacedim, RangeNumberType>
    M_hmat_preconditioner_;

  /**
   * The sequence of all DoF indices with the values \f$0, 1, \cdots\f$ for
   * different DoFHandlers.
   */
  std::vector<types::global_dof_index>
    dof_indices_for_dirichlet_space_on_dirichlet_domain_;
  std::vector<types::global_dof_index>
    dof_indices_for_neumann_space_on_dirichlet_domain_;
  std::vector<types::global_dof_index>
    dof_indices_for_dirichlet_space_on_neumann_domain_;
  std::vector<types::global_dof_index>
    dof_indices_for_neumann_space_on_neumann_domain_;

  /**
   * The list of all support points associated with @p dof_indices held
   * within different DoF handlers.
   */
  std::vector<Point<spacedim, real_type>>
    support_points_for_dirichlet_space_on_dirichlet_domain_;
  std::vector<Point<spacedim, real_type>>
    support_points_for_dirichlet_space_on_neumann_domain_;
  std::vector<Point<spacedim, real_type>>
    support_points_for_neumann_space_on_dirichlet_domain_;
  std::vector<Point<spacedim, real_type>>
    support_points_for_neumann_space_on_neumann_domain_;

  /**
   * Estimated average cell size values associated with @p dof_indices held
   * within different DoF handlers.
   */
  std::vector<real_type>
    dof_average_cell_size_for_dirichlet_space_on_dirichlet_domain_;
  std::vector<real_type>
    dof_average_cell_size_for_neumann_space_on_dirichlet_domain_;
  std::vector<real_type>
    dof_average_cell_size_for_dirichlet_space_on_neumann_domain_;
  std::vector<real_type>
    dof_average_cell_size_for_neumann_space_on_neumann_domain_;

  /**
   * Minimum cluster size. At present, assume all \bcts share this same
   * parameter.
   */
  unsigned int n_min_for_ct_;
  /**
   * Minimum block cluster size. At present, assume all \bcts share this
   * same parameter.
   */
  unsigned int n_min_for_bct_;
  /**
   * Admissibility constant. At present, assume all \bcts share this same
   * parameter.
   */
  real_type eta_;
  /**
   * Maximum rank of the \hmatrices to be built. At present, assume all
   * \hmatrices share this same parameter.
   */
  unsigned int max_hmat_rank_;
  /**
   * Relative approximation error used in ACA+. At present, assume all
   * \hmatrices share this same parameter.
   */
  real_type aca_relative_error_;
  /**
   * Admissibility constant for the preconditioner.
   */
  real_type eta_for_preconditioner_;
  /**
   * Maximum rank of the \hmatrices to be built for the preconditioner.
   */
  unsigned int max_hmat_rank_for_preconditioner_;
  /**
   * Relative approximation error used in ACA+ for the preconditioner.
   */
  real_type aca_relative_error_for_preconditioner_;

  /**
   * Map surface entity tag to Neumann boundary condition.
   */
  std::map<EntityTag, Function<spacedim, RangeNumberType> *>
    neumann_bc_definition_;

  /**
   * Neumann boundary condition data on all DoFs in the associated DoF
   * handler. When in the \hmat version, they are in the external DoF
   * numbering.
   */
  Vector<RangeNumberType> neumann_bc_;
  Vector<RangeNumberType> neumann_bc_on_selected_dofs_;
  /**
   * Neumann boundary condition data on all DoFs in the associated DoF handler
   * in the internal DoF numbering. Only used in the \hmat version.
   */
  Vector<RangeNumberType> neumann_bc_internal_dof_numbering_;

  /**
   * The free parameter \f$\alpha\f$ in the variational formulation of the
   * Laplace problem with Neumann boundary condition.
   */
  KernelNumberType alpha_for_neumann_;

  /**
   * Map surface entity tag to Dirichlet boundary condition.
   */
  std::map<EntityTag, Function<spacedim, RangeNumberType> *>
    dirichlet_bc_definition_;

  /**
   * Dirichlet boundary condition data on all DoFs in the associated DoF
   * handler.
   */
  Vector<RangeNumberType> dirichlet_bc_;
  /**
   * Dirichlet boundary condition data on those selected DoFs in the
   * associated DoF handler. When in the \hmat version, they are in the
   * external DoF numbering.
   */
  Vector<RangeNumberType> dirichlet_bc_on_selected_dofs_;
  /**
   * Dirichlet boundary condition data on those selected DoFs in the
   * associated DoF handler in the internal DoF numbering. Only used in the
   * \hmat version.
   */
  Vector<RangeNumberType> dirichlet_bc_internal_dof_numbering_;

  /**
   * Right hand side vector on the Dirichlet domain. When in the \hmat
   * version, it is in the internal DoF numbering.
   */
  Vector<RangeNumberType> system_rhs_on_dirichlet_domain_;
  /**
   * Right hand side vector on the Neumann domain. When in the \hmat version,
   * it is in the internal DoF numbering.
   */
  Vector<RangeNumberType> system_rhs_on_neumann_domain_;
  /**
   * Right hand side vector on both the Dirichlet domain and Neumann domain.
   * Only used in the mixed boundary value problem.
   */
  Vector<RangeNumberType> system_rhs_on_combined_domain_;

  /**
   * A list of stabilization vectors for the hypersingular operator, which is
   * the multiplication of the mass matrix and the natural density \f$w_{\rm
   * eq}\f$.
   *
   * \alert{Because the outer product of this vector with itself will be added
   * to the hyper singular matrix \f$\mathcal{D}\f$, when \f$\mathcal{D}\f$ is
   * an \hmat, it adopts the internal DoF numbering.}
   */
  std::vector<Vector<KernelNumberType>> mass_vmult_weq_;

  /**
   * Numerical solution on the Dirichlet domain for full matrix version or in
   * the external DoF numbering for the \hmat version.
   */
  Vector<RangeNumberType> neumann_data_;
  /**
   * Numerical solution on the Dirichlet domain in the internal DoF numbering.
   * Only used in the \hmat version.
   */
  Vector<RangeNumberType>
    neumann_data_on_dirichlet_domain_internal_dof_numbering_;
  /**
   * Numerical solution on the Neumann domain on all DoFs in the associated
   * DoF handler.
   */
  Vector<RangeNumberType> dirichlet_data_;
  /**
   * Numerical solution on the Neumann domain only on those selected DoFs in
   * the associated DoF handler. When in the \hmat version, they are in the
   * external DoF numbering.
   */
  Vector<RangeNumberType> dirichlet_data_on_neumann_domain_;
  Vector<RangeNumberType> neumann_data_on_dirichlet_domain_;
  /**
   * Numerical solution on the Neumann domain only on those selected DoFs in
   * the associated DoF handler in the internal DoF numbering. Only used in
   * the \hmat version.
   */
  Vector<RangeNumberType>
    dirichlet_data_on_neumann_domain_internal_dof_numbering_;
  /**
   * Solution vector on both the Dirichlet domain and Neumann domain. Only
   * used in the mixed boundary value problem and in the \hmat version.
   */
  Vector<RangeNumberType> solution_on_combined_domain_internal_dof_numbering_;

  /**
   * Analytical solution on the Dirichlet domain.
   */
  Vector<RangeNumberType> analytical_solution_on_dirichlet_domain_;
  /**
   * Analytical solution on the Neumann domain.
   */
  Vector<RangeNumberType> analytical_solution_on_neumann_domain_;

  /**
   * Type of the preconditioner.
   */
  PreconditionerType preconditioner_type_;

  /**
   * Operator preconditioner for Dirichlet problem, either on the whole domain
   * or a subdomain.
   */
  PreconditionerForLaplaceDirichlet<dim,
                                    spacedim,
                                    RangeNumberType,
                                    KernelNumberType>
    *operator_preconditioner_dirichlet_;

  /**
   * Operator preconditioner for Neumann problem, either on the whole domain or
   * a subdomain.
   */
  PreconditionerForLaplaceNeumann<dim,
                                  spacedim,
                                  RangeNumberType,
                                  KernelNumberType>
    *operator_preconditioner_neumann_;

  /**
   * Memory consumption table
   */
  TableHandler memory_consumption_table_;
#pragma endregion

#pragma region == == Internal class friend function decls == ==
  template <int dim1,
            int spacedim1,
            typename RangeNumberType1,
            typename MatrixType>
  friend void
  assemble_fem_scaled_mass_matrix(
    const DoFHandler<dim1, spacedim1> &dof_handler_for_test_space,
    const DoFHandler<dim1, spacedim1> &dof_handler_for_trial_space,
    const RangeNumberType1             factor,
    const Quadrature<dim1>            &quad_rule,
    MatrixType                        &target_full_matrix);

  template <int dim1,
            int spacedim1,
            typename RangeNumberType1,
            typename MatrixType>
  friend void
  assemble_fem_scaled_mass_matrix_serial(
    const DoFHandler<dim1, spacedim1> &dof_handler_for_test_space,
    const DoFHandler<dim1, spacedim1> &dof_handler_for_trial_space,
    const RangeNumberType1             factor,
    const Quadrature<dim1>            &quad_rule,
    MatrixType                        &target_full_matrix);

  template <int dim1,
            int spacedim1,
            template <int, typename> typename KernelFunctionType,
            typename KernelNumberType1,
            typename SurfaceNormalDetector,
            typename MatrixType>
  friend void
  assemble_bem_full_matrix(
    const KernelFunctionType<spacedim1, KernelNumberType1> &kernel,
    const KernelNumberType1                                 factor,
    const DoFHandler<dim1, spacedim1> &dof_handler_for_test_space,
    const DoFHandler<dim1, spacedim1> &dof_handler_for_trial_space,
    const std::vector<MappingInfo<dim1, spacedim1> *> &mappings,
    const std::map<types::material_id, unsigned int>
                                     &material_id_to_mapping_index,
    const SurfaceNormalDetector      &normal_detector,
    const SauterQuadratureRule<dim1> &sauter_quad_rule,
    MatrixType                       &target_full_matrix);

  template <int dim1,
            int spacedim1,
            template <int, typename> typename KernelFunctionType,
            typename KernelNumberType1,
            typename SurfaceNormalDetector,
            typename MatrixType>
  friend void
  assemble_bem_full_matrix_serial(
    const KernelFunctionType<spacedim1, KernelNumberType1> &kernel,
    const KernelNumberType1                                 factor,
    const DoFHandler<dim1, spacedim1> &dof_handler_for_test_space,
    const DoFHandler<dim1, spacedim1> &dof_handler_for_trial_space,
    const std::vector<MappingInfo<dim1, spacedim1> *> &mappings,
    const std::map<types::material_id, unsigned int>
                                     &material_id_to_mapping_order,
    const SurfaceNormalDetector      &normal_detector,
    const SauterQuadratureRule<dim1> &sauter_quad_rule,
    MatrixType                       &target_full_matrix);
#pragma endregion
};

#pragma region ****Internal ctor and dtor impls ****

template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::Priv()
  : project_name_("default")
  , fe_order_for_dirichlet_space_(0)
  , fe_order_for_neumann_space_(0)
  , problem_type_(UndefinedProblem)
  , is_interior_problem_(true)
  , thread_num_(0)
  , tria_(Triangulation<dim, spacedim>::MeshSmoothing::
            limit_level_difference_at_vertices)
  , mg_tria_for_preconditioner_(Triangulation<dim, spacedim>::MeshSmoothing::
                                  limit_level_difference_at_vertices)
  , fe_for_dirichlet_space_(0)
  , fe_for_neumann_space_(0)
  , dof_e2i_numbering_for_dirichlet_space_on_dirichlet_domain_(nullptr)
  , dof_i2e_numbering_for_dirichlet_space_on_dirichlet_domain_(nullptr)
  , dof_e2i_numbering_for_dirichlet_space_on_neumann_domain_(nullptr)
  , dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_(nullptr)
  , dof_e2i_numbering_for_neumann_space_on_dirichlet_domain_(nullptr)
  , dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_(nullptr)
  , dof_e2i_numbering_for_neumann_space_on_neumann_domain_(nullptr)
  , dof_i2e_numbering_for_neumann_space_on_neumann_domain_(nullptr)
  , use_hmat_(false)
  , cpu_serial_(false)
  , n_min_for_ct_(0)
  , n_min_for_bct_(0) // By default, it is the same as the @p n_min_for_ct
  , eta_(0)
  , max_hmat_rank_(0)
  , aca_relative_error_(0)
  , eta_for_preconditioner_(0)
  , max_hmat_rank_for_preconditioner_(0)
  , aca_relative_error_for_preconditioner_(0)
  , alpha_for_neumann_(1.0)
  , preconditioner_type_(PreconditionerType::HMatrixFactorization)
  , operator_preconditioner_dirichlet_(nullptr)
  , operator_preconditioner_neumann_(nullptr)
{}

template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::Priv(
  unsigned int fe_order_for_dirichlet_space,
  unsigned int fe_order_for_neumann_space,
  ProblemType  problem_type,
  bool         is_interior_problem,
  unsigned int thread_num)
  : project_name_("default")
  , fe_order_for_dirichlet_space_(fe_order_for_dirichlet_space)
  , fe_order_for_neumann_space_(fe_order_for_neumann_space)
  , problem_type_(problem_type)
  , is_interior_problem_(is_interior_problem)
  , thread_num_(thread_num)
  , tria_(Triangulation<dim, spacedim>::MeshSmoothing::
            limit_level_difference_at_vertices)
  , mg_tria_for_preconditioner_(Triangulation<dim, spacedim>::MeshSmoothing::
                                  limit_level_difference_at_vertices)
  , fe_for_dirichlet_space_(fe_order_for_dirichlet_space)
  , fe_for_neumann_space_(fe_order_for_neumann_space)
  , dof_e2i_numbering_for_dirichlet_space_on_dirichlet_domain_(nullptr)
  , dof_i2e_numbering_for_dirichlet_space_on_dirichlet_domain_(nullptr)
  , dof_e2i_numbering_for_dirichlet_space_on_neumann_domain_(nullptr)
  , dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_(nullptr)
  , dof_e2i_numbering_for_neumann_space_on_dirichlet_domain_(nullptr)
  , dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_(nullptr)
  , dof_e2i_numbering_for_neumann_space_on_neumann_domain_(nullptr)
  , dof_i2e_numbering_for_neumann_space_on_neumann_domain_(nullptr)
  , use_hmat_(false)
  , cpu_serial_(false)
  , n_min_for_ct_(0)
  , n_min_for_bct_(0) // By default, it is the same as the @p n_min_for_ct
  , eta_(0)
  , max_hmat_rank_(0)
  , aca_relative_error_(0)
  , eta_for_preconditioner_(0)
  , max_hmat_rank_for_preconditioner_(0)
  , aca_relative_error_for_preconditioner_(0)
  , alpha_for_neumann_(1.0)
  , preconditioner_type_(PreconditionerType::HMatrixFactorization)
  , operator_preconditioner_dirichlet_(nullptr)
  , operator_preconditioner_neumann_(nullptr)
{}

template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::Priv(
  unsigned int fe_order_for_dirichlet_space,
  unsigned int fe_order_for_neumann_space,
  ProblemType  problem_type,
  bool         is_interior_problem,
  unsigned int n_min_for_ct,
  unsigned int n_min_for_bct,
  real_type    eta,
  unsigned int max_hmat_rank,
  real_type    aca_relative_error,
  real_type    eta_for_preconditioner,
  unsigned int max_hmat_rank_for_preconditioner,
  real_type    aca_relative_error_for_preconditioner,
  unsigned int thread_num)
  : project_name_("default")
  , fe_order_for_dirichlet_space_(fe_order_for_dirichlet_space)
  , fe_order_for_neumann_space_(fe_order_for_neumann_space)
  , problem_type_(problem_type)
  , is_interior_problem_(is_interior_problem)
  , thread_num_(thread_num)
  , tria_(Triangulation<dim, spacedim>::MeshSmoothing::
            limit_level_difference_at_vertices)
  , mg_tria_for_preconditioner_(Triangulation<dim, spacedim>::MeshSmoothing::
                                  limit_level_difference_at_vertices)
  , fe_for_dirichlet_space_(fe_order_for_dirichlet_space)
  , fe_for_neumann_space_(fe_order_for_neumann_space)
  , dof_e2i_numbering_for_dirichlet_space_on_dirichlet_domain_(nullptr)
  , dof_i2e_numbering_for_dirichlet_space_on_dirichlet_domain_(nullptr)
  , dof_e2i_numbering_for_dirichlet_space_on_neumann_domain_(nullptr)
  , dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_(nullptr)
  , dof_e2i_numbering_for_neumann_space_on_dirichlet_domain_(nullptr)
  , dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_(nullptr)
  , dof_e2i_numbering_for_neumann_space_on_neumann_domain_(nullptr)
  , dof_i2e_numbering_for_neumann_space_on_neumann_domain_(nullptr)
  , use_hmat_(true)
  , cpu_serial_(false)
  , n_min_for_ct_(n_min_for_ct)
  , n_min_for_bct_(
      n_min_for_bct) // By default, it is the same as the @p n_min_for_ct
  , eta_(eta)
  , max_hmat_rank_(max_hmat_rank)
  , aca_relative_error_(aca_relative_error)
  , eta_for_preconditioner_(eta_for_preconditioner)
  , max_hmat_rank_for_preconditioner_(max_hmat_rank_for_preconditioner)
  , aca_relative_error_for_preconditioner_(
      aca_relative_error_for_preconditioner)
  , alpha_for_neumann_(1.0)
  , preconditioner_type_(PreconditionerType::HMatrixFactorization)
  , operator_preconditioner_dirichlet_(nullptr)
  , operator_preconditioner_neumann_(nullptr)
{}

template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::~Priv()
{
  dof_handler_for_dirichlet_space_.clear();
  dof_handler_for_neumann_space_.clear();

  local_to_full_dirichlet_dof_indices_on_dirichlet_domain_.clear();
  local_to_full_dirichlet_dof_indices_on_neumann_domain_.clear();
  local_to_full_neumann_dof_indices_on_dirichlet_domain_.clear();
  local_to_full_dirichlet_dof_indices_on_neumann_domain_.clear();

  dof_e2i_numbering_for_dirichlet_space_on_dirichlet_domain_ = nullptr;
  dof_i2e_numbering_for_dirichlet_space_on_dirichlet_domain_ = nullptr;
  dof_e2i_numbering_for_dirichlet_space_on_neumann_domain_   = nullptr;
  dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_   = nullptr;
  dof_e2i_numbering_for_neumann_space_on_dirichlet_domain_   = nullptr;
  dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_   = nullptr;
  dof_e2i_numbering_for_neumann_space_on_neumann_domain_     = nullptr;
  dof_i2e_numbering_for_neumann_space_on_neumann_domain_     = nullptr;

  if (operator_preconditioner_dirichlet_ != nullptr)
    {
      delete operator_preconditioner_dirichlet_;
      operator_preconditioner_dirichlet_ = nullptr;
    }

  if (operator_preconditioner_neumann_ != nullptr)
    {
      delete operator_preconditioner_neumann_;
      operator_preconditioner_neumann_ = nullptr;
    }

  // Release manifold objects.
  for (auto &m : manifolds_)
    {
      delete m.second;
    }

  // Release mapping objects.
  for (auto m : mappings_)
    {
      delete m;
    }
}

#pragma endregion
#pragma region ****Internal private member function impls ****

template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  collect_cell_iterators()
{
  cell_iterators_for_dirichlet_space_.reserve(
    dof_handler_for_dirichlet_space_.get_triangulation().n_active_cells());
  for (const auto &cell :
       dof_handler_for_dirichlet_space_.active_cell_iterators())
    {
      cell_iterators_for_dirichlet_space_.push_back(cell);
    }

  cell_iterators_for_neumann_space_.reserve(
    dof_handler_for_neumann_space_.get_triangulation().n_active_cells());
  for (const auto &cell :
       dof_handler_for_neumann_space_.active_cell_iterators())
    {
      cell_iterators_for_neumann_space_.push_back(cell);
    }
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  compute_stabilization_terms_for_D1_fullmat()
{
  const types::global_dof_index n_dofs_for_dirichlet_space =
    dof_handler_for_dirichlet_space_.n_dofs();
  const types::global_dof_index n_dofs_for_neumann_space =
    dof_handler_for_neumann_space_.n_dofs();

  // Create the mass matrix mapping from the Neumann space to the Dirichlet
  // space.
  SparsityPattern         M_sp;
  SparseMatrix<real_type> M;
  DynamicSparsityPattern  M_dsp(n_dofs_for_dirichlet_space,
                               n_dofs_for_neumann_space);
  DoFTools::make_sparsity_pattern(dof_handler_for_dirichlet_space_,
                                  dof_handler_for_neumann_space_,
                                  M_dsp);
  M_sp.copy_from(M_dsp);
  M.reinit(M_sp);
  assemble_fem_scaled_mass_matrix(dof_handler_for_dirichlet_space_,
                                  dof_handler_for_neumann_space_,
                                  real_type(1.0),
                                  QGauss<dim>(fe_for_dirichlet_space_.degree +
                                              1),
                                  M);

  const unsigned int n_boundary_components =
    subdomain_topology_.get_subdomain_to_surface().size();

  // Initialize stabilization vectors.
  mass_vmult_weq_.resize(n_boundary_components);
  for (auto &vec : mass_vmult_weq_)
    vec.reinit(n_dofs_for_dirichlet_space);

#if HBEM_NEUMANN_SOLUTION_SPACE == 1
  std::cout << "=== Assemble V for solving natural density ===" << std::endl;

  LAPACKFullMatrixExt<KernelNumberType> V(n_dofs_for_neumann_space,
                                          n_dofs_for_neumann_space);
  assemble_bem_full_matrix<dim,
                           spacedim,
                           PlatformShared::LaplaceKernel::SingleLayerKernel,
                           KernelNumberType,
                           SurfaceNormalDetector<dim, spacedim>,
                           LAPACKFullMatrixExt<KernelNumberType>>(
    single_layer_kernel_cpu_,
    KernelNumberType(1.0),
    dof_handler_for_neumann_space_,
    dof_handler_for_neumann_space_,
    mappings_,
    material_id_to_mapping_index_,
    SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
    SauterQuadratureRule<dim>(5, 4, 4, 3),
    V);

  // Natural density vector in the Neumann space \f$H^{-1/2}{\Gamma}\f$.
  Vector<KernelNumberType> natural_density(n_dofs_for_neumann_space);

  // Boundary indicator vectors \f$\{\chi_k\}_{k=1}^r\f$ as RHS vectors in the
  // operator equation \f$Vw_{\mathrm{eq},k}=\chi_k\f$. They are in the
  // Dirichlet space (primal space) and have the strong form.
  std::vector<Vector<real_type>> boundary_indicators(n_boundary_components);
  for (auto &vec : boundary_indicators)
    vec.reinit(n_dofs_for_dirichlet_space);

  // Interpolate the boundary indicator vectors in the Dirichlet space.
  interpolate_indicator_vectors_for_subdomains(dof_handler_for_dirichlet_space_,
                                               subdomain_topology_,
                                               mappings_,
                                               material_id_to_mapping_index_,
                                               boundary_indicators);

  // RHS vector in the variational equation \f$\langle Vw_{\mathrm{eq},k},v
  // \rangle_{\Gamma}=\langle \chi_k,v \rangle\f$. It is in the Neumann space
  // (dual space) and has the weak form.
  Vector<KernelNumberType> rhs(n_dofs_for_neumann_space);

  // Initialize the stabilization factor, which will be the average of the
  // optimal values for all boundary components.
  alpha_for_neumann_ = KernelNumberType(0.);
  for (unsigned int i = 0; i < n_boundary_components; i++)
    {
      // Assemble the rhs vector for solving the current natural density on the
      // i-th boundary component.
      M.Tvmult(rhs, boundary_indicators[i]);

      // Solve the natural density \f$w_{\rm eq}\f$.
      SolverControl solver_control(1000, 1e-6, true, true);
      SolverCGGeneral<Vector<KernelNumberType>> solver(solver_control);

      // At the moment, we can only use identity preconditioner.
      Assert(preconditioner_type_ == PreconditionerType::Identity,
             ExcInternalError());

      natural_density.reinit(n_dofs_for_neumann_space);
      solver.solve(V, natural_density, rhs, PreconditionIdentity());

      // Apply complex conjugation to the natural density in the complex valued
      // case.
      if constexpr (numbers::NumberTraits<KernelNumberType>::is_complex)
        LinAlg::conjugate_vector(natural_density);

      // Compute the stabilization vector.
      M.vmult(mass_vmult_weq_[i], natural_density);

      // Calculate the optimal stabilization factor for the current natural
      // density.
      alpha_for_neumann_ +=
        1.0 / 4.0 / LinAlg::linear_combination_tbb(rhs, natural_density);
    }
  // The stabilization factors for different natural densities are averaged.
  alpha_for_neumann_ /= n_boundary_components;

#elif HBEM_NEUMANN_SOLUTION_SPACE == 2
  // Boundary indicator vectors \f$\{\chi_k\}_{k=1}^r\f$ in the stabilization
  // term \f$\langle u,\chi_k \rangle_{\Gamma}\f$. They are in the Neumann space
  // (dual space) and have the weak form.
  std::vector<Vector<real_type>> boundary_indicators(n_boundary_components);
  for (auto &vec : boundary_indicators)
    vec.reinit(n_dofs_for_neumann_space);

  // Interpolate the boundary indicator vectors in the Neumann space.
  interpolate_indicator_vectors_for_subdomains(dof_handler_for_neumann_space_,
                                               subdomain_topology_,
                                               mappings_,
                                               material_id_to_mapping_index_,
                                               boundary_indicators);
  // Compute the stabilization vectors.
  for (unsigned int i = 0; i < n_boundary_components; i++)
    M.vmult(mass_vmult_weq_[i], boundary_indicators[i]);

  // The stabilization factor \f$\alpha\f$ is set to 1.
  // TODO: Use the average eigenvalue of the matrix D as the stabilization
  // factor.
  alpha_for_neumann_ = KernelNumberType(1.0);
#endif

  std::cout << "Neumann stabilization factor: " << alpha_for_neumann_
            << std::endl;
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  compute_stabilization_terms_for_D1_hmat()
{
  const types::global_dof_index n_dofs_for_dirichlet_space =
    dof_handler_for_dirichlet_space_.n_dofs();
  const types::global_dof_index n_dofs_for_neumann_space =
    dof_handler_for_neumann_space_.n_dofs();

  // Create the mass matrix mapping from the Neumann space to the Dirichlet
  // space.
  SparsityPattern         M_sp;
  SparseMatrix<real_type> M;
  DynamicSparsityPattern  M_dsp(n_dofs_for_dirichlet_space,
                               n_dofs_for_neumann_space);
  DoFTools::make_sparsity_pattern(dof_handler_for_dirichlet_space_,
                                  dof_handler_for_neumann_space_,
                                  M_dsp);
  M_sp.copy_from(M_dsp);
  M.reinit(M_sp);
  assemble_fem_scaled_mass_matrix(dof_handler_for_dirichlet_space_,
                                  dof_handler_for_neumann_space_,
                                  real_type(1.0),
                                  QGauss<dim>(fe_for_dirichlet_space_.degree +
                                              1),
                                  M);

  const unsigned int n_boundary_components =
    subdomain_topology_.get_subdomain_to_surface().size();

  // Initialize stabilization vectors.
  mass_vmult_weq_.resize(n_boundary_components);
  for (auto &vec : mass_vmult_weq_)
    vec.reinit(n_dofs_for_dirichlet_space);

  Vector<KernelNumberType> mass_vmult_weq_external_numbering(
    n_dofs_for_dirichlet_space);

#if HBEM_NEUMANN_SOLUTION_SPACE == 1
  std::cout << "=== Assemble V for solving natural density ===" << std::endl;

  bct_for_bilinear_form_V1_ = BlockClusterTree<spacedim, real_type>(
    ct_for_neumann_space_on_neumann_domain_,
    ct_for_neumann_space_on_neumann_domain_,
    eta_,
    n_min_for_bct_);
  bct_for_bilinear_form_V1_.partition(
    *dof_i2e_numbering_for_neumann_space_on_neumann_domain_,
    support_points_for_neumann_space_on_neumann_domain_,
    dof_average_cell_size_for_neumann_space_on_neumann_domain_);
  add_memory_consumption_row("Block cluster tree for V1",
                             bct_for_bilinear_form_V1_);

  HMatrix<spacedim, KernelNumberType> V(
    bct_for_bilinear_form_V1_,
    max_hmat_rank_,
    HMatrixSupport::Property::symmetric,
    HMatrixSupport::BlockType::diagonal_block);

  std::cout << "=== Leaf set information of V ===" << std::endl;
  V.print_leaf_set_info(std::cout);

  add_memory_consumption_row("V H-matrix for weq",
                             V,
                             "After initialization and before assembly");

  ACAConfig<real_type> aca_config(max_hmat_rank_, aca_relative_error_, eta_);

  // N.B. For the H-matrix V for solving the natural density, RangeNumberType
  // for the underlying matrix and vectors is the same as KernelNumberType,
  // which is enough.
  fill_hmatrix_with_aca_plus_smp<
    dim,
    spacedim,
    PlatformShared::LaplaceKernel::SingleLayerKernel,
    KernelNumberType,
    KernelNumberType,
    SurfaceNormalDetector<dim, spacedim>>(
    thread_num_,
    V,
    aca_config,
    single_layer_kernel_gpu_,
    CUDAKernelNumberType(1.0),
    dof_to_cell_topo_for_neumann_space_,
    dof_to_cell_topo_for_neumann_space_,
    SauterQuadratureRule<dim>(5, 4, 4, 3),
    dof_handler_for_neumann_space_,
    dof_handler_for_neumann_space_,
    nullptr,
    nullptr,
    *dof_i2e_numbering_for_neumann_space_on_neumann_domain_,
    *dof_i2e_numbering_for_neumann_space_on_neumann_domain_,
    mappings_,
    material_id_to_mapping_index_,
    SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
    true);

  add_memory_consumption_row("V H-matrix for weq", V, "After assembly");

  HMatrixSymmPreconditioner<spacedim, KernelNumberType> V_precond;
  if (preconditioner_type_ == PreconditionerType::HMatrixFactorization)
    {
      // Build the H-Cholesky preconditioner for @p V when H-matrix is used.
      // TODO: At the moment, we only allow KernelNumberType is real value for
      // this case, because complex valued H-matrix factorization has not
      // been implemented yet.
      static_assert(std::is_same<KernelNumberType, double>::value ||
                    std::is_same<KernelNumberType, float>::value);

      std::cout
        << "=== Assemble V H-matrix preconditioner for solving natural density ==="
        << std::endl;

      V_precond = V;
      V_precond.truncate_to_rank_preserve_positive_definite(
        max_hmat_rank_for_preconditioner_);

      add_memory_consumption_row("V H-matrix preconditioner for weq",
                                 V_precond,
                                 "After assembly");

      /**
       * Perform Cholesky factorisation of the preconditioner. Only when the
       * preconditioner @p V_precond has a hierarchical structure,
       * i.e. it does not contain a root node only, the task parallel
       * Cholesky factorization will be used.
       */
      std::cout
        << "=== Cholesky factorization of V H-matrix preconditioner for solving natural density ==="
        << std::endl;
      if (V_precond.get_type() == HMatrixType::HierarchicalMatrixType)
        V_precond.compute_cholesky_factorization_task_parallel(
          max_hmat_rank_for_preconditioner_);
      else
        V_precond.compute_cholesky_factorization(
          max_hmat_rank_for_preconditioner_);
    }

  // Natural density vector in the Neumann space \f$H^{-1/2}{\Gamma}\f$.
  Vector<KernelNumberType> natural_density_external_numbering(
    n_dofs_for_neumann_space);
  Vector<KernelNumberType> natural_density_internal_numbering(
    n_dofs_for_neumann_space);

  // Boundary indicator vectors \f$\{\chi_k\}_{k=1}^r\f$ in the external DoF
  // numbering as RHS vectors in the operator equation
  // \f$Vw_{\mathrm{eq},k}=\chi_k\f$. They are in the Dirichlet space (primal
  // space) and have the strong form.
  std::vector<Vector<real_type>> boundary_indicators(n_boundary_components);
  for (auto &vec : boundary_indicators)
    vec.reinit(n_dofs_for_dirichlet_space);

  // Interpolate the boundary indicator vectors in the Dirichlet space.
  interpolate_indicator_vectors_for_subdomains(dof_handler_for_dirichlet_space_,
                                               subdomain_topology_,
                                               mappings_,
                                               material_id_to_mapping_index_,
                                               boundary_indicators);

  // RHS vector in the internal DoF numbering in the variational equation
  // \f$\langle Vw_{\mathrm{eq},k},v
  // \rangle_{\Gamma}=\langle \chi_k,v \rangle\f$. It is in the Neumann space
  // (dual space) and has the weak form.
  Vector<KernelNumberType> rhs_internal_numbering(n_dofs_for_neumann_space);
  // RHS vector in the external DoF numbering.
  Vector<KernelNumberType> rhs_external_numbering(n_dofs_for_neumann_space);

  // Initialize the stabilization factor, which will be the average of the
  // optimal values for all boundary components.
  alpha_for_neumann_ = KernelNumberType(0.);
  for (unsigned int i = 0; i < n_boundary_components; i++)
    {
      // Assemble the rhs vector for solving the current natural density on the
      // i-th boundary component.
      M.Tvmult(rhs_external_numbering, boundary_indicators[i]);
      permute_vector(rhs_external_numbering,
                     *dof_i2e_numbering_for_neumann_space_on_neumann_domain_,
                     rhs_internal_numbering);

      // Solve the natural density \f$w_{\rm eq}\f$ in the internal DoF
      // numbering.
      SolverControl solver_control(1000, 1e-6, true, true);
      SolverCGGeneral<Vector<KernelNumberType>> solver(solver_control);

      natural_density_internal_numbering.reinit(n_dofs_for_neumann_space);
      switch (preconditioner_type_)
        {
            case PreconditionerType::HMatrixFactorization: {
              solver.solve(V,
                           natural_density_internal_numbering,
                           rhs_internal_numbering,
                           V_precond);
              break;
            }
            case PreconditionerType::Identity: {
              solver.solve(V,
                           natural_density_internal_numbering,
                           rhs_internal_numbering,
                           PreconditionIdentity());
              break;
            }
            case PreconditionerType::OperatorPreconditioning: {
              Assert(false, ExcNotImplemented());
              break;
            }
            case PreconditionerType::Jacobi: {
              Assert(false, ExcNotImplemented());
              break;
            }
            default: {
              Assert(false, ExcInternalError());
              break;
            }
        }
      // Convert the natural density from the internal DoF numbering to the
      // external numbering, since it is to be multiplied by the mass matrix
      // mapping the Neumann space to the Dirichlet space, which also adopts the
      // external numbering.
      permute_vector(natural_density_internal_numbering,
                     *dof_e2i_numbering_for_neumann_space_on_neumann_domain_,
                     natural_density_external_numbering);

      // Apply complex conjugation to the natural density in the complex valued
      // case.
      if constexpr (numbers::NumberTraits<KernelNumberType>::is_complex)
        LinAlg::conjugate_vector(natural_density_external_numbering);

      // Compute the stabilization vector.
      M.vmult(mass_vmult_weq_external_numbering,
              natural_density_external_numbering);
      permute_vector(mass_vmult_weq_external_numbering,
                     *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
                     mass_vmult_weq_[i]);

      // Calculate the optimal stabilization factor for the current natural
      // density.
      alpha_for_neumann_ +=
        1.0 / 4.0 /
        LinAlg::linear_combination_tbb(rhs_external_numbering,
                                       natural_density_external_numbering);
    }
  // The stabilization factors for different natural densities are averaged.
  alpha_for_neumann_ /= n_boundary_components;

#elif HBEM_NEUMANN_SOLUTION_SPACE == 2
  // Boundary indicator vectors \f$\{\chi_k\}_{k=1}^r\f$ in the stabilization
  // term \f$\langle u,\chi_k \rangle_{\Gamma}\f$ They are in the Neumann space
  // (dual space) and have the weak form.
  std::vector<Vector<real_type>> boundary_indicators(n_boundary_components);
  for (auto &vec : boundary_indicators)
    vec.reinit(n_dofs_for_neumann_space);

  // Interpolate the boundary indicator vectors in the Neumann space.
  interpolate_indicator_vectors_for_subdomains(dof_handler_for_neumann_space_,
                                               subdomain_topology_,
                                               mappings_,
                                               material_id_to_mapping_index_,
                                               boundary_indicators);
  // Compute the stabilization vector.
  for (unsigned int i = 0; i < n_boundary_components; i++)
    {
      M.vmult(mass_vmult_weq_external_numbering, boundary_indicators[i]);
      permute_vector(mass_vmult_weq_external_numbering,
                     *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
                     mass_vmult_weq_[i]);
    }

  // The stabilization factor \f$\alpha\f$ is set to 1.
  // TODO: Use the average eigenvalue of the matrix D as the stabilization
  // factor.
  alpha_for_neumann_ = KernelNumberType(1.0);
#endif

  std::cout << "Neumann stabilization factor: " << alpha_for_neumann_
            << std::endl;
}

template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  initialize_memory_consumption_table_headers()
{
  memory_consumption_table_.declare_column("Object");
  memory_consumption_table_.declare_column("Memory (MB)");
  memory_consumption_table_.declare_column("Comment");
}

template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
template <typename T>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  add_memory_consumption_row(const std::string &name,
                             const T           &obj,
                             const std::string &comment)
{
  memory_consumption_table_.start_new_row();
  memory_consumption_table_.add_value("Object", name);
  memory_consumption_table_.add_value(
    "Memory (MB)",
    MemoryConsumption::memory_consumption(obj) / 1024.0 / 1024.0);

  memory_consumption_table_.add_value("Comment", comment);
}

#pragma endregion
#pragma region ****Internal public member function impls ****

template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  extract_surface_triangulation(
    const Triangulation<dim + 1, spacedim> &volume_triangulation,
    Triangulation<dim, spacedim>          &&surf_tria,
    const bool                              debug)
{
  tria_ = std::move(surf_tria);

  GridGenerator::extract_boundary_mesh(volume_triangulation, tria_);

  if (debug)
    {
      std::cout << "=== Surface mesh information ===" << std::endl;
      print_mesh_info(std::cout, tria_);
    }

  add_memory_consumption_row("Surface mesh", tria_);
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  setup_system()
{
  LogStream::Prefix prefix_string("setup_system");
#if ENABLE_NVTX == 1
  HierBEM::CUDAWrappers::NVTXRange nvtx_range("setup_system");
#endif

  Timer timer;
  timer.stop();

  initialize_manifolds_from_manifold_description();
  initialize_mappings();

  switch (problem_type_)
    {
        case DirichletBCProblem: {
          dof_handler_for_dirichlet_space_.reinit(tria_);
          dof_handler_for_dirichlet_space_.distribute_dofs(
            fe_for_dirichlet_space_);
          dof_handler_for_neumann_space_.reinit(tria_);
          dof_handler_for_neumann_space_.distribute_dofs(fe_for_neumann_space_);

          const types::global_dof_index n_dofs_for_dirichlet_space =
            dof_handler_for_dirichlet_space_.n_dofs();
          const types::global_dof_index n_dofs_for_neumann_space =
            dof_handler_for_neumann_space_.n_dofs();

          std::cout << "=== DoF information ===" << std::endl;
          std::cout << "Number of DoFs in Dirichlet space: "
                    << n_dofs_for_dirichlet_space << "\n";
          std::cout << "Number of DoFs in Neumann space: "
                    << n_dofs_for_neumann_space << std::endl;

          if (!use_hmat_)
            {
              /**
               * If full matrices are used for verification purpose,
               * allocate memory for them here.
               */
              V1_matrix_.reinit(n_dofs_for_neumann_space,
                                n_dofs_for_neumann_space);
              K2_matrix_with_mass_matrix_.reinit(n_dofs_for_neumann_space,
                                                 n_dofs_for_dirichlet_space);

              add_memory_consumption_row("V1 full matrix", V1_matrix_);
              add_memory_consumption_row("K2 with mass full matrix",
                                         K2_matrix_with_mass_matrix_);
            }
          else
            {
              /**
               * Build the DoF-to-cell topology.
               */
              timer.start();

              collect_cell_iterators();
              DoFToolsExt::build_dof_to_cell_topology(
                dof_to_cell_topo_for_dirichlet_space_,
                cell_iterators_for_dirichlet_space_,
                dof_handler_for_dirichlet_space_);
              DoFToolsExt::build_dof_to_cell_topology(
                dof_to_cell_topo_for_neumann_space_,
                cell_iterators_for_neumann_space_,
                dof_handler_for_neumann_space_);

              timer.stop();
              print_wall_time(deallog, timer, "build dof-to-cell topology");

              /**
               * Generate lists of DoF indices.
               */
              dof_indices_for_dirichlet_space_on_dirichlet_domain_.resize(
                n_dofs_for_dirichlet_space);
              dof_indices_for_neumann_space_on_dirichlet_domain_.resize(
                n_dofs_for_neumann_space);

              gen_linear_indices<vector_uta, types::global_dof_index>(
                dof_indices_for_dirichlet_space_on_dirichlet_domain_);
              gen_linear_indices<vector_uta, types::global_dof_index>(
                dof_indices_for_neumann_space_on_dirichlet_domain_);

              /**
               * Get the spatial coordinates of the support points. Even
               * though different surfaces may be assigned a manifold which is
               * further associated with a high order mapping, here we only
               * use the first order mapping to generate the support points
               * for finite element shape functions. This is good enough for
               * the partition of cluster trees.
               */
              support_points_for_dirichlet_space_on_dirichlet_domain_.resize(
                n_dofs_for_dirichlet_space);
              DoFToolsExt::map_dofs_to_support_points(
                mappings_[0]->get_mapping(),
                dof_handler_for_dirichlet_space_,
                support_points_for_dirichlet_space_on_dirichlet_domain_);

              support_points_for_neumann_space_on_dirichlet_domain_.resize(
                n_dofs_for_neumann_space);
              // TODO In reality, different subdomains are assigned different
              // mapping objects, which should be handled separately.
              // Furthermore, the Jacobian of the mapping should also be taken
              // into account in numerical quadrature.
              DoFToolsExt::map_dofs_to_support_points(
                mappings_[0]->get_mapping(),
                dof_handler_for_neumann_space_,
                support_points_for_neumann_space_on_dirichlet_domain_);

              /**
               * Calculate the average mesh cell size at each support point.
               */
              dof_average_cell_size_for_dirichlet_space_on_dirichlet_domain_
                .assign(n_dofs_for_dirichlet_space, 0);
              DoFToolsExt::map_dofs_to_average_cell_size(
                dof_handler_for_dirichlet_space_,
                dof_average_cell_size_for_dirichlet_space_on_dirichlet_domain_);

              dof_average_cell_size_for_neumann_space_on_dirichlet_domain_
                .assign(n_dofs_for_neumann_space, 0);
              DoFToolsExt::map_dofs_to_average_cell_size(
                dof_handler_for_neumann_space_,
                dof_average_cell_size_for_neumann_space_on_dirichlet_domain_);

              /**
               * Initialize the cluster trees.
               */
              timer.start();

              ct_for_dirichlet_space_on_dirichlet_domain_ = ClusterTree<
                spacedim,
                real_type>(
                dof_indices_for_dirichlet_space_on_dirichlet_domain_,
                support_points_for_dirichlet_space_on_dirichlet_domain_,
                dof_average_cell_size_for_dirichlet_space_on_dirichlet_domain_,
                n_min_for_ct_);
              ct_for_neumann_space_on_dirichlet_domain_ =
                ClusterTree<spacedim, real_type>(
                  dof_indices_for_neumann_space_on_dirichlet_domain_,
                  support_points_for_neumann_space_on_dirichlet_domain_,
                  dof_average_cell_size_for_neumann_space_on_dirichlet_domain_,
                  n_min_for_ct_);

              /**
               * Partition the cluster trees.
               */
              ct_for_dirichlet_space_on_dirichlet_domain_.partition(
                support_points_for_dirichlet_space_on_dirichlet_domain_,
                dof_average_cell_size_for_dirichlet_space_on_dirichlet_domain_);
              ct_for_neumann_space_on_dirichlet_domain_.partition(
                support_points_for_neumann_space_on_dirichlet_domain_,
                dof_average_cell_size_for_neumann_space_on_dirichlet_domain_);

#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 3
              /**
               * @internal Visualize partitioned mesh on different levels
               * (from level #1 to the maximum level) in the cluster trees.
               */
              std::vector<
                typename ClusterTree<spacedim, real_type>::node_pointer_type>
                cluster_set;
              Vector<float>
                dof_cluster_indices_for_dirichlet_space_on_dirichlet_domain_(
                  n_dofs_for_dirichlet_space);
              Vector<float>
                dof_cluster_indices_for_neumann_space_on_dirichlet_domain_(
                  n_dofs_for_neumann_space);

              std::ofstream
                cluster_level_vtk_for_dirichlet_space_on_dirichlet_domain_;
              std::ofstream
                cluster_level_vtk_for_neumann_space_on_dirichlet_domain_;

              DataOut<dim, spacedim>
                cluster_level_data_out_for_dirichlet_space_on_dirichlet_domain_;
              DataOut<dim, spacedim>
                cluster_level_data_out_for_neumann_space_on_dirichlet_domain_;

              cluster_level_vtk_for_dirichlet_space_on_dirichlet_domain_.open(
                "cluster_levels_for_dirichlet_space_on_dirichlet_domain.vtk",
                std::ofstream::out);
              cluster_level_vtk_for_neumann_space_on_dirichlet_domain_.open(
                "cluster_levels_for_neumann_space_on_dirichlet_domain.vtk",
                std::ofstream::out);

              for (unsigned int l = 1;
                   l <=
                   ct_for_dirichlet_space_on_dirichlet_domain_.get_max_level();
                   l++)
                {
                  ct_for_dirichlet_space_on_dirichlet_domain_
                    .build_cluster_set_at_level(l, cluster_set);
                  /**
                   * @internal Assign the index for each cluster in the
                   * cluster set to its contained DoFs.
                   */
                  for (unsigned int c = 0; c < cluster_set.size(); c++)
                    {
                      const std::array<types::global_dof_index, 2>
                        &cluster_index_range =
                          cluster_set[c]->get_data_pointer()->get_index_range();

                      for (types::global_dof_index dof_index =
                             cluster_index_range[0];
                           dof_index < cluster_index_range[1];
                           dof_index++)
                        {
                          dof_cluster_indices_for_dirichlet_space_on_dirichlet_domain_(
                            ct_for_dirichlet_space_on_dirichlet_domain_
                              .get_internal_to_external_dof_numbering()
                                [dof_index]) = c;
                        }
                    }

                  cluster_level_data_out_for_dirichlet_space_on_dirichlet_domain_
                    .add_data_vector(
                      dof_handler_for_dirichlet_space_,
                      dof_cluster_indices_for_dirichlet_space_on_dirichlet_domain_,
                      std::string(
                        "cluster_for_dirichlet_space_on_dirichlet_domain_on_level_#") +
                        std::to_string(l));
                }

              for (unsigned int l = 1;
                   l <=
                   ct_for_neumann_space_on_dirichlet_domain_.get_max_level();
                   l++)
                {
                  ct_for_neumann_space_on_dirichlet_domain_
                    .build_cluster_set_at_level(l, cluster_set);
                  /**
                   * @internal Assign the index for each cluster in the
                   * cluster set to its contained DoFs.
                   */
                  for (unsigned int c = 0; c < cluster_set.size(); c++)
                    {
                      const std::array<types::global_dof_index, 2>
                        &cluster_index_range =
                          cluster_set[c]->get_data_pointer()->get_index_range();

                      for (types::global_dof_index dof_index =
                             cluster_index_range[0];
                           dof_index < cluster_index_range[1];
                           dof_index++)
                        {
                          dof_cluster_indices_for_neumann_space_on_dirichlet_domain_(
                            ct_for_neumann_space_on_dirichlet_domain_
                              .get_internal_to_external_dof_numbering()
                                [dof_index]) = c;
                        }
                    }

                  cluster_level_data_out_for_neumann_space_on_dirichlet_domain_
                    .add_data_vector(
                      dof_handler_for_neumann_space_,
                      dof_cluster_indices_for_neumann_space_on_dirichlet_domain_,
                      std::string(
                        "cluster_for_neumann_space_on_dirichlet_domain_on_level_#") +
                        std::to_string(l));
                }

              cluster_level_data_out_for_dirichlet_space_on_dirichlet_domain_
                .build_patches();
              cluster_level_data_out_for_neumann_space_on_dirichlet_domain_
                .build_patches();
              cluster_level_data_out_for_dirichlet_space_on_dirichlet_domain_
                .write_vtk(
                  cluster_level_vtk_for_dirichlet_space_on_dirichlet_domain_);
              cluster_level_data_out_for_neumann_space_on_dirichlet_domain_
                .write_vtk(
                  cluster_level_vtk_for_neumann_space_on_dirichlet_domain_);

              cluster_level_vtk_for_dirichlet_space_on_dirichlet_domain_
                .close();
              cluster_level_vtk_for_neumann_space_on_dirichlet_domain_.close();
#endif

              /**
               * Get the external-to-internal and internal-to-external DoF
               * numberings.
               */
              dof_e2i_numbering_for_dirichlet_space_on_dirichlet_domain_ =
                &(ct_for_dirichlet_space_on_dirichlet_domain_
                    .get_external_to_internal_dof_numbering());
              dof_i2e_numbering_for_dirichlet_space_on_dirichlet_domain_ =
                &(ct_for_dirichlet_space_on_dirichlet_domain_
                    .get_internal_to_external_dof_numbering());
              dof_e2i_numbering_for_neumann_space_on_dirichlet_domain_ =
                &(ct_for_neumann_space_on_dirichlet_domain_
                    .get_external_to_internal_dof_numbering());
              dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_ =
                &(ct_for_neumann_space_on_dirichlet_domain_
                    .get_internal_to_external_dof_numbering());

              timer.stop();
              print_wall_time(deallog, timer, "build cluster trees");

              add_memory_consumption_row(
                "Cluster tree for Dirichlet space on Dirichlet domain",
                ct_for_dirichlet_space_on_dirichlet_domain_);
              add_memory_consumption_row(
                "Cluster tree for Neumann space on Dirichlet domain",
                ct_for_neumann_space_on_dirichlet_domain_);

#if ENABLE_DEBUG == 1 && MESSAGE_LEVEL >= 3
              {
                /**
                 * @internal Generate the graph for the cluster tree in the
                 * PlantUML format.
                 */
                std::ofstream ct_dirichlet_space_out(
                  "ct-dirichlet-after-dof-numbering-reorder.puml");
                std::ofstream ct_neumann_space_out(
                  "ct-neumann-after-dof-numbering-reorder.puml");

                ct_for_dirichlet_space_on_dirichlet_domain_
                  .print_tree_info_as_dot(ct_dirichlet_space_out);
                ct_for_neumann_space_on_dirichlet_domain_
                  .print_tree_info_as_dot(ct_neumann_space_out);

                ct_dirichlet_space_out.close();
                ct_neumann_space_out.close();
              }
#endif

              /**
               * Create the block cluster trees.
               */
              timer.start();

              bct_for_bilinear_form_V1_ = BlockClusterTree<spacedim, real_type>(
                ct_for_neumann_space_on_dirichlet_domain_,
                ct_for_neumann_space_on_dirichlet_domain_,
                eta_,
                n_min_for_bct_);
              bct_for_bilinear_form_K2_ = BlockClusterTree<spacedim, real_type>(
                ct_for_neumann_space_on_dirichlet_domain_,
                ct_for_dirichlet_space_on_dirichlet_domain_,
                eta_,
                n_min_for_bct_);

              /**
               * Partition the block cluster trees.
               */
              bct_for_bilinear_form_V1_.partition(
                *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
                support_points_for_neumann_space_on_dirichlet_domain_,
                dof_average_cell_size_for_neumann_space_on_dirichlet_domain_);
              bct_for_bilinear_form_K2_.partition(
                *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
                *dof_i2e_numbering_for_dirichlet_space_on_dirichlet_domain_,
                support_points_for_neumann_space_on_dirichlet_domain_,
                support_points_for_dirichlet_space_on_dirichlet_domain_,
                dof_average_cell_size_for_neumann_space_on_dirichlet_domain_,
                dof_average_cell_size_for_dirichlet_space_on_dirichlet_domain_);

              timer.stop();
              print_wall_time(deallog, timer, "build block cluster trees");

              add_memory_consumption_row("Block cluster tree for V1",
                                         bct_for_bilinear_form_V1_);
              add_memory_consumption_row("Block cluster tree for K2 with mass",
                                         bct_for_bilinear_form_K2_);

              /**
               * Initialize \hmatrices.
               */
              timer.start();

              V1_hmat_ = HMatrix<spacedim, RangeNumberType>(
                bct_for_bilinear_form_V1_,
                max_hmat_rank_,
                HMatrixSupport::Property::symmetric,
                HMatrixSupport::BlockType::diagonal_block);

              std::cout << "=== Leaf set information of V1_hmat ==="
                        << std::endl;
              V1_hmat_.print_leaf_set_info(std::cout);

              K2_hmat_with_mass_matrix_ = HMatrix<spacedim, RangeNumberType>(
                bct_for_bilinear_form_K2_,
                max_hmat_rank_,
                HMatrixSupport::Property::general,
                HMatrixSupport::BlockType::diagonal_block);

              std::cout
                << "=== Leaf set information of K2_hmat_with_mass_matrix ==="
                << std::endl;
              K2_hmat_with_mass_matrix_.print_leaf_set_info(std::cout);

              timer.stop();
              print_wall_time(deallog, timer, "initialize H-matrices");

              add_memory_consumption_row(
                "V1 H-matrix",
                V1_hmat_,
                "After initialization and before assembly");
              add_memory_consumption_row(
                "K2 with mass H-matrix",
                K2_hmat_with_mass_matrix_,
                "After initialization and before assembly");
            }

          /**
           * Interpolate the Dirichlet boundary data.
           */
          timer.start();

          interpolate_dirichlet_bc();

          if (use_hmat_)
            {
              /**
               * Permute the Dirichlet boundary data by following the mapping
               * from internal to external DoF numbering.
               */
              dirichlet_bc_internal_dof_numbering_.reinit(
                n_dofs_for_dirichlet_space);
              permute_vector(
                dirichlet_bc_,
                *dof_i2e_numbering_for_dirichlet_space_on_dirichlet_domain_,
                dirichlet_bc_internal_dof_numbering_);
            }

          timer.stop();
          print_wall_time(deallog, timer, "interpolate boundary condition");

          /**
           * Allocate memory for the right-hand-side vector and solution
           * vector.
           */
          system_rhs_on_dirichlet_domain_.reinit(n_dofs_for_neumann_space);
          neumann_data_.reinit(n_dofs_for_neumann_space);

          if (use_hmat_)
            {
              // Solution vector in the internal numbering.
              neumann_data_on_dirichlet_domain_internal_dof_numbering_.reinit(
                n_dofs_for_neumann_space);
            }

          break;
        }
        case NeumannBCProblem: {
          dof_handler_for_dirichlet_space_.reinit(tria_);
          dof_handler_for_dirichlet_space_.distribute_dofs(
            fe_for_dirichlet_space_);
          dof_handler_for_neumann_space_.reinit(tria_);
          dof_handler_for_neumann_space_.distribute_dofs(fe_for_neumann_space_);

          const types::global_dof_index n_dofs_for_dirichlet_space =
            dof_handler_for_dirichlet_space_.n_dofs();
          const types::global_dof_index n_dofs_for_neumann_space =
            dof_handler_for_neumann_space_.n_dofs();

          std::cout << "=== DoF information ===" << std::endl;
          std::cout << "Number of DoFs in Dirichlet space: "
                    << n_dofs_for_dirichlet_space << "\n";
          std::cout << "Number of DoFs in Neumann space: "
                    << n_dofs_for_neumann_space << std::endl;

          if (!use_hmat_)
            {
              /**
               * If full matrices are used for verification purpose,
               * allocate memory for them here.
               */
              D1_matrix_.reinit(n_dofs_for_dirichlet_space,
                                n_dofs_for_dirichlet_space);
              K_prime2_matrix_with_mass_matrix_.reinit(
                n_dofs_for_dirichlet_space, n_dofs_for_neumann_space);

              add_memory_consumption_row("D1 full matrix", D1_matrix_);
              add_memory_consumption_row("K'2 with mass full matrix",
                                         K_prime2_matrix_with_mass_matrix_);
            }
          else
            {
              /**
               * Build the DoF-to-cell topology.
               */
              timer.start();

              collect_cell_iterators();
              DoFToolsExt::build_dof_to_cell_topology(
                dof_to_cell_topo_for_dirichlet_space_,
                cell_iterators_for_dirichlet_space_,
                dof_handler_for_dirichlet_space_);
              DoFToolsExt::build_dof_to_cell_topology(
                dof_to_cell_topo_for_neumann_space_,
                cell_iterators_for_neumann_space_,
                dof_handler_for_neumann_space_);

              timer.stop();
              print_wall_time(deallog, timer, "build dof-to-cell topology");

              /**
               * Generate lists of DoF indices.
               */
              dof_indices_for_dirichlet_space_on_neumann_domain_.resize(
                n_dofs_for_dirichlet_space);
              dof_indices_for_neumann_space_on_neumann_domain_.resize(
                n_dofs_for_neumann_space);

              gen_linear_indices<vector_uta, types::global_dof_index>(
                dof_indices_for_dirichlet_space_on_neumann_domain_);
              gen_linear_indices<vector_uta, types::global_dof_index>(
                dof_indices_for_neumann_space_on_neumann_domain_);

              /**
               * Get the spatial coordinates of the support points.
               */
              support_points_for_dirichlet_space_on_neumann_domain_.resize(
                n_dofs_for_dirichlet_space);
              // Here we only use the first order mapping to generate the
              // support point coordinates, which is good enough for cluster
              // partition.
              DoFToolsExt::map_dofs_to_support_points(
                mappings_[0]->get_mapping(),
                dof_handler_for_dirichlet_space_,
                support_points_for_dirichlet_space_on_neumann_domain_);

              support_points_for_neumann_space_on_neumann_domain_.resize(
                n_dofs_for_neumann_space);
              DoFToolsExt::map_dofs_to_support_points(
                mappings_[0]->get_mapping(),
                dof_handler_for_neumann_space_,
                support_points_for_neumann_space_on_neumann_domain_);

              /**
               * Calculate the average mesh cell size at each support point.
               */
              dof_average_cell_size_for_dirichlet_space_on_neumann_domain_
                .assign(n_dofs_for_dirichlet_space, 0);
              DoFToolsExt::map_dofs_to_average_cell_size(
                dof_handler_for_dirichlet_space_,
                dof_average_cell_size_for_dirichlet_space_on_neumann_domain_);

              dof_average_cell_size_for_neumann_space_on_neumann_domain_.assign(
                n_dofs_for_neumann_space, 0);
              DoFToolsExt::map_dofs_to_average_cell_size(
                dof_handler_for_neumann_space_,
                dof_average_cell_size_for_neumann_space_on_neumann_domain_);

              /**
               * Initialize the cluster trees.
               */
              timer.start();

              ct_for_dirichlet_space_on_neumann_domain_ =
                ClusterTree<spacedim, real_type>(
                  dof_indices_for_dirichlet_space_on_neumann_domain_,
                  support_points_for_dirichlet_space_on_neumann_domain_,
                  dof_average_cell_size_for_dirichlet_space_on_neumann_domain_,
                  n_min_for_ct_);
              ct_for_neumann_space_on_neumann_domain_ =
                ClusterTree<spacedim, real_type>(
                  dof_indices_for_neumann_space_on_neumann_domain_,
                  support_points_for_neumann_space_on_neumann_domain_,
                  dof_average_cell_size_for_neumann_space_on_neumann_domain_,
                  n_min_for_ct_);

              /**
               * Partition the cluster trees.
               */
              ct_for_dirichlet_space_on_neumann_domain_.partition(
                support_points_for_dirichlet_space_on_neumann_domain_,
                dof_average_cell_size_for_dirichlet_space_on_neumann_domain_);
              ct_for_neumann_space_on_neumann_domain_.partition(
                support_points_for_neumann_space_on_neumann_domain_,
                dof_average_cell_size_for_neumann_space_on_neumann_domain_);

              /**
               * Get the external-to-internal and internal-to-external DoF
               * numberings.
               */
              dof_e2i_numbering_for_dirichlet_space_on_neumann_domain_ =
                &(ct_for_dirichlet_space_on_neumann_domain_
                    .get_external_to_internal_dof_numbering());
              dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_ =
                &(ct_for_dirichlet_space_on_neumann_domain_
                    .get_internal_to_external_dof_numbering());
              dof_e2i_numbering_for_neumann_space_on_neumann_domain_ =
                &(ct_for_neumann_space_on_neumann_domain_
                    .get_external_to_internal_dof_numbering());
              dof_i2e_numbering_for_neumann_space_on_neumann_domain_ =
                &(ct_for_neumann_space_on_neumann_domain_
                    .get_internal_to_external_dof_numbering());

              timer.stop();
              print_wall_time(deallog, timer, "build cluster trees");

              add_memory_consumption_row(
                "Cluster tree for Dirichlet space on Neumann domain",
                ct_for_dirichlet_space_on_neumann_domain_);
              add_memory_consumption_row(
                "Cluster tree for Neumann space on Neumann domain",
                ct_for_neumann_space_on_neumann_domain_);

              /**
               * Create the block cluster trees.
               */
              timer.start();

              bct_for_bilinear_form_D1_ = BlockClusterTree<spacedim, real_type>(
                ct_for_dirichlet_space_on_neumann_domain_,
                ct_for_dirichlet_space_on_neumann_domain_,
                eta_,
                n_min_for_bct_);
              bct_for_bilinear_form_K_prime2_ =
                BlockClusterTree<spacedim, real_type>(
                  ct_for_dirichlet_space_on_neumann_domain_,
                  ct_for_neumann_space_on_neumann_domain_,
                  eta_,
                  n_min_for_bct_);

              /**
               * Partition the block cluster trees.
               */
              bct_for_bilinear_form_D1_.partition(
                *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
                support_points_for_dirichlet_space_on_neumann_domain_,
                dof_average_cell_size_for_dirichlet_space_on_neumann_domain_);
              bct_for_bilinear_form_K_prime2_.partition(
                *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
                *dof_i2e_numbering_for_neumann_space_on_neumann_domain_,
                support_points_for_dirichlet_space_on_neumann_domain_,
                support_points_for_neumann_space_on_neumann_domain_,
                dof_average_cell_size_for_dirichlet_space_on_neumann_domain_,
                dof_average_cell_size_for_neumann_space_on_neumann_domain_);

              timer.stop();
              print_wall_time(deallog, timer, "build block cluster trees");

              add_memory_consumption_row("Block cluster tree for D1",
                                         bct_for_bilinear_form_D1_);
              add_memory_consumption_row("Block cluster tree for K'2 with mass",
                                         bct_for_bilinear_form_K_prime2_);

              /**
               * Initialize \hmatrices.
               */
              timer.start();

              D1_hmat_ = HMatrix<spacedim, RangeNumberType>(
                bct_for_bilinear_form_D1_,
                max_hmat_rank_,
                HMatrixSupport::Property::symmetric,
                HMatrixSupport::BlockType::diagonal_block);

              std::cout << "=== Leaf set information of D1_hmat ==="
                        << std::endl;
              D1_hmat_.print_leaf_set_info(std::cout);

              K_prime2_hmat_with_mass_matrix_ =
                HMatrix<spacedim, RangeNumberType>(
                  bct_for_bilinear_form_K_prime2_,
                  max_hmat_rank_,
                  HMatrixSupport::Property::general,
                  HMatrixSupport::BlockType::diagonal_block);

              std::cout
                << "=== Leaf set information of K_prime2_hmat_with_mass_matrix ==="
                << std::endl;
              K_prime2_hmat_with_mass_matrix_.print_leaf_set_info(std::cout);

              timer.stop();
              print_wall_time(deallog, timer, "initialize H-matrices");

              add_memory_consumption_row(
                "D1 H-matrix",
                D1_hmat_,
                "After initialization and before assembly");
              add_memory_consumption_row(
                "K'2 with mass H-matrix",
                K_prime2_hmat_with_mass_matrix_,
                "After initialization and before assembly");
            }

          /**
           * Interpolate the Neumann boundary data.
           */
          timer.start();

          interpolate_neumann_bc();

          if (use_hmat_)
            {
              /**
               * Permute the Neumann boundary data by following the mapping
               * from internal to external DoF numbering.
               */
              neumann_bc_internal_dof_numbering_.reinit(
                n_dofs_for_neumann_space);
              permute_vector(
                neumann_bc_,
                *dof_i2e_numbering_for_neumann_space_on_neumann_domain_,
                neumann_bc_internal_dof_numbering_);
            }

          timer.stop();
          print_wall_time(deallog, timer, "interpolate boundary condition");

          /**
           * Allocate memory for the right-hand-side vector and solution
           * vector.
           */
          system_rhs_on_neumann_domain_.reinit(n_dofs_for_dirichlet_space);
          dirichlet_data_.reinit(n_dofs_for_dirichlet_space);

          if (use_hmat_)
            {
              // Solution vector in the internal numbering
              dirichlet_data_on_neumann_domain_internal_dof_numbering_.reinit(
                n_dofs_for_dirichlet_space);
            }

          break;
        }
        case MixedBCProblem: {
          Assert(use_hmat_, ExcInternalError());

          // Initialize DoF handlers.
          dof_handler_for_dirichlet_space_.reinit(tria_);
          dof_handler_for_dirichlet_space_.distribute_dofs(
            fe_for_dirichlet_space_);
          dof_handler_for_neumann_space_.reinit(tria_);
          dof_handler_for_neumann_space_.distribute_dofs(fe_for_neumann_space_);

          // Generate DoF selectors for the Dirichlet space on the extended
          // Dirichlet domain and retracted Neumann domain.
          timer.start();

          dof_selectors_for_dirichlet_space_on_dirichlet_domain_.resize(
            dof_handler_for_dirichlet_space_.n_dofs());
          dof_selectors_for_dirichlet_space_on_neumann_domain_.resize(
            dof_handler_for_dirichlet_space_.n_dofs());
          DoFToolsExt::extract_boundary_condition_dofs(
            dof_handler_for_dirichlet_space_,
            dirichlet_bc_definition_,
            dof_selectors_for_dirichlet_space_on_dirichlet_domain_);

          local_to_full_dirichlet_dof_indices_on_dirichlet_domain_.reserve(
            dof_handler_for_dirichlet_space_.n_dofs());
          local_to_full_dirichlet_dof_indices_on_neumann_domain_.reserve(
            dof_handler_for_dirichlet_space_.n_dofs());

          for (types::global_dof_index i = 0;
               i < dof_handler_for_dirichlet_space_.n_dofs();
               i++)
            {
              if (dof_selectors_for_dirichlet_space_on_dirichlet_domain_[i])
                {
                  dof_selectors_for_dirichlet_space_on_neumann_domain_[i] =
                    false;
                  local_to_full_dirichlet_dof_indices_on_dirichlet_domain_
                    .push_back(i);
                }
              else
                {
                  dof_selectors_for_dirichlet_space_on_neumann_domain_[i] =
                    true;
                  local_to_full_dirichlet_dof_indices_on_neumann_domain_
                    .push_back(i);
                }
            }

          // Generate DoF selectors for the Neumann space on the Dirichlet
          // domain and Neumann domain.
          dof_selectors_for_neumann_space_on_dirichlet_domain_.resize(
            dof_handler_for_neumann_space_.n_dofs());
          dof_selectors_for_neumann_space_on_neumann_domain_.resize(
            dof_handler_for_neumann_space_.n_dofs());
          DoFToolsExt::extract_boundary_condition_dofs(
            dof_handler_for_neumann_space_,
            dirichlet_bc_definition_,
            dof_selectors_for_neumann_space_on_dirichlet_domain_);

          local_to_full_neumann_dof_indices_on_dirichlet_domain_.reserve(
            dof_handler_for_neumann_space_.n_dofs());
          local_to_full_neumann_dof_indices_on_neumann_domain_.reserve(
            dof_handler_for_neumann_space_.n_dofs());

          for (types::global_dof_index i = 0;
               i < dof_handler_for_neumann_space_.n_dofs();
               i++)
            {
              if (dof_selectors_for_neumann_space_on_dirichlet_domain_[i])
                {
                  dof_selectors_for_neumann_space_on_neumann_domain_[i] = false;
                  local_to_full_neumann_dof_indices_on_dirichlet_domain_
                    .push_back(i);
                }
              else
                {
                  dof_selectors_for_neumann_space_on_neumann_domain_[i] = true;
                  local_to_full_neumann_dof_indices_on_neumann_domain_
                    .push_back(i);
                }
            }

          timer.stop();
          print_wall_time(deallog, timer, "generate DoF selectors");

          // Get the number of effective DoF number for each DoF handler.
          types::global_dof_index
            n_dofs_for_dirichlet_space_on_dirichlet_domain =
              local_to_full_dirichlet_dof_indices_on_dirichlet_domain_.size();
          types::global_dof_index n_dofs_for_dirichlet_space_on_neumann_domain =
            local_to_full_dirichlet_dof_indices_on_neumann_domain_.size();
          types::global_dof_index n_dofs_for_neumann_space_on_dirichlet_domain =
            local_to_full_neumann_dof_indices_on_dirichlet_domain_.size();
          types::global_dof_index n_dofs_for_neumann_space_on_neumann_domain =
            local_to_full_neumann_dof_indices_on_neumann_domain_.size();

          std::cout << "=== DoF information ===" << std::endl;
          std::cout << "Number of DoFs in Dirichlet space on Dirichlet domain: "
                    << n_dofs_for_dirichlet_space_on_dirichlet_domain << "\n";
          std::cout << "Number of DoFs in Dirichlet space on Neumann domain: "
                    << n_dofs_for_dirichlet_space_on_neumann_domain << "\n";
          std::cout << "Number of DoFs in Neumann space on Dirichlet domain: "
                    << n_dofs_for_neumann_space_on_dirichlet_domain << "\n";
          std::cout << "Number of DoFs in Neumann space on Neumann domain: "
                    << n_dofs_for_neumann_space_on_neumann_domain << std::endl;

          /**
           * Build the DoF-to-cell topology.
           *
           * \mynote{Access of this topology for the Dirichlet space
           * requires the map from local to full DoF indices.}
           */
          timer.start();

          collect_cell_iterators();
          DoFToolsExt::build_dof_to_cell_topology(
            dof_to_cell_topo_for_dirichlet_space_,
            cell_iterators_for_dirichlet_space_,
            dof_handler_for_dirichlet_space_);
          DoFToolsExt::build_dof_to_cell_topology(
            dof_to_cell_topo_for_neumann_space_,
            cell_iterators_for_neumann_space_,
            dof_handler_for_neumann_space_);

          timer.stop();
          print_wall_time(deallog, timer, "build dof-to-cell topology");

          /**
           * Generate lists of DoF indices.
           *
           * \mynote{N.B. For the Dirichlet space, some DoFs have been
           * excluded.}
           */
          dof_indices_for_dirichlet_space_on_dirichlet_domain_.resize(
            n_dofs_for_dirichlet_space_on_dirichlet_domain);
          dof_indices_for_dirichlet_space_on_neumann_domain_.resize(
            n_dofs_for_dirichlet_space_on_neumann_domain);
          dof_indices_for_neumann_space_on_dirichlet_domain_.resize(
            n_dofs_for_neumann_space_on_dirichlet_domain);
          dof_indices_for_neumann_space_on_neumann_domain_.resize(
            n_dofs_for_neumann_space_on_neumann_domain);

          gen_linear_indices<vector_uta, types::global_dof_index>(
            dof_indices_for_dirichlet_space_on_dirichlet_domain_);
          gen_linear_indices<vector_uta, types::global_dof_index>(
            dof_indices_for_dirichlet_space_on_neumann_domain_);
          gen_linear_indices<vector_uta, types::global_dof_index>(
            dof_indices_for_neumann_space_on_dirichlet_domain_);
          gen_linear_indices<vector_uta, types::global_dof_index>(
            dof_indices_for_neumann_space_on_neumann_domain_);

          /**
           * Get the spatial coordinates of the support points.
           */
          support_points_for_dirichlet_space_on_dirichlet_domain_.resize(
            n_dofs_for_dirichlet_space_on_dirichlet_domain);
          DoFToolsExt::map_dofs_to_support_points(
            mappings_[0]->get_mapping(),
            dof_handler_for_dirichlet_space_,
            local_to_full_dirichlet_dof_indices_on_dirichlet_domain_,
            support_points_for_dirichlet_space_on_dirichlet_domain_);

          support_points_for_dirichlet_space_on_neumann_domain_.resize(
            n_dofs_for_dirichlet_space_on_neumann_domain);
          DoFToolsExt::map_dofs_to_support_points(
            mappings_[0]->get_mapping(),
            dof_handler_for_dirichlet_space_,
            local_to_full_dirichlet_dof_indices_on_neumann_domain_,
            support_points_for_dirichlet_space_on_neumann_domain_);

          support_points_for_neumann_space_on_dirichlet_domain_.resize(
            n_dofs_for_neumann_space_on_dirichlet_domain);
          DoFToolsExt::map_dofs_to_support_points(
            mappings_[0]->get_mapping(),
            dof_handler_for_neumann_space_,
            local_to_full_neumann_dof_indices_on_dirichlet_domain_,
            support_points_for_neumann_space_on_dirichlet_domain_);

          support_points_for_neumann_space_on_neumann_domain_.resize(
            n_dofs_for_neumann_space_on_neumann_domain);
          DoFToolsExt::map_dofs_to_support_points(
            mappings_[0]->get_mapping(),
            dof_handler_for_neumann_space_,
            local_to_full_neumann_dof_indices_on_neumann_domain_,
            support_points_for_neumann_space_on_neumann_domain_);

          /**
           * Calculate the average mesh cell size at each support point.
           */
          dof_average_cell_size_for_dirichlet_space_on_dirichlet_domain_.assign(
            n_dofs_for_dirichlet_space_on_dirichlet_domain, 0);
          DoFToolsExt::map_dofs_to_average_cell_size(
            dof_handler_for_dirichlet_space_,
            local_to_full_dirichlet_dof_indices_on_dirichlet_domain_,
            dof_average_cell_size_for_dirichlet_space_on_dirichlet_domain_);

          dof_average_cell_size_for_dirichlet_space_on_neumann_domain_.assign(
            n_dofs_for_dirichlet_space_on_neumann_domain, 0);
          DoFToolsExt::map_dofs_to_average_cell_size(
            dof_handler_for_dirichlet_space_,
            local_to_full_dirichlet_dof_indices_on_neumann_domain_,
            dof_average_cell_size_for_dirichlet_space_on_neumann_domain_);

          dof_average_cell_size_for_neumann_space_on_dirichlet_domain_.assign(
            n_dofs_for_neumann_space_on_dirichlet_domain, 0);
          DoFToolsExt::map_dofs_to_average_cell_size(
            dof_handler_for_neumann_space_,
            local_to_full_neumann_dof_indices_on_dirichlet_domain_,
            dof_average_cell_size_for_neumann_space_on_dirichlet_domain_);

          dof_average_cell_size_for_neumann_space_on_neumann_domain_.assign(
            n_dofs_for_neumann_space_on_neumann_domain, 0);
          DoFToolsExt::map_dofs_to_average_cell_size(
            dof_handler_for_neumann_space_,
            local_to_full_neumann_dof_indices_on_neumann_domain_,
            dof_average_cell_size_for_neumann_space_on_neumann_domain_);

          /**
           * Initialize the cluster trees.
           */
          timer.start();

          ct_for_dirichlet_space_on_dirichlet_domain_ =
            ClusterTree<spacedim, real_type>(
              dof_indices_for_dirichlet_space_on_dirichlet_domain_,
              support_points_for_dirichlet_space_on_dirichlet_domain_,
              dof_average_cell_size_for_dirichlet_space_on_dirichlet_domain_,
              n_min_for_ct_);
          ct_for_dirichlet_space_on_neumann_domain_ =
            ClusterTree<spacedim, real_type>(
              dof_indices_for_dirichlet_space_on_neumann_domain_,
              support_points_for_dirichlet_space_on_neumann_domain_,
              dof_average_cell_size_for_dirichlet_space_on_neumann_domain_,
              n_min_for_ct_);
          ct_for_neumann_space_on_dirichlet_domain_ =
            ClusterTree<spacedim, real_type>(
              dof_indices_for_neumann_space_on_dirichlet_domain_,
              support_points_for_neumann_space_on_dirichlet_domain_,
              dof_average_cell_size_for_neumann_space_on_dirichlet_domain_,
              n_min_for_ct_);
          ct_for_neumann_space_on_neumann_domain_ =
            ClusterTree<spacedim, real_type>(
              dof_indices_for_neumann_space_on_neumann_domain_,
              support_points_for_neumann_space_on_neumann_domain_,
              dof_average_cell_size_for_neumann_space_on_neumann_domain_,
              n_min_for_ct_);

          /**
           * Partition the cluster trees.
           */
          ct_for_dirichlet_space_on_dirichlet_domain_.partition(
            support_points_for_dirichlet_space_on_dirichlet_domain_,
            dof_average_cell_size_for_dirichlet_space_on_dirichlet_domain_);
          ct_for_dirichlet_space_on_neumann_domain_.partition(
            support_points_for_dirichlet_space_on_neumann_domain_,
            dof_average_cell_size_for_dirichlet_space_on_neumann_domain_);
          ct_for_neumann_space_on_dirichlet_domain_.partition(
            support_points_for_neumann_space_on_dirichlet_domain_,
            dof_average_cell_size_for_neumann_space_on_dirichlet_domain_);
          ct_for_neumann_space_on_neumann_domain_.partition(
            support_points_for_neumann_space_on_neumann_domain_,
            dof_average_cell_size_for_neumann_space_on_neumann_domain_);

          /**
           * Get the external-to-internal and internal-to-external DoF
           * numberings.
           */
          dof_e2i_numbering_for_dirichlet_space_on_dirichlet_domain_ =
            &(ct_for_dirichlet_space_on_dirichlet_domain_
                .get_external_to_internal_dof_numbering());
          dof_i2e_numbering_for_dirichlet_space_on_dirichlet_domain_ =
            &(ct_for_dirichlet_space_on_dirichlet_domain_
                .get_internal_to_external_dof_numbering());
          dof_e2i_numbering_for_dirichlet_space_on_neumann_domain_ =
            &(ct_for_dirichlet_space_on_neumann_domain_
                .get_external_to_internal_dof_numbering());
          dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_ =
            &(ct_for_dirichlet_space_on_neumann_domain_
                .get_internal_to_external_dof_numbering());
          dof_e2i_numbering_for_neumann_space_on_dirichlet_domain_ =
            &(ct_for_neumann_space_on_dirichlet_domain_
                .get_external_to_internal_dof_numbering());
          dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_ =
            &(ct_for_neumann_space_on_dirichlet_domain_
                .get_internal_to_external_dof_numbering());
          dof_e2i_numbering_for_neumann_space_on_neumann_domain_ =
            &(ct_for_neumann_space_on_neumann_domain_
                .get_external_to_internal_dof_numbering());
          dof_i2e_numbering_for_neumann_space_on_neumann_domain_ =
            &(ct_for_neumann_space_on_neumann_domain_
                .get_internal_to_external_dof_numbering());

          timer.stop();
          print_wall_time(deallog, timer, "build cluster trees");

          add_memory_consumption_row(
            "Cluster tree for Dirichlet space on Dirichlet domain",
            ct_for_dirichlet_space_on_dirichlet_domain_);
          add_memory_consumption_row(
            "Cluster tree for Dirichlet space on Neumann domain",
            ct_for_dirichlet_space_on_neumann_domain_);
          add_memory_consumption_row(
            "Cluster tree for Neumann space on Dirichlet domain",
            ct_for_neumann_space_on_dirichlet_domain_);
          add_memory_consumption_row(
            "Cluster tree for Neumann space on Neumann domain",
            ct_for_neumann_space_on_neumann_domain_);

          /**
           * Create the block cluster trees.
           */
          timer.start();

          bct_for_bilinear_form_V1_ = BlockClusterTree<spacedim, real_type>(
            ct_for_neumann_space_on_dirichlet_domain_,
            ct_for_neumann_space_on_dirichlet_domain_,
            eta_,
            n_min_for_bct_);
          bct_for_bilinear_form_K1_ = BlockClusterTree<spacedim, real_type>(
            ct_for_neumann_space_on_dirichlet_domain_,
            ct_for_dirichlet_space_on_neumann_domain_,
            eta_,
            n_min_for_bct_);
          bct_for_bilinear_form_D1_ = BlockClusterTree<spacedim, real_type>(
            ct_for_dirichlet_space_on_neumann_domain_,
            ct_for_dirichlet_space_on_neumann_domain_,
            eta_,
            n_min_for_bct_);
          bct_for_bilinear_form_K2_ = BlockClusterTree<spacedim, real_type>(
            ct_for_neumann_space_on_dirichlet_domain_,
            ct_for_dirichlet_space_on_dirichlet_domain_,
            eta_,
            n_min_for_bct_);
          bct_for_bilinear_form_V2_ = BlockClusterTree<spacedim, real_type>(
            ct_for_neumann_space_on_dirichlet_domain_,
            ct_for_neumann_space_on_neumann_domain_,
            eta_,
            n_min_for_bct_);
          bct_for_bilinear_form_D2_ = BlockClusterTree<spacedim, real_type>(
            ct_for_dirichlet_space_on_neumann_domain_,
            ct_for_dirichlet_space_on_dirichlet_domain_,
            eta_,
            n_min_for_bct_);
          bct_for_bilinear_form_K_prime2_ =
            BlockClusterTree<spacedim, real_type>(
              ct_for_dirichlet_space_on_neumann_domain_,
              ct_for_neumann_space_on_neumann_domain_,
              eta_,
              n_min_for_bct_);

          /**
           * Partition the block cluster trees.
           */
          bct_for_bilinear_form_V1_.partition(
            *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
            support_points_for_neumann_space_on_dirichlet_domain_,
            dof_average_cell_size_for_neumann_space_on_dirichlet_domain_);
          bct_for_bilinear_form_K1_.partition(
            *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
            *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
            support_points_for_neumann_space_on_dirichlet_domain_,
            support_points_for_dirichlet_space_on_neumann_domain_,
            dof_average_cell_size_for_neumann_space_on_dirichlet_domain_,
            dof_average_cell_size_for_dirichlet_space_on_neumann_domain_);
          bct_for_bilinear_form_D1_.partition(
            *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
            support_points_for_dirichlet_space_on_neumann_domain_,
            dof_average_cell_size_for_dirichlet_space_on_neumann_domain_);
          bct_for_bilinear_form_K2_.partition(
            *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
            *dof_i2e_numbering_for_dirichlet_space_on_dirichlet_domain_,
            support_points_for_neumann_space_on_dirichlet_domain_,
            support_points_for_dirichlet_space_on_dirichlet_domain_,
            dof_average_cell_size_for_neumann_space_on_dirichlet_domain_,
            dof_average_cell_size_for_dirichlet_space_on_dirichlet_domain_);
          bct_for_bilinear_form_V2_.partition(
            *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
            *dof_i2e_numbering_for_neumann_space_on_neumann_domain_,
            support_points_for_neumann_space_on_dirichlet_domain_,
            support_points_for_neumann_space_on_neumann_domain_,
            dof_average_cell_size_for_neumann_space_on_dirichlet_domain_,
            dof_average_cell_size_for_neumann_space_on_neumann_domain_);
          bct_for_bilinear_form_D2_.partition(
            *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
            *dof_i2e_numbering_for_dirichlet_space_on_dirichlet_domain_,
            support_points_for_dirichlet_space_on_neumann_domain_,
            support_points_for_dirichlet_space_on_dirichlet_domain_,
            dof_average_cell_size_for_dirichlet_space_on_neumann_domain_,
            dof_average_cell_size_for_dirichlet_space_on_dirichlet_domain_);
          bct_for_bilinear_form_K_prime2_.partition(
            *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
            *dof_i2e_numbering_for_neumann_space_on_neumann_domain_,
            support_points_for_dirichlet_space_on_neumann_domain_,
            support_points_for_neumann_space_on_neumann_domain_,
            dof_average_cell_size_for_dirichlet_space_on_neumann_domain_,
            dof_average_cell_size_for_neumann_space_on_neumann_domain_);

          timer.stop();
          print_wall_time(deallog, timer, "build block cluster trees");

          add_memory_consumption_row("Block cluster tree for V1",
                                     bct_for_bilinear_form_V1_);
          add_memory_consumption_row("Block cluster tree for K1",
                                     bct_for_bilinear_form_K1_);
          add_memory_consumption_row("Block cluster tree for D1",
                                     bct_for_bilinear_form_D1_);
          add_memory_consumption_row("Block cluster tree for K2 with mass",
                                     bct_for_bilinear_form_K2_);
          add_memory_consumption_row("Block cluster tree for V2",
                                     bct_for_bilinear_form_V2_);
          add_memory_consumption_row("Block cluster tree for D2",
                                     bct_for_bilinear_form_D2_);
          add_memory_consumption_row("Block cluster tree for K'2 with mass",
                                     bct_for_bilinear_form_K_prime2_);

          /**
           * Initialize \hmatrices.
           */
          timer.start();

          V1_hmat_ = HMatrix<spacedim, RangeNumberType>(
            bct_for_bilinear_form_V1_,
            max_hmat_rank_,
            HMatrixSupport::Property::symmetric,
            HMatrixSupport::BlockType::diagonal_block);

          std::cout << "=== Leaf set information of V1_hmat ===" << std::endl;
          V1_hmat_.print_leaf_set_info(std::cout);

          K1_hmat_ = HMatrix<spacedim, RangeNumberType>(
            bct_for_bilinear_form_K1_,
            max_hmat_rank_,
            HMatrixSupport::Property::general,
            HMatrixSupport::BlockType::diagonal_block);

          std::cout << "=== Leaf set information of K1_hmat ===" << std::endl;
          K1_hmat_.print_leaf_set_info(std::cout);

          D1_hmat_ = HMatrix<spacedim, RangeNumberType>(
            bct_for_bilinear_form_D1_,
            max_hmat_rank_,
            HMatrixSupport::Property::symmetric,
            HMatrixSupport::BlockType::diagonal_block);

          std::cout << "=== Leaf set information of D1_hmat ===" << std::endl;
          D1_hmat_.print_leaf_set_info(std::cout);

          K2_hmat_with_mass_matrix_ = HMatrix<spacedim, RangeNumberType>(
            bct_for_bilinear_form_K2_,
            max_hmat_rank_,
            HMatrixSupport::Property::general,
            HMatrixSupport::BlockType::diagonal_block);

          std::cout
            << "=== Leaf set information of K2_hmat_with_mass_matrix ==="
            << std::endl;
          K2_hmat_with_mass_matrix_.print_leaf_set_info(std::cout);

          V2_hmat_ = HMatrix<spacedim, RangeNumberType>(
            bct_for_bilinear_form_V2_,
            max_hmat_rank_,
            HMatrixSupport::Property::general,
            HMatrixSupport::BlockType::diagonal_block);

          std::cout << "=== Leaf set information of V2_hmat ===" << std::endl;
          V2_hmat_.print_leaf_set_info(std::cout);

          D2_hmat_ = HMatrix<spacedim, RangeNumberType>(
            bct_for_bilinear_form_D2_,
            max_hmat_rank_,
            HMatrixSupport::Property::general,
            HMatrixSupport::BlockType::diagonal_block);

          std::cout << "=== Leaf set information of D2_hmat ===" << std::endl;
          D2_hmat_.print_leaf_set_info(std::cout);

          K_prime2_hmat_with_mass_matrix_ = HMatrix<spacedim, RangeNumberType>(
            bct_for_bilinear_form_K_prime2_,
            max_hmat_rank_,
            HMatrixSupport::Property::general,
            HMatrixSupport::BlockType::diagonal_block);

          std::cout
            << "=== Leaf set information of K_prime2_hmat_with_mass_matrix ==="
            << std::endl;
          K_prime2_hmat_with_mass_matrix_.print_leaf_set_info(std::cout);

          timer.stop();
          print_wall_time(deallog, timer, "initialize H-matrices");

          add_memory_consumption_row(
            "V1 H-matrix",
            V1_hmat_,
            "After initialization and before assembly");
          add_memory_consumption_row(
            "K1 H-matrix",
            K1_hmat_,
            "After initialization and before assembly");
          add_memory_consumption_row(
            "D1 H-matrix",
            D1_hmat_,
            "After initialization and before assembly");
          add_memory_consumption_row(
            "K2 with mass H-matrix",
            K2_hmat_with_mass_matrix_,
            "After initialization and before assembly");
          add_memory_consumption_row(
            "V2 H-matrix",
            V2_hmat_,
            "After initialization and before assembly");
          add_memory_consumption_row(
            "D2 H-matrix",
            D2_hmat_,
            "After initialization and before assembly");
          add_memory_consumption_row(
            "K'2 with mass H-matrix",
            K_prime2_hmat_with_mass_matrix_,
            "After initialization and before assembly");

          /**
           * Interpolate the Dirichlet boundary data on the extended Dirichlet
           * domain and set those unselected DoFs to be zero.
           */
          timer.start();

          interpolate_dirichlet_bc();

          /**
           * Extract the Dirichlet boundary data on the selected DoFs.
           */
          dirichlet_bc_on_selected_dofs_.reinit(
            n_dofs_for_dirichlet_space_on_dirichlet_domain);
          for (types::global_dof_index i = 0;
               i < n_dofs_for_dirichlet_space_on_dirichlet_domain;
               i++)
            {
              dirichlet_bc_on_selected_dofs_(i) = dirichlet_bc_(
                local_to_full_dirichlet_dof_indices_on_dirichlet_domain_[i]);
            }

          /**
           * Permute the Dirichlet boundary data by following the mapping
           * from internal to external DoF numbering.
           */
          dirichlet_bc_internal_dof_numbering_.reinit(
            n_dofs_for_dirichlet_space_on_dirichlet_domain);
          permute_vector(
            dirichlet_bc_on_selected_dofs_,
            *dof_i2e_numbering_for_dirichlet_space_on_dirichlet_domain_,
            dirichlet_bc_internal_dof_numbering_);

          /**
           * Interpolate Neumann boundary condition.
           */
          interpolate_neumann_bc();

          /**
           * Extract the Neumann boundary data on the selected DoFs.
           */
          neumann_bc_on_selected_dofs_.reinit(
            n_dofs_for_neumann_space_on_neumann_domain);
          for (types::global_dof_index i = 0;
               i < n_dofs_for_neumann_space_on_neumann_domain;
               i++)
            {
              neumann_bc_on_selected_dofs_(i) = neumann_bc_(
                local_to_full_neumann_dof_indices_on_neumann_domain_[i]);
            }

          /**
           * Permute the Neumann boundary data by following the mapping
           * from internal to external DoF numbering.
           */
          neumann_bc_internal_dof_numbering_.reinit(
            n_dofs_for_neumann_space_on_neumann_domain);
          permute_vector(
            neumann_bc_on_selected_dofs_,
            *dof_i2e_numbering_for_neumann_space_on_neumann_domain_,
            neumann_bc_internal_dof_numbering_);

          timer.stop();
          print_wall_time(deallog, timer, "interpolate boundary condition");

          /**
           * Allocate memory for the right-hand-side vectors and solution
           * vectors.
           */
          system_rhs_on_dirichlet_domain_.reinit(
            n_dofs_for_neumann_space_on_dirichlet_domain);
          system_rhs_on_neumann_domain_.reinit(
            n_dofs_for_dirichlet_space_on_neumann_domain);
          system_rhs_on_combined_domain_.reinit(
            n_dofs_for_neumann_space_on_dirichlet_domain +
            n_dofs_for_dirichlet_space_on_neumann_domain);

          // N.B. This is the solution vector on all DoFs in the associated
          // DoF handler.
          neumann_data_.reinit(dof_handler_for_neumann_space_.n_dofs());
          dirichlet_data_.reinit(dof_handler_for_dirichlet_space_.n_dofs());

          // N.B. This is the solution vector on selected DoFs in the
          // associated DoF handler in the external DoF numbering.
          neumann_data_on_dirichlet_domain_.reinit(
            n_dofs_for_neumann_space_on_dirichlet_domain);
          dirichlet_data_on_neumann_domain_.reinit(
            n_dofs_for_dirichlet_space_on_neumann_domain);

          neumann_data_on_dirichlet_domain_internal_dof_numbering_.reinit(
            n_dofs_for_neumann_space_on_dirichlet_domain);
          // N.B. This is the solution vector on the selected DoFs in the
          // associated DoF handler in the internal DoF numbering.
          dirichlet_data_on_neumann_domain_internal_dof_numbering_.reinit(
            n_dofs_for_dirichlet_space_on_neumann_domain);
          solution_on_combined_domain_internal_dof_numbering_.reinit(
            n_dofs_for_neumann_space_on_dirichlet_domain +
            n_dofs_for_dirichlet_space_on_neumann_domain);

          break;
        }
        default: {
          Assert(false, ExcInternalError());
          break;
        }
    }
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  assign_dirichlet_bc(Function<spacedim, RangeNumberType> &f,
                      const EntityTag                      surface_tag)
{
  if (surface_tag == -1)
    {
      for (const auto &record : subdomain_topology_.get_surface_to_subdomain())
        {
          dirichlet_bc_definition_[record.first] = &f;
        }
    }
  else
    {
      dirichlet_bc_definition_[surface_tag] = &f;
    }
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  assign_dirichlet_bc(Function<spacedim, RangeNumberType> &f,
                      const std::vector<EntityTag>        &surface_tags)
{
  for (const auto t : surface_tags)
    {
      dirichlet_bc_definition_[t] = &f;
    }
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  assign_neumann_bc(Function<spacedim, RangeNumberType> &f,
                    const EntityTag                      surface_tag)
{
  if (surface_tag == -1)
    {
      for (const auto &record : subdomain_topology_.get_surface_to_subdomain())
        {
          neumann_bc_definition_[record.first] = &f;
        }
    }
  else
    {
      neumann_bc_definition_[surface_tag] = &f;
    }
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  assign_neumann_bc(Function<spacedim, RangeNumberType> &f,
                    const std::vector<EntityTag>        &surface_tags)
{
  for (const auto t : surface_tags)
    {
      neumann_bc_definition_[t] = &f;
    }
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
bool
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  validate_subdomain_topology() const
{
  auto &subdomain_to_surface = subdomain_topology_.get_subdomain_to_surface();
  const unsigned int n_subdomains = subdomain_to_surface.size();

  // There should be at least one subdomain.
  if (n_subdomains > 0)
    {
      if (n_subdomains > 1)
        {
          // When there are more than 1 subdomains, they should be disjoint.
          for (auto iter1 = subdomain_to_surface.begin();
               iter1 != subdomain_to_surface.end();
               iter1++)
            {
              for (auto iter2 = std::next(iter1);
                   iter2 != subdomain_to_surface.end();
                   iter2++)
                {
                  std::vector<EntityTag> surface_tag_intersection;
                  std::set_intersection(iter1->second.begin(),
                                        iter1->second.end(),
                                        iter2->second.begin(),
                                        iter2->second.end(),
                                        std::back_inserter(
                                          surface_tag_intersection));

                  if (!surface_tag_intersection.empty())
                    return false;
                }
            }

          return true;
        }
      else
        return true;
    }
  else
    return false;
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  initialize_manifolds_from_manifold_description()
{
  // Assign manifold ids to all cells in the triangulation.
  for (auto &cell : tria_.active_cell_iterators())
    {
      cell->set_all_manifold_ids(manifold_description_[cell->material_id()]);
    }

  // Associate manifold objects with manifold ids in the triangulation.
  for (const auto &m : manifolds_)
    {
      tria_.set_manifold(m.first, *m.second);
    }
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  initialize_mappings()
{
  // Create different orders of mapping.
  mappings_.reserve(max_mapping_order);
  for (unsigned int i = 1; i <= max_mapping_order; i++)
    {
      mappings_.push_back(new MappingInfo<dim, spacedim>(i));
    }

  // Construct the map from material ids to mapping indices.
  for (const auto &m : manifold_description_)
    {
      material_id_to_mapping_index_[m.first] =
        manifold_id_to_mapping_order_[m.second] - 1;
    }
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  interpolate_dirichlet_bc()
{
  dirichlet_bc_.reinit(dof_handler_for_dirichlet_space_.n_dofs());

  // Because each surface may be assigned a different mapping object, here we
  // interpolate the Dirichlet boundary condition vector surface by surface.
  //
  // \mynote{Even though, a high order mapping is adopted, the fitted curved
  // surface is still not identifical to the orignal CAD model. This makes the
  // actually applied boundary condition function deviates from the
  // theoretical version, when we want to apply an analytical function. Even
  // when a manifold conforming mapping is adopted, which is realized in the
  // deal.ii class MappingManifold, the finite element space will produce
  // additional error when approximating the analytical function. This means
  // no matter how accurately we assemble the matrix and solve the linear
  // system, the solution vector will not be identical with the analytical
  // solution.}
  for (const auto &bc : dirichlet_bc_definition_)
    {
      std::map<types::material_id, const Function<spacedim, RangeNumberType> *>
        single_pair_map;
      single_pair_map[static_cast<types::material_id>(bc.first)] = bc.second;

      VectorTools::interpolate_based_on_material_id(
        mappings_[material_id_to_mapping_index_[bc.first]]->get_mapping(),
        dof_handler_for_dirichlet_space_,
        single_pair_map,
        dirichlet_bc_);
    }
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  interpolate_neumann_bc()
{
  neumann_bc_.reinit(dof_handler_for_neumann_space_.n_dofs());

  // Because each surface may be assigned a different mapping object, here we
  // interpolate the Neumann boundary condition vector surface by surface.
  for (const auto &bc : neumann_bc_definition_)
    {
      std::map<types::material_id, const Function<spacedim, RangeNumberType> *>
        single_pair_map;
      single_pair_map[static_cast<types::material_id>(bc.first)] = bc.second;

      VectorTools::interpolate_based_on_material_id(
        mappings_[material_id_to_mapping_index_[bc.first]]->get_mapping(),
        dof_handler_for_neumann_space_,
        single_pair_map,
        neumann_bc_);
    }
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  assemble_full_matrix_system()
{
  LogStream::Prefix prefix_string("assemble_full_matrix");

  MultithreadInfo::set_thread_limit(thread_num_);

  switch (problem_type_)
    {
        case DirichletBCProblem: {
          /**
           * Assemble the FEM scaled mass matrix, which is stored into the
           * full matrix for \f$K_2\f$.
           *
           * \mynote{The polynomial order specified for the Gauss-Legendre
           * quadrature rule for FEM integration is accurate for the
           * integration of \f$2N-1\f$-th polynomial, where \f$N\f is the
           * number of quadrature points in 1D.}
           */
          std::cout << "=== Assemble scaled mass matrix ===" << std::endl;

          /**
           * For the interior Laplace problem, \f$\frac{1}{2}I\f$ is
           * assembled, while for the exterior Laplace problem,
           * \f$-\frac{1}{2}I\f$ is assembled. It is also assumed that the
           * potential reference \f$u_0\f$ is zero when \f$\abs{x} \rightarrow
           * \infty\f$.
           */
          Timer timer;
          if (is_interior_problem_)
            {
              if (cpu_serial_)
                {
                  assemble_fem_scaled_mass_matrix_serial<
                    dim,
                    spacedim,
                    real_type,
                    LAPACKFullMatrixExt<RangeNumberType>>(
                    dof_handler_for_neumann_space_,
                    dof_handler_for_dirichlet_space_,
                    0.5,
                    QGauss<2>(fe_for_dirichlet_space_.degree + 1),
                    K2_matrix_with_mass_matrix_);
                }
              else
                {
                  assemble_fem_scaled_mass_matrix<
                    dim,
                    spacedim,
                    real_type,
                    LAPACKFullMatrixExt<RangeNumberType>>(
                    dof_handler_for_neumann_space_,
                    dof_handler_for_dirichlet_space_,
                    0.5,
                    QGauss<2>(fe_for_dirichlet_space_.degree + 1),
                    K2_matrix_with_mass_matrix_);
                }
            }
          else
            {
              if (cpu_serial_)
                {
                  assemble_fem_scaled_mass_matrix_serial<
                    dim,
                    spacedim,
                    real_type,
                    LAPACKFullMatrixExt<RangeNumberType>>(
                    dof_handler_for_neumann_space_,
                    dof_handler_for_dirichlet_space_,
                    -0.5,
                    QGauss<2>(fe_for_dirichlet_space_.degree + 1),
                    K2_matrix_with_mass_matrix_);
                }
              else
                {
                  assemble_fem_scaled_mass_matrix<
                    dim,
                    spacedim,
                    real_type,
                    LAPACKFullMatrixExt<RangeNumberType>>(
                    dof_handler_for_neumann_space_,
                    dof_handler_for_dirichlet_space_,
                    -0.5,
                    QGauss<2>(fe_for_dirichlet_space_.degree + 1),
                    K2_matrix_with_mass_matrix_);
                }
            }
          timer.stop();
          print_wall_time(deallog, timer, "assemble mass matrix I");

          /**
           * Assemble the DLP matrix, which is added with the previous
           * scaled FEM mass matrix.
           */
          std::cout << "=== Assemble DLP matrix ===" << std::endl;

          timer.start();
          if (cpu_serial_)
            {
              assemble_bem_full_matrix_serial<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::DoubleLayerKernel,
                KernelNumberType,
                SurfaceNormalDetector<dim, spacedim>,
                LAPACKFullMatrixExt<RangeNumberType>>(
                double_layer_kernel_cpu_,
                1.0,
                dof_handler_for_neumann_space_,
                dof_handler_for_dirichlet_space_,
                mappings_,
                material_id_to_mapping_index_,
                SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
                SauterQuadratureRule<dim>(5, 4, 4, 3),
                K2_matrix_with_mass_matrix_);
            }
          else
            {
              assemble_bem_full_matrix<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::DoubleLayerKernel,
                KernelNumberType,
                SurfaceNormalDetector<dim, spacedim>,
                LAPACKFullMatrixExt<RangeNumberType>>(
                double_layer_kernel_cpu_,
                1.0,
                dof_handler_for_neumann_space_,
                dof_handler_for_dirichlet_space_,
                mappings_,
                material_id_to_mapping_index_,
                SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
                SauterQuadratureRule<dim>(5, 4, 4, 3),
                K2_matrix_with_mass_matrix_);
            }
          timer.stop();
          print_wall_time(deallog, timer, "assemble K");

          /**
           * Assemble the SLP matrix.
           */
          std::cout << "=== Assemble SLP matrix ===" << std::endl;

          timer.start();
          if (cpu_serial_)
            {
              assemble_bem_full_matrix_serial<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::SingleLayerKernel,
                KernelNumberType,
                SurfaceNormalDetector<dim, spacedim>,
                LAPACKFullMatrixExt<RangeNumberType>>(
                single_layer_kernel_cpu_,
                1.0,
                dof_handler_for_neumann_space_,
                dof_handler_for_neumann_space_,
                mappings_,
                material_id_to_mapping_index_,
                SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
                SauterQuadratureRule<dim>(5, 4, 4, 3),
                V1_matrix_);
            }
          else
            {
              assemble_bem_full_matrix<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::SingleLayerKernel,
                KernelNumberType,
                SurfaceNormalDetector<dim, spacedim>,
                LAPACKFullMatrixExt<RangeNumberType>>(
                single_layer_kernel_cpu_,
                1.0,
                dof_handler_for_neumann_space_,
                dof_handler_for_neumann_space_,
                mappings_,
                material_id_to_mapping_index_,
                SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
                SauterQuadratureRule<dim>(5, 4, 4, 3),
                V1_matrix_);
            }
          timer.stop();
          print_wall_time(deallog, timer, "assemble V");

          /**
           * Calculate the RHS vector.
           */
          timer.start();
          K2_matrix_with_mass_matrix_.vmult(system_rhs_on_dirichlet_domain_,
                                            dirichlet_bc_);
          timer.stop();
          print_wall_time(deallog, timer, "assemble RHS vector");

          break;
        }
        case NeumannBCProblem: {
          std::cout << "=== Assemble scaled mass matrix ===" << std::endl;

          /**
           * For the interior Laplace problem, \f$\frac{1}{2}I\f$ is
           * assembled, while for the exterior Laplace problem,
           * \f$-\frac{1}{2}I\f$ is assembled.
           */
          if (is_interior_problem_)
            {
              assemble_fem_scaled_mass_matrix<
                dim,
                spacedim,
                real_type,
                LAPACKFullMatrixExt<RangeNumberType>>(
                dof_handler_for_dirichlet_space_,
                dof_handler_for_neumann_space_,
                0.5,
                QGauss<2>(fe_for_dirichlet_space_.degree + 1),
                K_prime2_matrix_with_mass_matrix_);
            }
          else
            {
              assemble_fem_scaled_mass_matrix<
                dim,
                spacedim,
                real_type,
                LAPACKFullMatrixExt<RangeNumberType>>(
                dof_handler_for_dirichlet_space_,
                dof_handler_for_neumann_space_,
                -0.5,
                QGauss<2>(fe_for_dirichlet_space_.degree + 1),
                K_prime2_matrix_with_mass_matrix_);
            }

          /**
           * Assemble the ADLP matrix, which is added with the
           * previous
           * scaled FEM mass matrix.
           */
          std::cout << "=== Assemble ADLP matrix ===" << std::endl;
          assemble_bem_full_matrix<
            dim,
            spacedim,
            PlatformShared::LaplaceKernel::AdjointDoubleLayerKernel,
            KernelNumberType,
            SurfaceNormalDetector<dim, spacedim>,
            LAPACKFullMatrixExt<RangeNumberType>>(
            adjoint_double_layer_kernel_cpu_,
            -1.0,
            dof_handler_for_dirichlet_space_,
            dof_handler_for_neumann_space_,
            mappings_,
            material_id_to_mapping_index_,
            SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
            SauterQuadratureRule<dim>(5, 4, 4, 3),
            K_prime2_matrix_with_mass_matrix_);

          /**
           * Assemble the matrix for the hyper singular operator, where the
           * stabilization method is adopted.
           */
          std::cout << "=== Assemble D matrix ===" << std::endl;

          assemble_bem_full_matrix<
            dim,
            spacedim,
            PlatformShared::LaplaceKernel::HyperSingularKernelRegular,
            KernelNumberType,
            SurfaceNormalDetector<dim, spacedim>,
            LAPACKFullMatrixExt<RangeNumberType>>(
            hyper_singular_kernel_cpu_,
            1.0,
            dof_handler_for_dirichlet_space_,
            dof_handler_for_dirichlet_space_,
            mappings_,
            material_id_to_mapping_index_,
            SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
            SauterQuadratureRule<dim>(5, 4, 4, 3),
            D1_matrix_);

          /**
           * Calculate the RHS vector.
           */
          K_prime2_matrix_with_mass_matrix_.vmult(system_rhs_on_neumann_domain_,
                                                  neumann_bc_);

          compute_stabilization_terms_for_D1_fullmat();

          /**
           * Add the matrix \f$\alpha a a^T\f$ into \f$D\f$. N.B. The outer
           * product here is only formal and there is no complex conjugation
           * on the second operand in the complex valued case.
           */
          LAPACKFullMatrixExt<KernelNumberType> aaT(D1_matrix_.m(),
                                                    D1_matrix_.n());
          for (const auto &vec : mass_vmult_weq_)
            {
              aaT.outer_product_formal(vec, vec);
              D1_matrix_.add(alpha_for_neumann_, aaT);
            }

          break;
        }
        case MixedBCProblem: {
          Assert(false, ExcNotImplemented());
          break;
        }
        default: {
          Assert(false, ExcInternalError());
          break;
        }
    }
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  assemble_hmatrix_system()
{
  LogStream::Prefix prefix_string("assemble_hmatrix_system");
#if ENABLE_NVTX == 1
  HierBEM::CUDAWrappers::NVTXRange nvtx_range("assemble_hmatrix_system");
#endif

  Timer timer;

  MultithreadInfo::set_thread_limit(thread_num_);

  /**
   * Define the @p ACAConfig object.
   */
  ACAConfig<real_type> aca_config(max_hmat_rank_, aca_relative_error_, eta_);

  switch (problem_type_)
    {
        case DirichletBCProblem: {
#if ENABLE_MATRIX_EXPORT == 1
          // Output stream for matrices and vectors.
          std::ofstream out_mat;
          // Output stream for block cluster trees.
          std::ofstream out_bct;
#endif

          if (is_interior_problem_)
            {
#if ENABLE_NVTX == 1
              HierBEM::CUDAWrappers::NVTXRange nvtx_range("assemble sigma*I+K");
#endif

              std::cout << "=== Assemble sigma*I+K ===" << std::endl;

              fill_hmatrix_with_aca_plus_smp<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::DoubleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                SurfaceNormalDetector<dim, spacedim>>(
                thread_num_,
                K2_hmat_with_mass_matrix_,
                aca_config,
                double_layer_kernel_gpu_,
                CUDAKernelNumberType(1.0),
                real_type(0.5),
                dof_to_cell_topo_for_neumann_space_,
                dof_to_cell_topo_for_dirichlet_space_,
                SauterQuadratureRule<dim>(5, 4, 4, 3),
                QGauss<dim>(fe_order_for_dirichlet_space_ + 1),
                dof_handler_for_neumann_space_,
                dof_handler_for_dirichlet_space_,
                nullptr,
                nullptr,
                *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
                *dof_i2e_numbering_for_dirichlet_space_on_dirichlet_domain_,
                mappings_,
                material_id_to_mapping_index_,
                SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
                false);

              timer.stop();
              print_wall_time(deallog, timer, "assemble sigma*I+K");
            }
          else
            {
#if ENABLE_NVTX == 1
              HierBEM::CUDAWrappers::NVTXRange nvtx_range(
                "assemble (sigma-1)*I+K");
#endif

              std::cout << "=== Assemble (sigma-1)*I+K ===" << std::endl;

              fill_hmatrix_with_aca_plus_smp<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::DoubleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                SurfaceNormalDetector<dim, spacedim>>(
                thread_num_,
                K2_hmat_with_mass_matrix_,
                aca_config,
                double_layer_kernel_gpu_,
                CUDAKernelNumberType(1.0),
                real_type(-0.5),
                dof_to_cell_topo_for_neumann_space_,
                dof_to_cell_topo_for_dirichlet_space_,
                SauterQuadratureRule<dim>(5, 4, 4, 3),
                QGauss<dim>(fe_order_for_dirichlet_space_ + 1),
                dof_handler_for_neumann_space_,
                dof_handler_for_dirichlet_space_,
                nullptr,
                nullptr,
                *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
                *dof_i2e_numbering_for_dirichlet_space_on_dirichlet_domain_,
                mappings_,
                material_id_to_mapping_index_,
                SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
                false);

              timer.stop();
              print_wall_time(deallog, timer, "assemble (sigma-1)*I+K");
            }

          add_memory_consumption_row("K2 with mass H-matrix",
                                     K2_hmat_with_mass_matrix_,
                                     "After assembly");

#if ENABLE_MATRIX_EXPORT == 1
          // Print the RHS matrix.
          out_mat.open("matrices.dat");

          K2_hmat_with_mass_matrix_.print_as_formatted_full_matrix(
            out_mat, "K", 15, true, 25);

          out_bct.open("K_bct.dat");
          K2_hmat_with_mass_matrix_.write_leaf_set_by_iteration(out_bct, 1e-12);
          out_bct.close();
#endif

          std::cout << "=== Assemble the RHS vector ===" << std::endl;

          timer.start();
          K2_hmat_with_mass_matrix_.vmult(system_rhs_on_dirichlet_domain_,
                                          dirichlet_bc_internal_dof_numbering_);

          timer.stop();
          print_wall_time(deallog, timer, "assemble RHS vector");

#if ENABLE_MATRIX_EXPORT == 1
          // Print the RHS vector.
          print_vector_to_mat(out_mat,
                              "system_rhs",
                              system_rhs_on_dirichlet_domain_,
                              false,
                              15,
                              25);
#endif

          // Release the RHS matrix.
          std::cout << "=== Release the RHS matrix ===" << std::endl;

          K2_hmat_with_mass_matrix_.release();

          {
#if ENABLE_NVTX == 1
            HierBEM::CUDAWrappers::NVTXRange nvtx_range("assemble V");
#endif

            std::cout << "=== Assemble V ===" << std::endl;

            timer.start();

            fill_hmatrix_with_aca_plus_smp<
              dim,
              spacedim,
              PlatformShared::LaplaceKernel::SingleLayerKernel,
              RangeNumberType,
              KernelNumberType,
              SurfaceNormalDetector<dim, spacedim>>(
              thread_num_,
              V1_hmat_,
              aca_config,
              single_layer_kernel_gpu_,
              CUDAKernelNumberType(1.0),
              dof_to_cell_topo_for_neumann_space_,
              dof_to_cell_topo_for_neumann_space_,
              SauterQuadratureRule<dim>(5, 4, 4, 3),
              dof_handler_for_neumann_space_,
              dof_handler_for_neumann_space_,
              nullptr,
              nullptr,
              *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
              *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
              mappings_,
              material_id_to_mapping_index_,
              SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
              true);

            timer.stop();
            print_wall_time(deallog, timer, "assemble V");
          }

          add_memory_consumption_row("V1 H-matrix", V1_hmat_, "After assembly");

#if ENABLE_MATRIX_EXPORT == 1
          V1_hmat_.print_as_formatted_full_matrix(out_mat, "V", 15, true, 25);

          out_bct.open("V_bct.dat");
          V1_hmat_.write_leaf_set_by_iteration(out_bct, 1e-12);
          out_bct.close();

          out_mat.close();
#endif

          break;
        }
        case NeumannBCProblem: {
#if ENABLE_MATRIX_EXPORT == 1
          // Output stream for matrices and vectors.
          std::ofstream out_mat;
          // Output stream for block cluster trees.
          std::ofstream out_bct;
#endif

          if (is_interior_problem_)
            {
              std::cout << "=== Assemble (1-sigma)*I-K' ===" << std::endl;

              fill_hmatrix_with_aca_plus_smp<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::AdjointDoubleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                SurfaceNormalDetector<dim, spacedim>>(
                thread_num_,
                K_prime2_hmat_with_mass_matrix_,
                aca_config,
                adjoint_double_layer_kernel_gpu_,
                CUDAKernelNumberType(-1.0),
                real_type(0.5),
                dof_to_cell_topo_for_dirichlet_space_,
                dof_to_cell_topo_for_neumann_space_,
                SauterQuadratureRule<dim>(5, 4, 4, 3),
                QGauss<dim>(fe_order_for_dirichlet_space_ + 1),
                dof_handler_for_dirichlet_space_,
                dof_handler_for_neumann_space_,
                nullptr,
                nullptr,
                *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
                *dof_i2e_numbering_for_neumann_space_on_neumann_domain_,
                mappings_,
                material_id_to_mapping_index_,
                SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
                false);

              timer.stop();
              print_wall_time(deallog, timer, "assemble (1-sigma)*I-K'");
            }
          else
            {
              std::cout << "=== Assemble -sigma*I-K' ===" << std::endl;

              fill_hmatrix_with_aca_plus_smp<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::AdjointDoubleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                SurfaceNormalDetector<dim, spacedim>>(
                thread_num_,
                K_prime2_hmat_with_mass_matrix_,
                aca_config,
                adjoint_double_layer_kernel_gpu_,
                CUDAKernelNumberType(-1.0),
                real_type(-0.5),
                dof_to_cell_topo_for_dirichlet_space_,
                dof_to_cell_topo_for_neumann_space_,
                SauterQuadratureRule<dim>(5, 4, 4, 3),
                QGauss<dim>(fe_order_for_dirichlet_space_ + 1),
                dof_handler_for_dirichlet_space_,
                dof_handler_for_neumann_space_,
                nullptr,
                nullptr,
                *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
                *dof_i2e_numbering_for_neumann_space_on_neumann_domain_,
                mappings_,
                material_id_to_mapping_index_,
                SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
                false);

              timer.stop();
              print_wall_time(deallog, timer, "assemble -sigma*I-K'");
            }

          add_memory_consumption_row("K'2 with mass H-matrix",
                                     K_prime2_hmat_with_mass_matrix_,
                                     "After assembly");

#if ENABLE_MATRIX_EXPORT == 1
          // Print the RHS matrix.
          out_mat.open("matrices.dat");

          K_prime2_hmat_with_mass_matrix_.print_as_formatted_full_matrix(
            out_mat, "K_prime", 15, true, 25);

          out_bct.open("K_prime_bct.dat");
          K_prime2_hmat_with_mass_matrix_.write_leaf_set_by_iteration(out_bct,
                                                                      1e-12);
          out_bct.close();
#endif

          /**
           * Calculate the RHS vector.
           */
          std::cout << "=== Assemble the RHS vector ===" << std::endl;

          timer.start();

          K_prime2_hmat_with_mass_matrix_.vmult(
            system_rhs_on_neumann_domain_, neumann_bc_internal_dof_numbering_);

          timer.stop();
          print_wall_time(deallog, timer, "assemble RHS vector");

#if ENABLE_MATRIX_EXPORT == 1
          // Print the RHS vector.
          print_vector_to_mat(out_mat,
                              "system_rhs",
                              system_rhs_on_neumann_domain_,
                              false,
                              15,
                              25);
#endif

          std::cout << "=== Release K' ===" << std::endl;
          K_prime2_hmat_with_mass_matrix_.release();

          std::cout << "=== Compute stabilization terms ===" << std::endl;
          timer.start();
          compute_stabilization_terms_for_D1_hmat();
          timer.stop();
          print_wall_time(deallog, timer, "compute stabilization terms");

          /**
           * Assemble the regularized bilinear form for the hyper-singular
           * operator along with the stabilization term.
           */
          std::cout << "=== Assemble D ===" << std::endl;

          timer.start();

          fill_hmatrix_with_aca_plus_smp<
            dim,
            spacedim,
            PlatformShared::LaplaceKernel::HyperSingularKernelRegular,
            RangeNumberType,
            KernelNumberType,
            SurfaceNormalDetector<dim, spacedim>>(
            thread_num_,
            D1_hmat_,
            aca_config,
            hyper_singular_kernel_gpu_,
            CUDAKernelNumberType(1.0),
            mass_vmult_weq_,
            alpha_for_neumann_,
            dof_to_cell_topo_for_dirichlet_space_,
            dof_to_cell_topo_for_dirichlet_space_,
            SauterQuadratureRule<dim>(5, 4, 4, 3),
            dof_handler_for_dirichlet_space_,
            dof_handler_for_dirichlet_space_,
            nullptr,
            nullptr,
            *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
            *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
            mappings_,
            material_id_to_mapping_index_,
            SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
            true);

          timer.stop();
          print_wall_time(deallog, timer, "assemble D");

          add_memory_consumption_row("D1 H-matrix", D1_hmat_, "After assembly");

#if ENABLE_MATRIX_EXPORT == 1
          D1_hmat_.print_as_formatted_full_matrix(out_mat, "D", 15, true, 25);

          out_bct.open("D_bct.dat");
          D1_hmat_.write_leaf_set_by_iteration(out_bct, 1e-12);
          out_bct.close();

          out_mat.close();
#endif

          break;
        }
        case MixedBCProblem: {
          /**
           * For the mixed boundary condition, we firstly assemble the right
           * hand side matrices and vectors. Then after releasing these
           * matrices for saving the memory, we continue to assemble the left
           * hand side matrices, i.e. stiff matrices.
           */
#if ENABLE_MATRIX_EXPORT == 1
          // Output stream for matrices and vectors.
          std::ofstream out_mat;
          // Output stream for block cluster trees.
          std::ofstream out_bct;
#endif

          if (is_interior_problem_)
            {
              std::cout << "=== Assemble sigma*I+K ===" << std::endl;

              fill_hmatrix_with_aca_plus_smp<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::DoubleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                SurfaceNormalDetector<dim, spacedim>>(
                thread_num_,
                K2_hmat_with_mass_matrix_,
                aca_config,
                double_layer_kernel_gpu_,
                CUDAKernelNumberType(1.0),
                real_type(0.5),
                dof_to_cell_topo_for_neumann_space_,
                dof_to_cell_topo_for_dirichlet_space_,
                SauterQuadratureRule<dim>(5, 4, 4, 3),
                QGauss<dim>(fe_order_for_dirichlet_space_ + 1),
                dof_handler_for_neumann_space_,
                dof_handler_for_dirichlet_space_,
                &local_to_full_neumann_dof_indices_on_dirichlet_domain_,
                &local_to_full_dirichlet_dof_indices_on_dirichlet_domain_,
                *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
                *dof_i2e_numbering_for_dirichlet_space_on_dirichlet_domain_,
                mappings_,
                material_id_to_mapping_index_,
                SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
                false);

              timer.stop();
              print_wall_time(deallog, timer, "assemble sigma*I+K");

              std::cout << "=== Assemble (1-sigma)*I-K' ===" << std::endl;

              timer.start();

              fill_hmatrix_with_aca_plus_smp<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::AdjointDoubleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                SurfaceNormalDetector<dim, spacedim>>(
                thread_num_,
                K_prime2_hmat_with_mass_matrix_,
                aca_config,
                adjoint_double_layer_kernel_gpu_,
                CUDAKernelNumberType(-1.0),
                real_type(0.5),
                dof_to_cell_topo_for_dirichlet_space_,
                dof_to_cell_topo_for_neumann_space_,
                SauterQuadratureRule<dim>(5, 4, 4, 3),
                QGauss<dim>(fe_order_for_dirichlet_space_ + 1),
                dof_handler_for_dirichlet_space_,
                dof_handler_for_neumann_space_,
                &local_to_full_dirichlet_dof_indices_on_neumann_domain_,
                &local_to_full_neumann_dof_indices_on_neumann_domain_,
                *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
                *dof_i2e_numbering_for_neumann_space_on_neumann_domain_,
                mappings_,
                material_id_to_mapping_index_,
                SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
                false);

              timer.stop();
              print_wall_time(deallog, timer, "assemble (1-sigma)*I-K'");
            }
          else
            {
              std::cout << "=== Assemble (sigma-1)*I+K ===" << std::endl;

              fill_hmatrix_with_aca_plus_smp<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::DoubleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                SurfaceNormalDetector<dim, spacedim>>(
                thread_num_,
                K2_hmat_with_mass_matrix_,
                aca_config,
                double_layer_kernel_gpu_,
                CUDAKernelNumberType(1.0),
                real_type(-0.5),
                dof_to_cell_topo_for_neumann_space_,
                dof_to_cell_topo_for_dirichlet_space_,
                SauterQuadratureRule<dim>(5, 4, 4, 3),
                QGauss<dim>(fe_order_for_dirichlet_space_ + 1),
                dof_handler_for_neumann_space_,
                dof_handler_for_dirichlet_space_,
                &local_to_full_neumann_dof_indices_on_dirichlet_domain_,
                &local_to_full_dirichlet_dof_indices_on_dirichlet_domain_,
                *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
                *dof_i2e_numbering_for_dirichlet_space_on_dirichlet_domain_,
                mappings_,
                material_id_to_mapping_index_,
                SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
                false);

              timer.stop();
              print_wall_time(deallog, timer, "assemble (sigma-1)*I+K");

              std::cout << "=== Assemble -sigma*I-K' ===" << std::endl;

              timer.start();

              fill_hmatrix_with_aca_plus_smp<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::AdjointDoubleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                SurfaceNormalDetector<dim, spacedim>>(
                thread_num_,
                K_prime2_hmat_with_mass_matrix_,
                aca_config,
                adjoint_double_layer_kernel_gpu_,
                CUDAKernelNumberType(-1.0),
                real_type(-0.5),
                dof_to_cell_topo_for_dirichlet_space_,
                dof_to_cell_topo_for_neumann_space_,
                SauterQuadratureRule<dim>(5, 4, 4, 3),
                QGauss<dim>(fe_order_for_dirichlet_space_ + 1),
                dof_handler_for_dirichlet_space_,
                dof_handler_for_neumann_space_,
                &local_to_full_dirichlet_dof_indices_on_neumann_domain_,
                &local_to_full_neumann_dof_indices_on_neumann_domain_,
                *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
                *dof_i2e_numbering_for_neumann_space_on_neumann_domain_,
                mappings_,
                material_id_to_mapping_index_,
                SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
                false);

              timer.stop();
              print_wall_time(deallog, timer, "assemble -sigma*I-K'");
            }

          add_memory_consumption_row("K2 with mass H-matrix",
                                     K2_hmat_with_mass_matrix_,
                                     "After assembly");
          add_memory_consumption_row("K'2 with mass H-matrix",
                                     K_prime2_hmat_with_mass_matrix_,
                                     "After assembly");

          std::cout << "=== Assemble -V2 ===" << std::endl;

          timer.start();

          fill_hmatrix_with_aca_plus_smp<
            dim,
            spacedim,
            PlatformShared::LaplaceKernel::SingleLayerKernel,
            RangeNumberType,
            KernelNumberType,
            SurfaceNormalDetector<dim, spacedim>>(
            thread_num_,
            V2_hmat_,
            aca_config,
            single_layer_kernel_gpu_,
            CUDAKernelNumberType(-1.0),
            dof_to_cell_topo_for_neumann_space_,
            dof_to_cell_topo_for_neumann_space_,
            SauterQuadratureRule<dim>(5, 4, 4, 3),
            dof_handler_for_neumann_space_,
            dof_handler_for_neumann_space_,
            &local_to_full_neumann_dof_indices_on_dirichlet_domain_,
            &local_to_full_neumann_dof_indices_on_neumann_domain_,
            *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
            *dof_i2e_numbering_for_neumann_space_on_neumann_domain_,
            mappings_,
            material_id_to_mapping_index_,
            SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
            false);

          timer.stop();
          print_wall_time(deallog, timer, "assemble -V2");

          add_memory_consumption_row("V2 H-matrix", V2_hmat_, "After assembly");

          std::cout << "=== Assemble -D2 ===" << std::endl;

          timer.start();

          fill_hmatrix_with_aca_plus_smp<
            dim,
            spacedim,
            PlatformShared::LaplaceKernel::HyperSingularKernelRegular,
            RangeNumberType,
            KernelNumberType,
            SurfaceNormalDetector<dim, spacedim>>(
            thread_num_,
            D2_hmat_,
            aca_config,
            hyper_singular_kernel_gpu_,
            CUDAKernelNumberType(-1.0),
            dof_to_cell_topo_for_dirichlet_space_,
            dof_to_cell_topo_for_dirichlet_space_,
            SauterQuadratureRule<dim>(5, 4, 4, 3),
            dof_handler_for_dirichlet_space_,
            dof_handler_for_dirichlet_space_,
            &local_to_full_dirichlet_dof_indices_on_neumann_domain_,
            &local_to_full_dirichlet_dof_indices_on_dirichlet_domain_,
            *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
            *dof_i2e_numbering_for_dirichlet_space_on_dirichlet_domain_,
            mappings_,
            material_id_to_mapping_index_,
            SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
            false);

          timer.stop();
          print_wall_time(deallog, timer, "assemble -D2");

          add_memory_consumption_row("D2 H-matrix", D2_hmat_, "After assembly");

#if ENABLE_MATRIX_EXPORT == 1
          // Print RHS matrices.
          out_mat.open("matrices.dat");

          K2_hmat_with_mass_matrix_.print_as_formatted_full_matrix(
            out_mat, "K2", 15, true, 25);
          K_prime2_hmat_with_mass_matrix_.print_as_formatted_full_matrix(
            out_mat, "K_prime2", 15, true, 25);
          V2_hmat_.print_as_formatted_full_matrix(out_mat, "V2", 15, true, 25);
          D2_hmat_.print_as_formatted_full_matrix(out_mat, "D2", 15, true, 25);

          out_bct.open("K2_bct.dat");
          K2_hmat_with_mass_matrix_.write_leaf_set_by_iteration(out_bct, 1e-12);
          out_bct.close();

          out_bct.open("K_prime2_bct.dat");
          K_prime2_hmat_with_mass_matrix_.write_leaf_set_by_iteration(out_bct,
                                                                      1e-12);
          out_bct.close();

          out_bct.open("V2_bct.dat");
          V2_hmat_.write_leaf_set_by_iteration(out_bct, 1e-12);
          out_bct.close();

          out_bct.open("D2_bct.dat");
          D2_hmat_.write_leaf_set_by_iteration(out_bct, 1e-12);
          out_bct.close();
#endif

          // Calculate the RHS vectors in the mixed boundary value problem.
          std::cout << "=== Assemble RHS vectors ===" << std::endl;

          timer.start();

          K2_hmat_with_mass_matrix_.vmult(system_rhs_on_dirichlet_domain_,
                                          dirichlet_bc_internal_dof_numbering_);
          V2_hmat_.vmult_add(system_rhs_on_dirichlet_domain_,
                             neumann_bc_internal_dof_numbering_);

          timer.stop();
          print_wall_time(deallog,
                          timer,
                          "assemble RHS vector on Dirichlet domain");

          timer.start();

          D2_hmat_.vmult(system_rhs_on_neumann_domain_,
                         dirichlet_bc_internal_dof_numbering_);
          K_prime2_hmat_with_mass_matrix_.vmult_add(
            system_rhs_on_neumann_domain_, neumann_bc_internal_dof_numbering_);

          timer.stop();
          print_wall_time(deallog,
                          timer,
                          "assemble RHS vector on Neumann domain");

          // Combine the two part of RHS vectors.
          copy_vector(system_rhs_on_combined_domain_,
                      0,
                      system_rhs_on_dirichlet_domain_,
                      0,
                      system_rhs_on_dirichlet_domain_.size());
          copy_vector(system_rhs_on_combined_domain_,
                      system_rhs_on_dirichlet_domain_.size(),
                      system_rhs_on_neumann_domain_,
                      0,
                      system_rhs_on_neumann_domain_.size());

#if ENABLE_MATRIX_EXPORT == 1
          // Print RHS vectors.
          print_vector_to_mat(out_mat,
                              "system_rhs_on_combined_domain",
                              system_rhs_on_combined_domain_,
                              false,
                              15,
                              25);

          print_vector_to_mat(out_mat,
                              "system_rhs_on_dirichlet_domain",
                              system_rhs_on_dirichlet_domain_,
                              false,
                              15,
                              25);

          print_vector_to_mat(out_mat,
                              "system_rhs_on_neumann_domain",
                              system_rhs_on_neumann_domain_,
                              false,
                              15,
                              25);
#endif

          // Release the RHS matrices.
          std::cout << "=== Release RHS matrices ===" << std::endl;

          K2_hmat_with_mass_matrix_.release();
          K_prime2_hmat_with_mass_matrix_.release();
          V2_hmat_.release();
          D2_hmat_.release();

          std::cout << "=== Assemble V1 ===" << std::endl;

          timer.start();

          fill_hmatrix_with_aca_plus_smp<
            dim,
            spacedim,
            PlatformShared::LaplaceKernel::SingleLayerKernel,
            RangeNumberType,
            KernelNumberType,
            SurfaceNormalDetector<dim, spacedim>>(
            thread_num_,
            V1_hmat_,
            aca_config,
            single_layer_kernel_gpu_,
            CUDAKernelNumberType(1.0),
            dof_to_cell_topo_for_neumann_space_,
            dof_to_cell_topo_for_neumann_space_,
            SauterQuadratureRule<dim>(5, 4, 4, 3),
            dof_handler_for_neumann_space_,
            dof_handler_for_neumann_space_,
            &local_to_full_neumann_dof_indices_on_dirichlet_domain_,
            &local_to_full_neumann_dof_indices_on_dirichlet_domain_,
            *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
            *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
            mappings_,
            material_id_to_mapping_index_,
            SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
            true);

          timer.stop();
          print_wall_time(deallog, timer, "assemble V1");

          add_memory_consumption_row("V1 H-matrix", V1_hmat_, "After assembly");

          std::cout << "=== Assemble -K1 ===" << std::endl;

          timer.start();

          fill_hmatrix_with_aca_plus_smp<
            dim,
            spacedim,
            PlatformShared::LaplaceKernel::DoubleLayerKernel,
            RangeNumberType,
            KernelNumberType,
            SurfaceNormalDetector<dim, spacedim>>(
            thread_num_,
            K1_hmat_,
            aca_config,
            double_layer_kernel_gpu_,
            CUDAKernelNumberType(-1.0),
            dof_to_cell_topo_for_neumann_space_,
            dof_to_cell_topo_for_dirichlet_space_,
            SauterQuadratureRule<dim>(5, 4, 4, 3),
            dof_handler_for_neumann_space_,
            dof_handler_for_dirichlet_space_,
            &local_to_full_neumann_dof_indices_on_dirichlet_domain_,
            &local_to_full_dirichlet_dof_indices_on_neumann_domain_,
            *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
            *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
            mappings_,
            material_id_to_mapping_index_,
            SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
            false);

          timer.stop();
          print_wall_time(deallog, timer, "assemble -K1");

          add_memory_consumption_row("K1 H-matrix", K1_hmat_, "After assembly");

          std::cout << "=== Assemble D1 ===" << std::endl;

          timer.start();

          fill_hmatrix_with_aca_plus_smp<
            dim,
            spacedim,
            PlatformShared::LaplaceKernel::HyperSingularKernelRegular,
            RangeNumberType,
            KernelNumberType,
            SurfaceNormalDetector<dim, spacedim>>(
            thread_num_,
            D1_hmat_,
            aca_config,
            hyper_singular_kernel_gpu_,
            CUDAKernelNumberType(1.0),
            dof_to_cell_topo_for_dirichlet_space_,
            dof_to_cell_topo_for_dirichlet_space_,
            SauterQuadratureRule<dim>(5, 4, 4, 3),
            dof_handler_for_dirichlet_space_,
            dof_handler_for_dirichlet_space_,
            &local_to_full_dirichlet_dof_indices_on_neumann_domain_,
            &local_to_full_dirichlet_dof_indices_on_neumann_domain_,
            *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
            *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
            mappings_,
            material_id_to_mapping_index_,
            SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
            true);

          timer.stop();
          print_wall_time(deallog, timer, "assemble D1");

          add_memory_consumption_row("D1 H-matrix", D1_hmat_, "After assembly");

          // Assemble the block matrix.
          std::cout << "=== Assemble system block matrix ===" << std::endl;
          M_hmat_ = HBlockMatrixSkewSymm<spacedim, RangeNumberType>(&V1_hmat_,
                                                                    &K1_hmat_,
                                                                    &D1_hmat_);

#if ENABLE_MATRIX_EXPORT == 1
          // Print LHS matrices.
          V1_hmat_.print_as_formatted_full_matrix(out_mat, "V1", 15, true, 25);
          K1_hmat_.print_as_formatted_full_matrix(out_mat, "K1", 15, true, 25);
          D1_hmat_.print_as_formatted_full_matrix(out_mat, "D1", 15, true, 25);

          out_bct.open("V1_bct.dat");
          V1_hmat_.write_leaf_set_by_iteration(out_bct, 1e-12);
          out_bct.close();

          out_bct.open("K1_bct.dat");
          K1_hmat_.write_leaf_set_by_iteration(out_bct, 1e-12);
          out_bct.close();

          out_bct.open("D1_bct.dat");
          D1_hmat_.write_leaf_set_by_iteration(out_bct, 1e-12);
          out_bct.close();

          out_mat.close();
#endif

          break;
        }
        default: {
          Assert(false, ExcInternalError());
          break;
        }
    }
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  assemble_hmatrix_preconditioner()
{
  LogStream::Prefix prefix_string("assemble_hmatrix_preconditioner");

  Timer timer;

  MultithreadInfo::set_thread_limit(thread_num_);

  switch (problem_type_)
    {
        case DirichletBCProblem: {
          std::cout << "=== Assemble preconditioner for V ===" << std::endl;

          switch (preconditioner_type_)
            {
                case PreconditionerType::HMatrixFactorization: {
                  // Directly make a copy of the existing \hmat and then
                  // truncate its rank.
                  V1_hmat_preconditioner_ = V1_hmat_;

                  // Only when the \hmat actually has a hierarchical
                  // structure, the SPD preserving rank truncation will be
                  // performed. This excludes
                  // the case when @p V1 has a single root node, which is a full
                  // matrix.
                  if (V1_hmat_preconditioner_.get_type() ==
                      HMatrixType::HierarchicalMatrixType)
                    {
                      V1_hmat_preconditioner_
                        .truncate_to_rank_preserve_positive_definite(
                          max_hmat_rank_for_preconditioner_);
                    }

                  timer.stop();
                  print_wall_time(deallog, timer, "truncate V");

                  add_memory_consumption_row("V1 H-matrix preconditioner",
                                             V1_hmat_preconditioner_,
                                             "After assembly");

                  /**
                   * Perform Cholesky factorization of the preconditioner.
                   */
                  std::cout
                    << "=== Cholesky factorization of the preconditioner for V ==="
                    << std::endl;

                  timer.start();

                  // Only when the \hmat actually has a hierarchical
                  // structure, the task parallel Cholesky factorization will
                  // be performed. This
                  // excludes the case when @p V1 has a single root node, which is a
                  // full matrix.
                  if (V1_hmat_preconditioner_.get_type() ==
                      HMatrixType::HierarchicalMatrixType)
                    {
                      V1_hmat_preconditioner_
                        .compute_cholesky_factorization_task_parallel(
                          max_hmat_rank_for_preconditioner_);
                    }
                  else
                    {
                      V1_hmat_preconditioner_.compute_cholesky_factorization(
                        max_hmat_rank_for_preconditioner_);
                    }

                  timer.stop();
                  print_wall_time(deallog,
                                  timer,
                                  "Cholesky factorization of V");

                  break;
                }
                case PreconditionerType::OperatorPreconditioning: {
                  // Generate the multigrid.
                  mg_tria_for_preconditioner_.copy_triangulation(tria_);
                  mg_tria_for_preconditioner_.refine_global();

                  if (operator_preconditioner_dirichlet_ != nullptr)
                    {
                      delete operator_preconditioner_dirichlet_;
                      operator_preconditioner_dirichlet_ = nullptr;
                    }

                  operator_preconditioner_dirichlet_ =
                    new PreconditionerForLaplaceDirichlet<dim,
                                                          spacedim,
                                                          RangeNumberType,
                                                          KernelNumberType>(
                      fe_for_neumann_space_,
                      fe_for_dirichlet_space_,
                      mg_tria_for_preconditioner_,
                      *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
                      *dof_e2i_numbering_for_neumann_space_on_dirichlet_domain_);

                  operator_preconditioner_dirichlet_->setup_preconditioner(
                    thread_num_,
                    HMatrixParameters(n_min_for_ct_,
                                      n_min_for_bct_,
                                      eta_,
                                      max_hmat_rank_,
                                      aca_relative_error_),
                    subdomain_topology_,
                    mappings_,
                    material_id_to_mapping_index_,
                    SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
                    SauterQuadratureRule<dim>(5, 4, 4, 3),
                    QGauss<2>(fe_for_dirichlet_space_.degree + 1));

                  break;
                }
                case PreconditionerType::Identity: {
                  break;
                }
                case PreconditionerType::Jacobi: {
                  // TODO
                  Assert(false, ExcNotImplemented());
                  break;
                }
                default: {
                  Assert(false, ExcInternalError());
                  break;
                }
            }

          break;
        }
        case NeumannBCProblem: {
          std::cout << "=== Assemble preconditioner for D ===" << std::endl;

          switch (preconditioner_type_)
            {
                case PreconditionerType::HMatrixFactorization: {
                  // Directly make a copy of the existing \hmat and then
                  // truncate its rank.
                  D1_hmat_preconditioner_ = D1_hmat_;

                  // Only when the \hmat actually has a hierarchical structure,
                  // the SPD preserving rank truncation will be performed. This
                  // excludes
                  // the case when @p D1 has a single root node, which is a full
                  // matrix.
                  if (D1_hmat_preconditioner_.get_type() ==
                      HMatrixType::HierarchicalMatrixType)
                    {
                      D1_hmat_preconditioner_
                        .truncate_to_rank_preserve_positive_definite(
                          max_hmat_rank_for_preconditioner_);
                    }

                  timer.stop();
                  print_wall_time(deallog, timer, "truncate D");

                  add_memory_consumption_row("D1 H-matrix preconditioner",
                                             D1_hmat_preconditioner_,
                                             "After assembly");

                  /**
                   * Perform Cholesky factorization of the preconditioner.
                   */
                  std::cout << "=== Cholesky factorization of D ==="
                            << std::endl;

                  timer.start();

                  // Only when the \hmat actually has a hierarchical structure,
                  // the task parallel Cholesky factorization will be performed.
                  // This
                  // excludes the case when @p D1 has a single root node, which is a
                  // full matrix.
                  if (D1_hmat_preconditioner_.get_type() ==
                      HMatrixType::HierarchicalMatrixType)
                    {
                      D1_hmat_preconditioner_
                        .compute_cholesky_factorization_task_parallel(
                          max_hmat_rank_for_preconditioner_);
                    }
                  else
                    {
                      D1_hmat_preconditioner_.compute_cholesky_factorization(
                        max_hmat_rank_for_preconditioner_);
                    }

                  timer.stop();
                  print_wall_time(deallog,
                                  timer,
                                  "Cholesky factorization of D");

                  break;
                }
                case PreconditionerType::OperatorPreconditioning: {
                  // Generate the multigrid.
                  mg_tria_for_preconditioner_.copy_triangulation(tria_);
                  mg_tria_for_preconditioner_.refine_global();

                  if (operator_preconditioner_neumann_ != nullptr)
                    {
                      delete operator_preconditioner_neumann_;
                      operator_preconditioner_neumann_ = nullptr;
                    }

                  operator_preconditioner_neumann_ =
                    new PreconditionerForLaplaceNeumann<dim,
                                                        spacedim,
                                                        RangeNumberType,
                                                        KernelNumberType>(
                      fe_for_dirichlet_space_,
                      fe_for_neumann_space_,
                      mg_tria_for_preconditioner_,
                      *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
                      *dof_e2i_numbering_for_dirichlet_space_on_neumann_domain_);

                  operator_preconditioner_neumann_->setup_preconditioner(
                    thread_num_,
                    HMatrixParameters(n_min_for_ct_,
                                      n_min_for_bct_,
                                      eta_,
                                      max_hmat_rank_,
                                      aca_relative_error_),
                    subdomain_topology_,
                    mappings_,
                    material_id_to_mapping_index_,
                    SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
                    SauterQuadratureRule<dim>(5, 4, 4, 3),
                    QGauss<2>(fe_for_dirichlet_space_.degree + 1));

                  break;
                }
                case PreconditionerType::Identity: {
                  break;
                }
                case PreconditionerType::Jacobi: {
                  // TODO
                  Assert(false, ExcNotImplemented());
                  break;
                }
                default: {
                  Assert(false, ExcInternalError());
                  break;
                }
            }

          break;
        }
        case MixedBCProblem: {
          // Assemble preconditioners for the mixed boundary value problem.
          std::cout
            << "=== Assemble preconditioner for the system block matrix ==="
            << std::endl;

          switch (preconditioner_type_)
            {
                case PreconditionerType::HMatrixFactorization: {
                  // Directly make copies of existing \hmatrices and then
                  // truncate their ranks.
                  M11_in_preconditioner_ = V1_hmat_;
                  M12_in_preconditioner_ = K1_hmat_;
                  M22_in_preconditioner_ = D1_hmat_;

                  // Only when the \hmat actually has a hierarchical structure,
                  // the SPD preserving rank truncation will be performed. This
                  // excludes
                  // the case when @p M11 has a single root node, which is a full
                  // matrix.
                  if (M11_in_preconditioner_.get_type() ==
                      HMatrixType::HierarchicalMatrixType)
                    {
                      M11_in_preconditioner_
                        .truncate_to_rank_preserve_positive_definite(
                          max_hmat_rank_for_preconditioner_);
                    }

                  timer.stop();
                  print_wall_time(deallog, timer, "truncate M11(==V1)");

                  add_memory_consumption_row("M11(V1) H-matrix preconditioner",
                                             M11_in_preconditioner_,
                                             "After assembly");

                  timer.start();

                  // Only when the \hmat actually has a hierarchical structure,
                  // the rank truncation will be performed. This excludes
                  // the case when @p M12 has a single root node, which is a full
                  // matrix.
                  if (M12_in_preconditioner_.get_type() ==
                      HMatrixType::HierarchicalMatrixType)
                    {
                      M12_in_preconditioner_.truncate_to_rank(
                        max_hmat_rank_for_preconditioner_);
                    }

                  timer.stop();
                  print_wall_time(deallog, timer, "truncate M12(==K1)");

                  add_memory_consumption_row("M12(K1) H-matrix preconditioner",
                                             M12_in_preconditioner_,
                                             "After assembly");

                  timer.start();

                  // Only when the \hmat actually has a hierarchical structure,
                  // the SPD preserving rank truncation will be performed. This
                  // excludes
                  // the case when @p M22 has a single root node, which is a full
                  // matrix.
                  if (M22_in_preconditioner_.get_type() ==
                      HMatrixType::HierarchicalMatrixType)
                    {
                      M22_in_preconditioner_
                        .truncate_to_rank_preserve_positive_definite(
                          max_hmat_rank_for_preconditioner_);
                    }

                  timer.stop();
                  print_wall_time(deallog, timer, "truncate M22(==D1)");

                  add_memory_consumption_row("M22(D1) H-matrix preconditioner",
                                             M22_in_preconditioner_,
                                             "After assembly");

                  M_hmat_preconditioner_ =
                    HBlockMatrixSkewSymmPreconditioner<spacedim,
                                                       RangeNumberType>(
                      &M11_in_preconditioner_,
                      &M12_in_preconditioner_,
                      &M22_in_preconditioner_);

                  // Perform \hmat-LU factorization to the block preconditioner.
                  std::cout << "=== LU factorization of system block matrix ==="
                            << std::endl;

                  timer.start();

                  M_hmat_preconditioner_.compute_lu_factorization(
                    max_hmat_rank_for_preconditioner_);

                  timer.stop();
                  print_wall_time(deallog, timer, "LU factorization of M");

                  break;
                }
                case PreconditionerType::OperatorPreconditioning: {
                  // Generate the multigrid.
                  mg_tria_for_preconditioner_.copy_triangulation(tria_);
                  mg_tria_for_preconditioner_.refine_global();

                  // Collect material ids into sets.
                  std::set<types::material_id> dirichlet_domain_material_ids;
                  for (const auto &bc : dirichlet_bc_definition_)
                    {
                      dirichlet_domain_material_ids.insert(bc.first);
                    }

                  std::set<types::material_id> neumann_domain_material_ids;
                  for (const auto &bc : neumann_bc_definition_)
                    {
                      neumann_domain_material_ids.insert(bc.first);
                    }

                  if (operator_preconditioner_dirichlet_ != nullptr)
                    {
                      delete operator_preconditioner_dirichlet_;
                      operator_preconditioner_dirichlet_ = nullptr;
                    }

                  operator_preconditioner_dirichlet_ =
                    new PreconditionerForLaplaceDirichlet<dim,
                                                          spacedim,
                                                          RangeNumberType,
                                                          KernelNumberType>(
                      fe_for_neumann_space_,
                      fe_for_dirichlet_space_,
                      mg_tria_for_preconditioner_,
                      *dof_i2e_numbering_for_neumann_space_on_dirichlet_domain_,
                      *dof_e2i_numbering_for_neumann_space_on_dirichlet_domain_,
                      dirichlet_domain_material_ids);

                  if (operator_preconditioner_neumann_ != nullptr)
                    {
                      delete operator_preconditioner_neumann_;
                      operator_preconditioner_neumann_ = nullptr;
                    }

                  operator_preconditioner_neumann_ =
                    new PreconditionerForLaplaceNeumann<dim,
                                                        spacedim,
                                                        RangeNumberType,
                                                        KernelNumberType>(
                      fe_for_dirichlet_space_,
                      fe_for_neumann_space_,
                      mg_tria_for_preconditioner_,
                      *dof_i2e_numbering_for_dirichlet_space_on_neumann_domain_,
                      *dof_e2i_numbering_for_dirichlet_space_on_neumann_domain_,
                      neumann_domain_material_ids,
                      dirichlet_domain_material_ids);

                  operator_preconditioner_dirichlet_->setup_preconditioner(
                    thread_num_,
                    HMatrixParameters(n_min_for_ct_,
                                      n_min_for_bct_,
                                      eta_,
                                      max_hmat_rank_,
                                      aca_relative_error_),
                    subdomain_topology_,
                    mappings_,
                    material_id_to_mapping_index_,
                    SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
                    SauterQuadratureRule<dim>(5, 4, 4, 3),
                    QGauss<2>(fe_for_dirichlet_space_.degree + 1));

                  operator_preconditioner_neumann_->setup_preconditioner(
                    thread_num_,
                    HMatrixParameters(n_min_for_ct_,
                                      n_min_for_bct_,
                                      eta_,
                                      max_hmat_rank_,
                                      aca_relative_error_),
                    subdomain_topology_,
                    mappings_,
                    material_id_to_mapping_index_,
                    SurfaceNormalDetector<dim, spacedim>(subdomain_topology_),
                    SauterQuadratureRule<dim>(5, 4, 4, 3),
                    QGauss<2>(fe_for_dirichlet_space_.degree + 1));

                  break;
                }
                case PreconditionerType::Identity: {
                  break;
                }
                case PreconditionerType::Jacobi: {
                  // TODO
                  Assert(false, ExcNotImplemented());
                  break;
                }
                default: {
                  Assert(false, ExcInternalError());
                  break;
                }
            }

          break;
        }
        default: {
          Assert(false, ExcInternalError());
          break;
        }
    }
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::solve()
{
#if ENABLE_NVTX == 1
  HierBEM::CUDAWrappers::NVTXRange nvtx_range("solve");
#endif

  std::cout << "=== Solve problem ===" << std::endl;

  if (!use_hmat_)
    {
      switch (problem_type_)
        {
            case DirichletBCProblem: {
              SolverControl solver_control(1000, 1e-8, true, true);
              SolverCGGeneral<Vector<RangeNumberType>> solver(solver_control);

              solver.solve(V1_matrix_,
                           neumann_data_,
                           system_rhs_on_dirichlet_domain_,
                           PreconditionIdentity());

              break;
            }
            case NeumannBCProblem: {
              SolverControl solver_control(1000, 1e-8, true, true);
              SolverCGGeneral<Vector<RangeNumberType>> solver(solver_control);

              solver.solve(D1_matrix_,
                           dirichlet_data_,
                           system_rhs_on_neumann_domain_,
                           PreconditionIdentity());

              break;
            }
            case MixedBCProblem: {
              Assert(false, ExcNotImplemented());
              break;
            }
            default: {
              Assert(false, ExcInternalError());
              break;
            }
        }
    }
  else
    {
      switch (problem_type_)
        {
            case DirichletBCProblem: {
              SolverControl solver_control(1000, 1e-8, true, true);
              SolverCGGeneral<Vector<RangeNumberType>> solver(solver_control);

              switch (preconditioner_type_)
                {
                    case PreconditionerType::HMatrixFactorization: {
                      solver.solve(
                        V1_hmat_,
                        neumann_data_on_dirichlet_domain_internal_dof_numbering_,
                        system_rhs_on_dirichlet_domain_,
                        V1_hmat_preconditioner_);

                      break;
                    }
                    case PreconditionerType::OperatorPreconditioning: {
                      solver.solve(
                        V1_hmat_,
                        neumann_data_on_dirichlet_domain_internal_dof_numbering_,
                        system_rhs_on_dirichlet_domain_,
                        *operator_preconditioner_dirichlet_);

                      mg_tria_for_preconditioner_.clear();
                      if (operator_preconditioner_dirichlet_ != nullptr)
                        {
                          delete operator_preconditioner_dirichlet_;
                          operator_preconditioner_dirichlet_ = nullptr;
                        }

                      break;
                    }
                    case PreconditionerType::Identity: {
                      solver.solve(
                        V1_hmat_,
                        neumann_data_on_dirichlet_domain_internal_dof_numbering_,
                        system_rhs_on_dirichlet_domain_,
                        PreconditionIdentity());

                      break;
                    }
                    case PreconditionerType::Jacobi: {
                      // TODO
                      Assert(false, ExcNotImplemented());
                      break;
                    }
                    default: {
                      Assert(false, ExcInternalError());
                      break;
                    }
                }

              /**
               * Permute the solution vector by following the mapping
               * from external to internal DoF numbering.
               */
              permute_vector(
                neumann_data_on_dirichlet_domain_internal_dof_numbering_,
                *dof_e2i_numbering_for_neumann_space_on_dirichlet_domain_,
                neumann_data_);

              break;
            }
            case NeumannBCProblem: {
              SolverControl solver_control(1000, 1e-8, true, true);
              SolverCGGeneral<Vector<RangeNumberType>> solver(solver_control);

              switch (preconditioner_type_)
                {
                    case PreconditionerType::HMatrixFactorization: {
                      solver.solve(
                        D1_hmat_,
                        dirichlet_data_on_neumann_domain_internal_dof_numbering_,
                        system_rhs_on_neumann_domain_,
                        D1_hmat_preconditioner_);

                      break;
                    }
                    case PreconditionerType::OperatorPreconditioning: {
                      solver.solve(
                        D1_hmat_,
                        dirichlet_data_on_neumann_domain_internal_dof_numbering_,
                        system_rhs_on_neumann_domain_,
                        *operator_preconditioner_neumann_);

                      mg_tria_for_preconditioner_.clear();
                      if (operator_preconditioner_neumann_ != nullptr)
                        {
                          delete operator_preconditioner_neumann_;
                          operator_preconditioner_neumann_ = nullptr;
                        }

                      break;
                    }
                    case PreconditionerType::Identity: {
                      solver.solve(
                        D1_hmat_,
                        dirichlet_data_on_neumann_domain_internal_dof_numbering_,
                        system_rhs_on_neumann_domain_,
                        PreconditionIdentity());

                      break;
                    }
                    case PreconditionerType::Jacobi: {
                      // TODO
                      Assert(false, ExcNotImplemented());
                      break;
                    }
                    default: {
                      Assert(false, ExcInternalError());
                      break;
                    }
                }

              /**
               * Permute the solution vector by following the mapping
               * from external to internal DoF numbering.
               */
              permute_vector(
                dirichlet_data_on_neumann_domain_internal_dof_numbering_,
                *dof_e2i_numbering_for_dirichlet_space_on_neumann_domain_,
                dirichlet_data_);

              break;
            }
            case MixedBCProblem: {
              // Solve the system of equations and obtain the solution in two
              // block vectors in the internal DoF numbering.
              switch (preconditioner_type_)
                {
                    case PreconditionerType::HMatrixFactorization: {
                      SolverControl solver_control(1000, 1e-8, true, true);
                      SolverBicgstabGeneral<Vector<RangeNumberType>> solver(
                        solver_control);

                      // In this case, H-LU for skew symmetric block H-matrix is
                      // adopted to solve the system of equations.
                      solver.solve(
                        M_hmat_,
                        solution_on_combined_domain_internal_dof_numbering_,
                        system_rhs_on_combined_domain_,
                        M_hmat_preconditioner_);

                      // Split the solution vector into two parts.
                      copy_vector(
                        neumann_data_on_dirichlet_domain_internal_dof_numbering_,
                        0,
                        solution_on_combined_domain_internal_dof_numbering_,
                        0,
                        neumann_data_on_dirichlet_domain_internal_dof_numbering_
                          .size());
                      copy_vector(
                        dirichlet_data_on_neumann_domain_internal_dof_numbering_,
                        0,
                        solution_on_combined_domain_internal_dof_numbering_,
                        neumann_data_on_dirichlet_domain_internal_dof_numbering_
                          .size(),
                        dirichlet_data_on_neumann_domain_internal_dof_numbering_
                          .size());

                      break;
                    }
                    case PreconditionerType::OperatorPreconditioning: {
                      // In this case, Schur complement method is adopted to
                      // solve the system of equations, which is different from
                      // using the H-matrix factorization method.
                      solve_hblockmatrix_skew_symm_using_schur_complement(
                        M_hmat_,
                        neumann_data_on_dirichlet_domain_internal_dof_numbering_,
                        dirichlet_data_on_neumann_domain_internal_dof_numbering_,
                        system_rhs_on_dirichlet_domain_,
                        system_rhs_on_neumann_domain_,
                        *operator_preconditioner_dirichlet_,
                        *operator_preconditioner_neumann_,
                        1000,
                        real_type(1e-8),
                        true,
                        true);

                      mg_tria_for_preconditioner_.clear();
                      if (operator_preconditioner_dirichlet_ != nullptr)
                        {
                          delete operator_preconditioner_dirichlet_;
                          operator_preconditioner_dirichlet_ = nullptr;
                        }
                      if (operator_preconditioner_neumann_ != nullptr)
                        {
                          delete operator_preconditioner_neumann_;
                          operator_preconditioner_neumann_ = nullptr;
                        }

                      // Combine the two block vectors into one vector.
                      copy_vector(
                        solution_on_combined_domain_internal_dof_numbering_,
                        0,
                        neumann_data_on_dirichlet_domain_internal_dof_numbering_,
                        0,
                        neumann_data_on_dirichlet_domain_internal_dof_numbering_
                          .size());
                      copy_vector(
                        solution_on_combined_domain_internal_dof_numbering_,
                        neumann_data_on_dirichlet_domain_internal_dof_numbering_
                          .size(),
                        dirichlet_data_on_neumann_domain_internal_dof_numbering_,
                        0,
                        dirichlet_data_on_neumann_domain_internal_dof_numbering_
                          .size());

                      break;
                    }
                    case PreconditionerType::Identity: {
                      // In this case, Schur complement method is adopted to
                      // solve the system of equations.
                      solve_hblockmatrix_skew_symm_using_schur_complement(
                        M_hmat_,
                        neumann_data_on_dirichlet_domain_internal_dof_numbering_,
                        dirichlet_data_on_neumann_domain_internal_dof_numbering_,
                        system_rhs_on_dirichlet_domain_,
                        system_rhs_on_neumann_domain_,
                        PreconditionIdentity(),
                        PreconditionIdentity(),
                        1000,
                        real_type(1e-8),
                        true,
                        true);

                      // Combine the two block vectors in the internal DoF
                      // numbering into one vector.
                      copy_vector(
                        solution_on_combined_domain_internal_dof_numbering_,
                        0,
                        neumann_data_on_dirichlet_domain_internal_dof_numbering_,
                        0,
                        neumann_data_on_dirichlet_domain_internal_dof_numbering_
                          .size());
                      copy_vector(
                        solution_on_combined_domain_internal_dof_numbering_,
                        neumann_data_on_dirichlet_domain_internal_dof_numbering_
                          .size(),
                        dirichlet_data_on_neumann_domain_internal_dof_numbering_,
                        0,
                        dirichlet_data_on_neumann_domain_internal_dof_numbering_
                          .size());

                      break;
                    }
                    case PreconditionerType::Jacobi: {
                      // TODO
                      Assert(false, ExcNotImplemented());
                      break;
                    }
                    default: {
                      Assert(false, ExcInternalError());
                      break;
                    }
                }

              // Convert the two block vectors from internal to external DoF
              // numbering.
              permute_vector(
                neumann_data_on_dirichlet_domain_internal_dof_numbering_,
                *dof_e2i_numbering_for_neumann_space_on_dirichlet_domain_,
                neumann_data_on_dirichlet_domain_);
              permute_vector(
                dirichlet_data_on_neumann_domain_internal_dof_numbering_,
                *dof_e2i_numbering_for_dirichlet_space_on_neumann_domain_,
                dirichlet_data_on_neumann_domain_);

              // Combine the Dirichlet solution on the Neumann domain in the
              // external DoF numbering and the Dirichlet boundary condition
              // vector to form the complete Dirichlet data.
              DoFToolsExt::extend_selected_dof_values_to_full_dofs(
                dirichlet_data_,
                dirichlet_data_on_neumann_domain_,
                local_to_full_dirichlet_dof_indices_on_neumann_domain_);
              DoFToolsExt::extend_selected_dof_values_to_full_dofs(
                dirichlet_data_,
                dirichlet_bc_on_selected_dofs_,
                local_to_full_dirichlet_dof_indices_on_dirichlet_domain_);

              // Combine the Neumann solution on the Dirichlet domain in the
              // external DoF numbering and the Neumann boundary condition
              // vector to form the complete Neumann data.
              DoFToolsExt::extend_selected_dof_values_to_full_dofs(
                neumann_data_,
                neumann_data_on_dirichlet_domain_,
                local_to_full_neumann_dof_indices_on_dirichlet_domain_);
              DoFToolsExt::extend_selected_dof_values_to_full_dofs(
                neumann_data_,
                neumann_bc_on_selected_dofs_,
                local_to_full_neumann_dof_indices_on_neumann_domain_);

              break;
            }
            default: {
              Assert(false, ExcInternalError());
              break;
            }
        }
    }
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  output_results() const
{
  std::cout << "=== Output results ===" << std::endl;

  std::ofstream          vtk_output;
  DataOut<dim, spacedim> data_out;
  std::ofstream          data_file(project_name_ + std::string(".output"));

  switch (problem_type_)
    {
        case DirichletBCProblem: {
          vtk_output.open(project_name_ + std::string(".vtk"),
                          std::ofstream::out);

          if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
            {
              ComplexOutputDataVector<Vector, real_type> neumann_data_vector(
                neumann_data_);
              ComplexOutputDataVector<Vector, real_type> dirichlet_data_vector(
                dirichlet_bc_);

              add_complex_data_vector(data_out,
                                      dof_handler_for_neumann_space_,
                                      neumann_data_vector,
                                      "neumann_data");
              add_complex_data_vector(data_out,
                                      dof_handler_for_dirichlet_space_,
                                      dirichlet_data_vector,
                                      "dirichlet_data");

              data_out.build_patches();
              data_out.write_vtk(vtk_output);
            }
          else
            {
              data_out.add_data_vector(dof_handler_for_neumann_space_,
                                       neumann_data_,
                                       "neumann_data");
              data_out.add_data_vector(dof_handler_for_dirichlet_space_,
                                       dirichlet_bc_,
                                       "dirichlet_data");

              data_out.build_patches();
              data_out.write_vtk(vtk_output);
            }

          print_vector_to_mat(data_file, "solution", neumann_data_, false);

          break;
        }
        case NeumannBCProblem: {
          vtk_output.open(project_name_ + std::string(".vtk"),
                          std::ofstream::out);

          if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
            {
              ComplexOutputDataVector<Vector, real_type> dirichlet_data_vector(
                dirichlet_data_);
              ComplexOutputDataVector<Vector, real_type> neumann_data_vector(
                neumann_bc_);

              add_complex_data_vector(data_out,
                                      dof_handler_for_dirichlet_space_,
                                      dirichlet_data_vector,
                                      "dirichlet_data");
              add_complex_data_vector(data_out,
                                      dof_handler_for_neumann_space_,
                                      neumann_data_vector,
                                      "neumann_data");

              data_out.build_patches();
              data_out.write_vtk(vtk_output);
            }
          else
            {
              data_out.add_data_vector(dof_handler_for_dirichlet_space_,
                                       dirichlet_data_,
                                       "dirichlet_data");
              data_out.add_data_vector(dof_handler_for_neumann_space_,
                                       neumann_bc_,
                                       "neumann_data");

              data_out.build_patches();
              data_out.write_vtk(vtk_output);
            }

          print_vector_to_mat(data_file, "solution", dirichlet_data_, false);

          break;
        }
        case MixedBCProblem: {
          vtk_output.open(project_name_ + std::string(".vtk"),
                          std::ofstream::out);

          if constexpr (numbers::NumberTraits<RangeNumberType>::is_complex)
            {
              ComplexOutputDataVector<Vector, real_type> dirichlet_data_vector(
                dirichlet_data_);
              ComplexOutputDataVector<Vector, real_type> neumann_data_vector(
                neumann_data_);

              add_complex_data_vector(data_out,
                                      dof_handler_for_dirichlet_space_,
                                      dirichlet_data_vector,
                                      "dirichlet_data");
              add_complex_data_vector(data_out,
                                      dof_handler_for_neumann_space_,
                                      neumann_data_vector,
                                      "neumann_data");

              data_out.build_patches();
              data_out.write_vtk(vtk_output);
            }
          else
            {
              data_out.add_data_vector(dof_handler_for_dirichlet_space_,
                                       dirichlet_data_,
                                       "dirichlet_data");
              data_out.add_data_vector(dof_handler_for_neumann_space_,
                                       neumann_data_,
                                       "neumann_data");

              data_out.build_patches();
              data_out.write_vtk(vtk_output);
            }

          constexpr unsigned int field_width =
            numbers::NumberTraits<RangeNumberType>::is_complex ? 35 : 25;
          print_vector_to_mat(
            data_file,
            "solution_on_combined_domain_internal_dof_numbering",
            solution_on_combined_domain_internal_dof_numbering_,
            false,
            15,
            field_width);
          print_vector_to_mat(
            data_file, "neumann_data", neumann_data_, false, 15, field_width);
          print_vector_to_mat(data_file,
                              "dirichlet_data",
                              dirichlet_data_,
                              false,
                              15,
                              field_width);

          break;
        }
        default: {
          Assert(false, ExcInternalError());
          break;
        }
    }

  vtk_output.close();
  data_file.close();
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  output_potential_at_target_points() const
{
  /**
   * Create a plane of regular grid for potential evaluation.
   */
  std::vector<Point<spacedim, real_type>> potential_grid_points;

  // Number of cells in the X direction.
  const unsigned int nx = 100;
  // Number of cells in the Y direction.
  const unsigned int ny = 100;
  // Plane dimension in the X direction.
  const double grid_plane_xdim = 4.0;
  // Plane dimension in the Y direction.
  const double grid_plane_ydim = 4.0;
  // Grid point spacing in the X direction.
  const double dx = grid_plane_xdim / nx;
  // Grid point spacing in the Y direction.
  const double dy = grid_plane_ydim / ny;
  // Shift in the X direction.
  const double x_shift = -grid_plane_xdim / 2;
  // Shift in the Y direction.
  const double y_shift = -grid_plane_ydim / 2;
  // Plane Z height
  const double z = 4.0;

  /**
   * For visualization in GNU Octave using @p surf, here we generate
   * the list of grid points with their X coordinate components
   * running the fastest.
   */
  for (unsigned int j = 0; j <= ny; j++)
    {
      for (unsigned int i = 0; i <= nx; i++)
        {
          potential_grid_points.push_back(
            Point<spacedim, real_type>(i * dx + x_shift, j * dy + y_shift, z));
        }
    }

  /**
   * Vector storing the list of evaluated potential values.
   */
  Vector<RangeNumberType> potential_values(potential_grid_points.size());

  switch (problem_type_)
    {
        case DirichletBCProblem: {
          if (is_interior_problem_)
            {
              /**
               * Evaluate the double layer potential, which is the negated
               * double layer potential integral operator applied to the
               * Dirichlet data. \f[
               * -\int_{\Gamma} \widetilde{\gamma}_{1,y} G(x,y) \gamma_0^{\rm
               * int} u(y) \intd s_y
               * \f]
               */
              std::cout << "=== Evaluate DLP potential values ===" << std::endl;
              evaluate_potential_at_points<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::DoubleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                Vector>(double_layer_kernel_cpu_,
                        -1.0,
                        dof_handler_for_dirichlet_space_,
                        dirichlet_bc_,
                        false,
                        potential_grid_points,
                        potential_values);

              /**
               * Evaluate the single layer potential, which is the single
               * layer potential integral operator applied to the Neumann
               * data. \f[ \int_{\Gamma} G(x,y) \widetilde{\gamma}_{1,y} u(y)
               * \intd s_y \f]
               */
              std::cout << "=== Evaluate SLP potential values ===" << std::endl;
              evaluate_potential_at_points<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::SingleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                Vector>(single_layer_kernel_cpu_,
                        1.0,
                        dof_handler_for_neumann_space_,
                        neumann_data_,
                        false,
                        potential_grid_points,
                        potential_values);
            }
          else
            {
              /**
               * Evaluate the double layer potential, which is the negated
               * double layer potential integral operator applied to the
               * Dirichlet data. \f[
               * -\int_{\Gamma} \widetilde{\gamma}_{1,y} G(x,y) \gamma_0^{\rm
               * int} u(y) \intd s_y
               * \f]
               */
              std::cout << "=== Evaluate DLP potential values ===" << std::endl;
              evaluate_potential_at_points<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::DoubleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                Vector>(double_layer_kernel_cpu_,
                        1.0,
                        dof_handler_for_dirichlet_space_,
                        dirichlet_bc_,
                        false,
                        potential_grid_points,
                        potential_values);

              /**
               * Evaluate the single layer potential, which is the single
               * layer potential integral operator applied to the Neumann
               * data. \f[ \int_{\Gamma} G(x,y) \widetilde{\gamma}_{1,y} u(y)
               * \intd s_y \f]
               */
              std::cout << "=== Evaluate SLP potential values ===" << std::endl;
              evaluate_potential_at_points<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::SingleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                Vector>(single_layer_kernel_cpu_,
                        -1.0,
                        dof_handler_for_neumann_space_,
                        neumann_data_,
                        false,
                        potential_grid_points,
                        potential_values);
            }

          break;
        }
        case NeumannBCProblem: {
          if (is_interior_problem_)
            {
              /**
               * Evaluate the double layer potential, which is the negated
               * double layer potential integral operator applied to the
               * Dirichlet data. \f[
               * -\int_{\Gamma} \widetilde{\gamma}_{1,y} G(x,y) \gamma_0^{\rm
               * int} u(y) \intd s_y
               * \f]
               */
              std::cout << "=== Evaluate DLP potential values ===" << std::endl;
              evaluate_potential_at_points<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::DoubleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                Vector>(double_layer_kernel_cpu_,
                        -1.0,
                        dof_handler_for_dirichlet_space_,
                        dirichlet_data_,
                        false,
                        potential_grid_points,
                        potential_values);

              /**
               * Evaluate the single layer potential, which is the single
               * layer potential integral operator applied to the Neumann
               * data. \f[ \int_{\Gamma} G(x,y) \widetilde{\gamma}_{1,y} u(y)
               * \intd s_y \f]
               */
              std::cout << "=== Evaluate SLP potential values ===" << std::endl;
              evaluate_potential_at_points<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::SingleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                Vector>(single_layer_kernel_cpu_,
                        1.0,
                        dof_handler_for_neumann_space_,
                        neumann_bc_,
                        false,
                        potential_grid_points,
                        potential_values);
            }
          else
            {
              /**
               * Evaluate the double layer potential, which is the negated
               * double layer potential integral operator applied to the
               * Dirichlet data. \f[
               * -\int_{\Gamma} \widetilde{\gamma}_{1,y} G(x,y) \gamma_0^{\rm
               * int} u(y) \intd s_y
               * \f]
               */
              std::cout << "=== Evaluate DLP potential values ===" << std::endl;
              evaluate_potential_at_points<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::DoubleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                Vector>(double_layer_kernel_cpu_,
                        1.0,
                        dof_handler_for_dirichlet_space_,
                        dirichlet_data_,
                        false,
                        potential_grid_points,
                        potential_values);

              /**
               * Evaluate the single layer potential, which is the single
               * layer potential integral operator applied to the Neumann
               * data. \f[ \int_{\Gamma} G(x,y) \widetilde{\gamma}_{1,y} u(y)
               * \intd s_y \f]
               */
              std::cout << "=== Evaluate SLP potential values ===" << std::endl;
              evaluate_potential_at_points<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::SingleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                Vector>(single_layer_kernel_cpu_,
                        -1.0,
                        dof_handler_for_neumann_space_,
                        neumann_bc_,
                        false,
                        potential_grid_points,
                        potential_values);
            }

          break;
        }
        case MixedBCProblem: {
          if (is_interior_problem_)
            {
              /**
               * Evaluate the double layer potential, which is the negated
               * double layer potential integral operator applied to the
               * Dirichlet data. \f[
               * -\int_{\Gamma} \widetilde{\gamma}_{1,y} G(x,y) \gamma_0^{\rm
               * int} u(y) \intd s_y
               * \f]
               */
              std::cout << "=== Evaluate DLP potential values ===" << std::endl;
              evaluate_potential_at_points<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::DoubleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                Vector>(double_layer_kernel_cpu_,
                        -1.0,
                        dof_handler_for_dirichlet_space_,
                        dirichlet_data_,
                        false,
                        potential_grid_points,
                        potential_values);

              /**
               * Evaluate the single layer potential, which is the single
               * layer potential integral operator applied to the Neumann
               * data. \f[ \int_{\Gamma} G(x,y) \widetilde{\gamma}_{1,y} u(y)
               * \intd s_y \f]
               */
              std::cout << "=== Evaluate SLP potential values ===" << std::endl;
              evaluate_potential_at_points<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::SingleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                Vector>(single_layer_kernel_cpu_,
                        1.0,
                        dof_handler_for_neumann_space_,
                        neumann_data_,
                        false,
                        potential_grid_points,
                        potential_values);
            }
          else
            {
              /**
               * Evaluate the double layer potential, which is the negated
               * double layer potential integral operator applied to the
               * Dirichlet data. \f[
               * -\int_{\Gamma} \widetilde{\gamma}_{1,y} G(x,y) \gamma_0^{\rm
               * int} u(y) \intd s_y
               * \f]
               */
              std::cout << "=== Evaluate DLP potential values ===" << std::endl;
              evaluate_potential_at_points<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::DoubleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                Vector>(double_layer_kernel_cpu_,
                        1.0,
                        dof_handler_for_dirichlet_space_,
                        dirichlet_data_,
                        false,
                        potential_grid_points,
                        potential_values);

              /**
               * Evaluate the single layer potential, which is the single
               * layer potential integral operator applied to the Neumann
               * data. \f[ \int_{\Gamma} G(x,y) \widetilde{\gamma}_{1,y} u(y)
               * \intd s_y \f]
               */
              std::cout << "=== Evaluate SLP potential values ===" << std::endl;
              evaluate_potential_at_points<
                dim,
                spacedim,
                PlatformShared::LaplaceKernel::SingleLayerKernel,
                RangeNumberType,
                KernelNumberType,
                Vector>(single_layer_kernel_cpu_,
                        -1.0,
                        dof_handler_for_neumann_space_,
                        neumann_data_,
                        false,
                        potential_grid_points,
                        potential_values);
            }

          break;
        }
        default: {
          Assert(false, ExcInternalError());
          break;
        }
    }

  print_vector_to_mat(std::cout, "potential_values", potential_values, false);
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::run()
{
  LogStream::Prefix prefix_string("run");
#if ENABLE_NVTX == 1
  HierBEM::CUDAWrappers::NVTXRange nvtx_range("run");
#endif

  Timer timer;
  setup_system();
  timer.stop();
  print_wall_time(deallog, timer, "setup system");

  if (!use_hmat_)
    {
      timer.start();
      assemble_full_matrix_system();
      timer.stop();
      print_wall_time(deallog, timer, "assemble full matrix system");
    }
  else
    {
      timer.start();
      assemble_hmatrix_system();
      timer.stop();
      print_wall_time(deallog, timer, "assemble H-matrix system");

      timer.start();
      assemble_hmatrix_preconditioner();
      timer.stop();
      print_wall_time(deallog, timer, "assemble H-matrix preconditioner");
    }

  timer.start();
  solve();
  timer.stop();
  print_wall_time(deallog, timer, "solve equation");

  timer.start();
  output_results();
  timer.stop();
  print_wall_time(deallog, timer, "output results");
}


template <int dim,
          int spacedim,
          typename RangeNumberType,
          typename KernelNumberType>
void
LaplaceBEM<dim, spacedim, RangeNumberType, KernelNumberType>::Priv::
  print_memory_consumption_table(std::ostream &out) const
{
  memory_consumption_table_.write_text(
    out, TableHandler::TextOutputFormat::org_mode_table);
}

#pragma endregion

HBEM_NS_CLOSE

#endif // HIERBEM_INCLUDE_LAPLACE_BEM_PRIV_H_