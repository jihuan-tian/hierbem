/**
 * \file debug_tools.h
 * \brief This file includes a bunch of helper functions for printing out and
 * visualizing information about grid, DoFs, map, etc.
 * \ingroup toolbox
 * \date 2021-04-25
 * \author Jihuan Tian
 */
#ifndef INCLUDE_DEBUG_TOOLS_HCU_
#define INCLUDE_DEBUG_TOOLS_HCU_

#include <deal.II/base/logstream.h>
#include <deal.II/base/table.h>

#include <deal.II/dofs/dof_handler.h>
#include <deal.II/dofs/dof_tools.h>

#include <deal.II/fe/fe.h>
#include <deal.II/fe/fe_system.h>
#include <deal.II/fe/fe_tools.h>
#include <deal.II/fe/mapping.h>
#include <deal.II/fe/mapping_q_generic.h>

#include <deal.II/grid/tria.h>

#include <iomanip>
#include <iostream>
#include <iterator>
#include <string>
#include <utility>

#include "bem_values.h"
#include "cu_bem_values.hcu"
#include "cu_qgauss.hcu"
#include "cu_table.hcu"
#include "lapack_full_matrix_ext.h"
#include "quadrature.templates.h"

namespace IdeoBEM
{
  using namespace dealii;

  template <int dim, int spacedim>
  void
  print_mesh_info(const Triangulation<dim, spacedim> &triangulation)
  {
    std::cout << "=== Mesh info ===\n"
              << "Manifold dimension: " << dim << "\n"
              << "Space dimension: " << spacedim << "\n"
              << "No. of cells: " << triangulation.n_active_cells()
              << std::endl;

    {
      std::map<types::boundary_id, unsigned int> boundary_count;

      // Loop over each cell using TriaAccessor.
      for (auto &cell : triangulation.active_cell_iterators())
        {
          for (unsigned int face = 0; face < GeometryInfo<dim>::faces_per_cell;
               ++face)
            {
              if (cell->face(face)->at_boundary())
                boundary_count[cell->face(face)->boundary_id()]++;
            }
        }

      std::cout << "Boundary indicators: ";
      for (const std::pair<const types::boundary_id, unsigned int> &pair :
           boundary_count)
        {
          std::cout << pair.first << "(" << pair.second << " cells) ";
        }
      std::cout << std::endl;
    }
  }

  template <typename VectorType>
  void
  print_vector_values(std::ostream      &out,
                      const VectorType  &values,
                      const std::string &sep         = std::string(","),
                      bool               has_newline = true)
  {
    typename VectorType::const_iterator iter_copy;

    for (auto iter = values.begin(); iter != values.end();
         std::advance(iter, 1))
      {
        iter_copy = iter;
        std::advance(iter_copy, 1);

        if (iter_copy == values.end())
          if (has_newline)
            {
              out << (*iter) << std::endl;
            }
          else
            {
              out << (*iter);
            }
        else
          out << (*iter) << sep;
      }
  }


  template <typename VectorType>
  void
  print_vector_indices(std::ostream      &out,
                       const VectorType  &values,
                       const std::string &sep,
                       bool               index_starting_from_zero,
                       bool               has_newline = true)
  {
    typename VectorType::const_iterator iter_copy;

    for (auto iter = values.cbegin(); iter != values.cend();
         std::advance(iter, 1))
      {
        iter_copy = iter;
        std::advance(iter_copy, 1);

        if (iter_copy == values.cend())
          if (has_newline)
            {
              if (index_starting_from_zero)
                {
                  out << (*iter) << std::endl;
                }
              else
                {
                  out << (*iter) + 1 << std::endl;
                }
            }
          else
            {
              if (index_starting_from_zero)
                {
                  out << (*iter);
                }
              else
                {
                  out << (*iter) + 1;
                }
            }
        else
          {
            if (index_starting_from_zero)
              {
                out << (*iter) << sep;
              }
            else
              {
                out << (*iter) + 1 << sep;
              }
          }
      }
  }


  template <typename Number>
  void
  print_scalar_to_mat(std::ostream      &out,
                      const std::string &name,
                      const Number       value)
  {
    out << "# name: " << name << "\n"
        << "# type: scalar\n"
        << value << "\n";

    out << "\n\n";
  }


  template <typename VectorType>
  void
  print_vector_to_mat(std::ostream      &out,
                      const std::string &name,
                      const VectorType  &values,
                      bool               is_row_vector = false,
                      const unsigned int precision     = 6,
                      const unsigned int width         = 10)
  {
    out << "# name: " << name << "\n";
    out << "# type: matrix\n";
    if (is_row_vector)
      {
        out << "# rows: 1\n";
        out << "# columns: " << values.size() << "\n";
      }
    else
      {
        out << "# rows: " << values.size() << "\n";
        out << "# columns: 1\n";
      }

    for (auto iter = values.begin(); iter != values.end(); iter++)
      {
        out << std::setprecision(precision) << std::setw(width) << (*iter)
            << "\n";
      }

    out << "\n\n";
  }


  /**
   * Print a @p FullMatrix or a @p LAPACKFullMatrix into an Octave matrix.
   *
   * @param out
   * @param name
   * @param values
   * @param precision
   * @param scientific
   * @param width
   * @param zero_string
   * @param denominator
   * @param threshold
   */
  template <typename MatrixType>
  void
  print_matrix_to_mat(std::ostream      &out,
                      const std::string &name,
                      const MatrixType  &values,
                      const unsigned int precision   = 8,
                      const bool         scientific  = true,
                      const unsigned int width       = 0,
                      const char        *zero_string = "0",
                      const double       denominator = 1.,
                      const double       threshold   = 0.)
  {
    out << "# name: " << name << "\n";
    out << "# type: matrix\n";
    out << "# rows: " << values.m() << "\n";
    out << "# columns: " << values.n() << "\n";

    values.print_formatted(
      out, precision, scientific, width, zero_string, denominator, threshold);

    out << "\n\n";
  }

  template <typename T>
  void
  print_2d_table_to_mat(std::ostream      &out,
                        const std::string &name,
                        const Table<2, T> &values,
                        const unsigned int precision  = 8,
                        const bool         scientific = true,
                        const unsigned int width      = 0)
  {
    const typename TableBase<2, T>::size_type m = values.size(0);
    const typename TableBase<2, T>::size_type n = values.size(1);

    out << "# name: " << name << "\n";
    out << "# type: matrix\n";
    out << "# rows: " << m << "\n";
    out << "# columns: " << n << "\n";

    for (typename TableBase<2, T>::size_type i = 0; i < m; i++)
      {
        for (typename TableBase<2, T>::size_type j = 0; j < n; j++)
          {
            out << (scientific ? std::scientific : std::fixed)
                << std::setw(width) << std::setprecision(precision)
                << values(TableIndices<2>(i, j)) << " ";
          }
        out << std::endl;
      }

    out << "\n\n";
  }

  template <typename node_pointer_type>
  void
  print_vector_of_tree_node_pointer_values(
    std::ostream                         &out,
    const std::vector<node_pointer_type> &tree_node_pointers,
    const std::string                    &sep = std::string(","))
  {
    for (auto iter = tree_node_pointers.cbegin();
         iter != tree_node_pointers.cend();
         iter++)
      {
        if ((iter + 1) == tree_node_pointers.cend())
          out << (*iter)->get_data_reference() << std::endl;
        else
          out << (*iter)->get_data_reference() << sep;
      }
  }

  /**
   * \brief Generate a table of DoF indices associated with each support point.
   * \details The information in the table is defined in the given Mapping and
   * DoFHandler objects, which can be then visualized in Gnuplot by executing
   * the following command.
   * 1. For spacedim=2:
   * \code
   * plot "./data_file.gpl" using 1:2:3 with labels offset 1,1 point pt 1 lc rgb
   * \ "red" notitle \endcode
   * 2. For spacedim=3:
   * \code
   * splot "./data_file.gpl" using 1:2:3:4 with labels offset 1,1 point pt 1 lc
   * \ rgb "red" \endcode
   *
   * @param fe_system The given FiniteElement object will be checked if it has support points.
   * @param mapping
   * @param dof_handler
   * @param base_name
   */
  template <int dim, int spacedim>
  void
  print_support_point_info(const FiniteElement<dim, spacedim> &fe,
                           const Mapping<dim, spacedim>       &mapping,
                           const DoFHandler<dim, spacedim>    &dof_handler,
                           const std::string                  &base_name)
  {
    if (fe.has_support_points())
      {
        /**
         * Allocate memory for the vector storing support points.
         */
        std::map<types::global_dof_index, Point<spacedim>> support_points;
        /**
         * Get the list of support point coordinates for all DoFs. The DoFs are
         * in the default numbering starting from 0.
         */
        DoFTools::map_dofs_to_support_points(mapping,
                                             dof_handler,
                                             support_points);

        /**
         * Write the table of DoF indices for each support point into file.
         */
        std::ofstream gnuplot_file(base_name + ".gpl");
        DoFTools::write_gnuplot_dof_support_point_info(gnuplot_file,
                                                       support_points);
      }
  }


  /**
   * Generate a table of DoF indices associated with each support point. The DoF
   * indices are automatically assigned by starting from zero.
   *
   * @param support_points
   * @param base_name
   */
  template <int spacedim>
  void
  print_support_point_info(const std::vector<Point<spacedim>> &support_points,
                           const std::string                  &base_name)
  {
    /**
     * Allocate memory for the vector storing support points. The DoF numbering
     * will automatically be given by starting from zero.
     */
    std::map<types::global_dof_index, Point<spacedim>> support_points_map;

    for (unsigned int i = 0; i < support_points.size(); i++)
      {
        support_points_map[i] = support_points[i];
      }

    /**
     * Write the table of DoF indices for each support point into file.
     */
    std::ofstream gnuplot_file(base_name + ".gpl");
    DoFTools::write_gnuplot_dof_support_point_info(gnuplot_file,
                                                   support_points_map);
  }


  /**
   * \brief Generate a table of DoF indices associated with each support point.
   * \details The information in the table is defined in the given Mapping and
   * DoFHandler objects, which can be then visualized in Gnuplot by executing
   * the following command.
   * 1. For spacedim=2:
   * \code
   * plot "./data_file.gpl" using 1:2:3 with labels offset 1,1 point pt 1 lc rgb
   * \ "red" notitle \endcode
   * 2. For spacedim=3:
   * \code
   * splot "./data_file.gpl" using 1:2:3:4 with labels offset 1,1 point pt 1 lc
   * \ rgb "red" \endcode
   * @param fe_system The given FESystem object will be checked if it has support points.
   * @param mapping
   * @param dof_handler
   * @param base_name
   */
  template <int dim, int spacedim>
  void
  print_support_point_info(const FESystem<dim, spacedim>   &fe_system,
                           const Mapping<dim, spacedim>    &mapping,
                           const DoFHandler<dim, spacedim> &dof_handler,
                           const std::string               &base_name)
  {
    if (fe_system.has_support_points())
      {
        /**
         * Allocate memory for the vector storing support points.
         */
        std::map<types::global_dof_index, Point<spacedim>> support_points;
        /**
         * Get the list of support point coordinates for all DoFs. The DoFs are
         * in the default numbering starting from 0.
         */
        DoFTools::map_dofs_to_support_points(mapping,
                                             dof_handler,
                                             support_points);

        /**
         * Write the table of DoF indices for each support point into file.
         */
        std::ofstream gnuplot_file(base_name + ".gpl");
        DoFTools::write_gnuplot_dof_support_point_info(gnuplot_file,
                                                       support_points);
      }
  }


  template <int dim, int spacedim>
  void
  print_support_point_info(const MappingQGeneric<dim, spacedim> &mapping,
                           const DoFHandler<dim, spacedim>      &dof_handler,
                           const std::string                    &fe_name)
  {
    if (dof_handler.get_fe().has_support_points())
      {
        // Allocate memory for the vector storing support points.
        std::map<types::global_dof_index, Point<spacedim>> support_points;
        DoFTools::map_dofs_to_support_points(mapping,
                                             dof_handler,
                                             support_points);
        std::ofstream gnuplot_file(fe_name + ".gpl");
        DoFTools::write_gnuplot_dof_support_point_info(gnuplot_file,
                                                       support_points);
      }
  }


  /**
   * Print out the polynomial space numbering and inverse numbering of a finite
   * element in Octave format.
   *
   * @param out
   * @param fe
   * @param fe_name
   */
  template <typename FiniteElementType>
  void
  print_polynomial_space_numbering(std::ostream            &out,
                                   const FiniteElementType &fe,
                                   const std::string       &fe_name)
  {
    print_vector_to_mat(out,
                        fe_name + std::string("_poly_space_numbering"),
                        fe.get_poly_space_numbering(),
                        true);
    print_vector_to_mat(out,
                        fe_name + std::string("_poly_space_numbering_inverse"),
                        fe.get_poly_space_numbering_inverse(),
                        true);
  }


  /**
   * Print out the mapping between lexicographic numbering and hierarchic
   * numbering of a finite element in Octave format.
   *
   * @param out
   * @param fe
   * @param fe_name
   */
  template <int dim, int spacedim = dim>
  void
  print_mapping_between_lexicographic_and_hierarchic_numberings(
    std::ostream                       &out,
    const FiniteElement<dim, spacedim> &fe,
    const std::string                  &fe_name)
  {
    print_vector_to_mat(out,
                        fe_name + std::string("_lexi2hier"),
                        FETools::lexicographic_to_hierarchic_numbering<dim>(
                          fe.degree),
                        true);
    print_vector_to_mat(out,
                        fe_name + std::string("_hier2lexi"),
                        FETools::hierarchic_to_lexicographic_numbering<dim>(
                          fe.degree),
                        true);
  }


  template <int dim, int spacedim = dim>
  void
  print_triangulation_info(std::ostream                       &out,
                           const Triangulation<dim, spacedim> &triangulation)
  {
    out << "Number of cells: " << triangulation.n_active_cells() << "\n"
        << "Number of faces: " << triangulation.n_active_faces() << "\n"
        << "Number of lines: " << triangulation.n_active_lines() << "\n"
        << "Number of vertices: " << triangulation.n_vertices() << std::endl;
  }


  template <int dim, int spacedim = dim>
  void
  print_fe_info(std::ostream &out, const FiniteElement<dim, spacedim> &fe)
  {
    out << "Finite element: " << fe.get_name() << "\n"
        << "Has support points: " << (fe.has_support_points() ? "Yes" : "No")
        << "\n"
        << "dofs_per_vertex: " << fe.dofs_per_vertex << "\n"
        << "dofs_per_line: " << fe.dofs_per_line << "\n"
        << "dofs_per_quad: " << fe.dofs_per_quad << "\n"
        << "dofs_per_hex: " << fe.dofs_per_hex << "\n"
        << "dofs_per_face: " << fe.dofs_per_face << "\n"
        << "dofs_per_cell: " << fe.dofs_per_cell << "\n"
        << "components: " << fe.components << "\n"
        << "degree: " << fe.degree << std::endl;
  }


  /**
   * Print out a @p QGauss object.
   *
   * @tparam dim
   * @param out
   * @param quad_cpu
   */
  template <int dim>
  void
  print_qgauss(std::ostream &out, const QGauss<dim> &quad_cpu)
  {
    for (unsigned int q = 0; q < quad_cpu.size(); q++)
      {
        out << "#" << q << ": points=(";

        for (unsigned int i = 0; i < dim; i++)
          {
            if (i == dim - 1)
              {
                out << quad_cpu.point(q)(i) << "), weights=";
              }
            else
              {
                out << quad_cpu.point(q)(i) << ",";
              }
          }

        out << quad_cpu.weight(q) << std::endl;
      }
  }


  /**
   * N.B. The points stored in the table adopt the C style indexing.
   *
   * @param out
   * @param points The first dimension is the quadrature point number. The second
   * dimension is the coordinate component. The index for the second dimension
   * runs faster.
   * @param weights
   */
  template <typename RangeNumberType = double>
  void
  print_qgauss(std::ostream                    &out,
               const Table<2, RangeNumberType> &points,
               const RangeNumberType *const     weights)
  {
    const unsigned int quad_num = points.size(0);
    const unsigned int dim      = points.size(1);

    for (unsigned int q = 0; q < quad_num; q++)
      {
        out << "#" << q << ": points=(";

        for (unsigned int i = 0; i < dim; i++)
          {
            if (i == dim - 1)
              {
                out << points(q, i) << "), weights=";
              }
            else
              {
                out << points(q, i) << ",";
              }
          }

        out << weights[q] << std::endl;
      }
  }


  /**
   * Check the equality of the quadrature objects on CPU and GPU.
   *
   * @tparam dim
   * @param quad_cpu
   * @param quad_gpu
   * @return
   */
  template <int dim>
  bool
  is_equal(const QGauss<dim>                            &quad_cpu,
           const IdeoBEM::CUDAWrappers::CUDAQGauss<dim> &quad_gpu)
  {
    if (quad_cpu.size() == quad_gpu.size())
      {
        const unsigned int quad_num = quad_cpu.size();
        // Extract quadrature points and weights from the device for comparison.
        Table<2, double> quad_points_from_gpu(quad_num, dim);
        quad_gpu.get_points().copy_to_host(quad_points_from_gpu);

        double     *weights_from_gpu = new double[quad_num];
        cudaError_t error_code       = cudaMemcpy(weights_from_gpu,
                                            quad_gpu.get_weights(),
                                            sizeof(double) * quad_num,
                                            cudaMemcpyDeviceToHost);
        AssertCuda(error_code);

        for (unsigned int q = 0; q < quad_num; q++)
          {
            for (unsigned int i = 0; i < dim; i++)
              {
                if (quad_points_from_gpu(q, i) != quad_cpu.point(q)(i))
                  {
                    std::cout << "(" << quad_cpu.point(q)(i) << ","
                              << quad_points_from_gpu(q, i) << ")" << std::endl;
                    delete weights_from_gpu;
                    return false;
                  }
              }

            if (*(weights_from_gpu + q) != quad_cpu.weight(q))
              {
                std::cout << "(" << quad_cpu.weight(q) << ","
                          << *(weights_from_gpu + q) << ")" << std::endl;
                delete weights_from_gpu;
                return false;
              }
          }

        delete weights_from_gpu;
        return true;
      }
    else
      {
        std::cout << "(" << quad_cpu.size() << "," << quad_gpu.size() << ")"
                  << std::endl;
        return false;
      }
  }


  /**
   * Check the equality of the vector of values on the CPU and the table (1
   * dimension) of values on the GPU.
   *
   * @tparam T
   * @param table_cpu
   * @param table_gpu
   * @return
   */
  template <typename T>
  bool
  is_equal(const std::vector<T>                         &vector_cpu,
           const IdeoBEM::CUDAWrappers::CUDATable<1, T> &table_gpu)
  {
    const unsigned int N = 1;

    // Make a copy of the GPU table on the host.
    TableIndices<N> table_sizes;
    IdeoBEM::CUDAWrappers::copy_table_indices(table_sizes, table_gpu.size());
    Table<N, T> table_copied_from_gpu(table_sizes[0]);
    table_gpu.copy_to_host(table_copied_from_gpu);

    // Check the equality of number of elements.
    if (vector_cpu.size() == table_copied_from_gpu.n_elements())
      {
        // Get the pointers to the first element in the two tables.
        const T *vector_cpu_ptr = vector_cpu.data();
        const T *table_from_gpu_ptr =
          &(table_copied_from_gpu(TableIndices<N>()));

        for (std::size_t i = 0; i < vector_cpu.size(); i++)
          {
            if (*(vector_cpu_ptr + i) != *(table_from_gpu_ptr + i))
              {
                return false;
              }
          }

        return true;
      }
    else
      {
        return false;
      }
  }


  /**
   * Check the equality of the vector of values on the CPU and the table (1
   * dimension) of values on the GPU (asynchronous).
   *
   * @tparam T
   * @param vector_cpu
   * @param table_gpu
   * @param stream
   * @return
   */
  template <typename T>
  bool
  is_equal(const std::vector<T>                         &vector_cpu,
           const IdeoBEM::CUDAWrappers::CUDATable<1, T> &table_gpu,
           const cudaStream_t                            stream)
  {
    const unsigned int N = 1;

    // Make a copy of the GPU table on the host.
    TableIndices<N> table_sizes;
    IdeoBEM::CUDAWrappers::copy_table_indices(table_sizes, table_gpu.size());
    Table<N, T> table_copied_from_gpu(table_sizes[0]);
    cudaError_t error_code =
      cudaHostRegister((void *)&(table_copied_from_gpu(0)),
                       table_copied_from_gpu.n_elements() * sizeof(T),
                       0);
    AssertCuda(error_code);

    table_gpu.copy_to_host(table_copied_from_gpu, stream);

    error_code = cudaStreamSynchronize(stream);
    AssertCuda(error_code);

    // Check the equality of number of elements.
    if (vector_cpu.size() == table_copied_from_gpu.n_elements())
      {
        // Get the pointers to the first element in the two tables.
        const T *vector_cpu_ptr = vector_cpu.data();
        const T *table_from_gpu_ptr =
          &(table_copied_from_gpu(TableIndices<N>()));

        for (std::size_t i = 0; i < vector_cpu.size(); i++)
          {
            if (*(vector_cpu_ptr + i) != *(table_from_gpu_ptr + i))
              {
                error_code =
                  cudaHostUnregister((void *)&(table_copied_from_gpu(0)));
                AssertCuda(error_code);
                return false;
              }
          }

        error_code = cudaHostUnregister((void *)&(table_copied_from_gpu(0)));
        AssertCuda(error_code);
        return true;
      }
    else
      {
        error_code = cudaHostUnregister((void *)&(table_copied_from_gpu(0)));
        AssertCuda(error_code);
        return false;
      }
  }


  /**
   * Check the numerical equality of a vector of @p Tensor objects on CPU and a
   * table of @p Tensor objects on GPU.
   *
   * @tparam spacedim
   * @tparam RangeNumberType
   * @param vector_cpu
   * @param table_gpu
   * @param eps
   * @param stream
   * @return
   */
  template <int spacedim, typename RangeNumberType>
  bool
  is_equal(const std::vector<Tensor<1, spacedim, RangeNumberType>> &vector_cpu,
           const IdeoBEM::CUDAWrappers::
             CUDATable<1, Tensor<1, spacedim, RangeNumberType>> &table_gpu,
           const RangeNumberType                                 eps,
           const cudaStream_t                                    stream)
  {
    const unsigned int N = 1;

    // Make a copy of the GPU table on the host.
    TableIndices<N> table_sizes;
    IdeoBEM::CUDAWrappers::copy_table_indices(table_sizes, table_gpu.size());
    Table<N, Tensor<1, spacedim, RangeNumberType>> table_copied_from_gpu(
      table_sizes[0]);
    cudaError_t error_code =
      cudaHostRegister((void *)&(table_copied_from_gpu(0)),
                       table_copied_from_gpu.n_elements() *
                         sizeof(Tensor<1, spacedim, RangeNumberType>),
                       0);
    AssertCuda(error_code);

    table_gpu.copy_to_host(table_copied_from_gpu, stream);

    error_code = cudaStreamSynchronize(stream);
    AssertCuda(error_code);

    // Check the equality of number of elements.
    if (vector_cpu.size() == table_copied_from_gpu.n_elements())
      {
        for (std::size_t i = 0; i < vector_cpu.size(); i++)
          {
            for (unsigned int d = 0; d < spacedim; d++)
              {
                deallog << "(" << vector_cpu[i][d] << ","
                        << table_copied_from_gpu(i)[d] << ")" << std::endl;

                if (std::fabs(vector_cpu[i][d] - table_copied_from_gpu(i)[d]) >
                    eps)
                  {
                    error_code =
                      cudaHostUnregister((void *)&(table_copied_from_gpu(0)));
                    AssertCuda(error_code);
                    return false;
                  }
              }
          }

        error_code = cudaHostUnregister((void *)&(table_copied_from_gpu(0)));
        AssertCuda(error_code);
        return true;
      }
    else
      {
        error_code = cudaHostUnregister((void *)&(table_copied_from_gpu(0)));
        AssertCuda(error_code);
        return false;
      }
  }


  /**
   * Check the numerical equality of a vector of @p Point objects on CPU and a
   * table of @p Point objects on GPU.
   *
   * @tparam spacedim
   * @tparam RangeNumberType
   * @param vector_cpu
   * @param table_gpu
   * @param eps
   * @param stream
   * @return
   */
  template <int spacedim, typename RangeNumberType>
  bool
  is_equal(
    const std::vector<Point<spacedim, RangeNumberType>> &vector_cpu,
    const IdeoBEM::CUDAWrappers::CUDATable<1, Point<spacedim, RangeNumberType>>
                         &table_gpu,
    const RangeNumberType eps,
    const cudaStream_t    stream)
  {
    const unsigned int N = 1;

    // Make a copy of the GPU table on the host.
    TableIndices<N> table_sizes;
    IdeoBEM::CUDAWrappers::copy_table_indices(table_sizes, table_gpu.size());
    Table<N, Point<spacedim, RangeNumberType>> table_copied_from_gpu(
      table_sizes[0]);
    cudaError_t error_code =
      cudaHostRegister((void *)&(table_copied_from_gpu(0)),
                       table_copied_from_gpu.n_elements() *
                         sizeof(Point<spacedim, RangeNumberType>),
                       0);
    AssertCuda(error_code);

    table_gpu.copy_to_host(table_copied_from_gpu, stream);

    error_code = cudaStreamSynchronize(stream);
    AssertCuda(error_code);

    // Check the equality of number of elements.
    if (vector_cpu.size() == table_copied_from_gpu.n_elements())
      {
        for (std::size_t i = 0; i < vector_cpu.size(); i++)
          {
            for (unsigned int d = 0; d < spacedim; d++)
              {
                deallog << "(" << vector_cpu[i][d] << ","
                        << table_copied_from_gpu(i)[d] << ")" << std::endl;

                if (std::fabs(vector_cpu[i](d) - table_copied_from_gpu(i)(d)) >
                    eps)
                  {
                    error_code =
                      cudaHostUnregister((void *)&(table_copied_from_gpu(0)));
                    AssertCuda(error_code);
                    return false;
                  }
              }
          }

        error_code = cudaHostUnregister((void *)&(table_copied_from_gpu(0)));
        AssertCuda(error_code);
        return true;
      }
    else
      {
        error_code = cudaHostUnregister((void *)&(table_copied_from_gpu(0)));
        AssertCuda(error_code);
        return false;
      }
  }


  /**
   * Check the equality of the table (2 dimensions) of scalar values on CPU and
   * GPU.
   *
   * @tparam T
   * @param table_cpu
   * @param table_gpu
   * @return
   */
  template <typename T>
  bool
  is_equal(const Table<2, T>                            &table_cpu,
           const IdeoBEM::CUDAWrappers::CUDATable<2, T> &table_gpu)
  {
    const unsigned int N = 2;

    // Make a copy of the GPU table on the host.
    TableIndices<N> table_sizes;
    IdeoBEM::CUDAWrappers::copy_table_indices(table_sizes, table_gpu.size());
    Table<N, T> table_copied_from_gpu(table_sizes[0], table_sizes[1]);
    table_gpu.copy_to_host(table_copied_from_gpu);

    // Check the equality of number of elements.
    if (table_cpu.n_elements() == table_copied_from_gpu.n_elements())
      {
        // Get the pointers to the first element in the two tables.
        const T *table_cpu_ptr = &(table_cpu(TableIndices<N>()));
        const T *table_from_gpu_ptr =
          &(table_copied_from_gpu(TableIndices<N>()));

        for (std::size_t i = 0; i < table_cpu.n_elements(); i++)
          {
            if (*(table_cpu_ptr + i) != *(table_from_gpu_ptr + i))
              {
                return false;
              }
          }

        return true;
      }
    else
      {
        return false;
      }
  }


  /**
   * Check the equality of the table (2 dimensions) of scalar values on CPU and
   * GPU (asynchronous).
   *
   * @tparam T
   * @param table_cpu
   * @param table_gpu
   * @param stream
   * @return
   */
  template <typename T>
  bool
  is_equal(const Table<2, T>                            &table_cpu,
           const IdeoBEM::CUDAWrappers::CUDATable<2, T> &table_gpu,
           const cudaStream_t                            stream)
  {
    const unsigned int N = 2;

    // Make a copy of the GPU table on the host.
    TableIndices<N> table_sizes;
    IdeoBEM::CUDAWrappers::copy_table_indices(table_sizes, table_gpu.size());
    Table<N, T> table_copied_from_gpu(table_sizes[0], table_sizes[1]);
    cudaError_t error_code =
      cudaHostRegister((void *)&(table_copied_from_gpu(0, 0)),
                       table_copied_from_gpu.n_elements() * sizeof(T),
                       0);
    AssertCuda(error_code);

    table_gpu.copy_to_host(table_copied_from_gpu, stream);

    error_code = cudaStreamSynchronize(stream);
    AssertCuda(error_code);

    // Check the equality of number of elements.
    if (table_cpu.n_elements() == table_copied_from_gpu.n_elements())
      {
        // Get the pointers to the first element in the two tables.
        const T *table_cpu_ptr = &(table_cpu(TableIndices<N>()));
        const T *table_from_gpu_ptr =
          &(table_copied_from_gpu(TableIndices<N>()));

        for (std::size_t i = 0; i < table_cpu.n_elements(); i++)
          {
            if (*(table_cpu_ptr + i) != *(table_from_gpu_ptr + i))
              {
                error_code =
                  cudaHostUnregister((void *)&(table_copied_from_gpu(0, 0)));
                AssertCuda(error_code);
                return false;
              }
          }

        error_code = cudaHostUnregister((void *)&(table_copied_from_gpu(0, 0)));
        AssertCuda(error_code);
        return true;
      }
    else
      {
        error_code = cudaHostUnregister((void *)&(table_copied_from_gpu(0, 0)));
        AssertCuda(error_code);
        return false;
      }
  }


  /**
   * Check the numerical equality of the table (2 dimensions) of scalar values
   * on CPU and GPU (asynchronous).
   *
   * @tparam T
   * @param table_cpu
   * @param table_gpu
   * @param eps
   * @param stream
   * @return
   */
  template <typename T>
  bool
  is_equal(const Table<2, T>                            &table_cpu,
           const IdeoBEM::CUDAWrappers::CUDATable<2, T> &table_gpu,
           const T                                       eps,
           const cudaStream_t                            stream)
  {
    const unsigned int N = 2;

    // Make a copy of the GPU table on the host.
    TableIndices<N> table_sizes;
    IdeoBEM::CUDAWrappers::copy_table_indices(table_sizes, table_gpu.size());
    Table<N, T> table_copied_from_gpu(table_sizes[0], table_sizes[1]);
    cudaError_t error_code =
      cudaHostRegister((void *)&(table_copied_from_gpu(0, 0)),
                       table_copied_from_gpu.n_elements() * sizeof(T),
                       0);
    AssertCuda(error_code);

    table_gpu.copy_to_host(table_copied_from_gpu, stream);

    error_code = cudaStreamSynchronize(stream);
    AssertCuda(error_code);

    // Check the equality of number of elements.
    if (table_cpu.n_elements() == table_copied_from_gpu.n_elements())
      {
        // Get the pointers to the first element in the two tables.
        const T *table_cpu_ptr = &(table_cpu(TableIndices<N>()));
        const T *table_from_gpu_ptr =
          &(table_copied_from_gpu(TableIndices<N>()));

        for (std::size_t i = 0; i < table_cpu.n_elements(); i++)
          {
            deallog << "(" << *(table_cpu_ptr + i) << ","
                    << *(table_from_gpu_ptr + i) << ")" << std::endl;

            if (std::fabs(*(table_cpu_ptr + i) - *(table_from_gpu_ptr + i)) >
                eps)
              {
                error_code =
                  cudaHostUnregister((void *)&(table_copied_from_gpu(0, 0)));
                AssertCuda(error_code);
                return false;
              }
          }

        error_code = cudaHostUnregister((void *)&(table_copied_from_gpu(0, 0)));
        AssertCuda(error_code);
        return true;
      }
    else
      {
        error_code = cudaHostUnregister((void *)&(table_copied_from_gpu(0, 0)));
        AssertCuda(error_code);
        return false;
      }
  }


  /**
   * Check the numerical equality of the table (2 dimensions) of @p Tensor
   * objects on CPU and on GPU (asynchronous).
   *
   * @tparam spacedim
   * @tparam RangeNumberType
   * @param table_cpu
   * @param table_gpu
   * @param eps
   * @param stream
   * @return
   */
  template <int spacedim, typename RangeNumberType>
  bool
  is_equal(const Table<2, Tensor<1, spacedim, RangeNumberType>> &table_cpu,
           const IdeoBEM::CUDAWrappers::
             CUDATable<2, Tensor<1, spacedim, RangeNumberType>> &table_gpu,
           const RangeNumberType                                 eps,
           const cudaStream_t                                    stream)
  {
    const unsigned int N = 2;

    // Make a copy of the GPU table on the host.
    TableIndices<N> table_sizes;
    IdeoBEM::CUDAWrappers::copy_table_indices(table_sizes, table_gpu.size());
    Table<N, Tensor<1, spacedim, RangeNumberType>> table_copied_from_gpu(
      table_sizes[0], table_sizes[1]);
    cudaError_t error_code =
      cudaHostRegister((void *)&(table_copied_from_gpu(0, 0)),
                       table_copied_from_gpu.n_elements() *
                         sizeof(Tensor<1, spacedim, RangeNumberType>),
                       0);
    AssertCuda(error_code);

    table_gpu.copy_to_host(table_copied_from_gpu, stream);

    error_code = cudaStreamSynchronize(stream);
    AssertCuda(error_code);

    // Check the equality of number of elements.
    if (table_cpu.n_elements() == table_copied_from_gpu.n_elements())
      {
        for (std::size_t i = 0; i < table_cpu.n_rows(); i++)
          {
            for (std::size_t j = 0; j < table_cpu.n_cols(); j++)
              {
                for (unsigned int d = 0; d < spacedim; d++)
                  {
                    deallog << "(" << table_cpu(i, j)[d] << ","
                            << table_copied_from_gpu(i, j)[d] << ")"
                            << std::endl;

                    if (std::fabs(table_cpu(i, j)[d] -
                                  table_copied_from_gpu(i, j)[d]) > eps)
                      {
                        error_code = cudaHostUnregister(
                          (void *)&(table_copied_from_gpu(0, 0)));
                        AssertCuda(error_code);
                        return false;
                      }
                  }
              }
          }

        error_code = cudaHostUnregister((void *)&(table_copied_from_gpu(0, 0)));
        AssertCuda(error_code);
        return true;
      }
    else
      {
        error_code = cudaHostUnregister((void *)&(table_copied_from_gpu(0, 0)));
        AssertCuda(error_code);
        return false;
      }
  }


  template <int spacedim, typename RangeNumberType>
  bool
  is_equal(
    const Table<2, Point<spacedim, RangeNumberType>> &table_cpu,
    const IdeoBEM::CUDAWrappers::CUDATable<2, Point<spacedim, RangeNumberType>>
                         &table_gpu,
    const RangeNumberType eps,
    const cudaStream_t    stream)
  {
    const unsigned int N = 2;

    // Make a copy of the GPU table on the host.
    TableIndices<N> table_sizes;
    IdeoBEM::CUDAWrappers::copy_table_indices(table_sizes, table_gpu.size());
    Table<N, Point<spacedim, RangeNumberType>> table_copied_from_gpu(
      table_sizes[0], table_sizes[1]);
    cudaError_t error_code =
      cudaHostRegister((void *)&(table_copied_from_gpu(0, 0)),
                       table_copied_from_gpu.n_elements() *
                         sizeof(Point<spacedim, RangeNumberType>),
                       0);
    AssertCuda(error_code);

    table_gpu.copy_to_host(table_copied_from_gpu, stream);

    error_code = cudaStreamSynchronize(stream);
    AssertCuda(error_code);

    // Check the equality of number of elements.
    if (table_cpu.n_elements() == table_copied_from_gpu.n_elements())
      {
        for (std::size_t i = 0; i < table_cpu.n_rows(); i++)
          {
            for (std::size_t j = 0; j < table_cpu.n_cols(); j++)
              {
                for (unsigned int d = 0; d < spacedim; d++)
                  {
                    deallog << "(" << table_cpu(i, j)[d] << ","
                            << table_copied_from_gpu(i, j)[d] << ")"
                            << std::endl;

                    if (std::fabs(table_cpu(i, j)(d) -
                                  table_copied_from_gpu(i, j)(d)) > eps)
                      {
                        error_code = cudaHostUnregister(
                          (void *)&(table_copied_from_gpu(0, 0)));
                        AssertCuda(error_code);
                        return false;
                      }
                  }
              }
          }

        error_code = cudaHostUnregister((void *)&(table_copied_from_gpu(0, 0)));
        AssertCuda(error_code);
        return true;
      }
    else
      {
        error_code = cudaHostUnregister((void *)&(table_copied_from_gpu(0, 0)));
        AssertCuda(error_code);
        return false;
      }
  }


  /**
   * Check the equality of the table (3 dimensions) of scalar values on CPU and
   * GPU.
   *
   * @tparam T
   * @param table_cpu
   * @param table_gpu
   * @return
   */
  template <typename T>
  bool
  is_equal(const Table<3, T>                            &table_cpu,
           const IdeoBEM::CUDAWrappers::CUDATable<3, T> &table_gpu)
  {
    const unsigned int N = 3;

    // Make a copy of the GPU table on the host.
    TableIndices<N> table_sizes;
    IdeoBEM::CUDAWrappers::copy_table_indices(table_sizes, table_gpu.size());
    Table<N, T> table_copied_from_gpu(table_sizes[0],
                                      table_sizes[1],
                                      table_sizes[2]);
    table_gpu.copy_to_host(table_copied_from_gpu);

    // Check the equality of number of elements.
    if (table_cpu.n_elements() == table_copied_from_gpu.n_elements())
      {
        // Get the pointers to the first element in the two tables.
        const T *table_cpu_ptr = &(table_cpu(TableIndices<N>()));
        const T *table_from_gpu_ptr =
          &(table_copied_from_gpu(TableIndices<N>()));

        for (std::size_t i = 0; i < table_cpu.n_elements(); i++)
          {
            if (*(table_cpu_ptr + i) != *(table_from_gpu_ptr + i))
              {
                return false;
              }
          }

        return true;
      }
    else
      {
        return false;
      }
  }


  /**
   * Check the equality of the table of matrices for the gradient of shape
   * functions.
   *
   * @tparam T
   * @param table_cpu
   * @param table_gpu
   * @return
   */
  template <typename T>
  bool
  is_equal(const Table<2, LAPACKFullMatrixExt<T>>       &table_cpu,
           const IdeoBEM::CUDAWrappers::CUDATable<4, T> &table_gpu)
  {
    const unsigned int N = 4;

    // Make a copy of the GPU table on the host.
    TableIndices<N> table_sizes;
    IdeoBEM::CUDAWrappers::copy_table_indices(table_sizes, table_gpu.size());
    Table<N, T> table_copied_from_gpu(table_sizes[0],
                                      table_sizes[1],
                                      table_sizes[2],
                                      table_sizes[3]);
    table_gpu.copy_to_host(table_copied_from_gpu);

    // Get the gradient matrix sizes.
    const unsigned int m = table_cpu(0, 0).m();
    const unsigned int n = table_cpu(0, 0).n();

    // Check the equality of number of elements.
    if (table_cpu.n_elements() * m * n == table_copied_from_gpu.n_elements())
      {
        // Get table sizes.
        const unsigned int k3_terms = table_cpu.n_rows();
        const unsigned int quad_num = table_cpu.n_cols();

        std::size_t counter = 0;
        const T    *table_from_gpu_ptr =
          &(table_copied_from_gpu(TableIndices<N>()));

        for (unsigned int k = 0; k < k3_terms; k++)
          {
            for (unsigned int q = 0; q < quad_num; q++)
              {
                for (unsigned int j = 0; j < n; j++)
                  {
                    for (unsigned int i = 0; i < m; i++)
                      {
                        if (*(table_from_gpu_ptr + counter) !=
                            table_cpu(k, q)(i, j))
                          {
                            std::cout << "(" << table_cpu(k, q)(i, j) << ","
                                      << *(table_from_gpu_ptr + counter) << ")"
                                      << std::endl;
                            return false;
                          }
                        else
                          {
                            counter++;
                          }
                      }
                  }
              }
          }

        return true;
      }
    else
      {
        std::cout << "(" << table_cpu.n_elements() * m * n << ","
                  << table_copied_from_gpu.n_elements() << ")" << std::endl;
        return false;
      }
  }


  /**
   * Check the equality of the table of matrices for the gradient of shape
   * functions (asynchronous).
   *
   * @tparam T
   * @param table_cpu
   * @param table_gpu
   * @param stream
   * @return
   */
  template <typename T>
  bool
  is_equal(const Table<2, LAPACKFullMatrixExt<T>>       &table_cpu,
           const IdeoBEM::CUDAWrappers::CUDATable<4, T> &table_gpu,
           const cudaStream_t                            stream)
  {
    const unsigned int N = 4;

    // Make a copy of the GPU table on the host.
    TableIndices<N> table_sizes;
    IdeoBEM::CUDAWrappers::copy_table_indices(table_sizes, table_gpu.size());
    Table<N, T> table_copied_from_gpu(table_sizes[0],
                                      table_sizes[1],
                                      table_sizes[2],
                                      table_sizes[3]);
    cudaError_t error_code =
      cudaHostRegister((void *)&(table_copied_from_gpu(0, 0, 0, 0)),
                       table_copied_from_gpu.n_elements() * sizeof(T),
                       0);
    AssertCuda(error_code);

    table_gpu.copy_to_host(table_copied_from_gpu);

    error_code = cudaStreamSynchronize(stream);
    AssertCuda(error_code);

    // Get the gradient matrix sizes.
    const unsigned int m = table_cpu(0, 0).m();
    const unsigned int n = table_cpu(0, 0).n();

    // Check the equality of number of elements.
    if (table_cpu.n_elements() * m * n == table_copied_from_gpu.n_elements())
      {
        // Get table sizes.
        const unsigned int k3_terms = table_cpu.n_rows();
        const unsigned int quad_num = table_cpu.n_cols();

        std::size_t counter = 0;
        const T    *table_from_gpu_ptr =
          &(table_copied_from_gpu(TableIndices<N>()));

        for (unsigned int k = 0; k < k3_terms; k++)
          {
            for (unsigned int q = 0; q < quad_num; q++)
              {
                for (unsigned int j = 0; j < n; j++)
                  {
                    for (unsigned int i = 0; i < m; i++)
                      {
                        if (*(table_from_gpu_ptr + counter) !=
                            table_cpu(k, q)(i, j))
                          {
                            std::cout << "(" << table_cpu(k, q)(i, j) << ","
                                      << *(table_from_gpu_ptr + counter) << ")"
                                      << std::endl;
                            error_code = cudaHostUnregister(
                              (void *)&(table_copied_from_gpu(0, 0, 0, 0)));
                            AssertCuda(error_code);
                            return false;
                          }
                        else
                          {
                            counter++;
                          }
                      }
                  }
              }
          }

        error_code =
          cudaHostUnregister((void *)&(table_copied_from_gpu(0, 0, 0, 0)));
        AssertCuda(error_code);
        return true;
      }
    else
      {
        std::cout << "(" << table_cpu.n_elements() * m * n << ","
                  << table_copied_from_gpu.n_elements() << ")" << std::endl;
        error_code =
          cudaHostUnregister((void *)&(table_copied_from_gpu(0, 0, 0, 0)));
        AssertCuda(error_code);
        return false;
      }
  }


  /**
   * Check the numerical equality of the table of matrices for the gradient of
   * shape functions (asynchronous).
   *
   * @tparam T
   * @param table_cpu
   * @param table_gpu
   * @param eps
   * @param stream
   * @return
   */
  template <typename T>
  bool
  is_equal(const Table<2, LAPACKFullMatrixExt<T>>       &table_cpu,
           const IdeoBEM::CUDAWrappers::CUDATable<4, T> &table_gpu,
           const T                                       eps,
           const cudaStream_t                            stream)
  {
    const unsigned int N = 4;

    // Make a copy of the GPU table on the host.
    TableIndices<N> table_sizes;
    IdeoBEM::CUDAWrappers::copy_table_indices(table_sizes, table_gpu.size());
    Table<N, T> table_copied_from_gpu(table_sizes[0],
                                      table_sizes[1],
                                      table_sizes[2],
                                      table_sizes[3]);
    cudaError_t error_code =
      cudaHostRegister((void *)&(table_copied_from_gpu(0, 0, 0, 0)),
                       table_copied_from_gpu.n_elements() * sizeof(T),
                       0);
    AssertCuda(error_code);

    table_gpu.copy_to_host(table_copied_from_gpu);

    error_code = cudaStreamSynchronize(stream);
    AssertCuda(error_code);

    // Get the gradient matrix sizes.
    const unsigned int m = table_cpu(0, 0).m();
    const unsigned int n = table_cpu(0, 0).n();

    // Check the equality of number of elements.
    if (table_cpu.n_elements() * m * n == table_copied_from_gpu.n_elements())
      {
        // Get table sizes.
        const unsigned int k3_terms = table_cpu.n_rows();
        const unsigned int quad_num = table_cpu.n_cols();

        std::size_t counter = 0;
        const T    *table_from_gpu_ptr =
          &(table_copied_from_gpu(TableIndices<N>()));

        for (unsigned int k = 0; k < k3_terms; k++)
          {
            for (unsigned int q = 0; q < quad_num; q++)
              {
                for (unsigned int j = 0; j < n; j++)
                  {
                    for (unsigned int i = 0; i < m; i++)
                      {
                        deallog << "(" << table_cpu(k, q)(i, j) << ","
                                << *(table_from_gpu_ptr + counter) << ")"
                                << std::endl;

                        if (std::fabs(*(table_from_gpu_ptr + counter) -
                                      table_cpu(k, q)(i, j)) > eps)
                          {
                            error_code = cudaHostUnregister(
                              (void *)&(table_copied_from_gpu(0, 0, 0, 0)));
                            AssertCuda(error_code);
                            return false;
                          }
                      }
                  }
              }
          }

        error_code =
          cudaHostUnregister((void *)&(table_copied_from_gpu(0, 0, 0, 0)));
        AssertCuda(error_code);
        return true;
      }
    else
      {
        std::cout << "(" << table_cpu.n_elements() * m * n << ","
                  << table_copied_from_gpu.n_elements() << ")" << std::endl;
        error_code =
          cudaHostUnregister((void *)&(table_copied_from_gpu(0, 0, 0, 0)));
        AssertCuda(error_code);
        return false;
      }
  }


  /**
   * Check the equality of @p BEMValues and @p CUDABEMValues.
   *
   * @tparam dim
   * @tparam spacedim
   * @tparam RangeNumberType
   * @param bem_values_cpu
   * @param bem_values_gpu
   * @return
   */
  template <int dim, int spacedim, typename RangeNumberType = double>
  bool
  is_equal(
    const BEMValues<dim, spacedim, RangeNumberType> &bem_values_cpu,
    const IdeoBEM::CUDAWrappers::CUDABEMValues<dim, spacedim, RangeNumberType>
      &bem_values_gpu)
  {
    if (is_equal(bem_values_cpu.quad_rule_for_same_panel,
                 bem_values_gpu.quad_rule_for_same_panel))
      {
        std::cout << "quad_rule_for_same_panel is equal" << std::endl;
      }
    else
      {
        std::cout << "quad_rule_for_same_panel is not equal" << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.quad_rule_for_common_edge,
                 bem_values_gpu.quad_rule_for_common_edge))
      {
        std::cout << "quad_rule_for_common_edge is equal" << std::endl;
      }
    else
      {
        std::cout << "quad_rule_for_common_edge is not equal" << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.quad_rule_for_common_vertex,
                 bem_values_gpu.quad_rule_for_common_vertex))
      {
        std::cout << "quad_rule_for_common_vertex is equal" << std::endl;
      }
    else
      {
        std::cout << "quad_rule_for_common_vertex is not equal" << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.quad_rule_for_regular,
                 bem_values_gpu.quad_rule_for_regular))
      {
        std::cout << "quad_rule_for_regular is equal" << std::endl;
      }
    else
      {
        std::cout << "quad_rule_for_regular is not equal" << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.kx_shape_value_table_for_same_panel,
                 bem_values_gpu.kx_shape_value_table_for_same_panel))
      {
        std::cout << "kx_shape_value_table_for_same_panel is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "kx_shape_value_table_for_same_panel is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.ky_shape_value_table_for_same_panel,
                 bem_values_gpu.ky_shape_value_table_for_same_panel))
      {
        std::cout << "ky_shape_value_table_for_same_panel is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "ky_shape_value_table_for_same_panel is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.kx_shape_value_table_for_common_edge,
                 bem_values_gpu.kx_shape_value_table_for_common_edge))
      {
        std::cout << "kx_shape_value_table_for_common_edge is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "kx_shape_value_table_for_common_edge is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.ky_shape_value_table_for_common_edge,
                 bem_values_gpu.ky_shape_value_table_for_common_edge))
      {
        std::cout << "ky_shape_value_table_for_common_edge is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "ky_shape_value_table_for_common_edge is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.kx_shape_value_table_for_common_vertex,
                 bem_values_gpu.kx_shape_value_table_for_common_vertex))
      {
        std::cout << "kx_shape_value_table_for_common_vertex is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "kx_shape_value_table_for_common_vertex is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.ky_shape_value_table_for_common_vertex,
                 bem_values_gpu.ky_shape_value_table_for_common_vertex))
      {
        std::cout << "ky_shape_value_table_for_common_vertex is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "ky_shape_value_table_for_common_vertex is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.kx_shape_value_table_for_regular,
                 bem_values_gpu.kx_shape_value_table_for_regular))
      {
        std::cout << "kx_shape_value_table_for_regular is equal" << std::endl;
      }
    else
      {
        std::cout << "kx_shape_value_table_for_regular is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.ky_shape_value_table_for_regular,
                 bem_values_gpu.ky_shape_value_table_for_regular))
      {
        std::cout << "ky_shape_value_table_for_regular is equal" << std::endl;
      }
    else
      {
        std::cout << "ky_shape_value_table_for_regular is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.kx_mapping_shape_value_table_for_same_panel,
                 bem_values_gpu.kx_mapping_shape_value_table_for_same_panel))
      {
        std::cout << "kx_mapping_shape_value_table_for_same_panel is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "kx_mapping_shape_value_table_for_same_panel is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.ky_mapping_shape_value_table_for_same_panel,
                 bem_values_gpu.ky_mapping_shape_value_table_for_same_panel))
      {
        std::cout << "ky_mapping_shape_value_table_for_same_panel is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "ky_mapping_shape_value_table_for_same_panel is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.kx_mapping_shape_value_table_for_common_edge,
                 bem_values_gpu.kx_mapping_shape_value_table_for_common_edge))
      {
        std::cout << "kx_mapping_shape_value_table_for_common_edge is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "kx_mapping_shape_value_table_for_common_edge is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.ky_mapping_shape_value_table_for_common_edge,
                 bem_values_gpu.ky_mapping_shape_value_table_for_common_edge))
      {
        std::cout << "ky_mapping_shape_value_table_for_common_edge is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "ky_mapping_shape_value_table_for_common_edge is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.kx_mapping_shape_value_table_for_common_vertex,
                 bem_values_gpu.kx_mapping_shape_value_table_for_common_vertex))
      {
        std::cout << "kx_mapping_shape_value_table_for_common_vertex is equal"
                  << std::endl;
      }
    else
      {
        std::cout
          << "kx_mapping_shape_value_table_for_common_vertex is not equal"
          << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.ky_mapping_shape_value_table_for_common_vertex,
                 bem_values_gpu.ky_mapping_shape_value_table_for_common_vertex))
      {
        std::cout << "ky_mapping_shape_value_table_for_common_vertex is equal"
                  << std::endl;
      }
    else
      {
        std::cout
          << "ky_mapping_shape_value_table_for_common_vertex is not equal"
          << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.kx_mapping_shape_value_table_for_regular,
                 bem_values_gpu.kx_mapping_shape_value_table_for_regular))
      {
        std::cout << "kx_mapping_shape_value_table_for_regular is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "kx_mapping_shape_value_table_for_regular is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.ky_mapping_shape_value_table_for_regular,
                 bem_values_gpu.ky_mapping_shape_value_table_for_regular))
      {
        std::cout << "ky_mapping_shape_value_table_for_regular is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "ky_mapping_shape_value_table_for_regular is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.kx_shape_grad_matrix_table_for_same_panel,
                 bem_values_gpu.kx_shape_grad_matrix_table_for_same_panel))
      {
        std::cout << "kx_shape_grad_matrix_table_for_same_panel is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "kx_shape_grad_matrix_table_for_same_panel is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.ky_shape_grad_matrix_table_for_same_panel,
                 bem_values_gpu.ky_shape_grad_matrix_table_for_same_panel))
      {
        std::cout << "ky_shape_grad_matrix_table_for_same_panel is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "ky_shape_grad_matrix_table_for_same_panel is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.kx_shape_grad_matrix_table_for_common_edge,
                 bem_values_gpu.kx_shape_grad_matrix_table_for_common_edge))
      {
        std::cout << "kx_shape_grad_matrix_table_for_common_edge is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "kx_shape_grad_matrix_table_for_common_edge is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.ky_shape_grad_matrix_table_for_common_edge,
                 bem_values_gpu.ky_shape_grad_matrix_table_for_common_edge))
      {
        std::cout << "ky_shape_grad_matrix_table_for_common_edge is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "ky_shape_grad_matrix_table_for_common_edge is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.kx_shape_grad_matrix_table_for_common_vertex,
                 bem_values_gpu.kx_shape_grad_matrix_table_for_common_vertex))
      {
        std::cout << "kx_shape_grad_matrix_table_for_common_vertex is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "kx_shape_grad_matrix_table_for_common_vertex is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.ky_shape_grad_matrix_table_for_common_vertex,
                 bem_values_gpu.ky_shape_grad_matrix_table_for_common_vertex))
      {
        std::cout << "ky_shape_grad_matrix_table_for_common_vertex is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "ky_shape_grad_matrix_table_for_common_vertex is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.kx_shape_grad_matrix_table_for_regular,
                 bem_values_gpu.kx_shape_grad_matrix_table_for_regular))
      {
        std::cout << "kx_shape_grad_matrix_table_for_regular is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "kx_shape_grad_matrix_table_for_regular is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.ky_shape_grad_matrix_table_for_regular,
                 bem_values_gpu.ky_shape_grad_matrix_table_for_regular))
      {
        std::cout << "ky_shape_grad_matrix_table_for_regular is equal"
                  << std::endl;
      }
    else
      {
        std::cout << "ky_shape_grad_matrix_table_for_regular is not equal"
                  << std::endl;
        return false;
      }

    if (is_equal(
          bem_values_cpu.kx_mapping_shape_grad_matrix_table_for_same_panel,
          bem_values_gpu.kx_mapping_shape_grad_matrix_table_for_same_panel))
      {
        std::cout
          << "kx_mapping_shape_grad_matrix_table_for_same_panel is equal"
          << std::endl;
      }
    else
      {
        std::cout
          << "kx_mapping_shape_grad_matrix_table_for_same_panel is not equal"
          << std::endl;
        return false;
      }

    if (is_equal(
          bem_values_cpu.ky_mapping_shape_grad_matrix_table_for_same_panel,
          bem_values_gpu.ky_mapping_shape_grad_matrix_table_for_same_panel))
      {
        std::cout
          << "ky_mapping_shape_grad_matrix_table_for_same_panel is equal"
          << std::endl;
      }
    else
      {
        std::cout
          << "ky_mapping_shape_grad_matrix_table_for_same_panel is not equal"
          << std::endl;
        return false;
      }

    if (is_equal(
          bem_values_cpu.kx_mapping_shape_grad_matrix_table_for_common_edge,
          bem_values_gpu.kx_mapping_shape_grad_matrix_table_for_common_edge))
      {
        std::cout
          << "kx_mapping_shape_grad_matrix_table_for_common_edge is equal"
          << std::endl;
      }
    else
      {
        std::cout
          << "kx_mapping_shape_grad_matrix_table_for_common_edge is not equal"
          << std::endl;
        return false;
      }

    if (is_equal(
          bem_values_cpu.ky_mapping_shape_grad_matrix_table_for_common_edge,
          bem_values_gpu.ky_mapping_shape_grad_matrix_table_for_common_edge))
      {
        std::cout
          << "ky_mapping_shape_grad_matrix_table_for_common_edge is equal"
          << std::endl;
      }
    else
      {
        std::cout
          << "ky_mapping_shape_grad_matrix_table_for_common_edge is not equal"
          << std::endl;
        return false;
      }

    if (is_equal(
          bem_values_cpu.kx_mapping_shape_grad_matrix_table_for_common_vertex,
          bem_values_gpu.kx_mapping_shape_grad_matrix_table_for_common_vertex))
      {
        std::cout
          << "kx_mapping_shape_grad_matrix_table_for_common_vertex is equal"
          << std::endl;
      }
    else
      {
        std::cout
          << "kx_mapping_shape_grad_matrix_table_for_common_vertex is not equal"
          << std::endl;
        return false;
      }

    if (is_equal(
          bem_values_cpu.ky_mapping_shape_grad_matrix_table_for_common_vertex,
          bem_values_gpu.ky_mapping_shape_grad_matrix_table_for_common_vertex))
      {
        std::cout
          << "ky_mapping_shape_grad_matrix_table_for_common_vertex is equal"
          << std::endl;
      }
    else
      {
        std::cout
          << "ky_mapping_shape_grad_matrix_table_for_common_vertex is not equal"
          << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.kx_mapping_shape_grad_matrix_table_for_regular,
                 bem_values_gpu.kx_mapping_shape_grad_matrix_table_for_regular))
      {
        std::cout << "kx_mapping_shape_grad_matrix_table_for_regular is equal"
                  << std::endl;
      }
    else
      {
        std::cout
          << "kx_mapping_shape_grad_matrix_table_for_regular is not equal"
          << std::endl;
        return false;
      }

    if (is_equal(bem_values_cpu.ky_mapping_shape_grad_matrix_table_for_regular,
                 bem_values_gpu.ky_mapping_shape_grad_matrix_table_for_regular))
      {
        std::cout << "ky_mapping_shape_grad_matrix_table_for_regular is equal"
                  << std::endl;
      }
    else
      {
        std::cout
          << "ky_mapping_shape_grad_matrix_table_for_regular is not equal"
          << std::endl;
        return false;
      }

    return true;
  }


  /**
   * Check the equality of @p PairCellWiseScratchData and @p CUDAPairCellWiseScratchData.
   *
   * @tparam dim
   * @tparam spacedim
   * @tparam RangeNumberType
   * @param scratch_data_cpu
   * @param scratch_data_gpu
   * @param stream
   * @return
   */
  template <int dim, int spacedim, typename RangeNumberType = double>
  bool
  is_equal(const PairCellWiseScratchData<dim, spacedim, RangeNumberType>
             &scratch_data_cpu,
           const IdeoBEM::CUDAWrappers::
             CUDAPairCellWiseScratchData<dim, spacedim, RangeNumberType>
                                &scratch_data_gpu,
           const RangeNumberType eps,
           const cudaStream_t    stream,
           const bool            is_covariants_calculated)
  {
    LogStream::Prefix prefix_string("Check ScratchData");

    bool check_result;

    if (is_equal(scratch_data_cpu.kx_mapping_support_points_permuted,
                 scratch_data_gpu.kx_mapping_support_points_permuted,
                 eps,
                 stream))
      {
        deallog << "kx_mapping_support_points_permuted is equal" << std::endl;
      }
    else
      {
        deallog << "kx_mapping_support_points_permuted is not equal"
                << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.ky_mapping_support_points_permuted,
                 scratch_data_gpu.ky_mapping_support_points_permuted,
                 eps,
                 stream))
      {
        deallog << "ky_mapping_support_points_permuted is equal" << std::endl;
      }
    else
      {
        deallog << "ky_mapping_support_points_permuted is not equal"
                << std::endl;
        check_result = false;
      }

    if (is_equal(
          scratch_data_cpu.kx_mapping_support_points_permuted_xy_components,
          scratch_data_gpu.kx_mapping_support_points_permuted_xy_components,
          eps,
          stream))
      {
        deallog << "kx_mapping_support_points_permuted_xy_components is equal"
                << std::endl;
      }
    else
      {
        deallog
          << "kx_mapping_support_points_permuted_xy_components is not equal"
          << std::endl;
        check_result = false;
      }

    if (is_equal(
          scratch_data_cpu.kx_mapping_support_points_permuted_yz_components,
          scratch_data_gpu.kx_mapping_support_points_permuted_yz_components,
          eps,
          stream))
      {
        deallog << "kx_mapping_support_points_permuted_yz_components is equal"
                << std::endl;
      }
    else
      {
        deallog
          << "kx_mapping_support_points_permuted_yz_components is not equal"
          << std::endl;
        check_result = false;
      }

    if (is_equal(
          scratch_data_cpu.kx_mapping_support_points_permuted_zx_components,
          scratch_data_gpu.kx_mapping_support_points_permuted_zx_components,
          eps,
          stream))
      {
        deallog << "kx_mapping_support_points_permuted_zx_components is equal"
                << std::endl;
      }
    else
      {
        deallog
          << "kx_mapping_support_points_permuted_zx_components is not equal"
          << std::endl;
        check_result = false;
      }

    if (is_equal(
          scratch_data_cpu.ky_mapping_support_points_permuted_xy_components,
          scratch_data_gpu.ky_mapping_support_points_permuted_xy_components,
          eps,
          stream))
      {
        deallog << "ky_mapping_support_points_permuted_xy_components is equal"
                << std::endl;
      }
    else
      {
        deallog
          << "ky_mapping_support_points_permuted_xy_components is not equal"
          << std::endl;
        check_result = false;
      }

    if (is_equal(
          scratch_data_cpu.ky_mapping_support_points_permuted_yz_components,
          scratch_data_gpu.ky_mapping_support_points_permuted_yz_components,
          eps,
          stream))
      {
        deallog << "ky_mapping_support_points_permuted_yz_components is equal"
                << std::endl;
      }
    else
      {
        deallog
          << "ky_mapping_support_points_permuted_yz_components is not equal"
          << std::endl;
        check_result = false;
      }

    if (is_equal(
          scratch_data_cpu.ky_mapping_support_points_permuted_zx_components,
          scratch_data_gpu.ky_mapping_support_points_permuted_zx_components,
          eps,
          stream))
      {
        deallog << "ky_mapping_support_points_permuted_zx_components is equal"
                << std::endl;
      }
    else
      {
        deallog
          << "ky_mapping_support_points_permuted_zx_components is not equal"
          << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.kx_jacobians_same_panel,
                 scratch_data_gpu.kx_jacobians_same_panel,
                 eps,
                 stream))
      {
        deallog << "kx_jacobians_same_panel is equal" << std::endl;
      }
    else
      {
        deallog << "kx_jacobians_same_panel is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.kx_jacobians_common_edge,
                 scratch_data_gpu.kx_jacobians_common_edge,
                 eps,
                 stream))
      {
        deallog << "kx_jacobians_common_edge is equal" << std::endl;
      }
    else
      {
        deallog << "kx_jacobians_common_edge is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.kx_jacobians_common_vertex,
                 scratch_data_gpu.kx_jacobians_common_vertex,
                 eps,
                 stream))
      {
        deallog << "kx_jacobians_common_vertex is equal" << std::endl;
      }
    else
      {
        deallog << "kx_jacobians_common_vertex is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.kx_jacobians_regular,
                 scratch_data_gpu.kx_jacobians_regular,
                 eps,
                 stream))
      {
        deallog << "kx_jacobians_regular is equal" << std::endl;
      }
    else
      {
        deallog << "kx_jacobians_regular is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.ky_jacobians_same_panel,
                 scratch_data_gpu.ky_jacobians_same_panel,
                 eps,
                 stream))
      {
        deallog << "ky_jacobians_same_panel is equal" << std::endl;
      }
    else
      {
        deallog << "ky_jacobians_same_panel is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.ky_jacobians_common_edge,
                 scratch_data_gpu.ky_jacobians_common_edge,
                 eps,
                 stream))
      {
        deallog << "ky_jacobians_common_edge is equal" << std::endl;
      }
    else
      {
        deallog << "ky_jacobians_common_edge is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.ky_jacobians_common_vertex,
                 scratch_data_gpu.ky_jacobians_common_vertex,
                 eps,
                 stream))
      {
        deallog << "ky_jacobians_common_vertex is equal" << std::endl;
      }
    else
      {
        deallog << "ky_jacobians_common_vertex is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.ky_jacobians_regular,
                 scratch_data_gpu.ky_jacobians_regular,
                 eps,
                 stream))
      {
        deallog << "ky_jacobians_regular is equal" << std::endl;
      }
    else
      {
        deallog << "ky_jacobians_regular is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.kx_normals_same_panel,
                 scratch_data_gpu.kx_normals_same_panel,
                 eps,
                 stream))
      {
        deallog << "kx_normals_same_panel is equal" << std::endl;
      }
    else
      {
        deallog << "kx_normals_same_panel is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.kx_normals_common_edge,
                 scratch_data_gpu.kx_normals_common_edge,
                 eps,
                 stream))
      {
        deallog << "kx_normals_common_edge is equal" << std::endl;
      }
    else
      {
        deallog << "kx_normals_common_edge is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.kx_normals_common_vertex,
                 scratch_data_gpu.kx_normals_common_vertex,
                 eps,
                 stream))
      {
        deallog << "kx_normals_common_vertex is equal" << std::endl;
      }
    else
      {
        deallog << "kx_normals_common_vertex is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.kx_normals_regular,
                 scratch_data_gpu.kx_normals_regular,
                 eps,
                 stream))
      {
        deallog << "kx_normals_regular is equal" << std::endl;
      }
    else
      {
        deallog << "kx_normals_regular is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.ky_normals_same_panel,
                 scratch_data_gpu.ky_normals_same_panel,
                 eps,
                 stream))
      {
        deallog << "ky_normals_same_panel is equal" << std::endl;
      }
    else
      {
        deallog << "ky_normals_same_panel is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.ky_normals_common_edge,
                 scratch_data_gpu.ky_normals_common_edge,
                 eps,
                 stream))
      {
        deallog << "ky_normals_common_edge is equal" << std::endl;
      }
    else
      {
        deallog << "ky_normals_common_edge is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.ky_normals_common_vertex,
                 scratch_data_gpu.ky_normals_common_vertex,
                 eps,
                 stream))
      {
        deallog << "ky_normals_common_vertex is equal" << std::endl;
      }
    else
      {
        deallog << "ky_normals_common_vertex is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.ky_normals_regular,
                 scratch_data_gpu.ky_normals_regular,
                 eps,
                 stream))
      {
        deallog << "ky_normals_regular is equal" << std::endl;
      }
    else
      {
        deallog << "ky_normals_regular is not equal" << std::endl;
        check_result = false;
      }

    if (is_covariants_calculated)
      {
        if (is_equal(scratch_data_cpu.kx_covariants_same_panel,
                     scratch_data_gpu.kx_covariants_same_panel,
                     eps,
                     stream))
          {
            deallog << "kx_covariants_same_panel is equal" << std::endl;
          }
        else
          {
            deallog << "kx_covariants_same_panel is not equal" << std::endl;
            check_result = false;
          }

        if (is_equal(scratch_data_cpu.kx_covariants_common_edge,
                     scratch_data_gpu.kx_covariants_common_edge,
                     eps,
                     stream))
          {
            deallog << "kx_covariants_common_edge is equal" << std::endl;
          }
        else
          {
            deallog << "kx_covariants_common_edge is not equal" << std::endl;
            check_result = false;
          }

        if (is_equal(scratch_data_cpu.kx_covariants_common_vertex,
                     scratch_data_gpu.kx_covariants_common_vertex,
                     eps,
                     stream))
          {
            deallog << "kx_covariants_common_vertex is equal" << std::endl;
          }
        else
          {
            deallog << "kx_covariants_common_vertex is not equal" << std::endl;
            check_result = false;
          }

        if (is_equal(scratch_data_cpu.kx_covariants_regular,
                     scratch_data_gpu.kx_covariants_regular,
                     eps,
                     stream))
          {
            deallog << "kx_covariants_regular is equal" << std::endl;
          }
        else
          {
            deallog << "kx_covariants_regular is not equal" << std::endl;
            check_result = false;
          }

        if (is_equal(scratch_data_cpu.ky_covariants_same_panel,
                     scratch_data_gpu.ky_covariants_same_panel,
                     eps,
                     stream))
          {
            deallog << "ky_covariants_same_panel is equal" << std::endl;
          }
        else
          {
            deallog << "ky_covariants_same_panel is not equal" << std::endl;
            check_result = false;
          }

        if (is_equal(scratch_data_cpu.ky_covariants_common_edge,
                     scratch_data_gpu.ky_covariants_common_edge,
                     eps,
                     stream))
          {
            deallog << "ky_covariants_common_edge is equal" << std::endl;
          }
        else
          {
            deallog << "ky_covariants_common_edge is not equal" << std::endl;
            check_result = false;
          }

        if (is_equal(scratch_data_cpu.ky_covariants_common_vertex,
                     scratch_data_gpu.ky_covariants_common_vertex,
                     eps,
                     stream))
          {
            deallog << "ky_covariants_common_vertex is equal" << std::endl;
          }
        else
          {
            deallog << "ky_covariants_common_vertex is not equal" << std::endl;
            check_result = false;
          }

        if (is_equal(scratch_data_cpu.ky_covariants_regular,
                     scratch_data_gpu.ky_covariants_regular,
                     eps,
                     stream))
          {
            deallog << "ky_covariants_regular is equal" << std::endl;
          }
        else
          {
            deallog << "ky_covariants_regular is not equal" << std::endl;
            check_result = false;
          }
      }

    if (is_equal(scratch_data_cpu.kx_quad_points_same_panel,
                 scratch_data_gpu.kx_quad_points_same_panel,
                 eps,
                 stream))
      {
        deallog << "kx_quad_points_same_panel is equal" << std::endl;
      }
    else
      {
        deallog << "kx_quad_points_same_panel is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.kx_quad_points_common_edge,
                 scratch_data_gpu.kx_quad_points_common_edge,
                 eps,
                 stream))
      {
        deallog << "kx_quad_points_common_edge is equal" << std::endl;
      }
    else
      {
        deallog << "kx_quad_points_common_edge is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.kx_quad_points_common_vertex,
                 scratch_data_gpu.kx_quad_points_common_vertex,
                 eps,
                 stream))
      {
        deallog << "kx_quad_points_common_vertex is equal" << std::endl;
      }
    else
      {
        deallog << "kx_quad_points_common_vertex is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.kx_quad_points_regular,
                 scratch_data_gpu.kx_quad_points_regular,
                 eps,
                 stream))
      {
        deallog << "kx_quad_points_regular is equal" << std::endl;
      }
    else
      {
        deallog << "kx_quad_points_regular is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.ky_quad_points_same_panel,
                 scratch_data_gpu.ky_quad_points_same_panel,
                 eps,
                 stream))
      {
        deallog << "ky_quad_points_same_panel is equal" << std::endl;
      }
    else
      {
        deallog << "ky_quad_points_same_panel is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.ky_quad_points_common_edge,
                 scratch_data_gpu.ky_quad_points_common_edge,
                 eps,
                 stream))
      {
        deallog << "ky_quad_points_common_edge is equal" << std::endl;
      }
    else
      {
        deallog << "ky_quad_points_common_edge is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.ky_quad_points_common_vertex,
                 scratch_data_gpu.ky_quad_points_common_vertex,
                 eps,
                 stream))
      {
        deallog << "ky_quad_points_common_vertex is equal" << std::endl;
      }
    else
      {
        deallog << "ky_quad_points_common_vertex is not equal" << std::endl;
        check_result = false;
      }

    if (is_equal(scratch_data_cpu.ky_quad_points_regular,
                 scratch_data_gpu.ky_quad_points_regular,
                 eps,
                 stream))
      {
        deallog << "ky_quad_points_regular is equal" << std::endl;
      }
    else
      {
        deallog << "ky_quad_points_regular is not equal" << std::endl;
        check_result = false;
      }

    check_result = true;

    return check_result;
  }


  /**
   * Check the equality of @p PairCellWisePerTaskData and @p CUDAPairCellWisePerTaskData.
   *
   * @tparam dim
   * @tparam spacedim
   * @tparam RangeNumberType
   * @param copy_data_cpu
   * @param copy_data_gpu
   * @param stream
   * @return
   */
  template <int dim, int spacedim, typename RangeNumberType = double>
  bool
  is_equal(
    const PairCellWisePerTaskData<dim, spacedim, RangeNumberType>
                                                             &copy_data_cpu,
    const IdeoBEM::CUDAWrappers::CUDAPairCellWisePerTaskData &copy_data_gpu,
    const cudaStream_t                                        stream)
  {
    LogStream::Prefix prefix_string("Check CopyData");

    if (is_equal(copy_data_cpu.kx_local_dof_indices_permuted,
                 copy_data_gpu.kx_local_dof_indices_permuted,
                 stream))
      {
        deallog << "kx_local_dof_indices_permuted is equal" << std::endl;
      }
    else
      {
        deallog << "kx_local_dof_indices_permuted is not equal" << std::endl;
        return false;
      }

    if (is_equal(copy_data_cpu.ky_local_dof_indices_permuted,
                 copy_data_gpu.ky_local_dof_indices_permuted,
                 stream))
      {
        deallog << "ky_local_dof_indices_permuted is equal" << std::endl;
      }
    else
      {
        deallog << "ky_local_dof_indices_permuted is not equal" << std::endl;
        return false;
      }

    return true;
  }
} // namespace IdeoBEM
#endif /* INCLUDE_DEBUG_TOOLS_HCU_ */
