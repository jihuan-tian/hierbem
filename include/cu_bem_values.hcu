/**
 * @file cu_bem_values.hcu
 * @brief Introduction of cu_bem_values.hcu
 *
 * @date 2023-01-29
 * @author Jihuan Tian
 */
#ifndef INCLUDE_CU_BEM_VALUES_HCU_
#define INCLUDE_CU_BEM_VALUES_HCU_

#include <deal.II/base/point.h>
#include <deal.II/base/tensor.h>
#include <deal.II/base/utilities.h>

#include "bem_values.h"
#include "cu_qgauss.hcu"
#include "cu_table.hcu"
#include "cu_table_indices.hcu"
#include "cu_vector.hcu"

namespace HierBEM
{
  using namespace dealii;
  using namespace BEMTools;

  namespace CUDAWrappers
  {
    /**
     * Perform memory copy for shape gradient matrix from host to device.
     *
     * \alert{The data on the host are not continuous, since the memory of each
     * matrix in the table is independently allocated,  while those on the
     * device are continuous.}
     *
     * \mynote{The memory address of the first element in a matrix is acquired
     * by first getting the iterator to the first matrix entry then getting its
     * references. For example, <tt>&(table_cpu(k, q).begin()->value()</tt>.}
     *
     * @tparam RangeNumberType
     * @param table_gpu
     * @param table_cpu
     */
    template <typename RangeNumberType = double>
    void
    shape_grad_matrix_table_assign_from_host(
      CUDATable<4, RangeNumberType>                        &table_gpu,
      const Table<2, LAPACKFullMatrixExt<RangeNumberType>> &table_cpu)
    {
      const unsigned int n_elements_in_grad_matrix =
        table_cpu(0, 0).m() * table_cpu(0, 0).n();

      // Get table sizes.
      const unsigned int k3_terms = table_cpu.n_rows();
      const unsigned int quad_num = table_cpu.n_cols();

      for (unsigned int k = 0; k < k3_terms; k++)
        {
          for (unsigned int q = 0; q < quad_num; q++)
            {
              // Calculate the offset address in the table on the device.
              std::size_t offset =
                (k * quad_num + q) * n_elements_in_grad_matrix;
              table_gpu.assign_from_host(&(table_cpu(k, q).begin()->value()),
                                         offset,
                                         n_elements_in_grad_matrix);
            }
        }
    }

    /**
     * @brief Perform memory copy for shape gradient matrix from host to device.
     *
     * \alert{The data on the host are not continuous, since the memory of each
     * matrix in the table is independently allocated,  while those on the
     * device are continuous.}
     *
     * \mynote{The memory address of the first element in a matrix is acquired
     * by first getting the iterator to the first matrix entry then getting its
     * references. For example, <tt>&(table_cpu(k, q).begin()->value()</tt>.}
     *
     * @tparam RangeNumberType
     * @param table_gpu
     * @param table_cpu
     * @param max_mapping_n_shape_function
     */
    template <typename RangeNumberType = double>
    void
    mapping_shape_grad_matrix_table_assign_from_host(
      CUDATable<4, RangeNumberType>                        &table_gpu,
      const Table<3, LAPACKFullMatrixExt<RangeNumberType>> &table_cpu,
      const unsigned int max_mapping_n_shape_function)
    {
      // Get the sizes of table dimensions.
      const unsigned int mapping_num = table_cpu.size(0);
      const unsigned int k3_terms    = table_cpu.size(1);
      const unsigned int quad_num    = table_cpu.size(2);
      const unsigned int dim         = table_cpu(0, 0, 0).n();
      // The gradient matrix should have 2 columns.
      AssertDimension(dim, 2);

      // The space on GPU reserved for the gradient matrix, which can hold the
      // data for the highest order mapping.
      const unsigned int reserved_elements_for_grad_matrix_gpu =
        max_mapping_n_shape_function * dim;

      for (unsigned int m = 0; m < mapping_num; m++)
        {
          // All gradient matrices should have @p dim columns.
          AssertDimension(dim, table_cpu(m, 0, 0).n());

          // Get the gradient matrix size on CPU.
          const unsigned int n_elements_in_grad_matrix_cpu =
            table_cpu(m, 0, 0).m() * table_cpu(m, 0, 0).n();

          Assert(reserved_elements_for_grad_matrix_gpu >=
                   n_elements_in_grad_matrix_cpu,
                 ExcInternalError());

          for (unsigned int k = 0; k < k3_terms; k++)
            {
              for (unsigned int q = 0; q < quad_num; q++)
                {
                  // Calculate the offset address in the table on the device.
                  std::size_t offset = ((m * k3_terms + k) * quad_num + q) *
                                       reserved_elements_for_grad_matrix_gpu;
                  table_gpu.assign_from_host(
                    &(table_cpu(m, k, q).begin()->value()),
                    offset,
                    n_elements_in_grad_matrix_cpu);
                }
            }
        }
    }


    template <int dim, int spacedim, typename RangeNumberType = double>
    class CUDABEMValues
    {
    public:
      using value_type = RangeNumberType;
      using size_type  = std::size_t;

      /**
       * Allocate global memory on the device and assign data from @p BEMValues
       * on the host.
       *
       * @param bem_values_cpu
       */
      __host__ void
      allocate_and_assign_from_host(
        const BEMValues<dim, spacedim, RangeNumberType> &bem_values_cpu);

      /**
       * Release the allocated global memory on the device.
       */
      __host__ void
      release();

      /**
       * Reference to 4D Sauter quadrature rule for the case that \f$K_x \equiv
       * K_y\f$.
       */
      CUDAQGauss<dim * 2> quad_rule_for_same_panel;
      /**
       * Reference to 4D Sauter quadrature rule for the case that \f$K_x\f$ and
       * \f$K_y\f$ share a common edge.
       */
      CUDAQGauss<dim * 2> quad_rule_for_common_edge;
      /**
       * Reference to 4D Sauter quadrature rule for the case that \f$K_x\f$ and
       * \f$K_y\f$ share a common vertex.
       */
      CUDAQGauss<dim * 2> quad_rule_for_common_vertex;
      /**
       * Reference to 4D Sauter quadrature rule for the case that \f$K_x\f$ and
       * \f$K_y\f$ are separated.
       */
      CUDAQGauss<dim * 2> quad_rule_for_regular;

      /**
       * Data table of finite element shape function values for \f$K_x\f$ in the
       * same panel case. It has three dimensions:
       * 1. shape function index: size=@p dofs_per_cell
       * 2. \f$k_3\f$ term index: size=8
       * 3. Quadrature point index: size=number of quadrature points
       */
      CUDATable<3, RangeNumberType> kx_shape_value_table_for_same_panel;
      /**
       * Data table of finite element shape function values for \f$K_y\f$ in the
       * same panel case. It has three dimensions:
       * 1. shape function index: size=@p dofs_per_cell
       * 2. \f$k_3\f$ term index: size=8
       * 3. Quadrature point index: size=number of quadrature points
       */
      CUDATable<3, RangeNumberType> ky_shape_value_table_for_same_panel;
      /**
       * Data table of finite element shape function values for \f$K_x\f$ in the
       * common edge case. It has three dimensions:
       * 1. shape function index: size=@p dofs_per_cell
       * 2. \f$k_3\f$ term index: size=6
       * 3. Quadrature point index: size=number of quadrature points
       */
      CUDATable<3, RangeNumberType> kx_shape_value_table_for_common_edge;
      /**
       * Data table of finite element shape function values for \f$K_y\f$ in the
       * common edge case. It has three dimensions:
       * 1. shape function index: size=@p dofs_per_cell
       * 2. \f$k_3\f$ term index: size=6
       * 3. Quadrature point index: size=number of quadrature points
       */
      CUDATable<3, RangeNumberType> ky_shape_value_table_for_common_edge;
      /**
       * Data table of finite element shape function values for \f$K_x\f$ in the
       * common vertex case. It has three dimensions:
       * 1. shape function index: size=@p dofs_per_cell
       * 2. \f$k_3\f$ term index: size=4
       * 3. Quadrature point index: size=number of quadrature points
       */
      CUDATable<3, RangeNumberType> kx_shape_value_table_for_common_vertex;
      /**
       * Data table of finite element shape function values for \f$K_y\f$ in the
       * common vertex case. It has three dimensions:
       * 1. shape function index: size=@p dofs_per_cell
       * 2. \f$k_3\f$ term index: size=4
       * 3. Quadrature point index: size=number of quadrature points
       */
      CUDATable<3, RangeNumberType> ky_shape_value_table_for_common_vertex;
      /**
       * Data table of finite element shape function values for \f$K_x\f$ in the
       * regular case. It has three dimensions:
       * 1. shape function index: size=@p dofs_per_cell
       * 2. \f$k_3\f$ term index: size=1
       * 3. Quadrature point index: size=number of quadrature points
       */
      CUDATable<3, RangeNumberType> kx_shape_value_table_for_regular;
      /**
       * Data table of finite element shape function values for \f$K_y\f$ in the
       * regular case. It has three dimensions:
       * 1. shape function index: size=@p dofs_per_cell
       * 2. \f$k_3\f$ term index: size=1
       * 3. Quadrature point index: size=number of quadrature points
       */
      CUDATable<3, RangeNumberType> ky_shape_value_table_for_regular;

      /**
       * Data table of mapping shape function values for \f$K_x\f$ in the
       * same panel case. It has 4 dimensions:
       * 1. Mapping index, which is mapping order minus 1. It is used to get the
       * corresponding pointer to the MappingInfo object in BEMValues::mappings.
       * 2. shape function index: size=number of shape functions in the highest
       * order mapping object
       * 3. \f$k_3\f$ term index: size=8
       * 4. Quadrature point index: size=number of quadrature points
       */
      CUDATable<4, RangeNumberType> kx_mapping_shape_value_table_for_same_panel;
      /**
       * Data table of mapping shape function values for \f$K_y\f$ in the
       * same panel case. It has 4 dimensions:
       * 1. Mapping index, which is mapping order minus 1. It is used to get the
       * corresponding pointer to the MappingInfo object in BEMValues::mappings.
       * 2. shape function index: size=number of shape functions in the highest
       * order mapping object
       * 3. \f$k_3\f$ term index: size=8
       * 4. Quadrature point index: size=number of quadrature points
       */
      CUDATable<4, RangeNumberType> ky_mapping_shape_value_table_for_same_panel;
      /**
       * Data table of mapping shape function values for \f$K_x\f$ in the
       * common edge case. It has 4 dimensions:
       * 1. Mapping index, which is mapping order minus 1. It is used to get the
       * corresponding pointer to the MappingInfo object in BEMValues::mappings.
       * 2. shape function index: size=number of shape functions in the
       * highest order mapping object
       * 3. \f$k_3\f$ term index: size=6
       * 4. Quadrature point index: size=number of quadrature points
       */
      CUDATable<4, RangeNumberType>
        kx_mapping_shape_value_table_for_common_edge;
      /**
       * Data table of mapping shape function values for \f$K_y\f$ in the
       * common edge case. It has 4 dimensions:
       * 1. Mapping index, which is mapping order minus 1. It is used to get the
       * corresponding pointer to the MappingInfo object in BEMValues::mappings.
       * 2. shape function index: size=number of shape functions in the
       * highest order mapping object
       * 3. \f$k_3\f$ term index: size=6
       * 4. Quadrature point index: size=number of quadrature points
       */
      CUDATable<4, RangeNumberType>
        ky_mapping_shape_value_table_for_common_edge;
      /**
       * Data table of mapping shape function values for \f$K_x\f$ in the
       * common vertex case. It has 4 dimensions:
       * 1. Mapping index, which is mapping order minus 1. It is used to get the
       * corresponding pointer to the MappingInfo object in BEMValues::mappings.
       * 2. shape function index: size=number of shape functions in the
       * highest order mapping object
       * 3. \f$k_3\f$ term index: size=4
       * 4. Quadrature point index: size=number of quadrature points
       */
      CUDATable<4, RangeNumberType>
        kx_mapping_shape_value_table_for_common_vertex;
      /**
       * Data table of mapping shape function values for \f$K_y\f$ in the
       * common vertex case. It has 4 dimensions:
       * 1. Mapping index, which is mapping order minus 1. It is used to get the
       * corresponding pointer to the MappingInfo object in BEMValues::mappings.
       * 2. shape function index: size=number of shape functions in the
       * highest order mapping object
       * 3. \f$k_3\f$ term index: size=4
       * 4. Quadrature point index: size=number of quadrature points
       */
      CUDATable<4, RangeNumberType>
        ky_mapping_shape_value_table_for_common_vertex;
      /**
       * Data table of mapping shape function values for \f$K_x\f$ in the
       * regular case. It has 4 dimensions:
       * 1. Mapping index, which is mapping order minus 1. It is used to get the
       * corresponding pointer to the MappingInfo object in BEMValues::mappings.
       * 2. shape function index: size=number of shape functions in the
       * highest order mapping object
       * 3. \f$k_3\f$ term index: size=1
       * 4. Quadrature point index: size=number of quadrature points
       */
      CUDATable<4, RangeNumberType> kx_mapping_shape_value_table_for_regular;
      /**
       * Data table of mapping shape function values for \f$K_y\f$ in the
       * regular case. It has 4 dimensions:
       * 11. Mapping index, which is mapping order minus 1. It is used to get
       * the corresponding pointer to the MappingInfo object in
       * BEMValues::mappings.
       * 2. shape function index: size=number of shape functions in the
       * highest order mapping object
       * 3. \f$k_3\f$ term index: size=1
       * 4. Quadrature point index: size=number of quadrature points
       */
      CUDATable<4, RangeNumberType> ky_mapping_shape_value_table_for_regular;

      /**
       * Data table of finite element shape function's gradient values for
       * \f$K_x\f$ in the same panel case. It has four dimensions:
       * 1. \f$k_3\f$ term index: size=8
       * 2. Quadrature point index: size=number of quadrature points
       * 3. Coordinate component index in the unit cell
       * 4. Shape function index: size=@p dofs_per_cell
       */
      CUDATable<4, RangeNumberType> kx_shape_grad_matrix_table_for_same_panel;
      /**
       * Data table of finite element shape function's gradient values for
       * \f$K_y\f$ in the same panel case. It has four dimensions:
       * 1. \f$k_3\f$ term index: size=8
       * 2. Quadrature point index: size=number of quadrature points
       * 3. Coordinate component index in the unit cell
       * 4. Shape function index: size=@p dofs_per_cell
       */
      CUDATable<4, RangeNumberType> ky_shape_grad_matrix_table_for_same_panel;
      /**
       * Data table of finite element shape function's gradient values for
       * \f$K_x\f$ in the common edge case. It has four dimensions:
       * 1. \f$k_3\f$ term index: size=8
       * 2. Quadrature point index: size=number of quadrature points
       * 3. Coordinate component index in the unit cell
       * 4. Shape function index: size=@p dofs_per_cell
       */
      CUDATable<4, RangeNumberType> kx_shape_grad_matrix_table_for_common_edge;
      /**
       * Data table of finite element shape function's gradient values for
       * \f$K_y\f$ in the common edge case. It has four dimensions:
       * 1. \f$k_3\f$ term index: size=8
       * 2. Quadrature point index: size=number of quadrature points
       * 3. Coordinate component index in the unit cell
       * 4. Shape function index: size=@p dofs_per_cell
       */
      CUDATable<4, RangeNumberType> ky_shape_grad_matrix_table_for_common_edge;
      /**
       * Data table of finite element shape function's gradient values for
       * \f$K_x\f$ in the common vertex case. It has four dimensions:
       * 1. \f$k_3\f$ term index: size=8
       * 2. Quadrature point index: size=number of quadrature points
       * 3. Coordinate component index in the unit cell
       * 4. Shape function index: size=@p dofs_per_cell
       */
      CUDATable<4, RangeNumberType>
        kx_shape_grad_matrix_table_for_common_vertex;
      /**
       * Data table of finite element shape function's gradient values for
       * \f$K_y\f$ in the common vertex case. It has four dimensions:
       * 1. \f$k_3\f$ term index: size=8
       * 2. Quadrature point index: size=number of quadrature points
       * 3. Coordinate component index in the unit cell
       * 4. Shape function index: size=@p dofs_per_cell
       */
      CUDATable<4, RangeNumberType>
        ky_shape_grad_matrix_table_for_common_vertex;
      /**
       * Data table of finite element shape function's gradient values for
       * \f$K_x\f$ in the regular case. It has four dimensions:
       * 1. \f$k_3\f$ term index: size=8
       * 2. Quadrature point index: size=number of quadrature points
       * 3. Coordinate component index in the unit cell
       * 4. Shape function index: size=@p dofs_per_cell
       */
      CUDATable<4, RangeNumberType> kx_shape_grad_matrix_table_for_regular;
      /**
       * Data table of finite element shape function's gradient values for
       * \f$K_y\f$ in the regular case. It has four dimensions:
       * 1. \f$k_3\f$ term index: size=8
       * 2. Quadrature point index: size=number of quadrature points
       * 3. Coordinate component index in the unit cell
       * 4. Shape function index: size=@p dofs_per_cell
       */
      CUDATable<4, RangeNumberType> ky_shape_grad_matrix_table_for_regular;

      /**
       * Data table of mapping shape function's gradient values for
       * \f$K_x\f$ in the same panel case. It has 5 dimensions:
       * 1. Mapping index, which is mapping order minus 1. It is used to get the
       * corresponding pointer to the MappingInfo object in BEMValues::mappings.
       * 2. \f$k_3\f$ term index: size=8
       * 3. Quadrature point index: size=number of quadrature points
       * 4. Gradient matrix element index in column major. The total number of
       * elements is (number of shape functions in the highest order mapping
       * object)*dim.
       */
      CUDATable<4, RangeNumberType>
        kx_mapping_shape_grad_matrix_table_for_same_panel;
      /**
       * Data table of mapping shape function's gradient values for
       * \f$K_y\f$ in the same panel case. It has 5 dimensions:
       * 1. Mapping index, which is mapping order minus 1. It is used to get the
       * corresponding pointer to the MappingInfo object in BEMValues::mappings.
       * 2. \f$k_3\f$ term index: size=8
       * 3. Quadrature point index: size=number of quadrature points
       * 4. Gradient matrix element index in column major. The total number of
       * elements is (number of shape functions in the highest order mapping
       * object)*dim.
       */
      CUDATable<4, RangeNumberType>
        ky_mapping_shape_grad_matrix_table_for_same_panel;
      /**
       * Data table of mapping shape function's gradient values for
       * \f$K_x\f$ in the common edge case. It has 5 dimensions:
       * 1. Mapping index, which is mapping order minus 1. It is used to get the
       * corresponding pointer to the MappingInfo object in BEMValues::mappings.
       * 2. \f$k_3\f$ term index: size=6
       * 3. Quadrature point index: size=number of quadrature points
       * 4. Gradient matrix element index in column major. The total number of
       * elements is (number of shape functions in the highest order mapping
       * object)*dim.
       */
      CUDATable<4, RangeNumberType>
        kx_mapping_shape_grad_matrix_table_for_common_edge;
      /**
       * Data table of mapping shape function's gradient values for
       * \f$K_y\f$ in the common edge case. It has 5 dimensions:
       * 1. Mapping index, which is mapping order minus 1. It is used to get the
       * corresponding pointer to the MappingInfo object in BEMValues::mappings.
       * 2. \f$k_3\f$ term index: size=6
       * 3. Quadrature point index: size=number of quadrature points
       * 4. Gradient matrix element index in column major. The total number of
       * elements is (number of shape functions in the highest order mapping
       * object)*dim.
       */
      CUDATable<4, RangeNumberType>
        ky_mapping_shape_grad_matrix_table_for_common_edge;
      /**
       * Data table of mapping shape function's gradient values for
       * \f$K_x\f$ in the common vertex case. It has 5 dimensions:
       * 1. Mapping index, which is mapping order minus 1. It is used to get the
       * corresponding pointer to the MappingInfo object in BEMValues::mappings.
       * 2. \f$k_3\f$ term index: size=4
       * 3. Quadrature point index: size=number of quadrature points
       * 4. Gradient matrix element index in column major. The total number of
       * elements is (number of shape functions in the highest order mapping
       * object)*dim.
       */
      CUDATable<4, RangeNumberType>
        kx_mapping_shape_grad_matrix_table_for_common_vertex;
      /**
       * Data table of mapping shape function's gradient values for
       * \f$K_y\f$ in the common vertex case. It has 5 dimensions:
       * 1. Mapping index, which is mapping order minus 1. It is used to get the
       * corresponding pointer to the MappingInfo object in BEMValues::mappings.
       * 2. \f$k_3\f$ term index: size=4
       * 3. Quadrature point index: size=number of quadrature points
       * 4. Gradient matrix element index in column major. The total number of
       * elements is (number of shape functions in the highest order mapping
       * object)*dim.
       */
      CUDATable<4, RangeNumberType>
        ky_mapping_shape_grad_matrix_table_for_common_vertex;
      /**
       * Data table of mapping shape function's gradient values for
       * \f$K_x\f$ in the regular case. It has 5 dimensions:
       * 1. Mapping index, which is mapping order minus 1. It is used to get the
       * corresponding pointer to the MappingInfo object in BEMValues::mappings.
       * 2. \f$k_3\f$ term index: size=1
       * 3. Quadrature point index: size=number of quadrature points
       * 4. Gradient matrix element index in column major. The total number of
       * elements is (number of shape functions in the highest order mapping
       * object)*dim.
       */
      CUDATable<4, RangeNumberType>
        kx_mapping_shape_grad_matrix_table_for_regular;
      /**
       * Data table of mapping shape function's gradient values for
       * \f$K_y\f$ in the regular case. It has 5 dimensions:
       * 1. Mapping index, which is mapping order minus 1. It is used to get the
       * corresponding pointer to the MappingInfo object in BEMValues::mappings.
       * 2. \f$k_3\f$ term index: size=1
       * 3. Quadrature point index: size=number of quadrature points
       * 4. Gradient matrix element index in column major. The total number of
       * elements is (number of shape functions in the highest order mapping
       * object)*dim.
       */
      CUDATable<4, RangeNumberType>
        ky_mapping_shape_grad_matrix_table_for_regular;

    protected:
      __host__ void
      init_quadrature_rules(
        const BEMValues<dim, spacedim, RangeNumberType> &bem_values_cpu);

      __host__ void
      init_shape_value_tables(
        const BEMValues<dim, spacedim, RangeNumberType> &bem_values_cpu);

      __host__ void
      init_mapping_shape_value_tables(
        const BEMValues<dim, spacedim, RangeNumberType> &bem_values_cpu);

      __host__ void
      init_shape_grad_matrix_tables(
        const BEMValues<dim, spacedim, RangeNumberType> &bem_values_cpu);

      __host__ void
      init_mapping_shape_grad_matrix_tables(
        const BEMValues<dim, spacedim, RangeNumberType> &bem_values_cpu);
    };


    template <int dim, int spacedim, typename RangeNumberType>
    __host__ void
    CUDABEMValues<dim, spacedim, RangeNumberType>::
      allocate_and_assign_from_host(
        const BEMValues<dim, spacedim, RangeNumberType> &bem_values_cpu)
    {
      init_quadrature_rules(bem_values_cpu);
      init_shape_value_tables(bem_values_cpu);
      init_mapping_shape_value_tables(bem_values_cpu);
      init_shape_grad_matrix_tables(bem_values_cpu);
      init_mapping_shape_grad_matrix_tables(bem_values_cpu);
    }


    template <int dim, int spacedim, typename RangeNumberType>
    __host__ void
    CUDABEMValues<dim, spacedim, RangeNumberType>::init_quadrature_rules(
      const BEMValues<dim, spacedim, RangeNumberType> &bem_values_cpu)
    {
      quad_rule_for_same_panel.allocate(
        bem_values_cpu.quad_rule_for_same_panel.size());
      quad_rule_for_common_edge.allocate(
        bem_values_cpu.quad_rule_for_common_edge.size());
      quad_rule_for_common_vertex.allocate(
        bem_values_cpu.quad_rule_for_common_vertex.size());
      quad_rule_for_regular.allocate(
        bem_values_cpu.quad_rule_for_regular.size());

      quad_rule_for_same_panel.assign_from_host(
        bem_values_cpu.quad_rule_for_same_panel);
      quad_rule_for_common_edge.assign_from_host(
        bem_values_cpu.quad_rule_for_common_edge);
      quad_rule_for_common_vertex.assign_from_host(
        bem_values_cpu.quad_rule_for_common_vertex);
      quad_rule_for_regular.assign_from_host(
        bem_values_cpu.quad_rule_for_regular);
    }


    template <int dim, int spacedim, typename RangeNumberType>
    __host__ void
    CUDABEMValues<dim, spacedim, RangeNumberType>::init_shape_value_tables(
      const BEMValues<dim, spacedim, RangeNumberType> &bem_values_cpu)
    {
      kx_shape_value_table_for_same_panel.allocate(
        TableIndices<3>(bem_values_cpu.kx_fe.dofs_per_cell,
                        8,
                        bem_values_cpu.quad_rule_for_same_panel.size()));
      ky_shape_value_table_for_same_panel.allocate(
        TableIndices<3>(bem_values_cpu.ky_fe.dofs_per_cell,
                        8,
                        bem_values_cpu.quad_rule_for_same_panel.size()));

      kx_shape_value_table_for_common_edge.allocate(
        TableIndices<3>(bem_values_cpu.kx_fe.dofs_per_cell,
                        6,
                        bem_values_cpu.quad_rule_for_common_edge.size()));
      ky_shape_value_table_for_common_edge.allocate(
        TableIndices<3>(bem_values_cpu.ky_fe.dofs_per_cell,
                        6,
                        bem_values_cpu.quad_rule_for_common_edge.size()));

      kx_shape_value_table_for_common_vertex.allocate(
        TableIndices<3>(bem_values_cpu.kx_fe.dofs_per_cell,
                        4,
                        bem_values_cpu.quad_rule_for_common_vertex.size()));
      ky_shape_value_table_for_common_vertex.allocate(
        TableIndices<3>(bem_values_cpu.ky_fe.dofs_per_cell,
                        4,
                        bem_values_cpu.quad_rule_for_common_vertex.size()));

      kx_shape_value_table_for_regular.allocate(
        TableIndices<3>(bem_values_cpu.kx_fe.dofs_per_cell,
                        1,
                        bem_values_cpu.quad_rule_for_regular.size()));
      ky_shape_value_table_for_regular.allocate(
        TableIndices<3>(bem_values_cpu.ky_fe.dofs_per_cell,
                        1,
                        bem_values_cpu.quad_rule_for_regular.size()));

      kx_shape_value_table_for_same_panel.assign_from_host(
        bem_values_cpu.kx_shape_value_table_for_same_panel);
      ky_shape_value_table_for_same_panel.assign_from_host(
        bem_values_cpu.ky_shape_value_table_for_same_panel);

      kx_shape_value_table_for_common_edge.assign_from_host(
        bem_values_cpu.kx_shape_value_table_for_common_edge);
      ky_shape_value_table_for_common_edge.assign_from_host(
        bem_values_cpu.ky_shape_value_table_for_common_edge);

      kx_shape_value_table_for_common_vertex.assign_from_host(
        bem_values_cpu.kx_shape_value_table_for_common_vertex);
      ky_shape_value_table_for_common_vertex.assign_from_host(
        bem_values_cpu.ky_shape_value_table_for_common_vertex);

      kx_shape_value_table_for_regular.assign_from_host(
        bem_values_cpu.kx_shape_value_table_for_regular);
      ky_shape_value_table_for_regular.assign_from_host(
        bem_values_cpu.ky_shape_value_table_for_regular);
    }


    template <int dim, int spacedim, typename RangeNumberType>
    __host__ void
    CUDABEMValues<dim, spacedim, RangeNumberType>::
      init_mapping_shape_value_tables(
        const BEMValues<dim, spacedim, RangeNumberType> &bem_values_cpu)
    {
      const unsigned int max_mapping_n_shape_functions =
        bem_values_cpu.mappings.back()->get_data()->n_shape_functions;

      kx_mapping_shape_value_table_for_same_panel.allocate(
        TableIndices<4>(bem_values_cpu.mappings.size(),
                        max_mapping_n_shape_functions,
                        8,
                        bem_values_cpu.quad_rule_for_same_panel.size()));
      ky_mapping_shape_value_table_for_same_panel.allocate(
        TableIndices<4>(bem_values_cpu.mappings.size(),
                        max_mapping_n_shape_functions,
                        8,
                        bem_values_cpu.quad_rule_for_same_panel.size()));

      kx_mapping_shape_value_table_for_common_edge.allocate(
        TableIndices<4>(bem_values_cpu.mappings.size(),
                        max_mapping_n_shape_functions,
                        6,
                        bem_values_cpu.quad_rule_for_common_edge.size()));
      ky_mapping_shape_value_table_for_common_edge.allocate(
        TableIndices<4>(bem_values_cpu.mappings.size(),
                        max_mapping_n_shape_functions,
                        6,
                        bem_values_cpu.quad_rule_for_common_edge.size()));

      kx_mapping_shape_value_table_for_common_vertex.allocate(
        TableIndices<4>(bem_values_cpu.mappings.size(),
                        max_mapping_n_shape_functions,
                        4,
                        bem_values_cpu.quad_rule_for_common_vertex.size()));
      ky_mapping_shape_value_table_for_common_vertex.allocate(
        TableIndices<4>(bem_values_cpu.mappings.size(),
                        max_mapping_n_shape_functions,
                        4,
                        bem_values_cpu.quad_rule_for_common_vertex.size()));

      kx_mapping_shape_value_table_for_regular.allocate(
        TableIndices<4>(bem_values_cpu.mappings.size(),
                        max_mapping_n_shape_functions,
                        1,
                        bem_values_cpu.quad_rule_for_regular.size()));
      ky_mapping_shape_value_table_for_regular.allocate(
        TableIndices<4>(bem_values_cpu.mappings.size(),
                        max_mapping_n_shape_functions,
                        1,
                        bem_values_cpu.quad_rule_for_regular.size()));

      kx_mapping_shape_value_table_for_same_panel.assign_from_host(
        bem_values_cpu.kx_mapping_shape_value_table_for_same_panel);
      ky_mapping_shape_value_table_for_same_panel.assign_from_host(
        bem_values_cpu.ky_mapping_shape_value_table_for_same_panel);

      kx_mapping_shape_value_table_for_common_edge.assign_from_host(
        bem_values_cpu.kx_mapping_shape_value_table_for_common_edge);
      ky_mapping_shape_value_table_for_common_edge.assign_from_host(
        bem_values_cpu.ky_mapping_shape_value_table_for_common_edge);

      kx_mapping_shape_value_table_for_common_vertex.assign_from_host(
        bem_values_cpu.kx_mapping_shape_value_table_for_common_vertex);
      ky_mapping_shape_value_table_for_common_vertex.assign_from_host(
        bem_values_cpu.ky_mapping_shape_value_table_for_common_vertex);

      kx_mapping_shape_value_table_for_regular.assign_from_host(
        bem_values_cpu.kx_mapping_shape_value_table_for_regular);
      ky_mapping_shape_value_table_for_regular.assign_from_host(
        bem_values_cpu.ky_mapping_shape_value_table_for_regular);
    }


    template <int dim, int spacedim, typename RangeNumberType>
    __host__ void
    CUDABEMValues<dim, spacedim, RangeNumberType>::
      init_shape_grad_matrix_tables(
        const BEMValues<dim, spacedim, RangeNumberType> &bem_values_cpu)
    {
      kx_shape_grad_matrix_table_for_same_panel.allocate(
        TableIndices<4>(8,
                        bem_values_cpu.quad_rule_for_same_panel.size(),
                        dim,
                        bem_values_cpu.kx_fe.dofs_per_cell));
      ky_shape_grad_matrix_table_for_same_panel.allocate(
        TableIndices<4>(8,
                        bem_values_cpu.quad_rule_for_same_panel.size(),
                        dim,
                        bem_values_cpu.ky_fe.dofs_per_cell));

      kx_shape_grad_matrix_table_for_common_edge.allocate(
        TableIndices<4>(6,
                        bem_values_cpu.quad_rule_for_common_edge.size(),
                        dim,
                        bem_values_cpu.kx_fe.dofs_per_cell));
      ky_shape_grad_matrix_table_for_common_edge.allocate(
        TableIndices<4>(6,
                        bem_values_cpu.quad_rule_for_common_edge.size(),
                        dim,
                        bem_values_cpu.ky_fe.dofs_per_cell));

      kx_shape_grad_matrix_table_for_common_vertex.allocate(
        TableIndices<4>(4,
                        bem_values_cpu.quad_rule_for_common_vertex.size(),
                        dim,
                        bem_values_cpu.kx_fe.dofs_per_cell));
      ky_shape_grad_matrix_table_for_common_vertex.allocate(
        TableIndices<4>(4,
                        bem_values_cpu.quad_rule_for_common_vertex.size(),
                        dim,
                        bem_values_cpu.ky_fe.dofs_per_cell));

      kx_shape_grad_matrix_table_for_regular.allocate(
        TableIndices<4>(1,
                        bem_values_cpu.quad_rule_for_regular.size(),
                        dim,
                        bem_values_cpu.kx_fe.dofs_per_cell));
      ky_shape_grad_matrix_table_for_regular.allocate(
        TableIndices<4>(1,
                        bem_values_cpu.quad_rule_for_regular.size(),
                        dim,
                        bem_values_cpu.ky_fe.dofs_per_cell));

      shape_grad_matrix_table_assign_from_host(
        kx_shape_grad_matrix_table_for_same_panel,
        bem_values_cpu.kx_shape_grad_matrix_table_for_same_panel);
      shape_grad_matrix_table_assign_from_host(
        ky_shape_grad_matrix_table_for_same_panel,
        bem_values_cpu.ky_shape_grad_matrix_table_for_same_panel);

      shape_grad_matrix_table_assign_from_host(
        kx_shape_grad_matrix_table_for_common_edge,
        bem_values_cpu.kx_shape_grad_matrix_table_for_common_edge);
      shape_grad_matrix_table_assign_from_host(
        ky_shape_grad_matrix_table_for_common_edge,
        bem_values_cpu.ky_shape_grad_matrix_table_for_common_edge);

      shape_grad_matrix_table_assign_from_host(
        kx_shape_grad_matrix_table_for_common_vertex,
        bem_values_cpu.kx_shape_grad_matrix_table_for_common_vertex);
      shape_grad_matrix_table_assign_from_host(
        ky_shape_grad_matrix_table_for_common_vertex,
        bem_values_cpu.ky_shape_grad_matrix_table_for_common_vertex);

      shape_grad_matrix_table_assign_from_host(
        kx_shape_grad_matrix_table_for_regular,
        bem_values_cpu.kx_shape_grad_matrix_table_for_regular);
      shape_grad_matrix_table_assign_from_host(
        ky_shape_grad_matrix_table_for_regular,
        bem_values_cpu.ky_shape_grad_matrix_table_for_regular);
    }


    template <int dim, int spacedim, typename RangeNumberType>
    __host__ void
    CUDABEMValues<dim, spacedim, RangeNumberType>::
      init_mapping_shape_grad_matrix_tables(
        const BEMValues<dim, spacedim, RangeNumberType> &bem_values_cpu)
    {
      const unsigned int max_mapping_n_shape_functions =
        bem_values_cpu.mappings.back()->get_data()->n_shape_functions;

      kx_mapping_shape_grad_matrix_table_for_same_panel.allocate(
        TableIndices<4>(bem_values_cpu.mappings.size(),
                        8,
                        bem_values_cpu.quad_rule_for_same_panel.size(),
                        dim * max_mapping_n_shape_functions));
      ky_mapping_shape_grad_matrix_table_for_same_panel.allocate(
        TableIndices<4>(bem_values_cpu.mappings.size(),
                        8,
                        bem_values_cpu.quad_rule_for_same_panel.size(),
                        dim * max_mapping_n_shape_functions));

      kx_mapping_shape_grad_matrix_table_for_common_edge.allocate(
        TableIndices<4>(bem_values_cpu.mappings.size(),
                        6,
                        bem_values_cpu.quad_rule_for_common_edge.size(),
                        dim * max_mapping_n_shape_functions));
      ky_mapping_shape_grad_matrix_table_for_common_edge.allocate(
        TableIndices<4>(bem_values_cpu.mappings.size(),
                        6,
                        bem_values_cpu.quad_rule_for_common_edge.size(),
                        dim * max_mapping_n_shape_functions));

      kx_mapping_shape_grad_matrix_table_for_common_vertex.allocate(
        TableIndices<4>(bem_values_cpu.mappings.size(),
                        4,
                        bem_values_cpu.quad_rule_for_common_vertex.size(),
                        dim * max_mapping_n_shape_functions));
      ky_mapping_shape_grad_matrix_table_for_common_vertex.allocate(
        TableIndices<4>(bem_values_cpu.mappings.size(),
                        4,
                        bem_values_cpu.quad_rule_for_common_vertex.size(),
                        dim * max_mapping_n_shape_functions));

      kx_mapping_shape_grad_matrix_table_for_regular.allocate(
        TableIndices<4>(bem_values_cpu.mappings.size(),
                        1,
                        bem_values_cpu.quad_rule_for_regular.size(),
                        dim * max_mapping_n_shape_functions));
      ky_mapping_shape_grad_matrix_table_for_regular.allocate(
        TableIndices<4>(bem_values_cpu.mappings.size(),
                        1,
                        bem_values_cpu.quad_rule_for_regular.size(),
                        dim * max_mapping_n_shape_functions));

      mapping_shape_grad_matrix_table_assign_from_host(
        kx_mapping_shape_grad_matrix_table_for_same_panel,
        bem_values_cpu.kx_mapping_shape_grad_matrix_table_for_same_panel,
        max_mapping_n_shape_functions);
      mapping_shape_grad_matrix_table_assign_from_host(
        ky_mapping_shape_grad_matrix_table_for_same_panel,
        bem_values_cpu.ky_mapping_shape_grad_matrix_table_for_same_panel,
        max_mapping_n_shape_functions);

      mapping_shape_grad_matrix_table_assign_from_host(
        kx_mapping_shape_grad_matrix_table_for_common_edge,
        bem_values_cpu.kx_mapping_shape_grad_matrix_table_for_common_edge,
        max_mapping_n_shape_functions);
      mapping_shape_grad_matrix_table_assign_from_host(
        ky_mapping_shape_grad_matrix_table_for_common_edge,
        bem_values_cpu.ky_mapping_shape_grad_matrix_table_for_common_edge,
        max_mapping_n_shape_functions);

      mapping_shape_grad_matrix_table_assign_from_host(
        kx_mapping_shape_grad_matrix_table_for_common_vertex,
        bem_values_cpu.kx_mapping_shape_grad_matrix_table_for_common_vertex,
        max_mapping_n_shape_functions);
      mapping_shape_grad_matrix_table_assign_from_host(
        ky_mapping_shape_grad_matrix_table_for_common_vertex,
        bem_values_cpu.ky_mapping_shape_grad_matrix_table_for_common_vertex,
        max_mapping_n_shape_functions);

      mapping_shape_grad_matrix_table_assign_from_host(
        kx_mapping_shape_grad_matrix_table_for_regular,
        bem_values_cpu.kx_mapping_shape_grad_matrix_table_for_regular,
        max_mapping_n_shape_functions);
      mapping_shape_grad_matrix_table_assign_from_host(
        ky_mapping_shape_grad_matrix_table_for_regular,
        bem_values_cpu.ky_mapping_shape_grad_matrix_table_for_regular,
        max_mapping_n_shape_functions);
    }


    template <int dim, int spacedim, typename RangeNumberType>
    __host__ void
    CUDABEMValues<dim, spacedim, RangeNumberType>::release()
    {
      quad_rule_for_same_panel.release();
      quad_rule_for_common_edge.release();
      quad_rule_for_common_vertex.release();
      quad_rule_for_regular.release();

      kx_shape_value_table_for_same_panel.release();
      kx_shape_value_table_for_common_edge.release();
      kx_shape_value_table_for_common_vertex.release();
      kx_shape_value_table_for_regular.release();

      ky_shape_value_table_for_same_panel.release();
      ky_shape_value_table_for_common_edge.release();
      ky_shape_value_table_for_common_vertex.release();
      ky_shape_value_table_for_regular.release();

      kx_mapping_shape_value_table_for_same_panel.release();
      kx_mapping_shape_value_table_for_common_edge.release();
      kx_mapping_shape_value_table_for_common_vertex.release();
      kx_mapping_shape_value_table_for_regular.release();

      ky_mapping_shape_value_table_for_same_panel.release();
      ky_mapping_shape_value_table_for_common_edge.release();
      ky_mapping_shape_value_table_for_common_vertex.release();
      ky_mapping_shape_value_table_for_regular.release();

      kx_shape_grad_matrix_table_for_same_panel.release();
      kx_shape_grad_matrix_table_for_common_edge.release();
      kx_shape_grad_matrix_table_for_common_vertex.release();
      kx_shape_grad_matrix_table_for_regular.release();

      ky_shape_grad_matrix_table_for_same_panel.release();
      ky_shape_grad_matrix_table_for_common_edge.release();
      ky_shape_grad_matrix_table_for_common_vertex.release();
      ky_shape_grad_matrix_table_for_regular.release();

      kx_mapping_shape_grad_matrix_table_for_same_panel.release();
      kx_mapping_shape_grad_matrix_table_for_common_edge.release();
      kx_mapping_shape_grad_matrix_table_for_common_vertex.release();
      kx_mapping_shape_grad_matrix_table_for_regular.release();

      ky_mapping_shape_grad_matrix_table_for_same_panel.release();
      ky_mapping_shape_grad_matrix_table_for_common_edge.release();
      ky_mapping_shape_grad_matrix_table_for_common_vertex.release();
      ky_mapping_shape_grad_matrix_table_for_regular.release();
    }


    template <int dim, int spacedim = dim, typename RangeNumberType = double>
    class CUDAPairCellWiseScratchData
    {
    public:
      using value_type = RangeNumberType;
      using size_type  = std::size_t;

      /**
       * Allocate global memory on the device according to the data size of
       * @p PairCellWiseScratchData on the host.
       *
       * @param bem_values_cpu
       */
      __host__ void
      allocate(const PairCellWiseScratchData<dim, spacedim, RangeNumberType>
                 &scratch_cpu);

      /**
       * Copy some of the calculated data in @p PairCellWiseScratchData on the host to
       * the device.
       *
       * @param scratch_cpu
       */
      __host__ void
      assign_from_host(
        const PairCellWiseScratchData<dim, spacedim, RangeNumberType>
          &scratch_cpu);

      /**
       * Release the allocated global memory on the device.
       */
      __host__ void
      release(const cudaStream_t stream);

      /**
       * Permuted list of mapping support points in the real cell \f$K_x\f$.
       */
      CUDATable<1, Point<spacedim, RangeNumberType>>
        kx_mapping_support_points_permuted;
      /**
       * Permuted list of mapping support points in the real cell \f$K_y\f$.
       */
      CUDATable<1, Point<spacedim, RangeNumberType>>
        ky_mapping_support_points_permuted;

      CUDATable<1, Point<2, RangeNumberType>>
        kx_mapping_support_points_permuted_xy_components;
      CUDATable<1, Point<2, RangeNumberType>>
        kx_mapping_support_points_permuted_yz_components;
      CUDATable<1, Point<2, RangeNumberType>>
        kx_mapping_support_points_permuted_zx_components;

      CUDATable<1, Point<2, RangeNumberType>>
        ky_mapping_support_points_permuted_xy_components;
      CUDATable<1, Point<2, RangeNumberType>>
        ky_mapping_support_points_permuted_yz_components;
      CUDATable<1, Point<2, RangeNumberType>>
        ky_mapping_support_points_permuted_zx_components;

      /**
       * Jacobian from the unit cell to the real cell \f$K_x\f$ for each
       * \f$k_3\f$ term and at each quadrature point for the same panel case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, RangeNumberType> kx_jacobians_same_panel;
      /**
       * Jacobian from the unit cell to the real cell \f$K_x\f$ for each
       * \f$k_3\f$ term and at each quadrature point for the common edge case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, RangeNumberType> kx_jacobians_common_edge;
      /**
       * Jacobian from the unit cell to the real cell \f$K_x\f$ for each
       * \f$k_3\f$ term and at each quadrature point for the common vertex case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, RangeNumberType> kx_jacobians_common_vertex;
      /**
       * Jacobian from the unit cell to the real cell \f$K_x\f$ for each
       * \f$k_3\f$ term and at each quadrature point for the regular case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, RangeNumberType> kx_jacobians_regular;

      /**
       * Normal vector at each quadrature point in the real cell \f$K_x\f$ for
       * the same panel case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, Tensor<1, spacedim, RangeNumberType>> kx_normals_same_panel;
      /**
       * Normal vector at each quadrature point in the real cell \f$K_x\f$ for
       * the common edge case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, Tensor<1, spacedim, RangeNumberType>> kx_normals_common_edge;
      /**
       * Normal vector at each quadrature point in the real cell \f$K_x\f$ for
       * the common vertex case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, Tensor<1, spacedim, RangeNumberType>>
        kx_normals_common_vertex;
      /**
       * Normal vector at each quadrature point in the real cell \f$K_x\f$ for
       * the regular case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, Tensor<1, spacedim, RangeNumberType>> kx_normals_regular;

      /**
       * Covariant transformation matrix (with dimension <tt>spacedim *
       * dim</tt>) for each \f$k_3\f$ term and each quadrature point in the real
       * cell \f$K_x\f$ for the same panel case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       * 3. Unit cell coordinate index
       * 4. Real cell coordinate index
       */
      CUDATable<4, RangeNumberType> kx_covariants_same_panel;
      /**
       * Covariant transformation matrix (with dimension <tt>spacedim *
       * dim</tt>) for each \f$k_3\f$ term and each quadrature point in the real
       * cell \f$K_x\f$ for the common edge case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       * 3. Unit cell coordinate index
       * 4. Real cell coordinate index
       */
      CUDATable<4, RangeNumberType> kx_covariants_common_edge;
      /**
       * Covariant transformation matrix (with dimension <tt>spacedim *
       * dim</tt>) for each \f$k_3\f$ term and each quadrature point in the real
       * cell \f$K_x\f$ for the common vertex case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       * 3. Unit cell coordinate index
       * 4. Real cell coordinate index
       */
      CUDATable<4, RangeNumberType> kx_covariants_common_vertex;
      /**
       * Covariant transformation matrix (with dimension <tt>spacedim *
       * dim</tt>) for each \f$k_3\f$ term and each quadrature point in the real
       * cell \f$K_x\f$ for the regular case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       * 3. Unit cell coordinate index
       * 4. Real cell coordinate index
       */
      CUDATable<4, RangeNumberType> kx_covariants_regular;

      /**
       * Coordinates in the real cell \f$K_x\f$ for each \f$k_3\f$ term and each
       * quadrature point for the same panel case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, Point<spacedim, RangeNumberType>> kx_quad_points_same_panel;
      /**
       * Coordinates in the real cell \f$K_x\f$ for each \f$k_3\f$ term and each
       * quadrature point for the common edge case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, Point<spacedim, RangeNumberType>> kx_quad_points_common_edge;
      /**
       * Coordinates in the real cell \f$K_x\f$ for each \f$k_3\f$ term and each
       * quadrature point for the common vertex case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, Point<spacedim, RangeNumberType>>
        kx_quad_points_common_vertex;
      /**
       * Coordinates in the real cell \f$K_x\f$ for each \f$k_3\f$ term and each
       * quadrature point for the regular case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, Point<spacedim, RangeNumberType>> kx_quad_points_regular;

      /**
       * Jacobian from the unit cell to the real cell \f$K_y\f$ for each
       * \f$k_3\f$ term and at each quadrature point for the same panel case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, RangeNumberType> ky_jacobians_same_panel;
      /**
       * Jacobian from the unit cell to the real cell \f$K_y\f$ for each
       * \f$k_3\f$ term and at each quadrature point for the common edge case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, RangeNumberType> ky_jacobians_common_edge;
      /**
       * Jacobian from the unit cell to the real cell \f$K_y\f$ for each
       * \f$k_3\f$ term and at each quadrature point for the common vertex case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, RangeNumberType> ky_jacobians_common_vertex;
      /**
       * Jacobian from the unit cell to the real cell \f$K_y\f$ for each
       * \f$k_3\f$ term and at each quadrature point for the regular case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, RangeNumberType> ky_jacobians_regular;

      /**
       * Normal vector at each quadrature point in the real cell \f$K_y\f$ for
       * the same panel case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, Tensor<1, spacedim, RangeNumberType>> ky_normals_same_panel;
      /**
       * Normal vector at each quadrature point in the real cell \f$K_y\f$ for
       * the common edge case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, Tensor<1, spacedim, RangeNumberType>> ky_normals_common_edge;
      /**
       * Normal vector at each quadrature point in the real cell \f$K_y\f$ for
       * the common vertex case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, Tensor<1, spacedim, RangeNumberType>>
        ky_normals_common_vertex;
      /**
       * Normal vector at each quadrature point in the real cell \f$K_y\f$ for
       * the regular case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, Tensor<1, spacedim, RangeNumberType>> ky_normals_regular;

      /**
       * Covariant transformation matrix (with dimension <tt>spacedim *
       * dim</tt>) for each \f$k_3\f$ term and each quadrature point in the real
       * cell \f$K_y\f$ for the same panel case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       * 3. Unit cell coordinate index
       * 4. Real cell coordinate index
       */
      CUDATable<4, RangeNumberType> ky_covariants_same_panel;
      /**
       * Covariant transformation matrix (with dimension <tt>spacedim *
       * dim</tt>) for each \f$k_3\f$ term and each quadrature point in the real
       * cell \f$K_y\f$ for the common edge case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       * 3. Unit cell coordinate index
       * 4. Real cell coordinate index
       */
      CUDATable<4, RangeNumberType> ky_covariants_common_edge;
      /**
       * Covariant transformation matrix (with dimension <tt>spacedim *
       * dim</tt>) for each \f$k_3\f$ term and each quadrature point in the real
       * cell \f$K_y\f$ for the common vertex case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       * 3. Unit cell coordinate index
       * 4. Real cell coordinate index
       */
      CUDATable<4, RangeNumberType> ky_covariants_common_vertex;
      /**
       * Covariant transformation matrix (with dimension <tt>spacedim *
       * dim</tt>) for each \f$k_3\f$ term and each quadrature point in the real
       * cell \f$K_y\f$ for the regular case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       * 3. Unit cell coordinate index
       * 4. Real cell coordinate index
       */
      CUDATable<4, RangeNumberType> ky_covariants_regular;

      /**
       * Coordinates in the real cell \f$K_y\f$ for each \f$k_3\f$ term and each
       * quadrature point for the same panel case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, Point<spacedim, RangeNumberType>> ky_quad_points_same_panel;
      /**
       * Coordinates in the real cell \f$K_y\f$ for each \f$k_3\f$ term and each
       * quadrature point for the common edge case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, Point<spacedim, RangeNumberType>> ky_quad_points_common_edge;
      /**
       * Coordinates in the real cell \f$K_y\f$ for each \f$k_3\f$ term and each
       * quadrature point for the common vertex case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, Point<spacedim, RangeNumberType>>
        ky_quad_points_common_vertex;
      /**
       * Coordinates in the real cell \f$K_y\f$ for each \f$k_3\f$ term and each
       * quadrature point for the regular case.
       *
       * Table dimensions
       * 1. k3 term index
       * 2. Quadrature point index
       */
      CUDATable<2, Point<spacedim, RangeNumberType>> ky_quad_points_regular;

      /**
       * Sauter quadrature values calculated from the accumulation of each
       * thread blocks.
       */
      RangeNumberType *quad_values_in_thread_blocks;
    };


    template <int dim, int spacedim, typename RangeNumberType>
    __host__ void
    CUDAPairCellWiseScratchData<dim, spacedim, RangeNumberType>::allocate(
      const PairCellWiseScratchData<dim, spacedim, RangeNumberType>
        &scratch_cpu)
    {
      kx_mapping_support_points_permuted.allocate(
        TableIndices<1>(scratch_cpu.kx_mapping_support_points_permuted.size()),
        scratch_cpu.cuda_stream_handle);

      kx_mapping_support_points_permuted_xy_components.allocate(
        TableIndices<1>(
          scratch_cpu.kx_mapping_support_points_permuted_xy_components.size()),
        scratch_cpu.cuda_stream_handle);

      kx_mapping_support_points_permuted_yz_components.allocate(
        TableIndices<1>(
          scratch_cpu.kx_mapping_support_points_permuted_yz_components.size()),
        scratch_cpu.cuda_stream_handle);

      kx_mapping_support_points_permuted_zx_components.allocate(
        TableIndices<1>(
          scratch_cpu.kx_mapping_support_points_permuted_zx_components.size()),
        scratch_cpu.cuda_stream_handle);

      kx_jacobians_same_panel.allocate(
        scratch_cpu.kx_jacobians_same_panel.size(),
        scratch_cpu.cuda_stream_handle);
      kx_jacobians_common_edge.allocate(
        scratch_cpu.kx_jacobians_common_edge.size(),
        scratch_cpu.cuda_stream_handle);
      kx_jacobians_common_vertex.allocate(
        scratch_cpu.kx_jacobians_common_vertex.size(),
        scratch_cpu.cuda_stream_handle);
      kx_jacobians_regular.allocate(scratch_cpu.kx_jacobians_regular.size(),
                                    scratch_cpu.cuda_stream_handle);

      kx_normals_same_panel.allocate(scratch_cpu.kx_normals_same_panel.size(),
                                     scratch_cpu.cuda_stream_handle);
      kx_normals_common_edge.allocate(scratch_cpu.kx_normals_common_edge.size(),
                                      scratch_cpu.cuda_stream_handle);
      kx_normals_common_vertex.allocate(
        scratch_cpu.kx_normals_common_vertex.size(),
        scratch_cpu.cuda_stream_handle);
      kx_normals_regular.allocate(scratch_cpu.kx_normals_regular.size(),
                                  scratch_cpu.cuda_stream_handle);

      // N.B. The covariant transformation matrix belongs to \f$\mathbb{R}^{{\rm
      // spacedim}\times{\rm dim}}\f$. Since a data table adopts the C style
      // indexing, i.e. the last index runs the fastest, while a LAPACK or BLAS
      // matrix adopts the Fortran style indexing, @p dim should be placed in
      // front of @p spacedim in the table indices.
      kx_covariants_same_panel.allocate(
        TableIndices<4>(scratch_cpu.kx_covariants_same_panel.n_rows(),
                        scratch_cpu.kx_covariants_same_panel.n_cols(),
                        dim,
                        spacedim),
        scratch_cpu.cuda_stream_handle);
      kx_covariants_common_edge.allocate(
        TableIndices<4>(scratch_cpu.kx_covariants_common_edge.n_rows(),
                        scratch_cpu.kx_covariants_common_edge.n_cols(),
                        dim,
                        spacedim),
        scratch_cpu.cuda_stream_handle);
      kx_covariants_common_vertex.allocate(
        TableIndices<4>(scratch_cpu.kx_covariants_common_vertex.n_rows(),
                        scratch_cpu.kx_covariants_common_vertex.n_cols(),
                        dim,
                        spacedim),
        scratch_cpu.cuda_stream_handle);
      kx_covariants_regular.allocate(
        TableIndices<4>(scratch_cpu.kx_covariants_regular.n_rows(),
                        scratch_cpu.kx_covariants_regular.n_cols(),
                        dim,
                        spacedim),
        scratch_cpu.cuda_stream_handle);

      kx_quad_points_same_panel.allocate(
        scratch_cpu.kx_quad_points_same_panel.size(),
        scratch_cpu.cuda_stream_handle);
      kx_quad_points_common_edge.allocate(
        scratch_cpu.kx_quad_points_common_edge.size(),
        scratch_cpu.cuda_stream_handle);
      kx_quad_points_common_vertex.allocate(
        scratch_cpu.kx_quad_points_common_vertex.size(),
        scratch_cpu.cuda_stream_handle);
      kx_quad_points_regular.allocate(scratch_cpu.kx_quad_points_regular.size(),
                                      scratch_cpu.cuda_stream_handle);

      ky_mapping_support_points_permuted.allocate(
        TableIndices<1>(scratch_cpu.ky_mapping_support_points_permuted.size()),
        scratch_cpu.cuda_stream_handle);

      ky_mapping_support_points_permuted_xy_components.allocate(
        TableIndices<1>(
          scratch_cpu.ky_mapping_support_points_permuted_xy_components.size()),
        scratch_cpu.cuda_stream_handle);

      ky_mapping_support_points_permuted_yz_components.allocate(
        TableIndices<1>(
          scratch_cpu.ky_mapping_support_points_permuted_yz_components.size()),
        scratch_cpu.cuda_stream_handle);

      ky_mapping_support_points_permuted_zx_components.allocate(
        TableIndices<1>(
          scratch_cpu.ky_mapping_support_points_permuted_zx_components.size()),
        scratch_cpu.cuda_stream_handle);

      ky_jacobians_same_panel.allocate(
        scratch_cpu.ky_jacobians_same_panel.size(),
        scratch_cpu.cuda_stream_handle);
      ky_jacobians_common_edge.allocate(
        scratch_cpu.ky_jacobians_common_edge.size(),
        scratch_cpu.cuda_stream_handle);
      ky_jacobians_common_vertex.allocate(
        scratch_cpu.ky_jacobians_common_vertex.size(),
        scratch_cpu.cuda_stream_handle);
      ky_jacobians_regular.allocate(scratch_cpu.ky_jacobians_regular.size(),
                                    scratch_cpu.cuda_stream_handle);

      ky_normals_same_panel.allocate(scratch_cpu.ky_normals_same_panel.size(),
                                     scratch_cpu.cuda_stream_handle);
      ky_normals_common_edge.allocate(scratch_cpu.ky_normals_common_edge.size(),
                                      scratch_cpu.cuda_stream_handle);
      ky_normals_common_vertex.allocate(
        scratch_cpu.ky_normals_common_vertex.size(),
        scratch_cpu.cuda_stream_handle);
      ky_normals_regular.allocate(scratch_cpu.ky_normals_regular.size(),
                                  scratch_cpu.cuda_stream_handle);

      // N.B. The covariant transformation matrix belongs to \f$\mathbb{R}^{{\rm
      // spacedim}\times{\rm dim}}\f$. Since a data table adopts the C style
      // indexing, i.e. the last index runs the fastest, while a LAPACK or BLAS
      // matrix adopts the Fortran style indexing, @p dim should be placed in
      // front of @p spacedim in the table indices.
      ky_covariants_same_panel.allocate(
        TableIndices<4>(scratch_cpu.ky_covariants_same_panel.n_rows(),
                        scratch_cpu.ky_covariants_same_panel.n_cols(),
                        dim,
                        spacedim),
        scratch_cpu.cuda_stream_handle);
      ky_covariants_common_edge.allocate(
        TableIndices<4>(scratch_cpu.ky_covariants_common_edge.n_rows(),
                        scratch_cpu.ky_covariants_common_edge.n_cols(),
                        dim,
                        spacedim),
        scratch_cpu.cuda_stream_handle);
      ky_covariants_common_vertex.allocate(
        TableIndices<4>(scratch_cpu.ky_covariants_common_vertex.n_rows(),
                        scratch_cpu.ky_covariants_common_vertex.n_cols(),
                        dim,
                        spacedim),
        scratch_cpu.cuda_stream_handle);
      ky_covariants_regular.allocate(
        TableIndices<4>(scratch_cpu.ky_covariants_regular.n_rows(),
                        scratch_cpu.ky_covariants_regular.n_cols(),
                        dim,
                        spacedim),
        scratch_cpu.cuda_stream_handle);

      ky_quad_points_same_panel.allocate(
        scratch_cpu.ky_quad_points_same_panel.size(),
        scratch_cpu.cuda_stream_handle);
      ky_quad_points_common_edge.allocate(
        scratch_cpu.ky_quad_points_common_edge.size(),
        scratch_cpu.cuda_stream_handle);
      ky_quad_points_common_vertex.allocate(
        scratch_cpu.ky_quad_points_common_vertex.size(),
        scratch_cpu.cuda_stream_handle);
      ky_quad_points_regular.allocate(scratch_cpu.ky_quad_points_regular.size(),
                                      scratch_cpu.cuda_stream_handle);

      AssertCuda(cudaMallocAsync((void **)&quad_values_in_thread_blocks,
                                 sizeof(RangeNumberType) * 100,
                                 scratch_cpu.cuda_stream_handle));
    }


    template <int dim, int spacedim, typename RangeNumberType>
    __host__ void
    CUDAPairCellWiseScratchData<dim, spacedim, RangeNumberType>::
      assign_from_host(
        const PairCellWiseScratchData<dim, spacedim, RangeNumberType>
          &scratch_cpu)
    {
      kx_mapping_support_points_permuted.assign_from_host(
        scratch_cpu.kx_mapping_support_points_permuted,
        scratch_cpu.cuda_stream_handle);

      ky_mapping_support_points_permuted.assign_from_host(
        scratch_cpu.ky_mapping_support_points_permuted,
        scratch_cpu.cuda_stream_handle);

      kx_mapping_support_points_permuted_xy_components.assign_from_host(
        scratch_cpu.kx_mapping_support_points_permuted_xy_components,
        scratch_cpu.cuda_stream_handle);
      kx_mapping_support_points_permuted_yz_components.assign_from_host(
        scratch_cpu.kx_mapping_support_points_permuted_yz_components,
        scratch_cpu.cuda_stream_handle);
      kx_mapping_support_points_permuted_zx_components.assign_from_host(
        scratch_cpu.kx_mapping_support_points_permuted_zx_components,
        scratch_cpu.cuda_stream_handle);

      ky_mapping_support_points_permuted_xy_components.assign_from_host(
        scratch_cpu.ky_mapping_support_points_permuted_xy_components,
        scratch_cpu.cuda_stream_handle);
      ky_mapping_support_points_permuted_yz_components.assign_from_host(
        scratch_cpu.ky_mapping_support_points_permuted_yz_components,
        scratch_cpu.cuda_stream_handle);
      ky_mapping_support_points_permuted_zx_components.assign_from_host(
        scratch_cpu.ky_mapping_support_points_permuted_zx_components,
        scratch_cpu.cuda_stream_handle);
    }


    template <int dim, int spacedim, typename RangeNumberType>
    __host__ void
    CUDAPairCellWiseScratchData<dim, spacedim, RangeNumberType>::release(
      const cudaStream_t stream)
    {
      kx_mapping_support_points_permuted.release(stream);

      kx_mapping_support_points_permuted_xy_components.release(stream);
      kx_mapping_support_points_permuted_yz_components.release(stream);
      kx_mapping_support_points_permuted_zx_components.release(stream);

      kx_jacobians_same_panel.release(stream);
      kx_jacobians_common_edge.release(stream);
      kx_jacobians_common_vertex.release(stream);
      kx_jacobians_regular.release(stream);

      kx_normals_same_panel.release(stream);
      kx_normals_common_edge.release(stream);
      kx_normals_common_vertex.release(stream);
      kx_normals_regular.release(stream);

      kx_covariants_same_panel.release(stream);
      kx_covariants_common_edge.release(stream);
      kx_covariants_common_vertex.release(stream);
      kx_covariants_regular.release(stream);

      kx_quad_points_same_panel.release(stream);
      kx_quad_points_common_edge.release(stream);
      kx_quad_points_common_vertex.release(stream);
      kx_quad_points_regular.release(stream);

      ky_mapping_support_points_permuted.release(stream);

      ky_mapping_support_points_permuted_xy_components.release(stream);
      ky_mapping_support_points_permuted_yz_components.release(stream);
      ky_mapping_support_points_permuted_zx_components.release(stream);

      ky_jacobians_same_panel.release(stream);
      ky_jacobians_common_edge.release(stream);
      ky_jacobians_common_vertex.release(stream);
      ky_jacobians_regular.release(stream);

      ky_normals_same_panel.release(stream);
      ky_normals_common_edge.release(stream);
      ky_normals_common_vertex.release(stream);
      ky_normals_regular.release(stream);

      ky_covariants_same_panel.release(stream);
      ky_covariants_common_edge.release(stream);
      ky_covariants_common_vertex.release(stream);
      ky_covariants_regular.release(stream);

      ky_quad_points_same_panel.release(stream);
      ky_quad_points_common_edge.release(stream);
      ky_quad_points_common_vertex.release(stream);
      ky_quad_points_regular.release(stream);

      AssertCuda(cudaFreeAsync(quad_values_in_thread_blocks, stream));
    }


    /**
     * PairCellWisePerTaskData on GPU device.
     */
    class CUDAPairCellWisePerTaskData
    {
    public:
      /**
       * Allocate global memory on the device.
       *
       * @tparam dim
       * @tparam spacedim
       * @tparam RangeNumberType
       * @param per_task_data
       */
      template <int dim, int spacedim, typename RangeNumberType>
      void
      allocate(const PairCellWisePerTaskData<dim, spacedim, RangeNumberType>
                                 &per_task_data,
               const cudaStream_t stream)
      {
        kx_local_dof_indices_permuted.allocate(
          CUDATableIndices<1>(
            per_task_data.kx_local_dof_indices_permuted.size()),
          stream);
        ky_local_dof_indices_permuted.allocate(
          CUDATableIndices<1>(
            per_task_data.ky_local_dof_indices_permuted.size()),
          stream);
      }

      /**
       * Assign values from @p PairCellWisePerTaskData on the host to the
       * device.
       *
       * @tparam dim
       * @tparam spacedim
       * @tparam RangeNumberType
       * @param per_task_data
       */
      template <int dim, int spacedim, typename RangeNumberType>
      void
      assign_from_host(
        const PairCellWisePerTaskData<dim, spacedim, RangeNumberType>
                          &per_task_data,
        const cudaStream_t stream)
      {
        kx_local_dof_indices_permuted.assign_from_host(
          per_task_data.kx_local_dof_indices_permuted, stream);
        ky_local_dof_indices_permuted.assign_from_host(
          per_task_data.ky_local_dof_indices_permuted, stream);
      }

      /**
       * Release the memory on the device.
       */
      void
      release(const cudaStream_t stream)
      {
        kx_local_dof_indices_permuted.release(stream);
        ky_local_dof_indices_permuted.release(stream);
      }

      CUDATable<1, types::global_dof_index> kx_local_dof_indices_permuted;
      CUDATable<1, types::global_dof_index> ky_local_dof_indices_permuted;
    };
  } // namespace CUDAWrappers
} // namespace HierBEM

#endif /* INCLUDE_CU_BEM_VALUES_HCU_ */
