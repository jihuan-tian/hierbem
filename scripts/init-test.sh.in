#!/bin/bash

# In the folder of the test program, this script can be called as below
#
# scripts/init-test.sh [-h] [-f {dealii|catch2}] [-t {cc|cuda}] [-d <test-dir>] [<test-target-name>]
#
# If the argument <test-target-name> is not given, it is set to $(basename
# $(pwd)), so that it will create the source code file and output file with
# their base names being the folder name of the test case.

usage_exit() {
    cat <<EOF
Usage: $0 [-h] [-f <FRAMEWORK>] [-t <CODETYPE>] [-d <TESTDIR>] [<TARGETNAME>]
Generate testcase skeleton in a directory.

    -h              Show this message.
    -f <FRAMEWORK>  Testing framework to use. <FRAMEWORK> can be 'dealii' or 'catch2'.
                    Default to 'dealii'.
    -t <CODETYPE>   Specify testcase code type. Source file will have '.cc' suffix if
                    <CODETYPE> is 'cc', '.cu' suffix if <CODETYPE> is 'cuda'.
                    Default to 'cc'.
    -d <TESTDIR>    Specify testcase directory. Create the directory if it does not
                    exist yet.
                    Default to the current directory.

The <TARGETNAME> argument specifies CMake target name, default to the basename of the
testcase directory if omitted.
EOF
    exit 0
}

# Stop script when any error occurs
set -e

test_framework='dealii'
test_code_type='cc'
test_dir=$(pwd)

# Parse arguments
while getopts ':f:t:d:' arg; do
    case "$arg" in
    f)
        [ "$OPTARG" = "dealii" -o "$OPTARG" = "catch2" ] || usage_exit
        test_framework="$OPTARG"
        ;;
    t)
        [ "$OPTARG" = "cc" -o "$OPTARG" = "cuda" ] || usage_exit
        test_code_type="$OPTARG"
        ;;
    d)
        test_dir="$OPTARG"
        # Create testcase directory if it does not exist yet
        [ -d "$test_dir" ] || mkdir -p "$test_dir"
        ;;
    *)
        usage_exit
        ;;
    esac
done
shift $((OPTIND - 1))

test_target_name=$(basename "${test_dir}")
if [ "$#" -gt 0 ]; then
    test_target_name="$1"
fi

cat <<EOF

* Testing framework: ${test_framework}
* Testcase code type: ${test_code_type}
* Testcase directory: ${test_dir}
* CMake target name: ${test_target_name}

EOF

# Change source file suffix according to code type
src_suffix='cc'
if [ "${test_code_type}" = "cuda" ]; then
    src_suffix='cu'
fi
src_filename=${test_target_name}.${src_suffix}

# Make sure target directory is empty
if [ "$(ls -A $test_dir)" ]; then
    echo "Error: Cannot generate testcase skeleton in $test_dir, for it is not empty!"
    exit 1
else
    # Change working directory to target path
    cd "$test_dir"
fi

# CMakeList.txt template using dealii testing framework
cmakelist_dealii_template=$(
    cat <<EOF
set(TEST_TARGET ${test_target_name})

# Link TEST_TARGET to my generic_tools library.
set(TEST_LIBRARIES
    generic_tools
    boost_program_options
    dl  # Lazy way: always link with libdl no matter if CUDA is used or not
)

deal_ii_pickup_tests()
EOF
)
# CMakeList.txt template using Catch2 testing framework
cmakelist_catch2_template=$(
    cat <<EOF
# Target should contains 'test' substring in any cases in order to be
# found by Visual Studio Code's TestMate extension
set(_target test-${test_target_name})

add_executable(\${_target} ${src_filename})

# Allow target to include deal.ii header files
deal_ii_setup_target(\${_target})

# Define SOURCE_DIR macro to be used in the source files
target_compile_definitions(\${_target} PUBLIC SOURCE_DIR="\${CMAKE_CURRENT_SOURCE_DIR}")

target_link_libraries(
    \${_target}
    generic_tools
    boost_program_options
    dl  # Lazy way: always link with libdl no matter if CUDA is used or not
    Catch2::Catch2WithMain
)

# Discover Catch2 testcases
include(CTest)
include(Catch)
catch_discover_tests(\${_target})
EOF
)

cmakelist_template_name="cmakelist_${test_framework}_template"
echo "${!cmakelist_template_name}" >CMakeLists.txt
# Create output comparison file only when dealii testing framework
# is used
[ "$test_framework" = "dealii" ] && touch $test_target_name.output

# Insert template code into the source file
date_string=$(date -I)
code_dealii_template=$(
    cat <<EOF
/**
 * @file ${src_filename}
 * @brief 
 *
 * @ingroup testers
 * @author 
 * @date $date_string
 */

#include <iostream>

using namespace std;

int main(int argc, const char *argv[])
{
    return 0;
}
EOF
)
code_catch2_template=$(
    cat <<EOF
/**
 * @file ${src_filename}
 * @brief 
 *
 * @ingroup testers
 * @author 
 * @date $date_string
 */
#include <catch2/catch_all.hpp>

using namespace Catch::Matchers;

TEST_CASE("Your test case desc here", "[your_test_case_tag_here]")
{
    INFO("*** test start");
    CHECK(1 == 1);

    double result = 0.5;
    double expected = 0.5;
    REQUIRE_THAT(result, WithinAbs(expected,1e-6) || WithinRel(expected,1e-8));
    INFO("*** test end");
}
EOF
)
code_template_name="code_${test_framework}_template"
echo "${!code_template_name}" >${src_filename}

# Add the newly created files to Git.
git add CMakeLists.txt
git add ${src_filename}
[ "$test_framework" = "dealii" ] && git add $test_target_name.output

# Rerun make debug or make release in the build directory silently
echo -e "\n* Rerun make in the build directory ...\n"
compilation_mode=`echo @CMAKE_BUILD_TYPE@ | tr '[:upper:]' '[:lower:]'`
pushd "@CMAKE_BINARY_DIR@" > /dev/null
make $compilation_mode > /dev/null
popd > /dev/null
# NOTE Bash script were executed in a child process. Any changes to the
# working directory won't affect parent session. So we can only prompt
# user to go to testcase directory manually.
cat <<EOF

* Execute the command to go to testcase directory:

    cd ${test_dir}

EOF
